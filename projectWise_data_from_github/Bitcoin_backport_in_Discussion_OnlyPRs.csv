https://api.github.com/repos/bitcoin/bitcoin,21028,bips_44-49-84::master,0,merged,Docs::,"If you don't like what they say, please suggest alternatives ;)* [`BIP 44`](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki): The experimental descriptor wallets introduced in **v0.21.0** by default use the Hierarchical Deterministic Wallet derivation proposed by BIP 44 [(PR #16528)](https://github.com/bitcoin/bitcoin/pull/16528). ::* [`BIP 49`](https://github.com/bitcoin/bips/blob/master/bip-0049.mediawiki): The experimental descriptor wallets introduced in **v0.21.0** by default use the Hierarchical Deterministic Wallet derivation proposed by BIP 49 [(PR #16528)](https://github.com/bitcoin/bitcoin/pull/16528). ::* [`BIP 84`](https://github.com/bitcoin/bips/blob/master/bip-0049.mediawiki): The experimental descriptor wallets introduced in **v0.21.0** by default use the Hierarchical Deterministic Wallet derivation proposed by BIP 84 [(PR #16528)](https://github.com/bitcoin/bitcoin/pull/16528). ::* [`BIP 65`](https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki): The CHECKLOCKTIMEVERIFY softfork was merged in **v0.12.0** ([PR #6351](https://github.com/bitcoin/bitcoin/pull/6351)), and backported to **v0.11.2** and **v0.10.4**. Mempool-only CLTV was added in [(PR #6124)](https://github.com/bitcoin/bitcoin/pull/6124). ::@luke-jr This is actually linking to BIP 49, not to BIP 84.::???::",c943326d3c06e481c142b112c7e7a0c6ff5a76b3::
https://api.github.com/repos/bitcoin/bitcoin,21022,broken_shared_mutex_sanity_check::master,0,closed,Build system::,"After #21016, `boost::shared_mutex` will basically be the last component of Boost Thread that Bitcoin Core is using. However, [a comment in #16684](https://github.com/bitcoin/bitcoin/issues/16684#issuecomment-726214696), pointed out that `std::shared_mutex` may be unsafe to use, when coupled with a range of glibc versions ~2.26->2.29, which may block our adoption and the removal of Boost Thread. Note that the comment first links to [""rdlock stalls indefinitely on an unlocked pthread rwlock""](https://sourceware.org/bugzilla/show_bug.cgi?id=23861), but then to the [Ubuntu bugtracker](https://bugs.launchpad.net/ubuntu/+source/glibc/+bug/1864864), which is actually for a different pthread bug: [""pthread_rwlock_trywrlock results in hang""](https://sourceware.org/bugzilla/show_bug.cgi?id=23844). This PR contains a modified version of the code to reproduce the second bug, for which a backport was done for Ubuntu 18.04s glibc (2.27-3ubuntu1.3). You can reproduce the hanging behaviour using the following. (You could also use any demos from the linked bug reports). Run a Bionic container, and install build dependencies. Clone the source and checkout this branch: ```bash docker run -it --rm ubuntu:18.04 /bin/bash apt update && apt upgrade -y apt install git build-essential libtool autotools-dev automake pkg-config bsdmainutils python3 libevent-dev libboost-system-dev libboost-filesystem-dev libboost-test-dev libboost-thread-dev -y git clone https://github.com/bitcoin/bitcoin git fetch origin pull/21022/head:21022 git checkout 21022 ``` Configure, disabling the wallet (unrelated) and enabling glibc back compat, so that our sanity checks are enabled: ```bash ./autogen.sh ./configure --disable-wallet --enable-glibc-back-compat make src/bitcoind -j8 ``` Before running bitcoind, check which version of libc you have installed. `23844` was fixed in `1.3`, so running `1.4` should mean no issues: ```bash apt-cache policy libc6 libc6: Installed: 2.27-3ubuntu1.4 Candidate: 2.27-3ubuntu1.4 ``` Run bitcoind ``` src/bitcoind Testing pthread trylock_wr 2021-01-28T13:24:39Z Bitcoin Core version v21.99.0-1e601c9d60f9 (release build) 2021-01-28T13:24:39Z Assuming ancestors of block 0000000000000000000b9d2ec5a352ecba0592946514a92f14319dc2b367fc72 have valid signatures. 2021-01-28T13:24:39Z Setting nMinimumChainWork=00000000000000000000000000000000000000001533efd8d716a517fe2c5008 ... # quit ``` Downgrade libc to `1.2`. You may need to uninstall `libc6-dev` first, otherwise it will block the downgrade of `libc6`: ```bash apt remove libc6-dev -y apt install libc6=2.27-3ubuntu1.2 -y # check that you're running 1.2 apt-cache policy libc6 libc6: Installed: 2.27-3ubuntu1.2 Candidate: 2.27-3ubuntu1.4 ``` Run `bitcoind` again. Note that this will *hang*. You will not be able to quit. ```bash # if it doesn't hang, quit and retry ./src/bitcoind Testing pthread trylock_wr .... hanging ``` I think it would be good to have more discussion around how we approach these sort of ""lower down the stack"" issues: * what sort of bug or issue warrants us from excluding a std library feature, i.e `std::shared_mutex`, from use? If you looked at the glibc issue tracker right now, you'd no doubt find half a dozen bugs across multiple versions of glibc that you may think warrant us excluding various things. * How widespread does the issue have to be? If it's in a single glibc version that is nearly EOL, that is obviously less of an issue compared to something affecting most recent versions. * how (in)tolerant are we of assuming that users are taking backports? * do we need to be more aggressive with runtime sanity checks? Should we be trying to detect more ""broken things"" that are applicable to us? It would certainly be unfortunate if migrating to more standard library components was blocked for extended periods (Ubuntu Bionic is LTS until mid 2023), due to these kinds of bugs.",1e601c9d60f9a5ebaa8a92fefface07382dfdd24::
https://api.github.com/repos/bitcoin/bitcoin,20901,2101-2101Backports::0.21,0,merged,Backport::,Current backports for *0.21.1*. One conflict was in the test case.,c33fbab25c82b6a18773b80e8b355c987066ae5a::bdce029191ab094a4a325b143324487f1c62ba7c::7bf3ed495b96f0959d5c45c6e1936d8628dec730::0dba346a568882434098dd08566978e23eb4a516::b7086e69ff3825c3f3bfde4ca9af90663a4575dd::7bc4498234e16bc75975555cbe7855384489782f::bdc64c9030488e7a6b88f369fb876c0b21c04a25::a98f211940dc6eaed8050263efad7656126b7b3e::e2ebc8567a96e92d1c039b2e7c5f48826fece810::6dc58e99457fe4609fa3c401e89f98c92dbd9878::4607019798c543f046bcd22d5b7c09750e7e0ee2::95218ee95cdb4046ee7d622eac822e74d94314c7::08dada84565ea5f49127123e356c82a150626f3c::d6b5eb5fcc8e8f7f0ab778f32d49aabf6e04d80d::4ef1e4bd407ccf80b2a1d40e946e2ac832e624e5::36ecf5eb8752890fdffd617c9fedb08033607f99::3a126724195fcf00d84e852a9247475fccd14f38::b35711efdebc4e95906b1e809e711bc707852f2d::58975d5c0abeab8cb66f6006ee558d4bb7cc12b5::6746cd078be8a15c69f8f5ba5253b1768d0acf21::a48c9d31610cab3ddd4f7334e83db5cf4f184df1::14e3f2a1c916fccf375a6570e58072c4d007fc3c::8426e3a8a1aad2e1ea794158ffb9a587f476d8d3::5a2d98c640cf308d3c7e85ba51fbb7e84f99322a::
https://api.github.com/repos/bitcoin/bitcoin,20861,202101_bech32m::master,0,merged,Utils/log/libs::,"This implements [BIP 350](https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki): * For segwit v1+ addresses, a new checksum algorithm called Bech32m is used. * Segwit v0 address keep using Bech32 as specified in [BIP 173](https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki). Why forbid Bech32m for v0? Seems like it might be nice to (very slowly) migrate to Bech32m exclusively, and drop Bech32 someday?::I think it's a bad idea to have multiple addresses valid for the same scriptPubKey. It only results in confusion when decoding/recoding doesn't roundtrip. v0 outputs use bech32, and I don't think this should ever change, for better or for worse. It also worsens error detection to 29 bits (as every v0 output now has two valid checksums).::Roundtrips (by uninvolved third parties) seem like strictly a bad thing IMO, but loss of error detection precision is a good reason. :/::Commit 6b28812881375311891e80c1d4e9df6aaa0b85d5 Perhaps too unorthodox, but it would theoretically be possible to do ```C++ BECH32 = 1, //... BECH32M = 0x2bc830a3, // ... ``` and get rid of `EncodingConstant`. (But the amount of casting required is probably not worth it.)::I prefer not to do that just for encapsulation reason. Nothing outside of bech32.cpp should care or see the constants.::Don't think this is needed anymore.::Fixed.::Shouldn't `0x2bc830a3` be made a global constant value?::Why here `Encoding` is added as the last parameter why in https://github.com/bitcoin/bitcoin/pull/20861/files#diff-f146300624c06d2e08aadf500952294148a1785edd6ff2e8b50f13b2c08255edR152 it became first? Is there any reason behind API inconsistency?::Won't this need to be backported to 0.21.1 with taproot activation?::Couldn't this be signet as well?::ditto signet comment::IMO, no. There is no reason why it should be exported from this module.::I have no opinion on that, but even if we do that, that's not part of this PR.::Also note that if 0.21.1 contains Taproot activation logic, it won't contain any wallet support. Being able to send _to_ a Taproot address is probably worth back-porting, but that could also wait for 0.21.2.::Added a signet copy of this.::And this.::Fixed.::There might be a Base58 string which is a valid Bech32m with future Witness version, and since Base58 is the first decoder, a future valid Bech32m address may be incorrectly parsed as Base58. So I propose to change their order.::in case of Bech32 address `error_str` will still be set to `""Invalid prefix for Base58-encoded address""` because it is not cleaned when we return https://github.com/bitcoin/bitcoin/pull/20861/files#diff-a83ac7cb4a9d60b647db6378ccfad815005724e594bf53f49745b0f40701292fR152 So I propose ```suggestion if (ConvertBits<5, 8, false>([&](unsigned char c) { data.push_back(c); }, dec.data.begin() + 1, dec.data.end())) { error_str = """"; ```::It's already wiped in line 102, I think?::True, don't know how I missed that::That seems like something for a separate PR.::I don't think there is any concern about that. The decoder only accepts Base58Check inputs that encode 20 data bytes, which means addresses of at most 35 characters (ceil(log(256)/log(58)*20) == 20). A Bech32(m) segwit address of 35 characters (assuming 2+-character HRP) would encode at most (35-6(checksum)-1(separator)-2(hrp)-1(version byte))*5 = 125 bits, rounded down to a byte, 120 bits. I don't think anyone is planning on proposing 120-bit addresses for Bitcoin any time soon.::Makes no difference to the compiled code, but the convention is to give the declaration's parameters names (which match the parameter names in the function definition). ```suggestion std::string Encode(Encoding encoding, const std::string& hrp, const std::vector<uint8_t>& values); ```::Perhaps update line 10: ```diff -// For more information, see BIP 173. +// For more information, see BIPs 173 and 350. ```::Should a round trip encode/decode always result in the same hrp (""bc"") here? Am I missing some way that this could legitimately fail?::>> I honestly don't really like the std::tuple stuff. It's pretty ugly and a simple struct containing the 3 elements passed as a copy by reference (edit: I meant like the tuples are passed now) in the same way would be more straightforward. (@kallewoof) > @kallewoof Agree, a struct is definitely warranted here. Updated. (@sipa) No need to change this again, but in future you may find that structured bindings (since c++17) offer a clean and readable way to avoid the boilerplate of declaring a `struct` return. Combining with an if init statement: ```suggestion if (const auto [encoding, hrp, data] = bech32::Decode(str); (encoding == bech32::Encoding::BECH32 || encoding == bech32::Encoding::BECH32M) && data.size() > 0) { // [... do stuff ] } // encoding, hrp and data fall out of scope at end of if block ```::Agree, though another reason why we may not want to do this: we'll want this PR backported as far as possible.::Makes sense. I'll mark this as resolved. Also, TIL: you can use structured bindings to unpack a `struct`, so this works even when the return value is a `DecodeResult`: `const auto [encoding, hrp, d] = bech32::Decode(str);` ::In commit ""Add Bech32m test vectors"" (f0e15955421870c297d4ddb523431dae711e27d3) I think this means to check != BECH32M, instead of != BECH32. Alternately could check == INVALID, if it is not a problem to be more strict. ::In commit ""Use Bech32m encoding for v1+ segwit addresses"" (ea3995aa3cd8f04d7328c95a43c79a5b20fa18a5) Should AddressDescriptor::GetOutputType should now return BECH32M instead of BECH32 for WitnessUnknown addresses to be consistent with this change? https://github.com/bitcoin/bitcoin/blob/ea3995aa3cd8f04d7328c95a43c79a5b20fa18a5/src/script/descriptor.cpp#L656 Also, this change seems like the first change that affects user-visible behavior, so it would be great if it added release notes or at least mentioned what the effects are in the commit message. I think the only thing current software can do with V1 addresses is validate them and do watchonly scans for them. So this only affects validate and import RPCs?::In commit ""Use Bech32m encoding for v1+ segwit addresses"" (ea3995aa3cd8f04d7328c95a43c79a5b20fa18a5) I probably just need to stare at this more, but maybe you could summarize the changes here. Like where did the 1,2 and 2,16 cases go?::Done.::Done.::This already existed in the code before this PR, but it's a good point. The only failure case is when the data is too big to fit in a valid Bech32(m) encoding (max 90 characters). I've added a check for that, and then dropped the `if (r2.hrp.empty()) {` branch.::Indeed. Replaced with `== INVALID`.::Very good point. We can't return `GetOutputType::BECH32M` because no such constant exists. It could be added, but I'd rather not do that in this PR, because I don't think it actually matters at this stage. The purpose of output types is so the user can select what kind of address to request from a wallet. You're right that technically a `addr(...)` descriptor could be imported (but I think that in most cases a ranged descriptor is required, so `addr(...)` won't even work), and it might matter to classify that as bech32m - but this seems like a very unrealistic edge case. However, I think this will matter once we want to add actual taproot support to the wallet (#21365, and follow-ups that at one point might want to construct such wallet descriptors by default). I suspect we may want an OutputType::BECH32M then, and permit wallets to have separate -addresstype=bech32 and -addresstype=bech32m active descriptors, as one may know that the sender they want to receive from supports bech32 but not bech32m yet. I've also added release notes. ping @achow101: thoughts on OutputType::BECH32M?::They're just gone and replaced by better cases. I got rid of (1,2) as (1,32) is a more relevant case (that's taproot) and added (2,2) too. To test a bit larger variety, some other (2, _) were replaced with (3, _) as well.::I think `-addresstype=bech32m` makes sense, e.g. `getnewaddress bech32m` as a way to request a taproot p2pk address. However it might be more future proof to use `-addresstype=tap` and  `getnewaddress tap`. Longer term I suspect it might be better to give wallet descriptors a name and then call `getnewaddress NAME`. See also #15590 for some earlier discussions around this issue.::s/350/341/ d1054b98e5ec04cd3cdb487eaaf561926ef6c82d::> However it might be more future proof to use `-addresstype=tap` and `getnewaddress tap`. I'm not sure. If Bech32m gets adopted as I hope it does, we won't need a new address type for post-taproot things anymore.::Since bech32m is (and bech32 was) intended to be used for different segwit versions, I think that we should actually move away from having bech32 or bech32m as the address type as with future segwit versions, it becomes ambiguous as to what type of address you want. For example, suppose we introduce a segwit v2 that, like segwit v1, will encode a pubkey in the address. Now the wallet would have a descriptor for segwit v1, and another for segwit v2. If I wanted a segwit v1 address, what do I provide as the address type? If I provide `bech32m`, that's ambiguous because both segwit v1 and segwit v2 use `bech32m` addresses. We would have to come up with another name for segwit v2 addresses, and even then, it is still confusing because technically both are bech32m addresses. With that in mind, I think we need to use a different and more unique naming scheme. Luckily this is pretty easy because segwit has version numbers, and proposals all have unique names. So for segwit v1 addresses, we could call the address type `tap` and just not expose bech32m in it. I have done a similar thing in HWI where segwit v0 is `wit` rather than `bech32`, and segwit v1 will be `tap`. Looking at it now, I do also think that having `bech32` as the address type for segwit v0 was not the right thing to do. It really should have just be `wit` or something like that that makes it unique to just segwit v0. Since bech32 is now segwit v0 only, it's fine, but in the future, we should not do the same thing.::How come this scenario is no longer relevant?::> Now the wallet would have a descriptor for segwit v1, and another for segwit v2. If I wanted a segwit v1 address, what do I provide as the address type? I think that's the crucial point: why would you want that? If every sender supports both equally, you'd always produce whatever you have a descriptor for that is compatible with that. If there is a reason for being more flexible, no objection to just using names or something. But then also, would you support having multiple distinct active descriptors that produce the same address type within the same wallet? I think that's the same problem. If anything, I think we should have done things in the other direction; OutputTypes should have been LEGACY, BIP16, BECH32 or so (and BIP16 should have been both usable for multisig and segwit v0). Because those are the classes senders care about.::The added `if` condition around it (which checks that the input is within acceptable range).::> I think that's the crucial point: why would you want that? If every sender supports both equally, you'd always produce whatever you have a descriptor for that is compatible with that. In the ideal world, sure. But as we have seen with segwit, that's not guaranteed. Even though senders were supposed to allow any segwit version with bech32, they didn't. I'm not sure that everyone will understand to do that with bech32m. The address type option is not just for senders. It's also for receivers and what they are comfortable with receiving. I could conceive of a situation where someone sets up a new wallet but wants to use v1 instead of v2 because, e.g., v2 introduces some new signature algo that has assumptions they aren't comfortable with using. What would they have to do to use v1?::> In the ideal world, sure. But as we have seen with segwit, that's not guaranteed. Even though senders were supposed to allow any segwit version with bech32, they didn't. I'm not sure that everyone will understand to do that with bech32m. Sure, that's why I suggest we may want to add an OutputType::BECH32M - precisely because Bech32 and Bech32m may differ for senders. But p2sh vs. p2sh-p2wpk shouldn't be distinguished, for example. > I could conceive of a situation where someone sets up a new wallet but wants to use v1 instead of v2 because, e.g., v2 introduces some new signature algo that has assumptions they aren't comfortable with using. What would they have to do to use v1? That's fair, and was a good argument for segwit vs non-segwit in pre-descriptor wallets. But in descriptor wallets if you don't want witness v9 addresses because you're not comfortable with them, simply don't import/create such a descriptor.::> Sure, that's why I suggest we may want to add an OutputType::BECH32M - precisely because Bech32 and Bech32m may differ for senders. Yes, I agree with doing that. > But in descriptor wallets if you don't want witness v9 addresses because you're not comfortable with them, simply don't import/create such a descriptor. That's reasonable, but I think it's too onerous on users to have to figure out which and how to create the descriptor that they want. I think it's reasonable that user would know about different address types and, at a high level, the consequences of using each type, but also not know (or be afraid of) the descriptor syntax, which derivation paths to use, safely handling xprvs for import, etc. I suppose we could add more options to the wallet creation stuff, but that still means the user has to deal with descriptors directly once they feel comfortable enough to upgrade, or they have to make a wholly new wallet. If instead the wallet generated v1 and v2 descriptors, then the user could switch to the new address type by choosing the option and it's very simple and easy to do so.::402cbb2 Perhaps move the `data` type alias to the header file to use it uniformly in `bech32.{h, cpp}` <details><summary>example code diff</summary><p> ```diff diff --git a/src/bech32.cpp b/src/bech32.cpp index 80794ec4f1..60d4d72ca5 100644 --- a/src/bech32.cpp +++ b/src/bech32.cpp @@ -13,8 +13,6 @@ namespace bech32 -typedef std::vector<uint8_t> data; - /** The Bech32 character set for encoding. */ const char* CHARSET = ""qpzry9x8gf2tvdw0s3jn54khce6mua7l""; diff --git a/src/bech32.h b/src/bech32.h index 3679ea8ccb..7a601a7b97 100644 --- a/src/bech32.h +++ b/src/bech32.h @@ -16,6 +16,8 @@ #include <string> #include <vector> +typedef std::vector<uint8_t> data; + namespace bech32 { @@ -28,16 +30,16 @@ enum class Encoding { /** Encode a Bech32 or Bech32m string. If hrp contains uppercase characters, this will cause an *  assertion error. Encoding must be one of BECH32 or BECH32M. */ -std::string Encode(Encoding encoding, const std::string& hrp, const std::vector<uint8_t>& values); +std::string Encode(Encoding encoding, const std::string& hrp, const data& values); struct DecodeResult { -    Encoding encoding;         //!< What encoding was detected in the result; Encoding::INVALID if failed. -    std::string hrp;           //!< The human readable part -    std::vector<uint8_t> data; //!< The payload (excluding checksum) +    Encoding encoding; //!< What encoding was detected in the result; Encoding::INVALID if failed. +    std::string hrp;   //!< The human readable part +    data data;         //!< The payload (excluding checksum) DecodeResult() : encoding(Encoding::INVALID) {} -    DecodeResult(Encoding enc, std::string&& h, std::vector<uint8_t>&& d) : encoding(enc), hrp(std::move(h)), data(std::move(d)) {} +    DecodeResult(Encoding enc, std::string&& h, ::data&& d) : encoding(enc), hrp(std::move(h)), data(std::move(d)) {} }; ``` </p></details> ::402cbb29516d5bf03a18822af9f1b4b574f319ac pico-nits, `check` can be `const` (and braced initialization for type safety) ```suggestion const uint32_t check{PolyMod(Cat(ExpandHRP(hrp), values))}; ``` Idem for `mod` on line 140, `result` on line 195, and `version` in `key_io.cpp::L106`::d1054b98e nit, s/system/systems/ and omit comma ```suggestion affect any production systems but may be observed on other networks where such ```::Checking for encoding type may be done frequently enough to consider adding helper functions (not necessarily in this PR). ::I'm going to mark this as resolved; we've discussed this in today's wallet meeting. It's not exactly clear how to proceed, but in any case, I don't think this is something for this PR. Please respond if you don't agree.::Discussion: http://www.erisian.com.au/bitcoin-core-dev/log-2021-03-12.html#l-286::Not necessarily for this PR but we may want to think about renaming this to `BECH32Legacy` or `BECH32v0` or so. In the code right now sometimes ""bech32"" refers to BIP173 specifically and sometimes to both BIP173 and BIP350. In this line it's the former case, in the namespace it's the latter case. I can see people getting confused by that in the future.::I don't think we want to pollute the global namespace with a type called `data`.::The caller can't do anything with a `DecodeResult` where encoding is `Encoding::INVALID`, so changing this return type to `std::optional<DecodeResult>` and removing the `Encoding::INVALID` enum type feels more natural to me. <details> <summary>Diff</summary> ```diff diff --git a/src/bech32.cpp b/src/bech32.cpp index 80794ec4f1..2fd84b395b 100644 --- a/src/bech32.cpp +++ b/src/bech32.cpp @@ -6,6 +6,7 @@ #include <util/vector.h> #include <assert.h> +#include <optional> namespace bech32 { @@ -120,7 +121,7 @@ data ExpandHRP(const std::string& hrp) } /** Verify a checksum. */ -Encoding VerifyChecksum(const std::string& hrp, const data& values) +std::optional<Encoding> VerifyChecksum(const std::string& hrp, const data& values) { // PolyMod computes what value to xor into the final values to make the checksum 0. However, // if we required that the checksum was 0, it would be the case that appending a 0 to a valid @@ -129,7 +130,7 @@ Encoding VerifyChecksum(const std::string& hrp, const data& values) uint32_t check = PolyMod(Cat(ExpandHRP(hrp), values)); if (check == EncodingConstant(Encoding::BECH32)) return Encoding::BECH32; if (check == EncodingConstant(Encoding::BECH32M)) return Encoding::BECH32M; -    return Encoding::INVALID; +    return {}; } /** Create a checksum. */ @@ -165,7 +166,7 @@ std::string Encode(Encoding encoding, const std::string& hrp, const data& values } /** Decode a Bech32 or Bech32m string. */ -DecodeResult Decode(const std::string& str) { +std::optional<DecodeResult> Decode(const std::string& str) { bool lower = false, upper = false; for (size_t i = 0; i < str.size(); ++i) { unsigned char c = str[i]; @@ -192,9 +193,9 @@ DecodeResult Decode(const std::string& str) { for (size_t i = 0; i < pos; ++i) { hrp += LowerCase(str[i]); } -    Encoding result = VerifyChecksum(hrp, values); -    if (result == Encoding::INVALID) return {}; -    return {result, std::move(hrp), data(values.begin(), values.end() - 6)}; +    auto result = VerifyChecksum(hrp, values); +    if (!result) return {}; +    return {{*result, std::move(hrp), data(values.begin(), values.end() - 6)}}; } } // namespace bech32 diff --git a/src/bech32.h b/src/bech32.h index 3679ea8ccb..f2f294bc3f 100644 --- a/src/bech32.h +++ b/src/bech32.h @@ -12,6 +12,7 @@ #ifndef BITCOIN_BECH32_H #define BITCOIN_BECH32_H +#include <optional> #include <stdint.h> #include <string> #include <vector> @@ -20,8 +21,6 @@ namespace bech32 { enum class Encoding { -    INVALID, //!< Failed decoding - BECH32,  //!< Bech32 encoding as defined in BIP173 BECH32M, //!< Bech32m encoding as defined in BIP350 }; @@ -32,16 +31,15 @@ std::string Encode(Encoding encoding, const std::string& hrp, const std::vector< struct DecodeResult { -    Encoding encoding;         //!< What encoding was detected in the result; Encoding::INVALID if failed. +    Encoding encoding;         //!< What encoding was detected in the result std::string hrp;           //!< The human readable part std::vector<uint8_t> data; //!< The payload (excluding checksum) -    DecodeResult() : encoding(Encoding::INVALID) {} DecodeResult(Encoding enc, std::string&& h, std::vector<uint8_t>&& d) : encoding(enc), hrp(std::move(h)), data(std::move(d)) {} }; /** Decode a Bech32 string. */ -DecodeResult Decode(const std::string& str); +std::optional<DecodeResult> Decode(const std::string& str); } // namespace bech32 diff --git a/src/key_io.cpp b/src/key_io.cpp index dbcbfa1f29..dbb4711d42 100644 --- a/src/key_io.cpp +++ b/src/key_io.cpp @@ -96,25 +96,25 @@ CTxDestination DecodeDestination(const std::string& str, const CChainParams& par } data.clear(); const auto dec = bech32::Decode(str); -    if ((dec.encoding == bech32::Encoding::BECH32 || dec.encoding == bech32::Encoding::BECH32M) && dec.data.size() > 0) { +    if (dec && dec->data.size() > 0) { // Bech32 decoding error_str = """"; -        if (dec.hrp != params.Bech32HRP()) { +        if (dec->hrp != params.Bech32HRP()) { error_str = ""Invalid prefix for Bech32 address""; return CNoDestination(); } -        int version = dec.data[0]; // The first 5 bit symbol is the witness version (0-16) -        if (version == 0 && dec.encoding != bech32::Encoding::BECH32) { +        int version = dec->data[0]; // The first 5 bit symbol is the witness version (0-16) +        if (version == 0 && dec->encoding != bech32::Encoding::BECH32) { error_str = ""Version 0 witness address must use Bech32 checksum""; return CNoDestination(); } -        if (version != 0 && dec.encoding != bech32::Encoding::BECH32M) { +        if (version != 0 && dec->encoding != bech32::Encoding::BECH32M) { error_str = ""Version 1+ witness address must use Bech32m checksum""; return CNoDestination(); } // The rest of the symbols are converted witness program bytes. -        data.reserve(((dec.data.size() - 1) * 5) / 8); -        if (ConvertBits<5, 8, false>([&](unsigned char c) { data.push_back(c); }, dec.data.begin() + 1, dec.data.end())) { +        data.reserve(((dec->data.size() - 1) * 5) / 8); +        if (ConvertBits<5, 8, false>([&](unsigned char c) { data.push_back(c); }, dec->data.begin() + 1, dec->data.end())) { if (version == 0) { { WitnessV0KeyHash keyid; diff --git a/src/test/bech32_tests.cpp b/src/test/bech32_tests.cpp index 2651e46430..835d3a1c79 100644 --- a/src/test/bech32_tests.cpp +++ b/src/test/bech32_tests.cpp @@ -23,8 +23,9 @@ BOOST_AUTO_TEST_CASE(bech32_testvectors_valid) }; for (const std::string& str : CASES) { const auto dec = bech32::Decode(str); -        BOOST_CHECK(dec.encoding == bech32::Encoding::BECH32); -        std::string recode = bech32::Encode(bech32::Encoding::BECH32, dec.hrp, dec.data); +        BOOST_CHECK(dec); +        BOOST_CHECK(dec->encoding == bech32::Encoding::BECH32); +        std::string recode = bech32::Encode(bech32::Encoding::BECH32, dec->hrp, dec->data); BOOST_CHECK(!recode.empty()); BOOST_CHECK(CaseInsensitiveEqual(str, recode)); } @@ -43,8 +44,9 @@ BOOST_AUTO_TEST_CASE(bech32m_testvectors_valid) }; for (const std::string& str : CASES) { const auto dec = bech32::Decode(str); -        BOOST_CHECK(dec.encoding == bech32::Encoding::BECH32M); -        std::string recode = bech32::Encode(bech32::Encoding::BECH32M, dec.hrp, dec.data); +        BOOST_CHECK(dec); +        BOOST_CHECK(dec->encoding == bech32::Encoding::BECH32M); +        std::string recode = bech32::Encode(bech32::Encoding::BECH32M, dec->hrp, dec->data); BOOST_CHECK(!recode.empty()); BOOST_CHECK(CaseInsensitiveEqual(str, recode)); } @@ -70,7 +72,7 @@ BOOST_AUTO_TEST_CASE(bech32_testvectors_invalid) }; for (const std::string& str : CASES) { const auto dec = bech32::Decode(str); -        BOOST_CHECK(dec.encoding == bech32::Encoding::INVALID); +        BOOST_CHECK(!dec); } } @@ -94,7 +96,7 @@ BOOST_AUTO_TEST_CASE(bech32m_testvectors_invalid) }; for (const std::string& str : CASES) { const auto dec = bech32::Decode(str); -        BOOST_CHECK(dec.encoding == bech32::Encoding::INVALID); +        BOOST_CHECK(!dec); } } diff --git a/src/test/fuzz/bech32.cpp b/src/test/fuzz/bech32.cpp index 15a3875828..c794fdafc3 100644 --- a/src/test/fuzz/bech32.cpp +++ b/src/test/fuzz/bech32.cpp @@ -17,10 +17,8 @@ FUZZ_TARGET(bech32) { const std::string random_string(buffer.begin(), buffer.end()); const auto r1 = bech32::Decode(random_string); -    if (r1.hrp.empty()) { -        assert(r1.data.empty()); -    } else { -        const std::string reencoded = bech32::Encode(r1.encoding, r1.hrp, r1.data); +    if (r1) { +        const std::string reencoded = bech32::Encode(r1->encoding, r1->hrp, r1->data); assert(CaseInsensitiveEqual(random_string, reencoded)); } @@ -33,9 +31,10 @@ FUZZ_TARGET(bech32) const std::string encoded = bech32::Encode(encoding, ""bc"", input); assert(!encoded.empty()); const auto r2 = bech32::Decode(encoded); -            assert(r2.encoding == encoding); -            assert(r2.hrp == ""bc""); -            assert(r2.data == input); +            assert(r2); +            assert(r2->encoding == encoding); +            assert(r2->hrp == ""bc""); +            assert(r2->data == input); } } } ``` </details> Note that we've removed the following check from the fuzz tester: ```diff -    if (r1.hrp.empty()) { -        assert(r1.data.empty()); ``` That inconsistent state can't exist where `DecodeResult` only contains a successfully decoded bech32{m} string. EDIT: I guess you're not using std::optional so it's easier to backport to versions that don't require c++17?::Is there a reason that this isn't simply a `std::map<Encoding, uint32_t>`? This can be `constexpr`ed to evaluate this in compile time for the `VerifyChecksum()` case: ```suggestion constexpr uint32_t EncodingConstant(Encoding encoding) { ```::It's slightly inconsistent that in the c++ code, this is called `encoding` and is the first argument, and here it's `spec` and the last argument.::Perhaps add constant `BECH32_CONST = 1`::Good point indeed: https://google.github.io/styleguide/cppguide.html#Aliases. ""However, local convenience aliases are fine in function definitions, private sections of classes, explicitly marked internal namespaces, and in .cc (.cpp) files.""::In 402cbb29516d5bf03a18822af9f1b4b574f319ac ""Implement Bech32m encoding/decoding"" It would be nice to also check that the encoding is `Encoding::INVALID`::In d1054b98e5ec04cd3cdb487eaaf561926ef6c82d ""Use Bech32m encoding for v1+ segwit addresses"" I think you meant https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki (341, not 350)::In 92ec3fcdd2f79949839ce269403396362bea9d54 ""Add signet support to gen_key_io_test_vectors.py"" There is a similar comment at the top of `contrib/testgen/gen_key_io_test_vectors.py` which should either be updated or removed. Also that comment says the file is for Base58 addresses when clearly both Base58 and Bech32 things are generated in it.::Perhaps this is more personal style. I don't think this is an improvement.::Perhaps it's worth having a global typedef for this (maybe with a more descriptive name than `data`), but if so, I think it's something for a different PR. Closing this.::I don't think that's the right solution. The bech32 module is independent of the concept of segwit or bitcoin or addresses or witness versions. If there are other places where the name bech32 is used in a confusing way to include bech32m, feel free to point them out so they can be fixed (in this PR or elsewhere).::@jnewbery Yes, exactly. I considered that, but decided against it, as I prefer to have something maximally backportable.::Hmm, a map feels like a lot more heavyweight/overkill to me.::Making it `constexpr` will prevent backporting to pre-C++17 code. It's also unnecessary (constexpr doesn't control whether the compiler can evaluate at compile time as an optimization, only whether you can use it in compile-time expressions).::I'm not sure what you're suggesting concretely here.::I think explicitly asserting is purposefully done to give a sort of code-visual cue on where updates are required, after adding additional encodings in the future, so I don't think helper functions would be appropriate here.::Added `const`.::Done.::Changed the test_framework code to also use (encoding,hrp,data) everywhere.::Done.::Done.::Done.::Done.::Thanks. Marking resolved.::```suggestion const = BECH32M_CONST if encoding == Encoding.BECH32M else BECH32_CONST ```::Done.::Ok, my naming suggestions were just what came to my head at that moment, I did not want to intentionally peg the encoding name to one of its use cases. I just think it's unfortunate that everything including the BIP173 encoding was called ""Bech32"" and now there is a new encoding called ""Bech32m"" that is also a Bech32 string. I think it might be helpful to have a naming distinction between Bech32 in general and the BIP173 encoding. But I also hope this code doesn't have to change much in the future and if no one else shares that view, I am happy to have it ignored :)::> there is a new encoding called ""Bech32m"" that is also a Bech32 string. That's wrong. We should fix places in the code where Bech32m is referred to as Bech32. I know of one, addresstype/OutputType::BECH32, which I'm intentionally ignoring in this to minimize code changes (see earlier discussion), but should be fixed still.::re: https://github.com/bitcoin/bitcoin/pull/20861#discussion_r596346647 The name ""bech32m"" does maybe seem unfortunate. It might have been nice to chose a completely different name (""fatfinger32, now catching more stupid typos!"") since from a user perspective you can't use a bech32 address when you need a bech32m address, or vice versa. It's just behind the scenes that they share an extremely similar implementation, and the ""human readable"" parts can be interpreted the same way.::Already fixed.::You are hereby promoted to Official Namer Of Stuff.::Nice, so much easier than my other jobs!::> That's wrong. We should fix places in the code where Bech32m is referred to as Bech32. Ok, re-reading the module now I think this is mostly clear and I was probably bringing in my own preconceived ideas or looking at older code like the comment 2 lines above that was actually removed. I nit-picked through the module and here a few suggestions where this could be clarified further: https://github.com/fjahr/bitcoin/commit/2156afd69e6e5bd587a9d734b21c3e068a037156 but obviously feel free to ignore or keep for a follow-up together with the OutputType maybe.::nit: Any reason to remove the branch that checks bech32 for larger input sizes? I know this isn't relevant for bitcoin addresses, but there are other applications that use bech32 for encoding and checking it here doesn't cost us anything, no?::nit: obviously unrelated to your changes, but the `B` should be a `G`. (blame me)::nit: Could add a benchmark for bech32m?::Bech32 and Bech32m do not permit encoded strings over 90 characters (the checksum properties break down past that point). BOLT11 uses a relaxed version of the spec that drops this requirement.::Yeah, could do. The performance should be exactly identical to Bech32 though.::",da2bb6976dadeec682d163c258c9afecc87d6428::25b1c6e13ddf1626210d5e3d37298d1f3a78a94f::fe5e495c31de47b0ec732b943db11fe345d874af::2e7c80fb5be82ad4a3f737cab65b31f70a772a23::03346022d611871f2cc185440b19d928b9264d9d::
https://api.github.com/repos/bitcoin/bitcoin,20849,disconnect_by_subnet_fix::master,0,closed,P2P::,"Previously, when disconnecting a peer with a given address we would create a dummy subnet that contains just 1 address (/32 for IPv4 and /128 for IPv6) and would disconnect all peers that belong to this subnet (there may be more than one connection, to a different port). The problem is that for any non-IPv4 and non-IPv6 address we would create an invalid subnet which would later not match any addresses. Thus, don't use a one-host-subnet, but compare the addresses directly. This works for any type of addresses. <!-- *** Please remove the following help text before submitting: *** Pull requests without a rationale and clear improvement may be closed immediately. GUI-related pull requests should be opened against https://github.com/bitcoin-core/gui first. See CONTRIBUTING.md --> <!-- Please provide clear motivation for your patch and explain how it improves Bitcoin Core user experience or Bitcoin Core developer experience significantly: * Any test improvements or new tests that improve coverage are always welcome. * All other changes should have accompanying unit tests (see `src/test/`) or functional tests (see `test/`). Contributors should note which tests cover modified code. If no tests exist for a region of modified code, new tests should accompany the change. * Bug fixes are most welcome when they come with steps to reproduce or an explanation of the potential issue as well as reasoning for the way the bug was fixed. * Features are welcome, but might be rejected due to design or scope issues. If a feature is based on a lot of dependencies, contributors should first consider building the system outside of Bitcoin Core, if possible. * Refactoring changes are only accepted if they are required for a feature or bug fix or otherwise improve developer experience significantly. For example, most ""code style"" refactoring changes require a thorough explanation why they are useful, what downsides they have and why they *significantly* improve developer experience or avoid serious programming bugs. Note that code style is often a subjective matter. Unless they are explicitly mentioned to be preferred in the [developer notes](/doc/developer-notes.md), stylistic code changes are usually rejected. --> <!-- Bitcoin Core has a thorough review process and even the most trivial change needs to pass a lot of eyes and requires non-zero or even substantial time effort to review. There is a huge lack of active reviewers on the project, so patches often sit for a long time. --> The new test code fails at the right place on master ``` test/denialofservice_tests.cpp(292): info: check banman->IsDiscouraged(addr1) has passed test/denialofservice_tests.cpp(293): info: check banman->IsDiscouraged(addr2) has passed test/denialofservice_tests.cpp(294): info: check banman->IsDiscouraged(addr3) has passed test/denialofservice_tests.cpp(296): info: check node->fDisconnect has passed test/denialofservice_tests.cpp(296): info: check node->fDisconnect has passed test/denialofservice_tests.cpp(296): error: in ""denialofservice_tests/peer_discouragement"": check node->fDisconnect has failed test/denialofservice_tests.cpp(222): Leaving test case ""peer_discouragement""; testing time: 32905us ``` nit, maybe not worth it for tests, could use `nodes.at()` notation for bounds checking instead of `nodes[]`::Is this change still needed with #20852? It seems to me that makes the old, much more compact, construction work?::No, if #20852 is merged, then this PR is not needed, see https://github.com/bitcoin/bitcoin/pull/20849#issuecomment-754122796. I first opened this PR to fix `DisconnectNode()` and then realized that the same problem exists in `BanMan`, thus opened #20852 which fixes both by modifying `CSubNet`. Maybe this PR could be preferred as less risky compared to #20852. It is ok if this is merged first and later #20852 is also merged - they do not conflict and both go in `master`.::std::make_unique for new code? Also, could split the refactoring changes from the new-test changes?::Nvm, forget the std::make_unique suggestion. We want to backport the test changes.::",5fd2cee7fbc38c677d08a1545770156cc061833e::98140bc855b037d2c552153496e8e4e2c2efdad9::
https://api.github.com/repos/bitcoin/bitcoin,20671,2012-stdOpt::master,0,merged,Refactoring::,"Now that we can use std::optional from the vanilla standard library, drop the third-party boost dependencyTo avoid conflicts with other pulls or backports? If so it could mention an acceptable time to remove this alias.::I'd say when 0.21.1 is out or when 0.22 is about to get branched off, whichever happens first.::Sounds good to me.::nit: to be explicit ```suggestion CMutableTransaction& tx = *Assert(psbt.tx.has_value()); ``` as were [suggested](https://github.com/bitcoin/bitcoin/pull/20671#issuecomment-748046093) by @jnewbery.::That wouldn't compile. Also, what is the benefit of it?::> That wouldn't compile. Indeed :man_facepalming: Sorry for noise.::",fadd4029dced574778ade228931a7706f92bc676::fa7e803f3e4df33117927aef6fef9bfaee4f410d::fa4435e22f78f632a455016ce00a357009aac059::
https://api.github.com/repos/bitcoin/bitcoin,20660,2020/12/signet-v3-onion::master,0,merged,P2P::,"Since v0.21 hidden services use the longer v3 address format. It may make sense to backport this to the v0.21 branch, although onion nodes can always use the non-onion seeds.",3e6657a14d501c6315ab46ffe7d204684491c710::
https://api.github.com/repos/bitcoin/bitcoin,20571,201204-u8::master,0,closed,Refactoring::,"> Using the C++11 std::array with explicit template parameters is problematic because overshooting the size will fill the memory with default constructed types. [Credits](https://github.com/bitcoin/bitcoin/pull/20566) to **MarcoFalke**.Maybe we should add some overflow assert here? it would be nice if `256_u8` won't compile. the downside is that this function might be used outside of constexpr, but that's very unlikely::ie `assert(byte <= std::numeric_limits<uint8_t>::max());`::> Maybe we should add some overflow assert here? it would be nice if `256_u8` won't compile. Agree... > ie `assert(byte <= std::numeric_limits<uint8_t>::max());` ... but this won't work, unfortunately.::Why not? https://godbolt.org/z/hTjch7::It is not a compile-time error.::You're right, idk how I didn't realized that::You can use runtime asserts in constexpr functions. It just means invocations that would trigger that revert to being runtime evaluated. If the result is assigned to a constexpr variable, it'll error at compile time.::Why does c++ not allow constexpr params, so that a static_assert could be used here?:::man_shrugging: ::C++20 adds [`consteval`](https://en.cppreference.com/w/cpp/language/consteval) which would be useful here.::I'd probably prefer `std::make_array` to be backported. https://en.cppreference.com/w/cpp/experimental/make_array This would allow to write `MakeArray<uint8_t>(1,2,3)`::[`std::to_array`](https://en.cppreference.com/w/cpp/container/array/to_array) from C++20 ?::",b6fb4fa999b927dce07bce239532b0f07bd393a2::
https://api.github.com/repos/bitcoin/bitcoin,20436,fix-clang-qt-determinism::0.21,0,closed,Build system::,"PR'ing into 0.21 because I don't think we want a hack like this in master. Clang fixed a determinism bug in the 9.x series: https://github.com/llvm/llvm-project/commit/db101864bdc938deb1d63fe4f7da761bd38e5cae It was never backported to 8.x, however. I have manually back-ported the fix to 8.x here in case it's useful (with Guix, for example): https://github.com/theuni/llvm-project/commit/df4158d8577618c1f728f89ca88aad5eead656a7 Credit Carl Dong for discovering the determinism problem while working on Guix. Clang 8.x emits non-deterministic code, but only with certain compile options enabled (-O2 is fine but -O3 is problematic; I haven't tracked down the exact guilty flag), and only when compiling very specific code. Qt builds with -O3, so we special-case the source file that manages to trigger the bug and force it to -O2. gcc/clang honor the _last_ -O option, so appending is fine. I suspect @fanquake will hate the fact that we're echoing into a generated file. This would be much cleaner if done at the qmake level, but I'm not sure how to do that. This is a quick nasty work-around, so here are some other potential options: - Bump to clang9 where this is fixed - As @dongcarl suggested: rewrite the some of the qt function (`qt_intersect_spans` in qpaintengine_raster.cpp) to avoid hitting the non-determinism - Disable the buggy behavior via cmdline option I've opted for the last option (Using -O2 as a large hammer), because it was the quickest to write, but the second option would be fine as well. I don't have much of a preference, this is a huge layer violation either way. :) I'd prefer not to bump clang this late in the release process, though.",ddec62c26e769f5ab41ab0eedc8a690f66d99400::
https://api.github.com/repos/bitcoin/bitcoin,20420,upgradewallet-fix-split::master,0,closed,Wallet::,"It is unnecessary to upgrade to FEATURE_HD_SPLIT if this feature is already supported by the wallet. Because upgrading to FEATURE_HD_SPLIT actually requires upgrading to FEATURE_PRE_SPLIT_KEYPOOL, users would accidentally be upgraded to FEATURE_PRE_SPLIT_KEYPOOL instead of nothing being done. Fixes the issue described at https://github.com/bitcoin/bitcoin/pull/20403#discussion_r526063920 Needs backport to 0.21",ecc6458b5a9ade3c6aa4a8a0fc088246eaba632b::
https://api.github.com/repos/bitcoin/bitcoin,20403,upgradewallet-improvements::master,0,merged,RPC/REST/ZMQ::Wallet::,"This follows up on #18836 and #20282 to fix and improve the as-yet unreleased `upgradewallet` feature and also implement review follow-up in https://github.com/bitcoin/bitcoin/pull/18836#discussion_r519328607. This PR fixes 4 upgradewallet issues: - this bug: https://github.com/bitcoin/bitcoin/pull/20403#discussion_r526063920 - it returns nothing in the absence of an RPC error, which isn't reassuring for users - it returns the same thing both in the case of a successful upgrade and when no upgrade took place - the error message object is currently dead code This PR fixes the above and provides: ...user feedback to not silently return without upgrading ``` { ""wallet_name"": ""disable private keys"", ""previous_version"": 169900, ""current_version"": 169900, ""result"": ""Already at latest version. Wallet version unchanged."" } ``` ...better feedback after successfully upgrading ``` { ""wallet_name"": ""watch-only"", ""previous_version"": 159900, ""current_version"": 169900, ""result"": ""Wallet upgraded successfully from version 159900 to version 169900."" } ``` ...helpful error responses ``` { ""wallet_name"": ""blank"", ""previous_version"": 169900, ""current_version"": 169900, ""error"": ""Cannot downgrade wallet from version 169900 to version 159900. Wallet version unchanged."" } { ""wallet_name"": ""blank"", ""previous_version"": 130000, ""current_version"": 130000, ""error"": ""Cannot upgrade a non HD split wallet from version 130000 to version 169899 without upgrading to support pre-split keypool. Please use version 169900 or no version specified."" } ``` updated help: ``` upgradewallet ( version ) Upgrade the wallet. Upgrades to the latest version if no version number is specified. New keys may be generated and a new wallet backup will need to be made. Arguments: 1. version    (numeric, optional, default=169900) The version number to upgrade to. Default is the latest wallet version. Result: {                            (json object) ""wallet_name"" : ""str"",     (string) Name of wallet this operation was performed on ""previous_version"" : n,    (numeric) Version of wallet before this operation ""current_version"" : n,     (numeric) Version of wallet after this operation ""result"" : ""str"",          (string, optional) Description of result, if no error ""error"" : ""str""            (string, optional) Error message (if there is one) } ```Is `static_cast` necessary here? `WalletFeature` should already be an int.::Oh you're right, looks like we can just do `version = new_version` here. Will test a push without the cast. Thanks!::It looks like this is dead code, and always has been. It would be easier to have one way to deal with errors. Either return them as `JSONRPCError` or as `{""error"":...}`, but not both. Also, the error approach should be documented.::Yes, I plan to have a look at this later today. That's the second part of my review feedback from #20282. In #20391 I proposed returning an error field rather than raising an RPC error for this type of errors but wasn't sure which is preferred.::I think either is fine as long as it is documented and consistent. An RPCError makes sense when the return object would otherwise be empty and would have to omit a lot of optional fields, except for the error.::Proposing this: ``` $ ./src/bitcoin-cli -signet -rpcwallet=""blank"" upgradewallet 5 { ""wallet_name"": ""blank"", ""previous_version"": 169900, ""current_version"": 169900, ""error"": ""Cannot downgrade wallet from version 169900 to version 5"" } ``` ::(currently that returns): ``` $ ./src/bitcoin-cli -signet -rpcwallet=""blank"" upgradewallet 5 error code: -4 error message: Cannot downgrade wallet ``` ::Done::Let me know if there is anything needed WRT documenting the error approach.::```suggestion else { CHECK_NONFATAL(!error.empty()); ```::the translation shouldn't be changed here, if you want this to be backported::Oh right (thanks!) and same for the translation just above as well, I suppose ```diff -        error = _(""Cannot downgrade wallet""); +        error = strprintf(_(""Cannot downgrade wallet from version %i to version %i. Wallet version unchanged.""), prev_version, version); ``` ::If you like the translation changes, you can put them into a separate commit and write ""not for backport"" in the commit body::Thanks--done.::Done, thanks::This is not testing what the log claims to test::Good catch ::Thought: do translated strings need to be static? I should look at the implementation.::They can only be literals, but may include format specifiers::Fixed::@achow101 sanity check, if current version is 139900 `FEATURE_HD`, and upgradewallet 159900 `FEATURE_NO_DEFAULT_KEY` is called, is the wallet actually upgrading to 169900 `FEATURE_PRE_SPLIT_KEYPOOL/FEATURE_LATEST` the expected behavior ?::in commit 2310fe9685246b0d505495ee98d38c82a1730293: would be a smaller diff and less complexity if this was moved to the caller, no?::Yes, I tried removing the first commit and just calling GetVersion() in `RPCHelpMan upgradewallet()` but the last test failed. Lines 345, 96 AssertionError: not({'wallet_name': '', 'previous_version': 139900, 'current_version': 169900, 'result': 'Wallet upgraded successfully from version 139900 to version 159900.'} == {'wallet_name': '', 'previous_version': 139900, 'current_version': 159900, 'result': 'Wallet upgraded successfully from version 139900 to version 159900.'}) ::Hm, will try again.::I didn't update one of the version variables the first time. Seems good.::Versions less than `FEATURE_HD_SPLIT` cannot upgrade to `FEATURE_HD_SPLIT` or `FEATURE_NO_DEFAULT_KEY`. They must upgrade to `FEATURE_PRE_SPLIT_KEYPOOL` at which time both the previous features will also be applied. If a user specifies `FEATURE_NO_DEFAULT_KEY` on ` FEATURE_HD` wallet, we should probably give an error and tell the user they can't do that. Edit: This test is `FEATURE_HD_SPLIT`, not `FEATURE_HD`. I'm not sure why it jumps to `FEATURE_LATEST`.::Found it. Here's a fix. ```diff diff --git a/src/wallet/scriptpubkeyman.cpp b/src/wallet/scriptpubkeyman.cpp index d2e1be6402..7dbbf17302 100644 --- a/src/wallet/scriptpubkeyman.cpp +++ b/src/wallet/scriptpubkeyman.cpp @@ -453,7 +453,7 @@ bool LegacyScriptPubKeyMan::Upgrade(int prev_version, int new_version, bilingual hd_upgrade = true; } // Upgrade to HD chain split if necessary -    if (IsFeatureSupported(new_version, FEATURE_HD_SPLIT)) { +    if (!IsFeatureSupported(prev_version, FEATURE_HD_SPLIT) && IsFeatureSupported(new_version, FEATURE_HD_SPLIT)) { WalletLogPrintf(""Upgrading wallet to use HD chain split\n""); m_storage.SetMinVersion(FEATURE_PRE_SPLIT_KEYPOOL); split_upgrade = FEATURE_HD_SPLIT > prev_version; diff --git a/test/functional/wallet_upgradewallet.py b/test/functional/wallet_upgradewallet.py index 7cae913fa1..fdd52ba574 100755 --- a/test/functional/wallet_upgradewallet.py +++ b/test/functional/wallet_upgradewallet.py @@ -342,7 +342,7 @@ class UpgradeWalletTest(BitcoinTestFramework): old_kvs = dump_bdb_kv(node_master_wallet) defaultkey = old_kvs[b'\x0adefaultkey'] self.log.info(""Upgrade the wallet. Should still have the same default key."") -        self.test_upgradewallet(wallet, previous_version=139900, requested_version=159900, expected_version=169900) +        self.test_upgradewallet(wallet, previous_version=139900, requested_version=159900, expected_version=159900) new_kvs = dump_bdb_kv(node_master_wallet) up_defaultkey = new_kvs[b'\x0adefaultkey'] assert_equal(defaultkey, up_defaultkey) ``` This particular change probably needs backport to 0.21, so I'll make a separate PR for it.::In commit 4dc34408bfe8fa1c229d99a3d0d03a42c83ced69 ""wallet: fix and improve upgradewallet result responses"" `requested_version` should be 129999, not 129900::In commit 4dc34408bfe8fa1c229d99a3d0d03a42c83ced69 ""wallet: fix and improve upgradewallet result responses"" The `assert_equal(wallet.getwalletinfo()[""walletversion""], 159900)` below can be removed now.::Good catch, thanks. Done.::Thanks for confirming that. Done.::""a"" is correct...::https://www.referencepointsoftware.com/a-vs-an-before-an-abbreviation/::nit 99d56e357159c7154f69f28cb5587c5ca20d6594: ```suggestion def test_upgradewallet(self, wallet, *, previous_version, requested_version, expected_version=None): ``` Could force named args and pass requested_version in all cases for clarity. Only one call needs to be adjusted, I think.::style nit ca8cd893bb56bf5d455154b0498b1f58f77d20ed: This should check (before the if) that there is either an error or a result, but not both. ```cpp CHECK_NONFATAL(error.empty != result.empty());::> nit [99d56e3](https://github.com/bitcoin/bitcoin/commit/99d56e357159c7154f69f28cb5587c5ca20d6594): > > Could force named args and pass requested_version in all cases for clarity. Only one call needs to be adjusted, I think. Thanks! Good idea.::> style nit [ca8cd89](https://github.com/bitcoin/bitcoin/commit/ca8cd893bb56bf5d455154b0498b1f58f77d20ed): > > This should check (before the if) that there is either an error or a result, but not both. Good idea, that would be better.::Done in e915a2a2c87dad5beb68a175b21a07136bcc21ca::Done in e915a2a2c87dad5beb68a175b21a07136bcc21ca::",c46c18b788cb0862aafbb116fd37936cbed6a431::2498b04ce88696a3216fc38b7d393906b733e8b1::99d56e357159c7154f69f28cb5587c5ca20d6594::ca8cd893bb56bf5d455154b0498b1f58f77d20ed::3eb6f8b2e61c24a22ea9396d86672307845f35eb::
https://api.github.com/repos/bitcoin/bitcoin,20317,2020-07-v20-wtxid-orphan::0.20,0,closed,Backport::P2P::,"wtxid relay (#18044) was backported to 0.20 in #19606. This PR backports the follow-up ""Enable fetching of orphan parents from wtxid peers"" #19569. Also included is commit _p2p: ensure inv is GenMsgTx before ToGenTxid in inv processing_ from #19610 to prevent a possible remote crash bug.",b456adae6e73185ea67501a6b089742f6d7fa9c5::71017eefca5ce5f85bf3a5afd9fc81302e31c340::fefafe39379120e2c047d1ab90bab27af9c72e70::f160607c7223fc34f160ff3a1d8b40e470af37a8::961b02dd7564bcce953588a2a964fce419b5c8da::
https://api.github.com/repos/bitcoin/bitcoin,20008,2020-09-appveyor-backport::0.20,0,merged,Backport::Tests::,"Required for appveyor builds to succeed for other v0.20 backports. For example #19606 fails to build on appveyor without these commits, and succeeds with them. The first commit is actually reversed by the second commit (which also changes `VCPKG_COMMIT_ID`), but I'm backporting them both so that they're clean cherrypicks.",ad99777b57f76a089fb87e3376e37081d560ce2e::498b7cb6f3f11d96129a4934cf1dbdc48c099f3a::
https://api.github.com/repos/bitcoin/bitcoin,19961,update-tor-md::master,0,merged,Docs::Waiting for author::,"It looks like `doc/tor.md` could use some updates and improvements, not only for Tor v3, but also for setting multiple addresses with `-externalip` (see the conversation from http://www.erisian.com.au/bitcoin-core-dev/log-2020-09-16.html#l-39), how to see information about your Tor config via Bitcoin Core, and other improvements. Closes #19924.When a hidden service is created via tor-control, `/var/lib/tor/bitcoin-service/hostname` is not created (credits to @vasild).::But this new text reads: > Given the above configuration ... and just a few lines above it says how to configure the hidden service via `torrc`: > HiddenServiceDir /var/lib/tor/bitcoin-service/ > HiddenServicePort 8333 127.0.0.1:8333 > HiddenServicePort 18333 127.0.0.1:18333 So it is ok to mention `/var/lib/tor/bitcoin-service/hostname`. I would suggest to drop the last line `HiddenServicePort 18333 127.0.0.1:18333` because it is for testnet and also to add `HiddenServiceVersion 3` so that the tor daemon creates a v3 service: ``` HiddenServiceDir /var/lib/tor/bitcoin-service/ HiddenServiceVersion 3 HiddenServicePort 8333 127.0.0.1:8333 ```::Does `bitcoind` configure its onion service via `torrc`?::nit: it is not proper to say ""since Prog1 version X, Prog2 does this..."". It should be ""Since Bitcoin Core version 1.2.3 we make use of..."". I guess it is ok to just drop ""Since Tor version 0.2.7.1, "".::Just suggest `chmod -R 777 .` - it always helps with filesystem permissions problems.::Hmm, https://tb-manual.torproject.org is the Tor _Browser_ manual. Would https://www.torproject.org/docs/tor-manual.html.en be more appropriate?::> Hmm, or https://2019.www.torproject.org/docs/tor-onion-service.html.en ::suggstetion i.e from https://github.com/ElementsProject/lightning/blob/master/doc/TOR.md ``` --- You also need to make your user a member of the Tor group. ""Your user"" here is whatever user will run lightningd. On Debian-derived systems, the Tor group will most likely be debian-tor. You can try listing all groups with the below command, and check for a debian-tor or tor groupname. getent group | cut -d: -f1 | sort Alternately, you could check the group of the cookie file directly. Usually, on most Linux systems, that would be /run/tor/control.authcookie: stat -c '%G' /run/tor/control.authcookie Once you have determined the ${TORGROUP} and selected the ${LIGHTNINGUSER} that will run lightningd, run this as root: usermod -a -G ${TORGROUP} ${LIGHTNINGUSER} Then restart the computer (logging out and logging in again should also work). Confirm that ${LIGHTNINGUSER} is in ${TORGROUP} by running the groups command as ${LIGHTNINGUSER} and checking ${TORGROUP} is listed. If the /run/tor/control.authcookie exists in your system, then log in as the user that will run lightningd and check this command: cat /run/tor/control.authcookie > /dev/null --- ```::""it can configured"" -> ""it can be configured""::good eye, fixed::thanks, done::rewrote the section based on this, thanks @Saibato ::dropped, thanks::Does this mean `onlynet=ipv4` `onion=0` does not disable onion connections? This seems confusing. `-noonion` or `onion=0` is always needed to explicitly disable outbound onion access, as described in the `-proxy` and `onion` section?::(I missed this last commit, glad you asked for the clarification.  I ACKd 42e61805734c36da7a11586aabc7fd5742dba267)::> Does this mean onlynet=ipv4 onion=0 does not disable onion connections? This seems confusing. Yes and No , a default fallback outbound pure .onion not IP name resolving proxy just for onion address will be created by default even without -proxy definition  if  onion!=0   to be precise if -onion== """" and regardless of -onlynet= if -listenonion=1 ( default) if the inbound Tor onion service could be created successfully by the ever  polling torcontroller in bitcoind   (What creates  your advertised Tor address created by bitcoind independent of what onion services defined in torrc ) The idea was, (i guess)  if that is successfully to create also an outbound proxy to reach Tor onion nodes. So suppose u have a running bitcoind daemon and edit at some point just torrc to allow the control port or start the Tor service, bitcoind does if -listeonion=1 permanent poll for such changes and instantly creates on the fly an inbound onion address and an outbound proxy.  So if u want to be sure that the outbound default proxy is disabled since u want i.e. just ipv4 set -noonion since -onlynet=ipv4 wont do that and please note the inbound Tor is created regardless of that if -listenonion=1 what is the default. If that is a desired way to act depends, fixes or changes to that are not merged yet and at least that's the way it is and its now documented so that users are aware of that.::What does it mean ""If SOCKS5 is selected""? How does one select SOCKS5 or what other options are there to select from? I think this should be removed: ```suggestion -proxy=ip:port  Set a proxy server. This proxy ``` as `-proxy=` only supports SOCKS5 proxies.::@jonatack  did edit the comment text to be more precise, so please review ur thumbs up ;-)::Huh! :-( This is indeed a strange behavior, but I think something like the following belongs to `bitcoind -help` rather than `doc/tor.md`: > If -onlynet= is used with other networks and -onlynet=onion is not among them, but -onion= or -proxy is provided then outbound onion connections will still be made! Use -noonion or -onion=0 to disable outbound onion connections in this case. Given that this is a guide on how to enable and configure Tor, not how to disable it, I would suggest to drop the last part and leave it to just: ``` -onlynet=onion  Make outgoing connections only to .onion addresses. Incoming connections are not affected by this option. ```::I think this is excessive and should be removed. * the ""sort"" in the getent command is unneeded and on my computer the entire thing prints: ``` operator _tor You have new mail in /home/toolame/mailbox ``` so, if I am a dummy user, how do I know which is the tor group? * stat gives me error: ``` $ stat -c '%G' /run/tor/control.authcookie stat: illegal option -- c usage: stat [-FLnq] [-f format | -l | -r | -s | -x] [-t timefmt] [file|handle ...] ``` This doc shouldn't be targeted for users who lack basic knowledge of how filesystem permissions work.::I can drop this, but it was existing before this PR.::Are you using a Debian-based system?::Dropped the commit.::Dropped the commit completely.::Dropping this commit.::Dropping this commit.::@jonatack  i am almost certain there will be an rc5 and some backport's ping @luke-jr, so no time to rush here and have another release that is not precise in what the options and Tor-controller does. Do u need a detailed descriiption and  log to show the real behavior?   ::@Rspigler tyi, only explicit -nonion or -onion=0 can prevent outbound onion connections, solely -onllynet=pv4/ipv6 is not sufficient to disable that. that what is said in the PR now dropped. ``` Please use -noonion or -onion=0 if you want to be sure to have no outbound onion connections over the default proxy or your defined proxy.. ``` https://github.com/bitcoin/bitcoin/commit/654dc04b67a44199352a1b25494c9d617cd090bc#diff-a33b1b15efbc14c65460ef7a883b530ca52144a4f06642e4a188351d959f9894R42 So please be so kind to hint what was misunderstanding in this wording that u came to the conclusion that -onion=0 would **not preven**t all outbound onion connections so that we can adapt that in followup PR::@Saibato I might propose the dropped commits, including yours, in a new PR and make some of the changes suggested by @vasild.::@vasild > -onlynet=onion  Make outgoing connections only to .onion addresses. Incoming connections are not affected by this option. I guess its hard to grasp and i was :woman_facepalming:  too when i stumbled about, but what we believed the code does from src comments or doc and almost any post i am aware about bitcoin and Tor and social media is not what really happens when assuming option do what they say and u follow the docs. only -noonion or -onion=0 can prevent that, onlynet= is buggy since  #7553 (2016) Similar but also fact is that although seeders are not called directly in IP if the DNS returns are random that is not the case when bootstrap over Tor here the seeders have full control and can be sure ( or ther MITM'S or proxys)  that the first entry in the DNS return a exit gets will be called since socks5 works that way all seeders ( or what they want to be called ) will be called in a distinct sequence over exist and then ADDR gossip that is highly disturbing give the timing correlation bogus Tor relays and exits can do. Tacking in account that all that happens and wrong configured at bootstrap at least once, *pure* Tor nodes are quite f***ed if they not aware.::@Saibato thanks for the explanation/edits.  Although now dropped, would ACK in a new PR::> @Saibato thanks for the explanation/edits. Although now dropped, would ACK in a new PR Done in #20757, please add suggestions or ACKs there.::Brought back the commits and added also to the -onlynet help in #20757, please add suggestions or ACKs there.::Revived without the `sort` and with a mention that the command is for Debian in #20757.::https://github.com/bitcoin/bitcoin/pull/19961#discussion_r492980674 Even given the above configuration, you make a point to consider we are talking about the operation of the parameter. If the hidden service is created via tor-control and you need to discover it please check you debug.log for lines similar to the following, it should automatically be added as AddLocal ``` 2020-08-11T13:42:26Z tor: Got service ID {random_service}, advertising service {random_service}.onion:8333 2020-08-11T13:42:26Z AddLocal({random_service}.onion:8333,4) ```::",e1765d8b04fe1fb775f3750e0fa59f13a58eb176::dc8a591222f249da81c7eef8aa5961f8d7dd1e23::a34eceb4cc054b4233e7321de927e8a7a2146301::
https://api.github.com/repos/bitcoin/bitcoin,19933,wallet-fix-missing-chars-boost-1.47::master,0,closed,Wallet::,"fixes: #19928Would it be safer to use `.at()` for bounds checks/no UB? nit, clang-formatting ```diff -    while(wallet_dir.string()[offset-1] == '\\' || wallet_dir.string()[offset-1] == '/') -    { +    while (wallet_dir.string()[offset - 1] == '\\' || wallet_dir.string()[offset - 1] == '/') { ```::yup,  draft ugly and no checks, maybe i close it, that PR is now like POC. What we need is an elegant way with just boost 1.47   to do this. Ideas? edit: what would be nice to have /> const fs::path path = fs::relative(it->path(), wallet_dir)::Maybe try `(wallet_dir / ""dummy"").remove_filename().string().size()`::Suggest we assert substr(0, offset) == what we used for calculating offset above::Now we have boost 1.58 (#19667).::Not in supported stable versions.::I guessed it might be backported at least to 0.19 and in 0.18 the bug is only int qt gui so 1.47 might be ok But In hindsight and since u both look at this, the comment at line 73  is not changed by the PR and looks to me like a lingering Dj vu with the GCC bug? Should we change or remove that, so that later no one grabs that trap when we change to std fs::? line 73: // This can be replaced by **boost::filesystem::lexically_relative** once boost is bumped to 1.60.::I think backporting pulls should consider boost 1.47, not this one.::It might be better if the comment said what version is requried, as opposed to the version that we have right now::```suggestion // account for possible trailing backslash,  if we would have bumped to boost 1.60 we could use a simple  fs::relative call ```::",7be117c58537d97db19a5f6f9ea268ac6c8ec49f::
https://api.github.com/repos/bitcoin/bitcoin,19740,backport-17204-fix::0.20,0,merged,Backport::,"Backport `CWallet::SignTransaction` from master which is simpler and not broken. Previously `CWallet::SignTransaction` would return false for a fully signed transaction. This is a regression and obviously incorrect - a fully signed transaction is always complete. This occurs because `CWallet::SignTransaction` would iterate through each input and skip any further checks if the input was already signed. It would then end up falling through to the `return false` catch-all thus erroneously saying a fully signed transaction is incomplete. The change to attempting to use all `ScriptPubKeyMan`s fixes this problem since the `LegacyScriptPubKeyMan` (the only spkm implemented in 0.20) will verify inputs during its signing attempt and correctly return that it is complete when the inputs verify. Thus a fully signed transaction will be correctly identified as complete, `LegacyScriptPubKeyMan::SignTranaction` will return true, and so `CWallet::Transaction` will return true too. Note that this is not a backport of any specific commit. Rather it is the end result of the changes we have made to this function in master. Fixes #19737",2d48d7dcfb93eeec36dd6f5cbad289b89ec69324::6a326cf66f04948ffe729e5540a69e159a7840ad::
https://api.github.com/repos/bitcoin/bitcoin,19612,fix_shellcheck_0_20::0.20,0,merged,Scripts and tools::,"This is causing the tests to fail for backports i.e #19606. If you look in the Travis logs there, the output is: ```bash You are downloading ShellCheck from an outdated URL! Please update to the new URL: https://github.com/koalaman/shellcheck/releases/download/v0.6.0/shellcheck-v0.6.0.linux.x86_64.tar.xz For more information, see: https://github.com/koalaman/shellcheck/issues/1871 PS: Sorry for breaking your build. The hosting costs were getting out of hand :( ```",7ee4769cd4be0975254b218134d057c2bb443509::
https://api.github.com/repos/bitcoin/bitcoin,19606,2020-07-v20-wtxid-relay::0.20,0,merged,Backport::P2P::,"We want wtxid relay to be widely deployed before taproot activation, so it should be backported to v0.20. The main difference from #18044 is removing the changes to the unbroadcast set (which was only added post-v0.20). The rest is mostly minor rebase conflicts (eg connman changed from a pointer to a reference in master, etc). We'll also want to backport #19569 after that's merged.Note: two below here does not get changed to checking for ``` +            if (i.type == MSG_TX) or (i.type == MSG_WTX): ``` as in master PR. Tests seem to still work when I make the change.::This is dropping the padding left zeroes I think with `hex(txid)[2:]` converting a smaller int to hex. Just save txid above as a string, then convert to int after this line and use it directly, or: ``` ""{0:0{1}x}"".format(txid, 64) ``` (I think former is easier :P )::How interesting. Must be a python version thing. I needed to do this locally to strip off the leading `0x`. Will fix.::Sorry I mean for example the txid is like ""5"". It's going to just be `0x05` or something rather than `0x00000000....05`::This will happen if the txid is a sufficiently small `int`::got it. So if the leading byte is 0x00 this fails (1/256 times)::Fixed::In 59f38ad8be2fdbbe2c6cc23bd8e6f226ac493d76 Hm, here I deleted that test by accident which @instagibbs added back, see https://github.com/bitcoin/bitcoin/pull/19649. Might want to not remove it here as well.::",4df3d139b7261de33c070691f76a535b8b17433a::f7833b5bd894aca2d8820402f4a500d71374ea0e::36549376740d28159a5834ecf4ed9eeeeef6715d::606755b840b1560e4f92c9252fa4cab6eacabdd3::73845211d16ad1558d84c966ae18e3507fa7dea6::be1b7a8916fdd060db56846ad5dcec0894aae314::2599277e9cb51e3619582978cba9bf03325c0cb6::93826726e76730b061ec4c91d69b2b34ebf98ec9::181ffadd162a84551b3518de77b5dcc08c712425::c1d6a1003d601ec4ff7d9507563254b29868182f::879a3cf2c2367d51310204d21030f3b218582c30::e364b2a2d879e8d30ca9dbc578e4d169b41eb227::6be398b6fb7a7d5c6c1fe6d74a0700b7ff93674e::e4816819630d1e94469ca5499361e0cd2c9ac7c2::22effa51a77a8b8c72ba3525cb08dd0cf8464715::f082a13ab756a378b260711a30d363f833a2306a::d4a1ee8f1d4c46ab726be83965bd86bace2ec1ec::
https://api.github.com/repos/bitcoin/bitcoin,19464,remove-banscore-option::master,0,merged,P2P::Settings::,"per https://github.com/bitcoin/bitcoin/pull/19219#issuecomment-652684340, https://github.com/bitcoin/bitcoin/pull/19219#discussion_r443074487 and https://github.com/bitcoin/bitcoin/pull/19219#issuecomment-652699592. Edit: now split into 3 PRs: - net: remove -banscore configuration option (this PR) - rpc: deprecate banscore field in getpeerinfo (#19469) - gui, doc, doc: no longer display ""Ban Score"" in GUI Peers window + test/doc fixups (#19512)Mind adding this to the main release notes file? There shouldn't be any conflicts and this is not for backport either.::Done::can be moved to the cpp file and made constexpr?::> can be moved to the cpp file and made constexpr? good idea::Done, then moved it back to the header file to be able to use it in the unit tests. This allowed for some nice improvements there.::Shouldn't this be in `doc/release-notes-19464.md`? `doc/developer-notes.md` says: > Release notes should be added to a PR-specific release note file at `/doc/release-notes-<PR number>.md`::Maybe worth mentioning what is the unit of this?::See https://github.com/bitcoin/bitcoin/pull/19464#discussion_r452835586::What unit would you suggest? It's just a score (see `Misbehaving` in net_processing.cpp), and expected to be removed (see the links in the PR description).::```suggestion section, ""Changes regarding misbehaving peers"" in the 0.20.1 release notes, for details. (#19464) ```::Why the change from 10 to 100 iterations here? :)::Why the change from `100` to `89` here? :)::Because we can no longer use `-banscore` to change the default threshold (see removed line in test: `self.extra_args = [['-banscore=' + str(banscore)]]`), so we have to use `DISCOURAGEMENT_THRESHOLD` here for the number of veracks sans version to send. Note to self: the words ""ban"" in this functional test should be updated to ""discourage"".::See the two removed `-banscore` lines of this test, particularly the first one: `gArgs.ForceSetArg(""-banscore"", ""111""); // because 11 is my favorite number`.::Oh, good catch.::Will touch it up in the GUI PR to remove the banscore field, mentioned in the PR description.::Done, thanks again for seeing that.::",1d4024bca8086cceff7539dd8c15e0b7fe1cc5ea::06059b0c2a6c2db70c87a7715f8a344a13400fa1::
https://api.github.com/repos/bitcoin/bitcoin,19300,2020-06-loadwallet::master,0,merged,Wallet::,"This PR handles concurrent wallet loading. This can be tested by running in parallel the following script a couple of times: ```sh for i in {1..10} do src/bitcoin-cli -regtest loadwallet foo src/bitcoin-cli -regtest unloadwallet foo done ``` Eventually the error occurs: ``` error code: -4 error message: Wallet already being loading. ``` For reference, loading and already loaded wallet gives: ``` error code: -4 error message: Wallet file verification failed. Error loading wallet w1. Duplicate -wallet filename specified. ``` Fixes #19232.I don't think we can assert that a race happened. Races are only intermittent.::I think this one is pretty much guaranteed, loading takes a bit.::```suggestion auto result = WITH_LOCK(g_loading_wallet_mutex, return g_loading_wallet_set.insert(location.GetName())); if (!result.second) { error = Untranslated(""Wallet already being loading.""); return nullptr; } ```::nit: It seems using an unnamed namespace is preferable: - https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines.html#Rs-unnamed2 - https://stackoverflow.com/questions/154469/unnamed-anonymous-namespaces-vs-static-functions - https://stackoverflow.com/questions/4422507/superiority-of-unnamed-namespace-over-static - https://stackoverflow.com/questions/4977252/why-an-unnamed-namespace-is-a-superior-alternative-to-static From the recent pull: - https://github.com/bitcoin/bitcoin/pull/19176#discussion_r435937252 - https://github.com/bitcoin/bitcoin/pull/19176#issuecomment-641304921 >  - Use anonymous namespace instead of static::Any reason to not test the cli? IIRC the reported bug was about the cli::I just need to get the cli equivalent to `get_rpc_proxy`.::I think this is better for a follow up - being a bugfix we should make it minimal so it's easily backported. Unless we allow an anonymous namespace between functions?::Thanks, will apply this.::> I think this is better for a follow up - being a bugfix we should make it minimal so it's easily backported. It's up to you :) > Unless we allow an anonymous namespace between functions? Why not?::Fixed.::Done.::Placed in anonymous namespace.::In commit ""qa: Test concurrent wallet loading"" (9b009fae6e2eb0ab2ee7ce7882c3556a9ac363a7) > I don't think we can assert that a race happened. Races are only intermittent. I would agree with Marco that in general tests like this are fragile and bad and slow and more trouble than they are worth, but also agree with promag that in practice this test is unlikely to fail. To avoid potential problems from this, I'd suggest adding a comment here like ""got_loading_error condition is not guaranteed to be true but very unlikely to be false based on how long it takes to load a wallet"", so in case this does fail, future developers don't waste time trying to figure it out and can ignore or remove the test In general it's easier to write tests for race conditions by making them invasive and implementing them in c++::The race does indeed happen: https://cirrus-ci.com/task/5075565516423168?command=ci#L5121::So it was slower to spawn those threads than to load the wallet. Not sure about c++ test because it would need to force block inside loading. Maybe we could improve this first by waiting for all threads to be ready to load?::",b9971ae5853c1d62e09d976a8705f4f731290d85::9b009fae6e2eb0ab2ee7ce7882c3556a9ac363a7::
https://api.github.com/repos/bitcoin/bitcoin,19224,0_20_1_backports::0.20,0,merged,Backport::,Currently backports the following to the 0.20 branch: * #18700 - Fix locking on WSL using flock instead of fcntl * #18982 - wallet: Minimal fix to restore conflicted transaction notifications * #19059 - gui: update Qt base translations for macOS release * #19152 - build: improve build OS configure output * #19194 -  util: Don't reference errno when pthread fails. * #19215 - psbt: Include and allow both non_witness_utxo and witness_utxo for segwit inputs * #19219 - Replace automatic bans with discouragement filter * #19300 - wallet: Handle concurrent wallet loading,0596a6eeb5ddb84c7095aed71bb7e6645c275f07::c219d21634b3eff537471c4d52e631679965d8d8::5c7151a60468bf3c603ffe0490fbbe95736fdd69::febebc4ea68104bba9ad2cf4468fc50e6136f803::654420d6dfb455ca4030055881db4e3aa9ec6e8b::27786d072dbcf65cba9110f1dd171f94b6abc107::68e0e6f85247c8b9e0b0f039bc31c434632c2982::ed5ec3080419445c0af7410c0af7a421704841a6::3228b59b1761a80bca6aa7309cb46db5acafc905::cf0b5a933da540416b530ca6eb0259ab18cc6548::c9b49d28563487e76169c7749b309244cabc70bd::eb6b82a5586a0cea5b72c376ff377a7322acb588::e7f06f9b0e84a65812d24ff6efa4bc2d3d818590::04773480575ac79f238ac5764247dddd0cae5051::2b79ac740622218a52e2cf3ae1755dd3a8d4847a::
https://api.github.com/repos/bitcoin/bitcoin,19185,fix_gbt_buried::0.19,0,closed,,Identical backport to #19019 (same commit). Backported because 0328dcd is also in 0.19.,2abe8cc3b760219cfa434e4c96e9f8d3611d0037::412d5fe8791c417bf46fc55a5bb8d59be98a33db::
https://api.github.com/repos/bitcoin/bitcoin,19059,macdeploy_translations::master,0,merged,GUI::macOS::,"These haven't been updated since their addition, so this updates the list that controls which qt base translations are bundled with the macOS binary, to all the languages that are available with qt 5.9.8. This could probably be improved in some way, however qt updates are infrequent, and I didn't want to spend any more time looking at this. Also given that no-one seems to have noticed and/or reported this it wouldn't seem high-priority. Could be backported to 0.20.1. Master: ![master](https://user-images.githubusercontent.com/863730/82729428-11bce200-9d2a-11ea-8569-ee65d46c7403.png) This PR: ![fixed](https://user-images.githubusercontent.com/863730/82729427-0f5a8800-9d2a-11ea-86dd-1e6a3e211efa.png)",69bfcac27a83440092bc6e61904ded910ed4baf4::
https://api.github.com/repos/bitcoin/bitcoin,18945,2020_11_0.20_tarball_prefix::0.20,0,merged,Build system::,"In the interest of moving 0.20.0 forward and being able to do rc2, extract and backport the non-controversial part from #18818.: ensure that the source tarball has leading directory name.",59d57f6c103100b3fdef59298d57ee8cf4c0b181::
https://api.github.com/repos/bitcoin/bitcoin,18748,0_20_rc2_backports::0.20,0,merged,Backport::,Currently backports the following to the 0.20 branch: * #18598 - gitian: Add missing automake package to gitian-win-signer.yml * #18702 - build: fix ASLR for bitcoin-cli on Windows * #18676 - build: Check libevent minimum version in configure script * #18665 - Do not expose and consider -logthreadnames when it does not work * #18553 - Avoid non-trivial global constants in SHA-NI code * #18589 - Fix naming of macOS SDK and clarify version,ade4185e63557aca9c60f75e4d6fa111f2c46fd4::842b13a5f44846e21d8a0a0eafb4be7234866a26::1d1e3585fee91c5c445fb6e836a79c3ee223f7cf::6986b26346f8d86128eb55bfa67c023afb7a236f::54d2063d1a395851d9ab9031d8600b983c1523b8::a9ca65bd29d5da63ade1e7995ec121a581ca7b17::7f7548d822549579c57685c691e737f862b29e93::
https://api.github.com/repos/bitcoin/bitcoin,18676,200416-libevent::master,0,merged,Build system::,"The non-`pkg-config` path is ignored as there is a hope to get rid of all of them in #18307. As xenial has [libevent 2.0.21](https://packages.ubuntu.com/xenial-updates/libevent-2.0-5) only, the default bionic Docker image is used in the _""[no depends, only system libs, sanitizers: thread (TSan), no wallet]""_ CI test.Please update the travis yaml as well::Also the workaround in line 18 can be removed::Also release notes are needed to say that xenial is no longer supported with system libs::> Also release notes are needed to say that xenial is no longer supported with system libs In which way: wiki or pr?::Building and running Bitcoin Core on xenial works fine today on master and 0.20.0. Your pull is changing that.::I mean: in which way add this info to release notes?  :)::I'd speak against backporting this to 0.20.0, so it should go into the release notes for 0.21.0::",b68e71796792a9da9daa0a4e759d284d15595230::
https://api.github.com/repos/bitcoin/bitcoin,18284,wrkarnd_boost_wait_until::0.19,0,merged,Utils/log/libs::,"Some boost versions have a bug that can cause a time prior to system boot (or wake from sleep) to throw an exception instead of return timeout See https://github.com/boostorg/thread/issues/308 NOTE: This was addressed in master with a refactor (#18234), so this isn't a strict backport and needs full review. Fixes #18227 Cleanly merges to 0.14+",ed0223ec59e5e7941abf17afd17ede393abea31b::
https://api.github.com/repos/bitcoin/bitcoin,18187,2020/02/macos_runtime_hardening::master,0,closed,Needs rebase::macOS::,"fixes #15774. Adds runtime hardening (which is necessary for macOS app notarization) https://developer.apple.com/documentation/security/hardened_runtime Notarization doc: https://developer.apple.com/documentation/xcode/notarizing_macos_software_before_distribution Hardened Runtime doc: https://developer.apple.com/documentation/security/hardened_runtime App Notarization has been tested [here](https://github.com/bitcoin/bitcoin/pull/18171#issuecomment-587488838) and [here](https://github.com/bitcoin/bitcoin/issues/15774#issuecomment-585331276) Additional release process notes are included. Needs backport.After reading through the [docs](https://developer.apple.com/documentation/xcode/notarizing_macos_software_before_distribution) it seems that passing `--timestamp` here would also be required for notarization; given that we are signing manually? > Include a secure timestamp with your code-signing signature. (The Xcode distribution workflow includes a secure timestamp by default. For custom workflows, include the --timestamp option when running the codesign tool.) ::Is there any reason why we can't pass `--strict` to `codesign` here as well? ```bash --strict options When validating code, apply additional restrictions beyond the defaults. symlinks  Check that symbolic links inside the code bundle point to sealed files inside its bundle. This means that broken symbolic links are rejected, as are links to places outside the bundle and to places that are not, for whatever reason, sealed by the signature. sideband  Check that no resource forks, Finder attributes, or similar sideband data is present in the signed code.  This is now automatically enforced by signing operations. Options can be specified as a comma-separated list. Use plain --strict or --strict=all to be as strict as possible. Note that --strict=all may include more checking types over time. Not all strictness check make sense in all circumstances, which is why these behaviors are not the defualt. ```::Isn't that for validation only?::Good point. Added.::Yes that looks correct.::nit: `notarization`::Thanks. Fixed.::Is ""resources"" misspelled intentionally?::Can `gitian-osx-signer.yml` do this, so we have gitian signatures on the final DMG?::How do we not provide this file? AFAIK anything listed here is required by gitian?::AFAIK it only produces a warning (`sha256sum: signature-osx.tar.gz: No such file or directory`).::Thanks. Fixed.::I don't think so since `stapler` is an macOS developer tool. Unsure if this can be made portable. But, we have gitian signatures on the final dmg. Everything remains deterministic. It's just the code signature and the notarization ticket that needs to be made manual and centralised. Though the notarization ticket is bound to the hash of the dmg (which is built deterministic). I think t is pointless for the macOS code signing key holder to notarize something else because the .dmg hash would not match and the notarization check would fail.::So we're NOT planning to upload the stapled DMG anywhere? ::We do. The staple command above does create the `CodeResources` file (that actually contains the notarization ticket). The macOS code signer commits that file together with the code signatures. See this example: https://github.com/jonasschnelli/bitcoin-detached-sigs/tree/0.19/osx/dist/Bitcoin-Qt.app/Contents. The `detached-sig-apply.sh` takes also that CodeResource file and places it in the final deterministic created app-folder that end up in the final dmg.::It's a bit confusing that there are two `CodeResources` files, that might be worth documenting. There's one in `Bitcoin-Qt.app/Contents/` that you copy below, that's new. And then there's one in `_CodeSignature`, which is bigger.::",55c089ad7008098dcaadf0972df3e9ef237b3112::2b611be101fb0393a1e81e59f32d81f59cabb322::3d596b9f74dafb91a5ba42839cb7b26b4c0733ce::
https://api.github.com/repos/bitcoin/bitcoin,18175,pr17569-0.18::0.19,0,closed,Backport::Build system::Scripts and tools::,Trivial backport of #17569,102547606f512f791ded0a610afe9f41b3ef2666::a0aad741ec2985c1b937383e084c7e062daab35b::
https://api.github.com/repos/bitcoin/bitcoin,18100,2002-univalueBump19::0.19,0,merged,Backport::,Version bump backported from #18099,5e1728017bc2005c70784d235f5d4ba8017d7efd::fa4d00b569253cfdd074821b60ecdc4f17026e88::
https://api.github.com/repos/bitcoin/bitcoin,18091,2020/02/missing_clientmodel::master,0,merged,GUI::,"Fixes #18090 We currently don't pass `clientmodel` changes from the `walletframe` to the `walletviews` leading to possible invalid access during shutdown because all walletviews miss the nullifying of the clientmodel. TODO: needs investigation if this is should be backported.nit, `auto i =`, also add `{`.::fixed.::",2af3e16ca917acd85c2d4f709f6d486519d6af0d::
https://api.github.com/repos/bitcoin/bitcoin,17974,bp18_network_exceptions::0.18,0,merged,Backport::P2P::,"Backport of #17762, currently only backported to 0.19. This seems like something we should opportunistically plug in case wiseguys decide it's a vector to exploit to try and fill people's disks.",c89611ebd33a86c0fe14adecc100065f16ea16da::
https://api.github.com/repos/bitcoin/bitcoin,17954,pr/unlock::master,0,merged,Review club::Wallet::,"This is a set of changes updating wallet code to make fewer calls to `Chain::Lock` methods, so the `Chain::Lock` class will be easier to remove in #16426 with fewer code changes and small changes to behavior.cfc9373 It just occurs to me than this assert and the one in GetLastBlockHeight (than I introduced in 5aacc3e) are unsafe if we don't have a Chain interface from which to query block height at wallet creation (CreateWalletFromFile) but that's something to keep in mind if in the future you can run the wallet without a chain.::cfc9373 As noted in commit, we may have asynchronicity between node and wallet w.r.t block processing. So returned block time may not be the one of last block height. To avoid this we may cache block time to fetch it when needed with `GetLastBlockTime`. It would also remove some `getBlockTime` (but not all last time I looked on).::e399fb4 Previously, `getBlockHeight` would have return nullopt if `merkleBlock` have been out of chain. With this change, a height can be returned and ancestry asserted while node and walle tip being unsynchronized, so `merkleBlock` have been reorged out. IMO that's fine if rpc caller is aware than processing have been done with best-wallet-knowledge. ::673e0b6 Another candidate for `GetLastBlockTime`::673e0b6 I'm not sure about the commit message, IMO it's less accurate but on the whole make the rescan protection better by starting farther in the past. Anyway, being based on wallet tip or node tip should be safe given the range of TIMESTAMP_WINDOW::1f4b604 If #17443 gets first + `GetLastBlockTime`, you may avoid to call `findBlock` here.::> [cfc9373](https://github.com/bitcoin/bitcoin/commit/cfc9373305eed32cd27eb436b555b06bc470dcbf) > > As noted in commit, we may have asynchronicity between node and wallet w.r.t block processing. So returned block time may not be the one of last block height. To avoid this we may cache block time to fetch it when needed with `GetLastBlockTime`. It would also remove some `getBlockTime` (but not all last time I looked on). Just to be clear, height and time here should be in sync due to cs_wallet being held above. Could still cache the time though. Commit description is saying how the GUI display should be more up to date after this commit, because the transaction data and num blocks value will be in sync, instead of a higher num blocks being returned with older transaction data::> [cfc9373](https://github.com/bitcoin/bitcoin/commit/cfc9373305eed32cd27eb436b555b06bc470dcbf) > > It just occurs to me than this assert and the one in GetLastBlockHeight (than I introduced in [5aacc3e](https://github.com/bitcoin/bitcoin/commit/5aacc3eff15b9b5bdc951f1e274f00d581f63bce)) are unsafe if we don't have a Chain interface from which to query block height at wallet creation (CreateWalletFromFile) but that's something to keep in mind if in the future you can run the wallet without a chain. Yes, I think these cases would only be hit when running wallet code offline with the `bitcoin-wallet` tool or something similar. But if we add more offline features more code will have to change to be flexible about missing data::re: https://github.com/bitcoin/bitcoin/pull/17954#discussion_r369228377 > [e399fb4](https://github.com/bitcoin/bitcoin/commit/e399fb49e81416267bb708075ab0a377cacf969d) > > Previously, `getBlockHeight` would have return nullopt if `merkleBlock` have been out of chain. With this change, a height can be returned and ancestry asserted while node and walle tip being unsynchronized, so `merkleBlock` have been reorged out. IMO that's fine if rpc caller is aware than processing have been done with best-wallet-knowledge. Thanks, will add these details to the commit description. I think ""best-wallet-knowledge"" can really be the only safe assumption for calling wallet rpcs if we're going to let the wallet act asynchronously from the node::> [673e0b6](https://github.com/bitcoin/bitcoin/commit/673e0b6e7c9f671096f4056f9db69ec43d5b4a3b) > > I'm not sure about the commit message, IMO it's less accurate but on the whole make the rescan protection better by starting farther in the past. Anyway, being based on wallet tip or node tip should be safe given the range of TIMESTAMP_WINDOW Hmm, I'm not sure when it would be less accurate. Are you thinking of a case?::Even further than cs_wallet, we are still holding cs_main there through the chain lock. When we're going to remove locked_chain we may have asynchronicity due to to height being based on BlockConnected locked by cs_wallet and findBlock locked by cs_main ?::re: https://github.com/bitcoin/bitcoin/pull/17954#discussion_r369234155 I think I meaned because we rely now on wallet last block hash instead of main tip and we may be late from one block, so in my opinion we are _less_ accurate from one block but we agree on rescan being safer. Nit interpretation, doesn't matter.::re: https://github.com/bitcoin/bitcoin/pull/17954#discussion_r369216493 (Relevant commit is cfc9373305eed32cd27eb436b555b06bc470dcbf) > Even further than cs_wallet, we are still holding cs_main there through the chain lock. When we're going to remove locked_chain we may have asynchronicity due to to height being based on BlockConnected locked by cs_wallet and findBlock locked by cs_main ? The GUI is asynchronous by design. It just needs to display internally consistent information within a transaction, and be able to determine if the information is fresh or out of date. The `num_blocks` height here returned to gui is used for that freshness check, so the new value set here should be better than the previous value for that. More ideally, though `num_blocks` will be replaced by a hash, which #17993 starts to do::re: https://github.com/bitcoin/bitcoin/pull/17954#discussion_r369234155 > I think I meaned because we rely now on wallet last block hash instead of main tip and we may be late from one block, so in my opinion we are _less_ accurate from one block but we agree on rescan being safer. Nit interpretation, doesn't matter. I think in the case you are talking about the block height/hash/time values in the backup are now more accurate than before because cs_wallet is locked already. So the backup information make will be consistent with the wallet block tip, not the node block tip, in any cases where they are different::I don't think `num_blocks` is even used. There's only one place that this interface function is called and it doesn't use the result. Can you just remove it?::Agree that caching the last block time would make some of these commits easier.::'specified blocks' is a bit vague. Can you be more precise about what `block_hash` `min_height` and `max_height` mean?::`GetLastBlockHeight()` can't return a `tip_height` that's < 0, so I think you can just remove `|| tip_height < 0 `::Do you need to hold the wallet lock for this entire block? Does it make sense to call: ``` WITH_LOCK(pwallet->cs_wallet, pwallet->GetLastBlockHeight()); ```::Again, I think this is always true, so you can remove this conditional.::re: https://github.com/bitcoin/bitcoin/pull/17954#discussion_r377949561 > 'specified blocks' is a bit vague. Can you be more precise about what `block_hash` `min_height` and `max_height` mean? Added description, also made min_height not `Optional` since nullopt was equivalent to 0::re: https://github.com/bitcoin/bitcoin/pull/17954#discussion_r377880523 > I don't think `num_blocks` is even used. There's only one place that this interface function is called and it doesn't use the result. Can you just remove it? Good catch, and thanks for bringing it up, it is fixed in #18123::re: https://github.com/bitcoin/bitcoin/pull/17954#discussion_r377952847 > Do you need to hold the wallet lock for this entire block? Does it make sense to call: > > ``` > WITH_LOCK(pwallet->cs_wallet, pwallet->GetLastBlockHeight()); > ``` The lock is also needed for the GetLastBlockHash call in the `findAncestorByHeight` line below. This could do something cleverer to reduce locking, and I'm happy to make changes if there are suggestions, but moving the lock seemed like simplest change that would work.::re: https://github.com/bitcoin/bitcoin/pull/17954#discussion_r377952195 > `GetLastBlockHeight()` can't return a `tip_height` that's < 0, so I think you can just remove `|| tip_height < 0 ` Thanks updated::re: https://github.com/bitcoin/bitcoin/pull/17954#discussion_r377953378 > Again, I think this is always true, so you can remove this conditional. Thanks, removed::e276b68 ""If both blocks are on the same chain ancestor_height is the height of the oldest between them. Also return height of first block which may be the same than ancestor height."" But honestly would prefer parameterize `findFork` instead of yet-another-single use method like passing wallet tip hash to findFork (and if null, then use default chain tip). By the way, is `findFork` still used after this change ?::e276b68 If I understand issue linked in the commit message, let's say you call listsinceblock(genesis_hash, 100) with current_tip == 1100 (shouldn't matter referring to `chain_tip` or `wallet_tip`). Target_confirm = 1100 + 1 - 100 = 1001. Lastblock = blockhash(1001) Now while calling again listsinceblock(lastblock_hash, 100) with current_tip = 1100 depth = 1100 + 1 - 1001 = 100 So only transactions with depth < 100 are returned and not the ones with 100-conf as expected by `target_confirmations` (i.e transactions for block 1101, the ""100th"" from the main chain). Is this the behavior you're fixing by returning now the ancestor hash? Seems to me documentation is already marching code ""So you would generally use a target_confirmations of say 6, you will be continually re-notified of transactions until they've reached 6 confirmations plus any new ones"" but not sure if this what we really want..::e276b68 Height of genesis block is 0 ? If so depth is -1 which I think isn't the behavior expected (already there before ?)::e276b68 Why not modify `getBlockHash` a bit to do a `LookupBlockIndex` instead of querying `ChainActive()` ? Every block in ChainActive needs a BlockIndex so second should be a superset and it shouldn't be an issue. If caller care about block being in the active chain, it should call `findFork` just after. (Long-term, IMO wallet shouldn't have to deal with fork and just have a _linear view_ of the chain, only when `BlockDisconnected` is called, state would be rewind. It's should be caller responsibility to enforce tips consistency between it's different components)::6067b74 I think you can move the existing `findFirstBlockWithTimeAndHeight` method of `Chain::Lock` and just avoid adding a new one, it still returns both block height & hash ::6067b74 Just to be sure but is `FindEarliestAtLeast` working as intended ? By passing `min_height=0` std::lower_bound is returning an iterator to the first element for which the comparison object return false, thus with the current comparison being `pBlock->GetBlockTimeMax() < blockparams.first || pBlock->nHeight < blockparams.second` it would return just after the genesis block  ?::9aa4b6b I find `findAncestorByHeight` unclear, here we may have `start_height` and `GetLastBlockHash` not pointing to same block. Behavior follows method documentation but why bother asking for the hash, query in ChainActive with the provided height ? Honestly here I would prefer to stick with `getBlockHash`, behavior is more straightforward.::9aa4b6b Same here, why `ScanForWalletTransactions` function to then add a call to get previously furnished information ? I would prefer to keep removed `getBlockHash` calls in `rescanblockchain`::re: https://github.com/bitcoin/bitcoin/pull/17954#discussion_r379133763 > [6067b74](https://github.com/bitcoin/bitcoin/commit/6067b74431169d54e2c3fd9141021f8caaf04461) > > Just to be sure but is `FindEarliestAtLeast` working as intended ? By passing `min_height=0` std::lower_bound is returning an iterator to the first element for which the comparison object return false, thus with the current comparison being `pBlock->GetBlockTimeMax() < blockparams.first || pBlock->nHeight < blockparams.second` it would return just after the genesis block ? It seems right because `pBlock->nHeight < 0` will be false for the genesis block so the lambda should be false, and lower_bound should stop there, returning the genesis block. This comes from #15670, by the way.::re: https://github.com/bitcoin/bitcoin/pull/17954#discussion_r379123410 > [6067b74](https://github.com/bitcoin/bitcoin/commit/6067b74431169d54e2c3fd9141021f8caaf04461) > > I think you can move the existing `findFirstBlockWithTimeAndHeight` method of `Chain::Lock` and just avoid adding a new one, it still returns both block height & hash I'm removing the other `findFirstBlockWithTimeAndHeight` call later in 3f1b867a096ac24073c59ecd2c660e07cfc2be50 in #15719. I didn't remove it here, because I wanted to keep this PR a little smaller and more limited in scope. I also didn't want to add an extra change for reviewers in code just that's going to be deleted later. But I think #16426 could make the change you're suggesting. I'm pretty sure we're going to merge #16426 before #15719 so it would make sense to have there::re: https://github.com/bitcoin/bitcoin/pull/17954#discussion_r379075632 > [e276b68](https://github.com/bitcoin/bitcoin/commit/e276b6821430ec2c18aba55137daf98bae770054) > > Why not modify `getBlockHash` a bit to do a `LookupBlockIndex` instead of querying `ChainActive()` ? Every block in ChainActive needs a BlockIndex so second should be a superset and it shouldn't be an issue. > > If caller care about block being in the active chain, it should call `findFork` just after. > > (Long-term, IMO wallet shouldn't have to deal with fork and just have a _linear view_ of the chain, only when `BlockDisconnected` is called, state would be rewind. It's should be caller responsibility to enforce tips consistency between it's different components) I'm removing `getBlockHash` in 3f1b867a096ac24073c59ecd2c660e07cfc2be50 from #15719. I think of `findAncestorByHeight` as a more robust replacement for `getBlockHash` that returns the same thing reliably regardless of the chain tip. `findAncestorByHeight` is used in a few places. It's possible these could all go away in the future with your rescan branch, and by replacing `listsinceblock` and `GetKeyBirthTimes` code. The ugliest code is the rescan code. I'm not too worried about the other places, and I think none of the places involve wallet code that would be useful to run offline::re: https://github.com/bitcoin/bitcoin/pull/17954#discussion_r379042572 > [e276b68](https://github.com/bitcoin/bitcoin/commit/e276b6821430ec2c18aba55137daf98bae770054) > > ""If both blocks are on the same chain ancestor_height is the height of the oldest between them. Also return height of first block which may be the same than ancestor height."" > > But honestly would prefer parameterize `findFork` instead of yet-another-single use method like passing wallet tip hash to findFork (and if null, then use default chain tip). > > By the way, is `findFork` still used after this change ? `findFork` only used on startup after this change and is removed later in 3f1b867a096ac24073c59ecd2c660e07cfc2be50 from #15719. I think `findCommonAncestor` is a more robust and more general version of `findFork` that works on any two blocks always returning the same value regardless of the current tip, avoiding race conditions that would otherwise happen when the tip is changing. `findCommonAncestor` returns multiple values, so which of those values comes back in the return type, and which come back through output parameters is an aesthetic choice that isn't too important to me. Probably if we were using c++17 I would have this return a tuple. If you think it's bad to return block1 height, though, I could add a new `int* block1_height` output parameter, and change the return type from `Optional<int>` to `bool`. ::re: https://github.com/bitcoin/bitcoin/pull/17954#discussion_r379070527 > [e276b68](https://github.com/bitcoin/bitcoin/commit/e276b6821430ec2c18aba55137daf98bae770054) > > Height of genesis block is 0 ? If so depth is -1 which I think isn't the behavior expected (already there before ?) `height` is an `Optional<int>` so `height ?` is just checking if the optional value is set. If `height` is `0` the condition will evaluate to true and the correct depth should be set.::re: https://github.com/bitcoin/bitcoin/pull/17954#discussion_r379069325 > [e276b68](https://github.com/bitcoin/bitcoin/commit/e276b6821430ec2c18aba55137daf98bae770054) > > If I understand issue linked in the commit message, let's say you call listsinceblock(genesis_hash, 100) with current_tip == 1100 (shouldn't matter referring to `chain_tip` or `wallet_tip`). > Target_confirm = 1100 + 1 - 100 = 1001. > Lastblock = blockhash(1001) > > Now while calling again listsinceblock(lastblock_hash, 100) with current_tip = 1100 > depth = 1100 + 1 - 1001 = 100 > So only transactions with depth < 100 are returned and not the ones with 100-conf as expected by `target_confirmations` (i.e transactions for block 1101, the ""100th"" from the main chain). > > Is this the behavior you're fixing by returning now the ancestor hash? Seems to me documentation is already marching code ""So you would generally use a target_confirmations of say 6, you will be continually re-notified of transactions until they've reached 6 confirmations plus any new ones"" but not sure if this what we really want.. I think I need to reread your example more closely to give a better response, but the case which this commit should fix is specifically the case where `wallet_tip != chain_tip`. So if the wallet is behind and `wallet_tip=1100` while `chain_tip=1150`, I want the first `listsinceblock` call to return `lastblock=blockhash(1001)` instead of `blockhash(1051)` so transactions aren't missed in the second call::re: https://github.com/bitcoin/bitcoin/pull/17954#discussion_r379150008 > [9aa4b6b](https://github.com/bitcoin/bitcoin/commit/9aa4b6bb6fb5f44a943cd50cb46e0d80275060ce) > > I find `findAncestorByHeight` unclear, here we may have `start_height` and `GetLastBlockHash` not pointing to same block. Behavior follows method documentation but why bother asking for the hash, query in ChainActive with the provided height ? > > Honestly here I would prefer to stick with `getBlockHash`, behavior is more straightforward. Maybe `findAncestorByHeight` needs a better name, but it is supposed to be a direct replacement for `getBlockHash` that turns a block height into a block hash. The only difference is that `getBlockHash` will return different values depending on the current tip, while `findAncestorByHeight` is more stable and always returns the same values regardless of the tip.::> [9aa4b6b](https://github.com/bitcoin/bitcoin/commit/9aa4b6bb6fb5f44a943cd50cb46e0d80275060ce) > > Same here, why `ScanForWalletTransactions` function to then add a call to get previously furnished information ? I would prefer to keep removed `getBlockHash` calls in `rescanblockchain` I don't think that would be an improvement, or know what advantages you see there. The problem with `getBlockHash` calls is that their behavior varies depending on the current node tip. Wallet code is simpler and easier to reason about it only has to deal the last block processed and not have to reconcile last processed information with the node tip. This is why `rescanblockchain` function gets shorter and simpler as a result of this change (and longer and more complicated in the current #16426) This commit just tweaks 3 lines of code in `ScanForWalletTransactions`, and don't seem too significant. The next commit e1381908537267a937bbd3b83eb00f2fa562928e simplifies `ScanForWalletTransactions` a little more, though.::Here's a change that would make all the find block methods return block information same way 6f74c0a042b001283e1d7dd8a8ad8b46c75328e5 ([branch](https://github.com/ryanofsky/bitcoin/commits/pr/getblock)), if it helps EDIT: Newer version 25c1ae48204215622bc9fd3a8bc9677f15c32674::Oh right, it's an Optional, forget about it, forgive my C++ noobiness::Hmmm if I understand `RescanFromTime` expected behavior is to find earliest block with _both_ nTime and height superior at the ones passed not _either_ so sounds like I broke it ?::re: https://github.com/bitcoin/bitcoin/pull/17954#discussion_r379688216 #15670 seems right to me, at least at first glance. `a || b` can only be false if both a and b are false::I think it's confusing to return something unrelated to the common ancestor here...::re: https://github.com/bitcoin/bitcoin/pull/17954#discussion_r381473300 > I think it's confusing to return something unrelated to the common ancestor here... Agreed, will backport 25c1ae48204215622bc9fd3a8bc9677f15c32674 ([branch](https://github.com/ryanofsky/bitcoin/commits/pr/getblock)) as soon as I get a chance::nit: Maybe using `std::numeric_limits<int>::max()` would have been a tiny bit nicer because it would have allowed passing in a default initialized `height`.::I think this means height will not be set within `findAncestorByHash()` and stay 0. Since it seems to not be needed it can probably be removed. Then passing an explicit 0 into the `Confirmation` constructor makes it more explicit that this value is not used/needed.::nit: The other functions around here follow a different style, returning a `bool`. I would have preferred to keep this consistent.::nit: Style-wise I find the use of `Optional` here a bit weird because there are other, more common ways to make an argument optional.::re: https://github.com/bitcoin/bitcoin/pull/17954#discussion_r382628960 > nit: The other functions around here follow a different style, returning a `bool`. I would have preferred to keep this consistent. Yes, this is better. It returns a bool now.::re: https://github.com/bitcoin/bitcoin/pull/17954#discussion_r382654842 > nit: Style-wise I find the use of `Optional` here a bit weird because there are other, more common ways to make an argument optional. Probably most common way we denote optional heights is to use `-1` as a magic unset height value. But I think using `Optional` and `nullopt` is nicer here because it is more explicit and also because the rest of the `interfaces/chain` code is currently using `Optional` instead of `-1`. Since this is a maximum height and the last function parameter, another approach would be to use a `std::numeric_limits<int>::max()` default argument value. But IMO, while default argument values are great for optional outputs, for optional inputs they can be confusing and lead to bugs, especially when there are multiple arguments of the same type and the compiler can't check when a value is passed as the wrong argument::re: https://github.com/bitcoin/bitcoin/pull/17954#discussion_r382500790 > nit: Maybe using `std::numeric_limits<int>::max()` would have been a tiny bit nicer because it would have allowed passing in a default initialized `height`. Should be resolved. Height was just a pointer because it was an output parameter. But now the `FoundBlock` class is used to return information instead of a height pointer::re: https://github.com/bitcoin/bitcoin/pull/17954#discussion_r382612052 > I think this means height will not be set within `findAncestorByHash()` and stay 0. Since it seems to not be needed it can probably be removed. Then passing an explicit 0 into the `Confirmation` constructor makes it more explicit that this value is not used/needed. `height` is passed as output argument to `findAncestorByHash` below, and initialized by that call. The height value does get used and shouldn't actually be 0::3e64b9e I really like this new helper class, just what do you think here of enforching check with a boolean flag to `FillBlock` and upper level method instead of a attribute setup by FoundBlock constructor caller. E.g in `WalletTxToJSON`, `findBlock` is called and `FoundBlock` constructed with a check requirement, which then calls `LookupBlockIndex` and `FillBlock`, and only in this last function the check is going to be enforced.::153f749 Also why not adding a `FoundBlock& ancestor(uint256& hash) { .. }` and let `FillBlock` check if ancestor exists ? (once you understand `FoundBlock` helper class, that's easier to reason on than adding one-use method IMO)::9da0e41 Same here, I think you can make `findAncestorByHeight` and `findCommonAncestor` as `FoundBlock` methods (at least I've tried for `findAncestorByHeight ` it works well)::9701379 Was a bit confused at first, would comment code, here ""If a `max_height` is provided, do a rescan from start_block to it. Otherwise use wallet tip hash as an ending point""::bfa71f8 You may keep the assert against `block_height` parameter?::bfa71f8 We take another wallet lock just few lines behind, I think you can move the call to `GetLocktimeForNewTransaction` there, shouldn't change anything.::Re: https://github.com/bitcoin/bitcoin/pull/17954#discussion_r379693744 After reading again semantics of std::lower_bound _comp_ I think you're right, while block timestamp is inferior at `min_time`, iterator is going to keep moving forward, whatever `min_height` in this case.::re: https://github.com/bitcoin/bitcoin/pull/17954#discussion_r385852029 > [3e64b9e](https://github.com/bitcoin/bitcoin/commit/3e64b9e0d5ac289b525c083f5519d1cf0e5173ed) > > what do you think here of enforching check with a boolean flag to `FillBlock` and upper level method instead of a attribute setup by FoundBlock constructor caller. I didn't really think about it, but looking again, the `.require()` method is pretty pointless. It's easier and clearer to just use CHECK_NONFATAL at the call sites directly. I updated the PR to do this and drop `require()`, but let me know if you think more changes still make sense.::re: https://github.com/bitcoin/bitcoin/pull/17954#discussion_r385876138 > [9da0e41](https://github.com/bitcoin/bitcoin/commit/9da0e4121bf51b5cee6742fce7cec20dbbb9beb1) > > Same here, I think you can make `findAncestorByHeight` and `findCommonAncestor` as `FoundBlock` methods (at least I've tried for `findAncestorByHeight ` it works well) It's not clear when you would want a function to be a member of the chain class vs the block class. Having all functions side by side seems like the simplest starting point::re: https://github.com/bitcoin/bitcoin/pull/17954#discussion_r385861975 > [153f749](https://github.com/bitcoin/bitcoin/commit/153f74900e5241c6f31381902ee7f6cc5bf42e3a) > > Also why not adding a `FoundBlock& ancestor(uint256& hash) { .. }` and let `FillBlock` check if ancestor exists ? > (once you understand `FoundBlock` helper class, that's easier to reason on than adding one-use method IMO) FoundBlock is currently more of a struct with accessor methods than a real class with methods that execute code. If it became a real class wrapping a BlockIndex*, wallet code would no longer be able to construct it locally, instead it would have to make IPC calls to the node to create and destroy it. Also the new methods would have to be virtual and forward from the wallet to node process. The interface would also seem less better organized. I think it's nice for `findBlock` `findFirstBlockWithTimeAndHeight` `findNextBlock` `findAncestorByHeight` `findAncestorByHash` `findCommonAncestor` to all be methods of the same class and all work the same way, than to be in different classes and follow different conventions. I do think a followup could unify these methods, something like: ```c++ chain.findBlock(hash, FoundBlock.height(out_height).time(out_time));                                // current chain.findBlock().hash(hash).getHeight(out_height).getTime(out_time);                               // new chain.findAncestorByHash(block, ancestor, FoundBlock.height(out_height).time(out_time));            // current chain.findBlock().hash(ancestor).descendant(block).getHeight(out_height).getTime(out_time);         // new chain.findAncestorByHeight(block, height, FoundBlock.height(out_height).time(out_time));            // current chain.findBlock().height(height).descendant(block).getHeight(out_height).getTime(out_time);         // new chain.findCommonAncestor(block1, block2, FoundBlock.height(out_height).time(out_time));             // current chain.findBlock().descendant(block1).descendant(block2).getHeight(out_height).getTime(out_time);    // new chain.findNextBlock(hash, height, FoundBlock.height(out_height).time(out_time));                    // current chain.findBlock().hash(hash).height(height).next(), FoundBlock.height(out_height).time(out_time));  // new chain.findFirstBlockWithTimeAndHeight(time, height, FoundBlock.height(out_height).time(out_time));  // current chain.findBlock().minTime(time).minHeight(height).getHeight(out_height).getTime(out_time));         // new ``` But this is kind of baroque and I didn't want to attempt something like that here, even though it could be a followup ::re: https://github.com/bitcoin/bitcoin/pull/17954#discussion_r385895403 > [9701379](https://github.com/bitcoin/bitcoin/commit/9701379d37c6307d8fcdcfbf57d1fe76e6cff060) > > Was a bit confused at first, would comment code, here ""If a `max_height` is provided, do a rescan from start_block to it. Otherwise use wallet tip hash as an ending point"" Thanks, added a similar comment::re: https://github.com/bitcoin/bitcoin/pull/17954#discussion_r385904359 > [bfa71f8](https://github.com/bitcoin/bitcoin/commit/bfa71f856172dc941c844d4b60f15974e8579d61) > > You may keep the assert against `block_height` parameter? If you think it helps, I can add this back, but I did remove it intentionally. It seemed pointless to assert locktime is less than the height just after setting it to the height, something like ```c++ a = b + c; assert(a == b + c); ```::re: https://github.com/bitcoin/bitcoin/pull/17954#discussion_r385909767 > [bfa71f8](https://github.com/bitcoin/bitcoin/commit/bfa71f856172dc941c844d4b60f15974e8579d61) > > We take another wallet lock just few lines behind, I think you can move the call to `GetLocktimeForNewTransaction` there, shouldn't change anything. Thanks, moved under the existing wallet lock ::Okay I get your point with struct-with-accessor-methods vs real-class-with-methods-that-execute-code wrt with IPC/memory separation. My assumption here was we should clean up completely these methods by storing more inside the wallet (like any block header tied to a transaction which matters for us), but that something we should discuss in future PRs/issues. I'm fine with Chain API right now, let's move forward::g++ compiler `-Wmaybe-uninitialized` warning: ``` wallet/rpcwallet.cpp: In function UniValue rescanblockchain(const JSONRPCRequest&): wallet/rpcwallet.cpp:3550:19: warning: *((void*)& stop_height +4) may be used uninitialized in this function [-Wmaybe-uninitialized] Optional<int> stop_height; ^~~~~~~~~~~ ``` Could be ```suggestion #include <optional.h> Optional<int> stop_height = MakeOptional(false, int()); ``` ?::Why `auto locked_chain = wallet->chain().lock();` is still needed?::re: https://github.com/bitcoin/bitcoin/pull/17954#discussion_r395737849 > Why `auto locked_chain = wallet->chain().lock();` is still needed? Good catch, simplified this code::re: https://github.com/bitcoin/bitcoin/pull/17954#discussion_r395695797 > g++ compiler `-Wmaybe-uninitialized` warning: This is a known false positive with no side effects from an old compiler. https://www.boost.org/doc/libs/1_72_0/libs/optional/doc/html/boost_optional/tutorial/gotchas/false_positive_with__wmaybe_uninitialized.html I don't think making code less readable to silence these is a good tradeoff. But if silencing them is actually important, we should at least have an automated check, like a linter or an old gcc running on travis and failing so there doesn't have to be a manual reporting, update, and review cycle each time a new instance turns up. ::> I don't think making code less readable to silence these is a good tradeoff. Let me add some context: https://github.com/bitcoin/bitcoin/pull/14711#pullrequestreview-193702611, #15292, #18052 > But if silencing them is actually important, we should at least have an automated check, like a linter or an old gcc running on travis and failing so there doesn't have to be a manual reporting, update, and review cycle each time a new instance turns up. Do you mean adding of the `-Werror=maybe-uninitialized` option to a compiler on Travis?::nit: ```suggestion const CBlockIndex* ancestor = block->GetAncestor(ancestor_height); return FillBlock(ancestor, ancestor_out, lock); ```::re: https://github.com/bitcoin/bitcoin/pull/17954#discussion_r395866090 > Do you mean adding of the `-Werror=maybe-uninitialized` option to a compiler on Travis? I don't want to make code less readable and I don't want to spend time on an going basis in every PR that uses `Optional` to have a back and forth discussion and extra review cycles just because an old compiler prints a harmless, nonsensical warning. If you disagree and care about these false positive warnings, adding an automated check that catches them on travis should save all of us effort as we continue to use `Optional` variables more places. Maybe that automated check would be a linter, maybe it would be a changed operating system setting or -Werror flag on travis. Again I don't really want these checks, but they would probably work and save some time if we have to spend time this way.::Why the second check `!block->pprev` is needed?::nit: parameter names in the function declaration differ from ones in the function definition: - `FoundBlock& next` vs `FoundBlock& block_out` - `bool* reorg` vs `bool* reorg_out`::Is this comment still relevant? And the mention of `stop_block` in `@pre` comment?::`tip_hash` and `tip_height` could be `const`: ```suggestion CMutableTransaction txNew; FeeCalculation feeCalc; CAmount nFeeNeeded; int nBytes; { std::set<CInputCoin> setCoins; auto locked_chain = chain().lock(); LOCK(cs_wallet); const uint256 tip_hash = GetLastBlockHash(); const int tip_height = GetLastBlockHeight(); ```::re: https://github.com/bitcoin/bitcoin/pull/17954#discussion_r395876846 > nit: I don't see any advantage in this, it is just making the function less consistent internally. It would help to state what perceived advantages are with suggestions like this.::re: https://github.com/bitcoin/bitcoin/pull/17954#discussion_r395892467 > Why the second check `!block->pprev` is needed? Semantics of what hasBlocks should return when blocks don't exist is arbitrary, but I wrote it to consistently return false if any blocks that exist in the specified range are missing data, and true otherwise. There are test cases to ensure this works consistently for min_height and max_height `<` earlier on this line should have been `<=` though, so I fixed this and added some more test cases for edge conditions,::re: https://github.com/bitcoin/bitcoin/pull/17954#discussion_r395903022 > Is this comment still relevant? And the mention of `stop_block` in `@pre` comment? Thanks, removed::re: https://github.com/bitcoin/bitcoin/pull/17954#discussion_r395897426 > nit: parameter names in the function declaration differ from ones in the function definition: > > * `FoundBlock& next` vs `FoundBlock& block_out` > * `bool* reorg` vs `bool* reorg_out` Thanks, switched to names from declaration::re: https://github.com/bitcoin/bitcoin/pull/17954#discussion_r395909697 > `tip_hash` and `tip_height` could be `const`: Thanks, removed these variables that were left over from an earlier version of this commit::in commit e0b02c8cb3 ```suggestion const FoundBlock& ancestor_out={}) = 0; ```::in commit d83fd92520 This is no longer human readable. Idk why the tests don't fail we used to have at least one parser in the python functional test suite :shrug: ::08211e640f ```suggestion virtual bool findAncestorByHeight(const uint256& block_hash, int ancestor_height, const FoundBlock& ancestor_out={}) = 0; ```::08211e640f ```suggestion const FoundBlock& block2_out={}) = 0; ``` Same for other args::```suggestion if (!pwallet->chain().findCommonAncestor(blockId, pwallet->GetLastBlockHash(), /* ancestor_out */ FoundBlock().height(*height), /* blockId out */ FoundBlock().height(*altheight))) { ```::re: https://github.com/bitcoin/bitcoin/pull/17954#discussion_r406891999 > in commit [d83fd92](https://github.com/bitcoin/bitcoin/commit/d83fd9252050b0c44a3d18f23b99bac41aec3865) > > This is no longer human readable. Idk why the tests don't fail we used to have at least one parser in the python functional test suite Thanks, confirmed fix with your test from #18597!::re: https://github.com/bitcoin/bitcoin/pull/17954#discussion_r406887223 > in commit [e0b02c8](https://github.com/bitcoin/bitcoin/commit/e0b02c8cb3e6f3bb079c4bed278003fd69b6d5b3) Updated::re: https://github.com/bitcoin/bitcoin/pull/17954#discussion_r406896254 > [08211e6](https://github.com/bitcoin/bitcoin/commit/08211e640f4432af4a3d67c804ef4a9d0a94edb4) > > Same for other args Updated::re: https://github.com/bitcoin/bitcoin/pull/17954#discussion_r406905419 > Updated::re: https://github.com/bitcoin/bitcoin/pull/17954#discussion_r406896059 > [08211e6](https://github.com/bitcoin/bitcoin/commit/08211e640f4432af4a3d67c804ef4a9d0a94edb4) Updated::",bf30cd4922ea62577d7bf63f5029e8be62665d45::f6da44ccce4cfff53433e665305a6fe0a01364e4::ade5f87971211bc67753f14a0d49e020142efc7c::c1694ce6bb7e19a8722d5583cd85ad17da40bb67::25a9fcf9e53bfa94e8f8b19a4abfda0f444f6b2a::bc96a9bfc61afdb696fb92cb644ed5fc3d1793f1::f7ba881bc669451a60fedac58a449794702a3e23::3cb85ac594f115db99f96b0a0f4bfdcd69ef0590::1be8ff280c78c30baabae9429c53c0bebb89c44d::c0d07dc4cba7634cde4e8bf586557772f3248a42::e958ff9ab5607da2cd321f29fc785a6d359e44f4::48973402d8bccb673eaeb68b7aa86faa39d3cb8a::
https://api.github.com/repos/bitcoin/bitcoin,17924,reuse_regression::master,0,merged,Wallet::,"Regression introduced in https://github.com/bitcoin/bitcoin/pull/17621 which causes p2sh-segwit addresses to be erroneously missed. Tests are only failing in 0.19 branch, likely because that release still uses p2sh-segwit addresses rather than bech32 by default. I'll devise a test case to catch this going forward.Instead of deleting them, couldn't you just call `GetScriptForDestination` in the constructor?::Yes, but that means I have to think more if we want to support more conversions, like `ScriptHash(PKHash())` etc. Like, is this a general tool for generating output scripts, or what?::Yeah, I guess highest priority is fixing the sharp edge. One way or another.::> Instead of deleting them, couldn't you just call GetScriptForDestination in the constructor? Sounds like begging for sharp edges in backporting...::Not sure the second one is needed... WitnessV0ScriptHash is a uint256, which has no constructor?::fixed, added `PKHash` instead since that *is* possible::Why `explicit` here?::I was going back and forth on how to fix this and left that there :) I think this is a no-op::Thank you::",4b8f1e989f3b969dc628b0801d5c31ebd373719c::6dd59d2e491bc11ab26498668543e65440a3a931::
https://api.github.com/repos/bitcoin/bitcoin,17920,2020-01-guix-macos::master,0,merged,Build system::,"This PR brings our Guix builds on par with Gitian in terms of supported architectures. Reviewers: if you run a build, please submit: ``` find output/ -type f -print0 | env LC_ALL=C sort -z | xargs -r0 sha256sum ``` So that we can compare hashes and ensure reproducibility! I assume we no longer have to set `ZERO_AR_DATE` here because we're not using a libtool from cctools? From [libtool.c](https://opensource.apple.com/source/cctools/cctools-927.0.2/misc/libtool.c.auto.html): > all of these values are initialized to reasonable defaults for deterministic archives: archives that are consistent regardless of user, time, or umask differences. Ordinarily, these values and will be set to more specific ones when building new archives, but that can be suppressed using the '-D' option or the ZERO_AR_DATE environment variable.:: ::```suggestion x86_64-apple-darwin18"")_ ``` Throughout this PR, to match depends, gitian etc.::Why are we skipping the security checks for macOS builds? Same Q re symbol checks below. If there's a specific reason why these can't be run right now, we should add a comment. You could also drop `ELF`, as these are already being done on Linux & Win binaries.::Thanks! Fixed as of 05a31a95832b592ee565d3a429afcf6cbf5ae672::Originally I skipped them because we don't perform them in gitian osx builds, which I thought had some significance. As of 05a31a95832b592ee565d3a429afcf6cbf5ae672 they are enabled for all builds in Guix. Sweet!::Why is this changed, seems unrelated to macos, no? Does this break gcc cross builds for our linux archs that need gcc 8 at least?::Btw, this is the comment I was referring to: https://github.com/bitcoin/bitcoin/pull/13665#issuecomment-405601228 I presume that guix is using a gcc-7 that has a fix backported?::",37fe73a092b08fe9d7ce636a1021429de6cda757::c9eb4cf3a0f81bfd72f06fd43b5610f0a4f5e804::f3835dc6a3732dcd4afbb5987f84dc27f2bf55af::34b23f597ec52efb795d72e9e5620712d0010edd::8dbf18cb1d3260d34ba822ceb12e67b1f124ea13::771c4b98a8693eee642f2b118b3193fe6e022291::f1694757ddbcb3635213b085e864851e285c8c12::
https://api.github.com/repos/bitcoin/bitcoin,16690,2019-08-0.19-notes::master,0,merged,Docs::,"Merges in detached release notes, edits each change down to a single paragraph bullet point (or, in a couple cases, two individual bullet points in separate sections each with a single paragraph).  Adds notes for some undocumented changes I found reviewing `git log --merges`.  Also tries something new: adds the PR number(s) after each entry to make it easier for both reviewers and end-user readers to look up the details behind each change.  (If the PR numbers are unwanted, they're easy to remove either in this PR or later in the release process.) I also checked the 0.18 branch but I didn't find anything in the current release notes that had been backported. A particular focus in my editing was trying to keep things concise, particularly by pointing to RPC documentation when available (or upcoming, as in #16629).  I do suspect that one downside of detached notes is that people write longer summaries than they would if they knew there were already 300 other lines of release notes.  :-) The first commit only moves notes, puts them in bullet form, adjusts indentation appropriately, and drops unneeded headers.  It can be reviewed with `git diff --color-moved=dimmed-zebra` for a little bit of a speedup, but unfortunately I wasn't smart enough to split my copy/pasting and line wrapping into separate commits, so it's not a transparently move-only change.s/tweeks/tweaks::I think this is not good advise. BIP37, when connected to your own node, is the most efficient way to get a light wallet without the need of installing middlewares or the need of separate index incompatible with pruning. For this reason, `whitebind` and `whitelist` now support the `bloomfilter` permission, so whitelisted peer can still enjoy BIP37.::>  a warning will be printed I only see a warning calling `src/bitcoin-cli createwallet ""test"" false false """" false` (i.e empty passphrase). Not in the `src/bitcoin-cli createwallet ""test""` (unset?) case.::I'll add a mention of the bloomfilter permission (the ability to specify per-peer/network/interface options via white\* is already mentioned in the document). That said, I'm skeptical of your argument.  For privacy, BIP37 needs to be over a secure private link (e.g. authenticated and encrypted), and if you have that, you can just run the wallet RPCs for even higher efficiency than BIP37 with minimal false positives.  Your pruning argument doesn't make sense to me (BIP37 needs full blocks, so it has problems with pruning that BIP158 doesn't---with BIP158, you can create the block filter and then throw away the full block and undo data); if you're thinking about Electrum-style indexes or Electrum Personal Server rescanning, BIP37 seems equivalent in problems related to pruning).  This is probably off-topic for release notes discussion, though, so DM me on IRC or poke me in #bitcoin if you're bored and want to debate it.  :-)::Is the second comma redundant?::DMed on twitter :)::Among writers, whether or not to always use the serial comma is our version of vi versus emacs.  [Here's](https://www.quickanddirtytips.com/education/grammar/serial-comma) the first search result for the issue, which seems reasonably descriptive and even-handed.  I fall into the camp of people who always use the serial comma, but I willing to do lazy commas if necessary with only a few sotto voce grumblings as if you had also asked me to work in emacs.  :-)::Looks like this detached release note was lost?::note: this was also dropped (seems ok though)::`-whitebind` and `-whitelist`::This was just substantially rewritten.  Original was: ```markdown - The -maxtxfee setting no longer has any effect on non-wallet RPCs. The `sendrawtransaction` and `testmempoolaccept` RPC methods previously accepted an `allowhighfees` parameter to fail the mempool acceptance in case the transaction's fee would exceed the value of the command line argument `-maxtxfee`. To uncouple the RPCs from the global option, they now have a hardcoded default for the maximum transaction fee, that can be changed for both RPCs on a per-call basis with the `maxfeerate` parameter. The `allowhighfees` boolean option has been removed and replaced by the `maxfeerate` numeric option. ``` Revised is: ```markdown - `sendrawtransaction` and `testmempoolaccept` no longer accept a `allowhighfees` parameter to fail mempool acceptance if the transaction fee exceedes the value of the configuration option `-maxtxfee`.  Now there is a hardcoded default maximum feerate that can be changed when calling either RPC using a `maxfeerate` parameter. (#15620) ``` The other note you identified as lost does seem to be so.  I'll create a followup PR for that and the formatting change.  Thanks!::Jup, this is missing now.::```vim s/a error/an error/ ``` ?::This will be release in 0.18.2, so I'd rather mention it in those release notes.::this was never fixed right? I don't see it :(::",e7415a5a95f53abf1f8ffa2085217b249d7caf61::7e1634a927f86dcffc7e35fdd479d19c414b14ab::74e38769895c643d75f77634519c1442fa38bad6::
https://api.github.com/repos/bitcoin/bitcoin,16639,2019/08/backport_max_fee::0.17,0,merged,Backport::Tests::Wallet::,"Backport #16257. Cherry-picked from the 0.18 backport in #16414, but without the [wip] messages and without the last commit (which adds a test in a file that didn't exist in 0.17).",e9adb96f8854d21a02d80b4295f1a2e57579cc18::0e7c7465bf2b9911da094d9790480f94e158f9a5::
https://api.github.com/repos/bitcoin/bitcoin,16608,2018/08/backport-wallet-rbf-default::0.18,0,merged,Backport::RPC/REST/ZMQ::Wallet::,"Backport of #15911 for 0.18 branch. The original PR changed `rawtransaction_util.cpp`, whereas the backport changes `rawtransaction.cpp` to avoid having to also backport #15638.nit: indentation::Fix::",ee950ec465b616b1f7dd14df8f77c66a817c0b64::0942a60c06ab4bde275369e7b7bd1caa3b20778e::576580fe8a063f21c0e903af1cf8f85cd6cb71d7::
https://api.github.com/repos/bitcoin/bitcoin,16504,2019-07-release-notes-15996::master,0,merged,Docs::,"Adds release notes for #15996.This is not going to be backported, so might as well inline it into the main release notes right now.::Done.::",73b692b5310158a5da23a0cbfc6deed76623860d::
https://api.github.com/repos/bitcoin/bitcoin,16341,box-the-wallet::master,0,closed,Refactoring::Wallet::,"Introducing the `ScriptPubKeyMan` (short for ScriptPubKeyManager) for managing scriptPubKeys and their associated scripts and keys. This functionality is moved over from `CWallet`. Instead, `CWallet` will have a pointer to a `ScriptPubKeyMan` for every possible address type, internal and external. It will fetch the correct `ScriptPubKeyMan` as necessary. When fetching new addresses, it chooses the `ScriptPubKeyMan` based on address type and whether it is change. For signing, it takes the script and asks each `ScriptPubKeyMan` for whether that `ScriptPubKeyMan` considers that script `IsMine`, whether it has that script, or whether it is able to produce a signature for it. If so, the `ScriptPubKeyMan` will provide a `SigningProvider` to the caller which will use that in order to sign. There is currently one `ScriptPubKeyMan` - the `LegacyScriptPubKeyMan`. Each `CWallet` will have only one `LegacyScriptPubKeyMan` with the pointers for all of the address types and change pointing to this `LegacyScriptPubKeyMan`. It is created when the wallet is loaded and all keys and metadata are loaded into it instead of `CWallet`. The `LegacyScriptPubKeyMan` is primarily made up of all of the key and script management that used to be in `CWallet`. For convenience, `CWallet` has a `GetLegacyScriptPubKeyMan` which will return the `LegacyScriptPubKeyMan` or a `nullptr` if it does not have one (not yet implemented, but callers will check for the `nullptr`). For purposes of signing, `LegacyScriptPubKeyMan`'s `GetSigningProvider` will return itself rather than a separate `SigningProvider`. This will be different for future `ScriptPubKeyMan`s. The `LegacyScriptPubKeyMan` will also handle the importing and exporting of keys and scripts instead of `CWallet`. As such, a number of RPCs have been limited to work only if a `LegacyScriptPubKeyMan` can be retrieved from the wallet. These RPCs are `sethdseed`, `addmultisigaddress`, `importaddress`, `importprivkey`, `importpubkey`, `importmulti`, `dumpprivkey`, and `dumpwallet`. Other RPCs which relied on the wallet for scripts and keys have been modified in order to take the `SigningProvider` retrieved from the `ScriptPubKeyMan` for a given script. Overall, these changes should not effect how everything actually works and the user should experience no difference between having this change and not having it. As such, no functional tests were changed, and the only unit tests changed were those that were directly accessing `CWallet` functions that have been removed. This PR is the last step in the [Wallet Structure Changes](https://github.com/bitcoin-core/bitcoin-devwiki/wiki/Wallet-Class-Structure-Changes). The commits are organized as follows: * Miscellaneous changes that don't necessarily make sense outside of this PR * Move wallet enums to walletutil.h * List output types in an array in order to be iterated over * Always try to sign for all pubkeys in multisig * Interface definitions and miscellaneous changes in preparation for `ScriptPubKeyMan` integration * Introduce both ScriptPubKeyMan as an interface and LegacyScriptPubKeyMan as a dummy class * Add LegacyScriptPubKeyMan to CWallet * Add function callbacks for wallet flags and versions and wallet database * Fetch the SigningProvider for a script from the wallet * Fetch the ScriptPubKeyMan for given output type and internal-ness, or a given script, or ScriptPubKeyMan id * Implementation of `LegacyScriptPubKeyMan` by copying existing code from `CWallet`. These will pass all tests and do not affect `CWallet` * Implement GetSigningProvider in LegacyScriptPubKeyMan * Implement function to connect ScriptPubKeyMan's NotifyCanGetAddessesChanged and NotifyWatchOnlyChanged to CWallet's * Implement IsLocked and IsCrypted in LegacyScriptPubKeyMan * Implement LoadCryptedKey and AddCryptedKey in LegacyScriptPubKeyMan * Implement UpdateTimeFirstKey, and GetTimeFirstKey in LegacyScriptPubKeyMan * Implement AddWatchOnly, RemoveWatchOnly, HaveWatchOnly, and LoadWatchOnly in LegacyScriptPubKeyMan * Implement AddKeyPubKey and LoadKey in LegacyScriptPubKeyMan * Implement WalletLogPrintf in LegacyScriptPubKeyMan * Implement SetHDCHain, and IsHDEnabled in LegacyScriptPubKeyMan * Implement LoadCScript in LegacyScriptPubKeyMan * Implement LoadKeyMetadata and LoadScriptMetadata in LegacyScriptPubKeyMan * Implement GetKey, HaveKey, and GetPubKey in LegacyScriptPubKeyMan * Implement GenerateNewKey in LegacyScriptPubKeyMan * Implement LoadKeyPool in LegacyScriptPubKeyMan * Implement GetOldestKeyPoolTime, KeypoolCountExternalKeys, and GetKeypoolSize in LegacyScriptPubKeyMan * Implement CanGetAddresses, CanGenerateKeys, and HavePrivateKeys in LegacyScriptPubKeyMan * Implement GenerateNewSeed, DeriveNewSeed, and SetHDSeed for LegacyScriptPubKeyMan * Implement TopUpKeypool, TopUp, and NewKeyPool in LegacyScriptPubKeyMan * Implement ReturnAddress, and KeepKey in LegacyScriptPubKeyMan * Implement GetNewAddress, and GetReservedAddress in LegacyScriptPubKeyMan * Implement MarkUnusedAddresses in LegacyScriptPubKeyMan * Implement IsMine in LegacyScriptPubKeyMan * Implement UpgradeKeyMetaData, SetupGeneration, IsFirstRun, Upgrade, RewriteDB in LegacyScriptPubKeyMan * Implement Unlock, Lock, and Encrypt and LegacyScriptPubKeyMan * Implement ImporScripts, ImportPrivKeys, ImportPubKeys, and ImportScriptPubKeys in LegacyScriptPubKeyMan * Implement GetMetadata in LegacyScriptPubKeyMan * Implement GetKeyOrigin in LegacyScriptPubKeyMan * Implement actually loading everything into LegacyScriptPubKeyMan * Implement CanProvide in LegacyScriptPubKeyMan * Replacing `CWallet` functions and RPC things with calls to `ScriptPubKeyMan` or `LegacyScriptPubKeyMan`. These will compile but are not expected to pass tests hence the `[ci skip]`. * [ci skip] Remove CWallet from IsMine and have CWallet always use ScriptPubKeyMan's IsMine * [ci skip] moveonly: move ismine stuff to be a module of LegacyScriptPubKeyMan * [ci skip] Have GetNewAddress, GetNewChangeAddress, and ReserveAddress use ScriptPubKeyMan * [ci skip] Mark used addresses in ScriptPubKeyMan * [ci skip] Call UpgradeKeyMetaData for each ScriptPubKeyMan * [ci skip] Sign using SigningProvider from ScriptPubKeyMan when signing within CWallet * [ci skip] Do not allow import*, dump*, and addmultisigaddress RPCs when wallet is not backed by LegacyScriptPubKeyMan * [ci skip] Change Imports to use LegacyScriptPubKeyMan Imports * [ci skip] Use SigningProviders and ScriptPubKeyMans in listunspent, signmessage, signrawtransactionwithwallet, and getaddressinfo * [ci skip] Use LegacyScriptPubKeyMan in addmultisigaddress and sethdseed * [ci skip] Use LegacyScriptPubKeyMan for hdseedid in getwalletinfo * [ci skip] Change KeypoolCountExternal and GetKeypoolSize to get aggregate sizes from ScriptPubKeyMans * [ci skip] Have IsHDEnabled fetch from ScriptPubKeyMans * [ci skip] Fetch oldest keypool time from ScriptPubKeyMans * [ci skip] have TopUpKeyPool call TopUp in each ScriptPubKeyMan * [ci skip] Have EncryptWallet, Lock, and Unlock call their respective functions in ScriptPubKeyMans * [ci skip] Use LegacyScriptPubKeyMan throughout psbt_wallet_tests * [ci skip] Use LegacyScriptPubKeyMan throughout wallettool * [ci skip] Use ScriptPubKeyMans' Setup and Upgrade functions when loading or creating a wallet * [ci skip] Define first run as having no ScriptPubKeyMans * [ci skip] Use RewriteDB action when DB needs rewrite * [ci skip] Use GetTimeFirstKey instead of nTimeFirstKey * [ci skip] Use LegacyScriptPubKeyMan for in wallet_tests * [ci skip] Use LegacyScriptPubKeyMan in dumpprivkey and dumpwallet * [ci skip] Change CanGetAddresses to fetch from ScriptPubKeyMan * [ci skip] Fetch the correct SigningProvider for signing PSBTs * [ci skip] Use LegacyScriptPubKeyMan in test util * [ci skip] Use LegacyScriptPubKeyMan in some parts of getbalances and createwallet * [ci skip] Have getPubKey and getPrivKey use SigningProvider * [ci skip] Use LegacyScriptPubKeyMan in benchmarks involving the wallet * [ci skip] Store p2sh scripts in AddAndGetDestinationForScript * Tying everything together and removing the `CWallet` functions. * Remove unused functions and switch CWallet to use ScriptPubKeyManI'm very suspect at this line. We are assigning a dereference pointer. I think we should prefer `is_mine = &m_wallet->IsMine(dest);`::This name doesn't indicate a boolean return value.  Why not isPubKey()?::Include `redeemScript.size()` size in the logging so we can debug easier ::Can we use BYTE to be more informative of the type::`provider` should be checked before dereferencing ::Please add space around operators ::Could be void since we always return true.::Looks like we could remove error and use empty string `""""`  below. ::Is this done as an optimization? I'd prefer: ``` void CWallet::SetCrypted() { LOCK(cs_wallet); fUseCrypto = true; } ```::Please try to understand the code you're commenting on.::C++11 does not have such a type.::@sipa: Clarifying what you're referring to would be both constructive and polite :)::The old `get...Key` returning `bool` smells: either the pubKey is a boolean, or `getPubKey` has a side effect of getting the key somewhere else instead of as a result. Could this PR fix that by renaming it to `isPubKey()`?::Such key code would certainly benefit from linting.::This line is merely changing how `IsMine` is called. In order to avoid difficulties for reviewers, the existing code (the assignment itself) is not being changed.::I am trying to avoid changing existing code as much as possible in order to avoid additional review burden. Feel free to change this later, but changing it here is out of scope for this PR.::This is part of a scripted diff. Such a change would both not part of the script and be unrelated to this PR.::This is existing code and is merely a rename. Changing what it returns is out of scope for this PR.::This is moved code and I will not be changing it in order to avoid overburdening reviewers with ensuring that behavior hasn't changed.::No, `GetNewAddress` takes a reference which `""""` is not.::Done::Done::The nice thing about the way it was done before is that if this expr returns false it would get short circuited and `CreateSig` wouldn't be called too. Now it's the opposite. which I think makes less sense when we know that CreateSig is more work than that simple expr, so it might do CreateSig just to fail that if afterwards.::shouldn't this be `return sh;`?::This is necessary for `LegacyScriptPubKeyMan::CanProvide` to pass. That uses the `DUMMY_SIGNATURE_CREATOR` which creates dummy signatures without checking whether the `SigningProvider` has the private keys (as it should). However, in `CanProvide`, we want to make sure that we do actually have the private keys, and if the dummy signing returns us dummy signatures that correspond to keys that we don't have, `CanProvide` will fail. So we need it to give us all of the signatures (by putting them in the `sigdata`) so that `CanProvide` can check for whether it actually could sign.::Yes, done.::is checking that `spk_man` isn't null needed here assuming you already call `spk_man->cs_KeyStore` which is a deference?::nit. snake case for the function arguments?::&& short-circuits; it doesn't evaluate its right hand is the left hand was false.::Yes. My point was that he deferences it a few lines above when he acquires a lock. ::wallettool looks to be broken when there are other `ScriptPubKeyMan` classes. I'll investigate in the Descriptor wallets PR.::This change to using `spk_man` here is not actually needed. I've changed it to use `CWallet::IsHDEnabled`::In commit ""Always try to sign for all pubkeys in multisig"" (d0b41dc26a74e158bd22259aed50869c9676e3fd) I'm not deeply familiar with this code, and I found the explanation a little hard to follow, but in case it helps anyone else, the key seems to be that calling CreateSig unconditionally is needed to fill sigdata. I can confirm that `rpc_psbt.py` test fails without this change.::In commit ""Add function callbacks for wallet flags and versions and wallet database"" (bae5b518ec507d071a54ce4810dd24b016bcfe12) This could just say `using ScriptPubKeyMan::ScriptPubKeyMan` to inherit the parent constructor instead of repeating it all. Even at the end of this PR, this constructor is empty except for some member initializations which would be better to do at the points of declaration.::I also found this explanation difficult. Is there any way to succinctly say the desired effect, and put it in a comment in the code?::Please add a short comment on what this is in charge of and what it's not.::s/output_types/OUTPUT_TYPES/::Comment on how these are indexed?::> m_internal_spk_managers[OutputType::LEGACY] Please leave a comment noting that any output type is the same in this context.::we have the list of output types, let's just iterate through them here to build this::we have the list of output types, let's just iterate through them here to assert these::In commit ""Refactor rawtransaction_util's SignTransaction to have previous tx parsing be separate"" (b49bbb939be92a67ff77c3f7bca5bb94dd141906) > nit. snake case for the function arguments? Better in a separate PR, this PR is huge already and the change would make this commit a lot harder to follow.::In commit ""Implement GetSigningProvider in LegacyScriptPubKeyMan"" (a31374df794d709cf8acfbafc7d5b57f74b1d75a) Not important, but this should never be null so a reference makes more sense than a pointer in this class::In commit ""Implement function to connect ScriptPubKeyMan's NotifyCanGetAddessesChanged and NotifyWatchOnlyChanged to CWallet's"" (7b57deac879499e4b0ee99f1efc320600907bc59) `const auto&` instead of `auto` would avoid copying and incrementing / decrementing shared_ptr atomic reference counts, would also make it clear that the std::pair is not changing::In commit ""Implement GetKeyOrigin in LegacyScriptPubKeyMan"" (b893f0d053f1b5be1229d4fb77ced46b222f9993) It's unclear why this change is in this commit. Is it supposed to be part of the next one 93322bf756fd8991fb445e327c878e2695fe9ca9?::I added a comment.::Done::Done::Changed all of these iterations to `const auto&`::Done::Done::Done::Done::Done::Yeah. Moved it::Done::I think this commit deserves its own PR anyway; as does any refactor that's a prequisite for the main PR.::this function doesn't create one, just returns null::I know this is from CWallet but I'd rather avoid hungarian notation for new variables: `m_use_crypto`::I know there's no documentation where you got this from but could there be an explanation of this field?::for reviewers: this whole commit is cloned from CWallet's implementation::I know this is cloning but `std::make_pair` like everywhere else::please change all these ""store"" references to pubkeyman references::this seems to add the optional params for no reason vs master. remove them, or at least annotate what they mean.::renamed to `GetTotalKeypoolSize` to make it clear it counts both?::on second thought, nevermind. for now straight copy is good.::It's always counted both, and I would prefer to keep this consistent with `CWallet::GetKeypoolSize`.::I don't think it's necessary to change all of these.::Edited comment.::Done::Done::Removed the optional params. They still need to be specified in when binding the function though.::missing `error.clear()` that CWallet has?::realized this doesn't exist in master, please put explanation in comment on what it's used for::there's no flag being set here anymore. If intentional, I'd like an explanation and fixup of this comment::please elaborate on stuff :P it's important for spotting missing functionality since I don't think there's an equiv block in old wallet code::seems a bit of a misnomer even based on my reading::any reason you're not actually referencing `VERSION_HD_CHAIN_SPLIT` directly?::and why the logic change here? master doesn't have this version check::this has nothing to do with the DB, other than it's called right after `database->Rewrite(""\x04pool"")` by the caller. Please rename it to something sensible e.g., `ClearKeypool`::can you explain the diff in code from master with the batch pointer being set in this function, when it's set to null, etc?::Can you explain where the `SetAddressBookWithDB` call went for reviewers? ::Brief comment on what this does? (I don't think similar existed before in CWallet)::why this move? is this preparatory? ::Maybe leave a comment in this block that the pubkeyman has no use for this key, it's just an encryption key. I was tripped up on this. Bad naming! bad!::please explain in header what it `CanProvide`::why?::nit: annotate the bool arg, or make it an enum::no need to gate here, `TopUp` already checks for this in `TopUpKeyPool`::`LegacyScriptPubKeyMan::GetReservedDestination` does this check as well::It remains in wallet.cpp since the address book isn't part of `ScriptPubKeyMan`.::not immediately obvious to me how this gets accomplished in new flow? `GetNewDestination` case is covered, just not this one?::It could be watch only (as DUMMY_SIGNATURE_CREATOR works for watch only things), which then causes issues elsewhere when a private key is assumed to exist but doesn't for watch only things. So this prevents those code paths being taken for watch only things.::The equivalent blocks in old wallet code are the various `SetHDSeed(GenerateNewSeed())` lines scattered around in a bunch of places. How is it a misnomer?::just use `spk_man` here (if you cannot, please annotate why in comments)::just use spk_man here (if you cannot, please annotate why in comments)::just use spk_man here (if you cannot, please annotate why in comments)::just use spk_man here (if you cannot, please annotate why in comments)::Referencing `VERSION_HD_CHAIN_SPLIT` directly requires including walletdb.h which is a circular dependency. The logic is slightly different here because without it, it would end up marking the newly generated keys as pre-split on later runs on the same LegacyScriptPubKeyMan. This is an issue because for a LegacyScriptPubKeyMan, Upgrade() will be called 6 times (once for each address type and internalness). If you were to run `-upgradewallet` multiple times on master, you would see the same problem.::It's supposed to be post-processing that is done by ScriptPubKeyMan when the db had to be rewritten, hence the name. Other ScriptPubKeyMans may do something different.::encrypted_batch used to be set from within `EncryptWallet` before `EncryptKeys` was called. Since `EncryptKeys` is now `ScriptPubKeyMan::Encrypt`, it doesn't have access to CWallet's encrypted_batch, so we need to pass it in and set it when the `ScriptPubKeyMan` is encrypting.::It just returns a `CKeyMetadata` as the function name suggests. It is needed so that getting metadata no longer requires direct access to `mapKeyMetadata` which no longer exists in CWallet and is not guaranteed to exist in other ScriptPubKeyMans (e.g. it is generated on the fly in native descriptor wallets).::Yes. `cs_KeyStore` sometimes needs to be locked by the caller.::Done::Done.::Removed the comment.::I updated the comment.::Done::Done::why not just iterate over `GetActiveScriptPubKeyMans` result, should be more complete and less brittle to updates?::`GetActiveScriptPubKeyMans`?::GetActiveScriptPubKeyMans?::GetActiveScriptPubKeyMans?::comment for this whole commit: why is this here? I don't see direct connection with anything. Could this be moved earlier in PR or split out?::It's handled internally by `spk_man` in the same way that `GetNewDestination` does.::Done::Done::Done::Done::Done::Done::Done::Done::Done::Done::Done::it was needed for some tests to pass. I've moved it up near the front of the PR.::Please be specific. `GetNewDestination` literally has the call to `LearnRelatedScripts`, I can't find the corresponding one for this.::I've added a call to `LearnRelatedScripts` in `GetReservedDestination`::The state variables vMasterKey, fUseCrypto, and fDecryptionThoroughlyChecked seem to end up duplicated in both the CWallet and in KeyMan classes: https://github.com/bitcoin/bitcoin/blob/fb0058ed68a18053959001a0191f3fbcfec50526/src/wallet/wallet.h#L591 https://github.com/bitcoin/bitcoin/blob/fb0058ed68a18053959001a0191f3fbcfec50526/src/wallet/scriptpubkeyman.h#L246 Is this by design, or could KeyMan instances store references or pointers instead? It seems not ideal for different KeyMan instances to potentially be storing their own copies of encryption state and maybe having variables like fDecryptionThoroughlyChecked set inconsistently. Also, the SetCrypted and IsLocked functions are duplicated almost but not quite verbatim across both classes: https://github.com/bitcoin/bitcoin/blob/fb0058ed68a18053959001a0191f3fbcfec50526/src/wallet/wallet.cpp#L3996-L4012 https://github.com/bitcoin/bitcoin/blob/fb0058ed68a18053959001a0191f3fbcfec50526/src/wallet/scriptpubkeyman.cpp#L213-L231 I don't know if any of this is harmful, but it does seem more messy than it needs to be. What would you think about introducing an interface like: ```c++ class WalletStorage { virtual ~WalletStorage() = default; virtual const std::string& GetDisplayName() = 0; virtual WalletDatabase& GetDatabase() = 0; virtual const CKeyingMaterial& GetMasterKey() = 0; virtual void IsWalletFlagSet(uint64_t)> = 0; virtual void SetWalletFlag(WalletBatch&, uint64_t)> = 0; virtual bool UnsetWalletFlagWithDB(uint64_t) = 0; virtual bool CanSupportFeature(enum WalletFeature) = 0; virtual void SetMinVersion(enum WalletFeature) = 0; }; ``` that would allow ScriptPubKeyMan to get access to database and crypto functionality without creating a circular dependency on CWallet, and without needing the current std::function trampolines and duplication of crypto code. The idea would be to declare this interface in scriptpubkeyman.h or a standalone header, pass it to scriptpubkeymanager instances, and have CWallet inherit and implement it.::I've added `WalletStorage` as you suggested. However I did not change `vMasterKey`, `fUseCrypto`, and `fDecryptionThorouglyChecked` to be references or pointers as allowing `ScriptPubKeyMan`s to modify these variables in `CWallet` itself may result in inconsistent states where one `ScriptPubKeyMan` has finished en/decrypting but another has not. Properly changing them to use references could be done in the future, but doing it now would cause the places that use them to differ even more and thus make review harder.::What's the reason for using `unique_ptr` and `shared_ptr` so many places to begin with? It doesn't seem like we'd ever want `KeyMan` instances to outlive their `CWallet` instance, or to be shared between multiple `CWallet` instances. So wouldn't it be simplest to store `KeyMan` instances in `CWallet` `unique_ptr<>` or `set<unique_ptr<>>` member variables so they get cleaned up when the wallet does, but otherwise just use plain `&` references or `*` pointers everywhere else (address types maps, accessors, and higher level code)?::The use of `shared_ptr` was because `ScriptPubKeyMan` objects were being passed around a lot. I've changed this to store them as a `unique_ptr` and instead just pass around the `ScriptPubKeyMan*` as you suggested.::Thanks! If desired, I think you could take it further and drop LegacySigningProvider wrapper class if the CWallet::GetSigningProvider methods are returning plain pointers. Also, I think there's no need anymore to change CWallet::database from a unique_ptr to a shared_ptr. (It's a little nicer as a unique_ptr to be sure the database is closed when a wallet's unloaded and not kept open with a dangling reference.)::Can you add the bit about `LegacyScriptPubKeyMan::CanProvide` as well to the comment?::Should this say ""we have _any_ private key"" instead of _the_ private key? ""DUMMY_SIGNATURE_CREATOR works for watch only things"" is useful to add as a comment. Can you also explain under what circumstance `DUMMY_SIGNATURE_CREATOR` does _not_ produce a signature? It's also useful to reiterate here that `ProduceSignature` doesn't necessarily produce an ECDSA signature, but a script signature, which in turn may contain a (dummy?) ECDSA signature.::What's the equivalent pre-box code for this? If nothing, can you explain in a comment why you need these three distinct checks?::I think you can drop `[ci-skip]`; tests pass for me locally on this commit. It's still not clear to me what this is doing. The function already calls ` keystore.AddCScript`, so why do this twice?::I suppose we can't burry `IsMine` deep inside a private method? :-)::Nit: move closer to `UpgradeKeyMetadata`::Shouldn't this be part of the legacy box?::Why does this live in `scriptpubkeyman.h` rather than `wallet.h`? Can you add a few comment lines to explain the purpose of `WalletStorage` and how it relates to `CWallet` and `ScriptPubKeyMan`? In particular I don't get why (in the next commit) each `ScriptPubKeyMan` instance needs this. Maybe move this commit closer to where you first need it.::Maybe point out that having only 1 entry in `m_spk_managers` here means that functions like `GetSigningProvider`  that iterate over ""all"" `PubKeyMan`s really only query once.::How is this different from `m_spk_managers`?::Maybe clarify the meaning of ""Active"", and how this is different from `m_spk_managers`. Presumably the latter may, in a descriptor wallet, include `PubKeyMan` that we don't draw new address for. Maybe rename commit to `Introduce GetScriptPubKeyMan methods`.::I think `LegacySigningProvider` class adds some clarity.::Shouldn't this only loop over active `ScriptPubKeyMan`s?::It makes sense to me to have `WalletStorage` only cover stuff that's global to the wallet, rather than unique to each  `ScriptPubKeyMan`. The end result is that this commit is now manageably small. However, at the PR level, shouldn't `CWallet`'s `IsCrypted()` be looping over all  `ScriptPubKeyMan`s, just like `SetCrypted()` does? _update: `IsCrypted()` doesn't loop, I was looking at `CWallet::EncryptWallet`_::Would be good to prefix with `m_`::> However, at the PR level, shouldn't `CWallet`'s `IsCrypted()` be looping over all `ScriptPubKeyMan`s, just like `SetCrypted()` does? `SetCrypted` doesn't loop. The thought I had here was that it could be possible that a wallet is considered encrypted (by virtue of having an encryption key set) without any of the `ScriptPubKeyMan`s having any of them actually encrypting anything and thus be `IsCrypted() == false`.::Of course there is no pre-box equivalent, CWallet was just passed in as the SiginingProvider always!::No::No::To avoid circular dependencies. I am not moving this commit. It belongs right there. *** It serves the exact same purpose as the commits it replaces does, to provide access to some functions that require reading and/or modifying some wallet storage things like the database handle, the wallet version number, and wallet flags. It's there to avoid having callbacks and binding functions.::I don't think that's necessary to point out.::`m_spk_managers` can have inactive `ScriptPubKeyMan`s.::Active means that we actively draw addresses from them, i.e. they are in `m_internal_spk_managers` and `m_external_spk_managers`.::It makes everything else more complicated to do so.::In commit ""Implement LoadKeyPool in LegacyScriptPubKeyMan"" (0d701bd42d0d9db9da858a4e6ae346ae0b1dda90) Empty `src/qt/stqG2SM` file in this commit should be dropped::> It's still not clear to me what this is doing. Nor is it to me. It makes the tests pass. That's. it.::I'm not writing an essay. It is completely unnecessary to describe what DUMMY_SIGNATURE_CREATOR does here as you can just look at the `sign.cpp/h` where it is defined and read the comments and code there yourself. It's less than 10 lines.::Done::How'd that get there? Removed it.::This function has no tests, half a dozen different code paths and calls really confusing legacy code like IsMine. There's probably less than 5 people on the planet who understand it, and even fewer who understand the ways this can break for some weird use cases. The only excuse for not documenting it is if it's copied from a legacy function. <img width=""775"" alt=""Schermafbeelding 2019-09-18 om 09 18 31"" src=""https://user-images.githubusercontent.com/10217/65124848-4fc47200-d9f5-11e9-8772-b278589d4f46.png""> ::Did this call move somewhere? Or is it not important and just dropped?::I've added some comments.::No.. but we should probably keep it, so I've added it back in.::Yes. Changed::I don't think it makes sense to have a comment with such specific information about the wallet in the non-wallet signing code. There's already a comment there explaining why we try to sign for all keys.::I wasn't sure if the new `m_spk_managers.empty()` condition here is equivalent to the previous `mapKeys.empty() && mapCryptedKeys.empty() && mapWatchKeys.empty() && setWatchOnly.empty() && mapScripts.empty()` condition. I think it is equivalent because the `LoadWallet(*this)` call above will only call `GetLegacyScriptPubKeyMan()` internally if keys are found, and if it does not, `SetupLegacyScriptPubKeyMan()` will not have been called yet and  `m_spk_managers` will be empty. But correct me if I'm wrong. I guess it's a little confusing that `GetLegacyScriptPubKeyMan` right now will actually create a legacy keyman if one doesn't exist, and never return null, even though there are checks for it returning null throughout the code. Maybe there should be two different methods for clarity: ```c++ LegacyScriptPubKeyMan* GetLegacyScriptPubKeyMan(); LegacyScriptPubKeyMan& GetOrCreateLegacyScriptPubKeyMan(); ``` Just a suggestion, though, and correct me if I missed anything.::CWallet::fDecryptionThoroughlyChecked variable isn't actually used anymore, only assigned to. It should probably either be used or removed. Maybe it's not necessary anymore since keyman has the same variable.::It'd make more sense to call spk_man_pair.second->IsHDEnabled on the individual keyman object than IsHDEnabled on the wallet object, which is the intersection of all IsHDEnabled statuses.::Yes, that is correct. That's pretty much the only reason `GetLegacyScriptPubKeyMan` also creates a `LegacyScriptPubKeyMan`. The checks for null are for the future when we have more `ScriptPubKeyMan` classes.::I've added `GetOrCreateLegacyScriptPubKeyMan`::Removed it::Done::The encryption stuff here is making my head spin. Wallet encryption was already confusing before, but now with CWallet and ScriptPubKeyMan both having duplicate `fUseCrypto`, `SetCrypted()`, `IsCrypted()`,  `vMasterKey`, `IsLocked()` states and code, it's hard to tell which combinations of state are expected, and which are bugs, and whether the code supposed to be keeping states in sync actually works. I have a few suggestions to try clarify things. These should also simplify the code. 1. Drop the `CWallet::fUseCrypto` member and `CWallet::SetCrypted()` method. Change `CWallet::IsCrypted()` method to just loop over keyman objects and call IsCrypted on them. As far as I can tell the `CWallet::fUseCrypto` state is broken in the current PR. `CWallet::SetCrypted()` used to be called whenever any encrypted data was present, but now that now longer happens, and `CWallet::IsCrypted()` returns false if the wallet hasn't been explicitly encrypted or locked since startup, regardless of what encrypted keys or data are present. 2. If the intent is to consider a wallet encrypted ""by virtue of having an encryption key set"", it'd be better to add a new method `bool HasEncryptionKey() { return !mapCryptedKeys.empty(); }` instead of overloading `IsCrypted()`. It might also make sense to rename the existing `IsCrypted()` function `HasEncryptedData()` in that case so the meaning is not confused. 3. This last suggestion is less important, but I think it'd be better to lock and unlock the entire wallet, instead of parts of it. The keyman `vMasterKey` member and `IsLocked()`, `Locked()`, and `Unlocked()` implementations copied from wallet code could all be dropped. Keyman instances should have a `fDecryptionThoroughlyChecked` member and have `CheckDecryption()` methods, but otherwise would be simpler if they just called `IsLocked()` and `GetMasterKey()` from `WalletStorage` instead of implementing locking and unlocking themselves.::I'll take a look at reworking the encryption state stuff.::In 8a2d51c741b896842e093fa35590ef36abb907c4: `case TX_PUBKEYHASH` contains a bug fix. Maybe move that to a seperate commit so this commit is actually move-only. <img width=""566"" alt=""Schermafbeelding 2019-09-21 om 10 27 29"" src=""https://user-images.githubusercontent.com/10217/65370562-746d5380-dc5a-11e9-9eb4-f979ba634ac3.png""> ::In 3099b7c2dbfd31f4a1747f7e38629e44988d6ef7: for other reviewers, this is more or less lifted from `getaddressinfo` in `rpcwallet.cpp`.::In d3dde67e4aba051bea38daae60ed80fd4db69d3b:  `GetOldestKeyPoolTime` was introduced in #10235. It calls `GetOldestKeyTimeInPool` for the internal and external keypools. IIUC this gets the timestamp from keypool entry at index 0. For legacy wallets those are the same, so `std::max` is fine. But if we add descriptor wallets, and allow importing them after wallet creation, then `std::max` would return the newest one. So maybe we should switch to `std::min` here and initialize `oldestKey` with `Time()`? Alternatively we could drop `keypoololdest` in the RPC wallet for non-legacy spk_managers, and show it for each individual descriptor instead of the whole wallet.::I've changed the encryption stuff to be mostly in line with @ryanofsky's suggestions. *** > As far as I can tell the `CWallet::fUseCrypto` state is broken in the current PR. `CWallet::SetCrypted()` used to be called whenever any encrypted data was present, but now that now longer happens, and `CWallet::IsCrypted()` returns false if the wallet hasn't been explicitly encrypted or locked since startup, regardless of what encrypted keys or data are present. FWIW it wasn't broken. `SetCrypted` was changed to be called during wallet loading so `fUseCrypto` would be true and thus `IsCrypted()` returned true. Otherwise tests wouldn't pass.::Moved into its own commit::I've changed it to use `min`. Looking at the original implementation in master, it actually looks like it's broken as it uses `max`.::I don't think there's any reason for CWallet::encrypted_batch to exist as a member variable anymore. It could just be a local in CWallet::EncryptWallet::Seems like this should use GetLegacyScriptPubKeyMan not GetOrCreateLegacyScriptPubKeyMan to make more sense and be in line with the previous code. Or if GetOrCreateLegacyScriptPubKeyMan is actually better here, probably should drop if (spk_man) condition which would never be false::Done::Changed to GetLegacyScriptPubKeyMan.::It'd be good to initialize this to nullptr since it's not set in the constructor like pwallet is::SetWalletFlag method and override don't seem to be called anymore could be removed.::Looks like this should be removed. (Calls and definition were removed but not this declaration.)::In commit ""Remove unused functions and switch CWallet to use ScriptPubKeyMan"" (47b342db0ddb1bc9bc595635e36bb2f16921a605) There's no replacement for this function and I think losing it might break `CWallet::GetKeyBirthTimes` for encrypted wallets. Regardless, this should probably become a keyman method instead of being removed so the SigningProvider interface returns consistent results.::Master key argument should be a const reference, not mutable. Also these arguments could be named master_key, since there's no longer any vMasterKeyIn/vMasterKey conflict.::The `fUseCrypto` variable seems completely pointless now that IsCrypted is locking `cs_KeyStore` and checking `mapCryptedKeys.empty()`. As far as I can tell it only barely made sense before as an optimization to avoid locking. Would suggest dropping `fUseCrypto` and dropping the `SetCrypted` method, just replacing `if(!SetCrypted()) return false` calls with `if (!mapKeys.empty()) return false`::`fUseCrypto` is needed for wallet loading in order to load the initial encrypted key. In that situation, `mapCryptedKeys` will be empty because no keys have been loaded into memory.::It's used in descriptor wallets (next PR).::Done::Done::Added `LegacyScriptPubKeyMan::GetKeys`::Done::re: https://github.com/bitcoin/bitcoin/pull/16341#discussion_r328791872 > `fUseCrypto` is needed for wallet loading in order to load the initial encrypted key. In that situation, `mapCryptedKeys` will be empty because no keys have been loaded into memory. I think since you removed the `SetCrypted` call at the beginning of  `CWallet::Lock`, the `fUseCrypto` variable no longer contains any useful information (it's just a stale sometimes out-of-date cache of `!mapCryptedKeys.empty()`), and that's why HasEncryptedData now has to take a lock and return `fUseCrypto || !mapCryptedKeys.empty()` instead of just the previous `fUseCrypto`. If you got rid of the `fUseCrypto` variable and the `SetCrypted()` method as described https://github.com/bitcoin/bitcoin/pull/16341#discussion_r328786049, I think it would be equivalent to the current code and more comprehensible.::It doesn't feel like that is safe. A blank wallet would have `mapKeys` empty so would that be considered encrypted?::> It doesn't feel like that is safe. A blank wallet would have `mapKeys` empty so would that be considered encrypted? No, but I'm not suggesting that. `HasEncryptedData()` could return `!mapCryptedKeys.empty()` and `fUseCrypto` and `SetCrypted` could both be deleted. The two `if(!SetCrypted()) return false` lines would just be replaced by `if (!mapKeys.empty()) return false`::> No, but I'm not suggesting that. `HasEncryptedData()` could return `!mapCryptedKeys.empty()` and `fUseCrypto` and `SetCrypted` could both be deleted. The two `if(!SetCrypted()) return false` lines would just be replaced by `if (!mapKeys.empty()) return false` This does not work since `mapKeys` is not empty utnil after a wallet is encrypted, but the places the `SetCrypted` are used are `AddCryptedKey` which is used during `Encrypt`.::> This does not work since `mapKeys` is not empty utnil after a wallet is encrypted, but the places the `SetCrypted` are used are `AddCryptedKey` which is used during `Encrypt`. Wow, that's confusing. It makes the meaning of the fUseCrypto member very difficult to describe. How about just clearing mapKeys at the beginning instead of the end of the encrypt function? ```diff -    fUseCrypto = true; -    for (const KeyMap::value_type& mKey : mapKeys) +    KeyMap keys_to_encrypt; +    keys_to_encrypt.swap(mapKeys); // Clear mapKeys so AddCryptedKeyInner will succeed. +    for (const KeyMap::value_type& mKey : keys_to_encrypt) ```::This breaks blank encrypted wallets (necessary for born encrypted wallets).::I was able to remove `fUseCrypto` and instead used a check for whether there were any encryption keys present (required adding `HasEncrytionKeys` to `WalletStorage`).::Might be good to standardize on `GetKeyPoolSize` pr `GetKeypoolSize` (both are used after this change)::In commit ""Implement GetOldestKeyPoolTime, KeypoolCountExternalKeys, and GetKeypoolSize in LegacyScriptPubKeyMan"" (26c1ebe6a7bea812860636f9d7316fc71b8d90dc) Is it a bugfix to include set_pre_split_keypool size in this return value? Wallet method doesn't do this, so behavior seems to change in later commit 937cf1e2265ace44147475dc9da8a5ec0b1dda47 https://github.com/bitcoin/bitcoin/blob/f4a0d27e85754d60804ffa36e415b67c263180b9/src/wallet/wallet.h#L1251-L1255::In commit ""[ci skip] Use GetTimeFirstKey instead of nTimeFirstKey"" (4b7effe37f5efeddb54523b95e58d464bc317e7f) Is this a bug? It seems like this should say ``` time_first_key = std::min(time_first_key, spk_man->GetTimeFirstKey()); ``` If this is a bug, I'm a little surprised there isn't any test coverage for this.::Yes, that is a bug fix.::Standardized on `GetKeyPoolSize` as that was already being used.::Seems like a bug, fixed. Changing it has no effect on any tests...::I think it'd make sense to add `if (HasEncryptionKeys()) return true;` before this loop so `IsCrypted` meaning is unchanged and it'll reliably return true if wallet encryption is present, regardless of what keyman instances are created and how they function internally.::Not asking for this change here since it could be a pain to backport, but in the future I think it'd be nicer if `HasEncryptedData` simply returned `!mapCryptedKeys.empty()` and `HasEncryptionKeys` simply returned `!mapMasterKeys.empty()` so the two functions would be independent and not call each other. At call sites, I think it would be an improvement to write: ```c++ if (!m_storage.HasEncryptionKeys() && !HasEncryptedData()) ``` instead of ```c++ if (!HasEncryptedData()) ``` because otherwise it's not clear that the presence of wallet encryption keys is a controlling factor (this is confusing in `AddKeyPubKeyInner` when you'd expect to be checking for the presense of keys to encypt new data with, not the presence of already encrypted data)::Should this be called `m_storage` instead of `storage`?  Also any particular reason this is private and not protected so keyman implementations could access the interface directly without having to go through an extra hop?::Not asking for this change here since it could be a pain to backport, but in the future I think it'd be nicer to drop these wrapper functions and for keyman implementations to explicitly call storage methods, so the split between what data is managed by the top level wallet class and what data is managed by individual keyman implementations is clearer.::Should drop this clear. The map is already cleared above, so having this extra clear separated by a long loop seems confusing and maybe dangerous if the code is changed again in the future::Sure. I used the wrappers so that moved code wouldn't need to change.::Why is `&& !IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)` added here? This seems broken because why would you want to return true from GetReserved if reserving a key failed? But it also seems like it should not be able to make any difference because the CanGetAddresses call above would return false if private keys were disabled. I'd suggest either dropping this condition or adding an explanatory comment. Tests do seem to pass if this is dropped. Also, I'm not sure if the CanGetAddresses check added above is more than just a sanity check, but if it is actually an expected condition, it'd be useful to have a comment saying when it's expected to trigger. It seems like a fine check, but it's not clear what the motivation was for adding it. Tests do seem to pass without it.::Done::Changed to `m_storage` and made protected.::Done::This TopUp seems newly added rather than moved, and the return value isn't checked. Tests also seem to pass without it. I also noticed TopUp calls were removed in `GetNewChangeDestination` and `CreateWalletFromFile`, and I don't know why. These changes seem ok, but I guess the things I'd like to know would be: 1. If something in particular motivated these changes, or if they just seemed like a good ideas. 2. In general, if there's some kind of reasoning about where the keypool should be topped up. For example, I'd expect either keyman objects to be responible for topping up internally, or for the wallet to be responsible, but not for calls to happen both places. If there is intent behind this, maybe the Topup method could have a comment saying when it's supposed to be called. Could also consider reverting top up changes that aren't necessary here. I think I'll be done with my neverending review of this PR soon, but little changes like this I don't understand do not make the end seem closer!  :smiley:::This particular `TopUp` was moved from `GetNewChangeDestination` into `GetReservedDestination` because `GetNewChangeDestination` does not determine which `ScriptPubKeyMan` to use, but `GetReservedDestination` does. Where in `CreateWalletFromFile` were `TopUp`s removed? It's likely that those were rolled into `SetupGeneration`.::Removed. I don't remember why they were added, could have been due to some previous change that was since changed so they are no longer needed. I believe the CanGetAddresses check is for sanity.::Ok, thanks for the explanation. The changes here do make sense since they're just moves. I didn't realize the GetNewChangeDestination and GetReservedDestination changes were related, or that SetupGeneration calls TopUp (indirectly through LegacyScriptPubKeyMan::NewKeyPool). ::In the original line that this was copied from there was a `&& !DISABLE_PRIVATE_KEYS` check, I believe to avoid the `GenerateNewKey` call below. I think this got accidentally deleted in a [recent update](https://github.com/bitcoin/bitcoin/compare/c14ad7a89811cb1efe6ed82dff22890dc654ac44..ce944a2f30b21f9950fd5f5b69a860eb180d2eb9) and would be good to restore: https://github.com/bitcoin/bitcoin/blob/7b701fef58f627956d597817a1f9422edd890cdc/src/wallet/wallet.cpp#L3694::Done::Should remove CryptedKeyMap, WatchOnlySet, and WatchKeyMap definitions from wallet.h since they are now unused and duplicated in scriptpubkeyman.h::Can this be changed to start with max int rather than the current time, similar to the other oldest key loop: https://github.com/bitcoin/bitcoin/blob/2d8785dd618b85dd8714d70a47e066be9b6e1969/src/wallet/wallet.cpp#L3830-L3833 It seems nicer as an API if GetOldestKeyPoolTime would return a fixed value you could check against, rather than an ever changing current time.::Done::Done::The `EXCLUSIVE_LOCKS_REQUIRED(cs_KeyStore)` annotation appears to be a mistake. `Wallet::GetNewDestination` calls this method without acquiring cs_KeyStore: https://github.com/bitcoin/bitcoin/blob/0fb52e481f411fdf67257965a9144522b4bac87c/src/wallet/wallet.cpp#L3082 The only reason there's no compile error is that the call is happening through the overridden declaration above which is missing EXCLUSIVE_LOCKS_REQUIRED: https://github.com/bitcoin/bitcoin/blob/0fb52e481f411fdf67257965a9144522b4bac87c/src/wallet/scriptpubkeyman.h#L161 Probably what should happen here is that `EXCLUSIVE_LOCKS_REQUIRED(cs_KeyStore)` should be dropped and `cs_KeyStore` get locked internally instead.::The EXCLUSIVE_LOCKS_REQUIRED annotation here is a little dodgy because the parent virtual method doesn't have the same annotation, so it will be bypassed if this is called through the parent class. To address this, it might be a good idea to add EXCLUSIVE_LOCKS_REQUIRED to the parent declaration in SigningProvider, or to add an AssertLockHeld in `LegacyScriptPubKeyMan::AddKeyPubKey` for more enforcement, or to remove the annotation and just lock cs_KeyStore internally in AddKeyPubKey. It might be a good idea to AssertLockHeld(cs_KeyStore) in LegacyScriptPubKeyMan::AddKeyPubKey, because the EXCLUSIVE_LOCKS_REQUIRED annotation won't be enforced if AddKeyPubKey is called through the overriden virtual method. Other options would be to EXCLUSIVE_LOCKS_REQUIRED::Seems like a bug to no longer set ReserveDestination::address here, since it might be needed later to call ReturnDestination: https://github.com/bitcoin/bitcoin/blob/0fb52e481f411fdf67257965a9144522b4bac87c/src/wallet/wallet.cpp#L3294 Should there be a `this->address = dest` line after the GetReservedDestination call above?::I think the `address` property is unused, so we could just drop it: https://github.com/Sjors/bitcoin/commit/aa5ea3768a2858d7776d798edf63b421849b9714::While it may be unused, it may also be useful in the future with other ScriptPubKeyMans. I think it also makes more sense for ReserveDestination to explicitly have the destination stored as that was part of why that was added. I've added `address = dest` back in.::Changed to lock internally.::Changed to lock internally.::micro-nit: `ScriptHash sh(script);`::nit: Check for what about the decryption check?::future cleanup: Redundant with `HasEncryptionKeys`::CWallet also needs this apparently?::non-blocking nit: No longer an extension of a keystore, which isn't found anywhere anymore::Can this explanation be made more concrete? Why are these things set here versus elsewhere in ScriptPubKeyMans/CWallet? ""storage"" vs ""database"", why does the database in ScriptPubKeyMan and referenced inside m_storage as well?::re: https://github.com/bitcoin/bitcoin/pull/16341#discussion_r334172583 > ""storage"" vs ""database"", why does the database in ScriptPubKeyMan and referenced inside m_storage as well? There isn't a good reason for this. I marked the change adding `m_database` as one of the ""Unclear if this change is necessary or useful"" changes in my branch: d18e2cd8642a6b4e73be0482ef19f76698f1ef62::The underlying relations were explained to me offline. Incoming expanded comment hopefully.::Done::Added a comment::Expanded the comment.::Shortened.::""Wallet storage for things""::I think it is correct as is. It's things for wallet storage that ScriptPubKeyMans need.::This comment isn't the clearest, its only right now that this is true. But I guess you're changing this soon in the other PR anyway.::nit: `its`::All of these are properties of the wallet itself as you describe in the comment above. Why make them accessible from each scriptpubkeymanager? (d89011ffca9144ddd28e53177d5e722fadaf2164 Add WalletStorage class and have CWallet inherit it)::This constant is used elsewhere in the code too (e.g. BIP32PubkeyProvider), it would be good to factor it out everywhere (not important for this PR though)::I don't really understand why this is a function in LegacyScriptPubKeyMan. IMO these should be moved out into standalone functions and just SetHDSeed should be part of the LegacyScriptPubKeyMan. Or just combine these functions with SetHDSeed so it derives+sets at the same time.::This could be simplified for readability ::Why is this TODO here? ::The commit title is wrong, Address ->  Destination::why not just return true and get rid of `result`::new_version isn't used? What situation did you have in mind for this? I haven't checked to see if this changes in descriptor wallets yet so I won't be surprised if its here for the future, but it seems weird not to check it before upgrading to HD (new_version = prev_version should be a noop)::They were originally together but later split apart to allow for the `sethdseed` RPC. I suppose it should be `DeriveAndSetHDSeed` which calls `SetHDSeed`. But since this is moved from how it is currently, I will leave it as is.::Maybe for a followup? Would prefer to leave this as a move::It was moved from the original implementation.::IIRC I had that there originally for upgrading a legacy wallet to a descriptor wallet. But since we are no longer doing that, it can be removed. I believe it was going to be used in combination with #15761 (or rather #15761 was split from an earlier implementation).::Yes, should be cleaned up in a follow up.::I've updated the comment to be a bit clearer. I don't think it will be changed with descriptor wallets.::Fixed.::Done. Got rid of `result`.::Removed `new_version`. For anyone who is wondering why this is works and/or is safe, the new version is set as the wallet maximum version so all of the `CanSupportFeature` calls will fail if the specified new version is too low.::@meshcollider several of these (`protected`) methods are used by each scriptpubkeymanager. E.g. `IsWalletFlagSet()` is checked in `LegacyScriptPubKeyMan::UpgradeKeyMetadata()`. `UnsetWalletFlagWithDB()` is used to mark a wallet as no longer blank when a key is added. `GetDisplayName()` and `SetWalletFlag` are unused, but I'm fine with keeping them for completeness.::re: https://github.com/bitcoin/bitcoin/pull/16341#discussion_r338954347 > @meshcollider several of these (`protected`) methods are used by each scriptpubkeymanager. E.g. `IsWalletFlagSet()` is checked in `LegacyScriptPubKeyMan::UpgradeKeyMetadata()`. `UnsetWalletFlagWithDB()` is used to mark a wallet as no longer blank when a key is added. `GetDisplayName()` and `SetWalletFlag` are unused, but I'm fine with keeping them for completeness. I think it would be best to eliminate **all** these methods because they obscure the difference between wallet and key manager objects and between storage and key management functionality. They also make call sites less clear about what the calls are intended to do. In my [`pr/keyman` branch](https://github.com/ryanofsky/bitcoin/commits/pr/keyman) I've marked the change adding these methods (2d08c308a3d9936c389c86786e666c0b71c81052) as one of the questionable ""Unclear if this change is necessary or useful"" changes and put it at the end of the branch so it could be easily dropped or reverted.::I don't have strong feelings on whether the left or right side of 2d08c30 is more clear. Explicit references to `m_storage` might discourage relying on it more; is the long term goal to get rid of `m_storage` usage in `ScriptPubKeyMan`s?::> is the long term goal to get rid of `m_storage` usage in `ScriptPubKeyMan`s? This would be a surprise to me. As far as I know, key managers will continue to need a way to read and store data in the wallet database, and `WalletStorage` provides a limited and controlled interface for doing that. Even if the wallet storage interface is going to be eliminated or cut back at some point, having wrapper functions that imply a key manager is storing its own data now when it isn't muddles the code and adds pointless hops in the meantime. I don't think this is an important issue at all. Just surprised if getting rid of the indirection here wouldn't be the obvious choice.::They can be removed in a follow up PR. The intention of wrapping up each function was to make the moves less painful and more clear that they were moves.::Now we know :-) #18067::re: https://github.com/bitcoin/bitcoin/pull/16341#discussion_r377810942 Wow, missed this thread. Reviewers: ""I don't know what this this doing."" Author: ""Me either, but it makes tests pass."" Reviewers: ""ACK"" ""ACK"" You guys! :heart:::There was a bit more back and forth, but yeah... :-(::",f44a1f4202d4e1d748910ac1dba0f8eb6047dec8::3a5fb0135db302af1016240261ba846ea906b862::36eaf9e7399d9097aa7fbdf3d79905765ee3fdb4::67891ae7f345c1889ad2aadf9a2152633e71f81a::fb7647a6fc3b44a62a608c2b28fb546a35d44586::43c43ff4d498343f8408193cf7e03c26979ba2ed::b363de355d2fdbd0208d1347f6376b083df04cfd::ee6bacd7b5ddd8c041b50b0597f2248c8976ec84::f4958a4ee71772acb373c4553830c7408bd8413c::d8831ee5e08412c502ed01c365e86fe040db7cd0::1557bb64a8eed3a5247481fcc6bf7ca1fdeb3dc1::3946efcde6cf0ee6825cf41fe7afaf0e70b7aa40::d67b8f41fedaad9bbc9dec9751d6295f2c2f50c6::e3333365036b9ed38086ebef8851f1e4b3de2cba::4626daacd4074917f43262a39c273b08f17832c8::8bfe9e5bbea53f0525c776247fa377dac4f5663b::a6d1b2d5ba7e119daf6d6f4cb0a2687af8b1e2e3::3900abb6e34c6d2a5af0262d03b77af3722e4d32::642a802b3622aa067b75a405546fbbb8eaea25d8::739ace8144ed8dc9903aa9d4f5c9ad752a116819::0161c0c20fd73f328d9e9eb852aa36a889ec3fa4::96801f0d56d1c0a770a0a922f54b8295250c230d::84b294259c053a388649244596b1ff34746c5333::62d57108b87b184cc098f2a6b769541a90814201::b88b27d0c38bb57ff469de2770a6efb0f23750b5::cc11df184370c8ca15224537dfc6147e1ad7ad47::8653db5ed5adc31472bc3ffb15f329987fe1bb62::334bb173403051991c2ac22e5d54c9fe4ee27f4f::e15037cbf904bddb61c241779cd190ffcd02965b::0045e372e75605d6c21b13192c7c69a317378d7d::666ff362b687a169f912dfb6edb161e29433ae42::8550e365caca77254470da120c1dbaf130c7623b::d1834ac0642e2444b5cff6097933eebb79761a24::dc2642e1de946d648cd8386654d3ae1830e017c7::335ede966b06a835c21c3e7d5d7de37b27b42149::94d0ea0ebc21ac8acee2e166cdbe27262579d9f9::4cd8392f2986149ac02c31ce0f7d685fdea48e89::280e8c6b6142839f8793b54f49ffc9461a73b60f::cec6828cc1cf4da95e8856fb93ef32cacfaa1ee4::150dbffde59c460f396503950e200a679bc1bf87::7dc1b6e2210e916a8b919188f8636b3334fb1e33::af0f740ae99ccfa5d1b6876eb258ca6a917e16e7::8e736f1092e70e7eb8865395aff2070ea78561dc::b3e712a72b8e9b6450a4dad8b5de477b1041e927::95e9343b0d64c1fd8fcb9b6157eac4b434fa3c90::9417a68047bf7bd7ca1b51cd6f4652b44fe2960b::86c05b10ae19cc668f9c06b976877295c3ccf9aa::3bf4cd424507279d7bfc802e373faba43d668dc1::ecc4371c46b9c899916a6ab8fe5548382d877199::d03ed2c77f679c2e261a5e00b317c914cb34950f::473df837aa49461c59d1a7dce0a71fe2fa512fe6::921261e2456b67d27a702952467b0d3595f9aef9::bf8491c5f066e986356ed7862eaf1f9e71e373c1::bdfac28a220e81d9bb5469bdd4d62c8ce6f29dd6::da4ca24ced03040dcafed890978175c1a06b8fba::6fa358591c9f9e2f0e02e20ef9953088de65919e::6480910fba8d09b62deab8f8f264e5b1fa04f405::9585527a562281088d8dcb2ec133ba1311640e2e::4c97a6ba515e8ab21d4914158c900096f1634d4a::111a09479123f27f68422dd5d776fbdb1bc1655a::1ee0c5a87e1a0dbf22fc3691f92a6209824e6b99::e5b834e8eee47264b7c0faaa3557cb302e624076::0c1a3cd0ce25ace2a7aa81c5ea2c9ccd89fa4b0a::01fa6dc1a5447694872301a86541a81cd59e0af8::77417b4360a7d7105fc56d02671e69e943a99365::ecd7054f3eaf7b75904df90b37648646ff3109a7::3cb41d78f8974be27e530809fd96b25e5bf92b94::f86100c8bf20322392629fa24ecd8b45b03a7c6a::9c452b0e86dd6086926561d73b89cb0823f31e8c::c37be157851666e35f42bd7520af51fb1dd06877::
https://api.github.com/repos/bitcoin/bitcoin,16322,2019-07-fix-16257::master,0,merged,Wallet::,"Follow up to #16257, this PR makes `bumpfee` aware of `-maxtxfee`. It also prevents dangling locked unspents when calling `fundrawtransaction` - because the previous check was after `LockCoin`.style-nit: ```suggestion if (nFeeRet > m_default_max_tx_fee) { ``` `m_` already means `this->`, no need for duplicate.::style-nit: Maybe for the purpose of a backport, this could be inlined as a string literal?::Don't you prefer an unclean-but-easy-cherry-pick backport?::`.format(fee_setting)` part is a mistake? :-)::Yap, @MarcoFalke I'll amend.::",5c1b9714cb0a13be28324f91f4ec9ca66a1de8c7::177550101b600ccb32886695326eb72cd9752c8b::0d101a340c44841cbbc5982d55354b1787bc39e2::
https://api.github.com/repos/bitcoin/bitcoin,16240,2019-06-json-aware-helper::master,0,merged,RPC/REST/ZMQ::Refactoring::,"Every single RPC call has a helper-section at the start, which throws a help string if the user asks for help or if the user provided too few/many arguments. ```C++ const RPCHelpMan help{...}; if (request.fHelp || !help.IsValidNumArgs(request.params.size())) { throw std::runtime_error(help.ToString()); } ``` or (older version) ```C++ if (request.fHelp || request.params.size() < min || request.params.size() > max) throw std::runtime_error( RPCHelpMan{...}.ToString() ); ``` It seems like an obvious improvement, and less copy-pasting, to make `RPCHelpMan` aware of `JSONRPCRequest`, and to let it handle the checks instead. Both of the above become ```C++ RPCHelpMan{...}.Check(request); ``` which means we save roughly 3 lines per RPC command, and the `RPCHelpMan` instance is never referenced afterwards, so the approach is a tiny fraction cleaner. This is a complete update, sans a few special case locations that had special rules. 623 lines turn into 284 (which includes the addition to `RPCHelpMan`). in commit 2512d3d2e2f2a2b891f9a3baa1a1309edaf41e01: Could add a doc string?::Done!::Does this need backport? Should be a separate pull request, since behavior changes should not be mixed with refactoring.::This is wrong anyway, it is required and needs to be set to: ``` getblocktemplate must be called with the segwit rule set (call with {""rules"": [""segwit""]}) (code -8)::It may be wrong doc-wise, but tests break if you make this mandatory. And it *is* optional in the code. Edit: on the same note, this is not a behavior change, for the reasons stated above. It always behaved this way, even if the docs indicated differently. Edit 2: the thing you pointed at actually throws the help topic because it does not provide any values; https://github.com/bitcoin/bitcoin/blob/0221420d1a0550cd849e0f3a5ada3738d5931bdd/test/functional/mining_basic.py#L107-L108 When running with ```diff $ git diff | cat diff --git a/src/rpc/mining.cpp b/src/rpc/mining.cpp index 1744acbb2..7b664e73b 100644 --- a/src/rpc/mining.cpp +++ b/src/rpc/mining.cpp @@ -291,7 +291,7 @@ static UniValue getblocktemplate(const JSONRPCRequest& request) ""    https://github.com/bitcoin/bips/blob/master/bip-0009.mediawiki#getblocktemplate_changes\n"" ""    https://github.com/bitcoin/bips/blob/master/bip-0145.mediawiki\n"", { -                    {""template_request"", RPCArg::Type::OBJ, ""{\""mode\"":\""template\""}"", ""A json object in the following spec"", +                    {""template_request"", RPCArg::Type::OBJ, RPCArg::Optional::NO, ""A json object in the following spec"", { {""mode"", RPCArg::Type::STR, /* treat as named arg */ RPCArg::Optional::OMITTED_NAMED_ARG, ""This must be set to \""template\"", \""proposal\"" (see BIP 23), or omitted""}, {""capabilities"", RPCArg::Type::ARR, /* treat as named arg */ RPCArg::Optional::OMITTED_NAMED_ARG, ""A list of strings"", ``` the output ends up as ``` $ ./mining_basic.py [..] 2019-06-19T15:51:46.621000Z TestFramework (INFO): Create some old blocks 2019-06-19T15:51:48.842000Z TestFramework (INFO): getmininginfo 2019-06-19T15:51:48.849000Z TestFramework (INFO): getblocktemplate: Test capability advertised 2019-06-19T15:51:48.870000Z TestFramework (INFO): getblocktemplate: segwit rule must be set 2019-06-19T15:51:48.871000Z TestFramework (ERROR): Assertion failed Traceback (most recent call last): File ""/Users/user/git/bitcoin/test/functional/test_framework/util.py"", line 113, in try_rpc fun(*args, **kwds) File ""/Users/user/git/bitcoin/test/functional/test_framework/coverage.py"", line 47, in __call__ return_val = self.auth_service_proxy_instance.__call__(*args, **kwargs) File ""/Users/user/git/bitcoin/test/functional/test_framework/authproxy.py"", line 141, in __call__ raise JSONRPCException(response['error'], status) test_framework.authproxy.JSONRPCException: getblocktemplate ""template_request"" If the request parameters include a 'mode' key, that is used to explicitly select between the default 'template' request or a 'proposal'. It returns data needed to construct a block to work on. For full specification, see BIPs 22, 23, 9, and 145: https://github.com/bitcoin/bips/blob/master/bip-0022.mediawiki [...] > curl --user myusername --data-binary '{""jsonrpc"": ""1.0"", ""id"":""curltest"", ""method"": ""getblocktemplate"", ""params"": [{""rules"": [""segwit""]}] }' -H 'content-type: text/plain;' http://127.0.0.1:8332/ (-1) During handling of the above exception, another exception occurred: Traceback (most recent call last): File ""/Users/user/git/bitcoin/test/functional/test_framework/test_framework.py"", line 193, in main self.run_test() File ""./mining_basic.py"", line 108, in run_test assert_raises_rpc_error(-8, ""getblocktemplate must be called with the segwit rule set"", node.getblocktemplate) File ""/Users/user/git/bitcoin/test/functional/test_framework/util.py"", line 105, in assert_raises_rpc_error assert try_rpc(code, message, fun, *args, **kwds), ""No exception raised"" File ""/Users/user/git/bitcoin/test/functional/test_framework/util.py"", line 117, in try_rpc raise AssertionError(""Unexpected JSONRPC error code %i"" % e.error[""code""]) AssertionError: Unexpected JSONRPC error code -1 2019-06-19T15:51:48.937000Z TestFramework (INFO): Stopping nodes 2019-06-19T15:51:49.579000Z TestFramework (WARNING): Not cleaning up dir /var/folders/92/y_j8bzw95kn_lky71wr033dw0000gr/T/bitcoin_func_test_7trykhuw 2019-06-19T15:51:49.579000Z TestFramework (ERROR): Test failed. Test logging available at /var/folders/92/y_j8bzw95kn_lky71wr033dw0000gr/T/bitcoin_func_test_7trykhuw/test_framework.log 2019-06-19T15:51:49.580000Z TestFramework (ERROR): Hint: Call /Users/user/git/bitcoin/test/functional/combine_logs.py '/var/folders/92/y_j8bzw95kn_lky71wr033dw0000gr/T/bitcoin_func_test_7trykhuw' to consolidate all logs ``` which is why I did this fix in the first place.::Which tests break?::minig_basic.py (see above log)::Ah, so the default is not `{\""mode\"":\""template\""}`, but the empty dict `{}`? The help text for mode says ""This must be set to \""template\"", \""proposal\"" (see BIP 23), **or omitted**"" (emphasis mine)::~If it can be omitted, `Optional::NO` is probably wrong, then.~ (I read too fast; you were talking about mode, not template_request) I can change the default to simply say `{}`~, but the code essentially acts as if it was `{""mode"":""template""}`.~ ::In commit 09e176a958  Make the RPCHelpMan aware of JSONRPCRequest and add Check() helper Looks like you added the implementation to an unrelated header file (should be in rpc/util.cpp). You can solve the circular dependency by moving JSONRPCRequest to rpc/protocol.h ::That sounds like a good solution, yeah. Thanks, doing that.::? :eyes: ::Sigh. I moved it to .h because it needed RPCHelpMan at one point. Fixed!::I'm not 100% convinced that `protocol.h` is the right place for this architecturally, as it's supposed to be functions and data structures shared between RPC client and server, and `JSONRPCRequest` is internal to the server. I understand the rationale, though (but we might just want to create a new header instead for it).::I think you're right, but I also think we have stuff in `protocol` that does not belong there to begin with. I made an attempt at cleaning this up by splitting the 'request' stuff into a separate file. This moves stuff from `server.cpp` and `server.h` and `protocol.h` into `request.h`, and `protocol.cpp` is replaced by `request.cpp`.::09f0bf5f1a5a50168d64c488c2b8972774711a98 nit, add `{ }`.::Added.::",0ab8ba1ac65b70f044a5e323b13d098cef33695a::5c5e32bbe3dfa790dd8bb421fbd6301ae10b09f5::c7a9fc234f3ce400ce78b9b434d2d210b2646c50::b6fb617aaaad5f9cdd7f2ad2825b253ca792055d::
https://api.github.com/repos/bitcoin/bitcoin,16189,1906-18Backport::0.18,0,merged,Backport::,First run clang-format on the wallet options list (review with `--word-diff-regex=.`). This is not a backport. Then backport Github-Pull: #15913,206c30f6d7ff9fbcdb0f0b882e8da54870f8ee73::106471d0d710a957280c36862df222657ace17f5::
https://api.github.com/repos/bitcoin/bitcoin,16080,bitcoin_config-and-release_process-updates::master,0,merged,Docs::,"- Bump PACKAGE_VERSION and PACKAGE_STRING in `build_msvc/bitcoin_config.h` from 0.17 to 0.18 (follow-up to 48ed65b). - Update `doc/release_process.md` (follow-up to e47dc4f), new version visible [here](https://github.com/jonatack/bitcoin/blob/bitcoin_config-and-release_process-updates/doc/release-process.md). - Perhaps worth backporting the version updates to 0.18.0.",3ee28c506d846b525afc1cbb7b77e7c5d7228955::8afca323e371a7a191d874928046d6bf2fbbe072::
https://api.github.com/repos/bitcoin/bitcoin,15959,1905-gccBugWorkaround::master,0,closed,Refactoring::Tests::,"The gcc compiler creates ""optimized"" code (`-finline-small-functions`) that modifies `in` a second time after it has been initialized with random bits. Working around the bug can be achieved in different ways: Moving `in` into a new `const` array, rearranging the loop to break the optimization, or moving the array into the outer scope, ... This fix is needed to release 0.18.1 on 32 bit platforms, thus needs backport. https://gcc.gnu.org/bugzilla/show_bug.cgi?id=90348 Fixes #14580",faa924a9427e3ca0238bd928b93b31e910651ef4::
https://api.github.com/repos/bitcoin/bitcoin,15911,2019/04/walletcreatefundedpsbt::master,0,merged,RPC/REST/ZMQ::Wallet::,"The `walletcreatefundedpsbt` RPC call currently ignores `-walletrbf` and defaults to not use RBF. This PR fixes that. This PR also replaces UniValue in `ConstructTransaction` with a `bool` in preparation of moving this helper method out of the RPC codebase entirely. This may be a bit overkill, but does slightly simplify it. Fixes #15878""fallback to"" seems unnecessary here.::Probably ought to throw an error if it's not a boolean here.::Would need a scripted diff to change that? ``` $ git grep --count  ""fallback to wallet's default"" src/wallet/rpcwallet.cpp:7 ::I used the same wording as elsewhere, so could indeed do a replace-all.::Done, but not scripted.::Added a check.::nit: typo in `explictly`::Will `ConstructTransaction` be moved out of the RPC module? Without this change the issue could probably have been addressed with a small update in `walletcreatefundedpsbt`. If `ConstructTransaction` stays in the RPC codebase forever then this change has also introduced duplicate code at two call sites for no reason. ::Perhaps test the `walletrbf=0` case `assert tx_in[""sequence""] > MAX_BIP125_RBF_SEQUENCE` on `nodes[1]`?::I expect more stuff to be moved out of the RPC over time, but for now this was the simplest fix, also easiest to backport.::Added a commit with that test (it shouldn't break existing ACKs)::No need to `zip` here. ``` for tx_in in decoded_psbt[""tx""][""vin""]: assert tx_in[""sequence""] > MAX_BIP125_RBF_SEQUENCE ```::17f0cb0f792883c791954472a3173bf46356ce09 Agree, same as L223 is enough.::17f0cb0f792883c791954472a3173bf46356ce09 Use `assert_greater_than`.::43483889cfa7cb0aa95ba6bb298c9d644e4f21d0 Use `assert_greater_than`.::",4fcb698bc2bb74171cd3a14b94f9882d8e19e9fb::9ed062b5685eb6227d694572cb0f7bfbcc151b36::d6b3640ac732f6f66a8cb6761084d1beecc8a876::
https://api.github.com/repos/bitcoin/bitcoin,15803,201904_backport_15749::0.18,0,merged,Backport::RPC/REST/ZMQ::Wallet::,Clean backport of #15749 by sipa to 0.18,7fcbe7dc112b3d35a5066e6d181f286fb630f744::802dcd37d196aab07f377938d851d7eaf095b03b::235550d01992555a316c9c4639f5bec6255a244f::
https://api.github.com/repos/bitcoin/bitcoin,15652,2019-03-fix-15591::master,0,merged,Wallet::,"Fixes #15591.nit, this lock is not at the begin of a scope, could move this to a new `CWallet` member.::The wallet module is not allowed to call directly into the node. This should be an interface method.::Right, added 51cb2eb and then refactored `LoadWallet` to use it.::Could there be a race, since we don't take cs_main when removing txs from the mempool? I.e. a tx is first removed due to eviction, the wallet is notified and then it is re-added here.::Any reason not to do this in `postInitProcess`? I understand that this is also called when the `createwallet` rpc is called, but the post-init seems useless in that case anyway. I'd suggest: * Remove `postInitProcess` from `createwallet`, because the wallet is fresh and there couldn't be any txs that need to be exchanged between mempool and wallet * Rename `postInitProcess` to `postLoadProcess`, since it is not needed on init, but on load * Move the below code into `postLoadProcess` with mempool::cs hold while adding the txs.::I agree, `postInitProcess` is ""pre dynamic wallet support"". However I'd prefer to refactor in a different PR, this is a bug fix.::Indeed, between `getMemoryPoolTransactions` and `TransactionAddedToMempool` a tx can be evicted. I see 2 solutions: - lock the wallet before the loop so that `TransactionRemovedFromMempool` comes after this - add a way to lock the mempool in `interfaces::` but not sure if this is wanted? cc @ryanofsky ::re: https://github.com/bitcoin/bitcoin/pull/15652#discussion_r268645607 > I see 2 solutions: I think more ideally the wallet doesn't have knowledge or control of node locks, and can just register for notifications and handle them as they come in. Maybe the `ChainImpl::handleNotifications` method can be changed to something like: ```c++ std::unique_ptr<Handler> handleNotifications(Notifications& notifications) override { LOCK2(::cs_main, ::mempool.cs); for (const CTxMemPoolEntry& entry : ::mempool.mapTx) { notifications.TransactionAddedToMempool(entry.GetSharedTx()); } return MakeUnique<NotificationsHandlerImpl>(*this, notifications); } ```::Fine with doing the rename et al. later, but is there any reason not to put it in `postInitProcess`? IIRC it was in there previously in this pull::If you move the loop into `postInitProcess`, you can just take a `LOCK(::mempool.cs)` in there::Yes, could be moved back there.::@MarcoFalke `postInitProcess` is wallet module, should not use that right? https://github.com/bitcoin/bitcoin/pull/15652#discussion_r268407542::Yeah, you'd have to move it to the interface Alternatively you could add it to `handleNotifications` as suggested by @ryanofsky, but then it would also be called for `createwallet`, which seems a bit wasteful::@ryanofsky nice, I thought of something like `replayMemoryPoolNotifications`. However I'm not sure if these notifications should come after `ReacceptWalletTransactions`?::in commit 596f91d20732a1714395e9f6e5d1e6c41f14a2e5: Could remove empty hunk to avoid having to solve conflicts in a backport?::Not sure how to solve the deadlock warning. Maybe take cs_wallet before both of these? ``` node1 2019-03-25T17:06:10.586193Z Leaving InitialBlockDownload (latching to false) node1 2019-03-25T17:06:10.586301Z POTENTIAL DEADLOCK DETECTED node1 2019-03-25T17:06:10.586314Z Previous lock order was: node1 2019-03-25T17:06:10.586326Z  ::cs_main  interfaces/chain.cpp:372 node1 2019-03-25T17:06:10.586335Z  (1) ::mempool.cs  interfaces/chain.cpp:372 node1 2019-03-25T17:06:10.586350Z  cs_main  interfaces/chain.cpp:264 node1 2019-03-25T17:06:10.586359Z  (2) cs_wallet  wallet/wallet.cpp:1230 node1 2019-03-25T17:06:10.586386Z Current lock order is: node1 2019-03-25T17:06:10.586397Z  cs_main  interfaces/chain.cpp:264 node1 2019-03-25T17:06:10.586406Z  (2) cs_wallet  wallet/wallet.cpp:1871 node1 2019-03-25T17:06:10.586419Z  (1) pool.cs  validation.cpp:580 ::Could you call this notifyMempoolTransactions? I'd like to converge on _mempool_ spelling rather than _memPool_ or _memoryPool_. Currently we have: <pre> Chain::hasDescendantsIn<i>Mempool</i> Chain::<i>mempool</i>MinFee Chain::Notifications::TransactionAddedTo<i>Mempool</i> Chain::Notifications::TransactionRemovedFrom<i>Mempool</i> Chain::Lock::submitTo<i>MemoryPool</i> </pre> so the only existing exception is the `Chain::Lock` method, which I want to go away anyway. ::re: https://github.com/bitcoin/bitcoin/pull/15652#discussion_r268760261 > Not sure how to solve the deadlock warning. Maybe take cs_wallet before both of these? It looks like you need to do the opposite and release cs_wallet before calling this.::re: https://github.com/bitcoin/bitcoin/pull/15652#discussion_r268645607 > Alternatively you could add it to handleNotifications as suggested by @ryanofsky, but then it would also be called for createwallet, which seems a bit wasteful Agree, this would be too wasteful. Having the separate method to replay notifications is probably better. > I'm not sure if these notifications should come after ReacceptWalletTransactions? I'm not 100% sure, but I don't think I see a problem if notifications about what's already in the mempool happen before the wallet adds more transactions to the mempool. I think what you have now basically seems good though.::The lock order is `cs_main, cs_wallet, ::mempool.cs`, no?::I can get the functional tests to pass with the diff ```diff diff --git a/src/interfaces/chain.cpp b/src/interfaces/chain.cpp index cb76461647..94e7a7ad53 100644 --- a/src/interfaces/chain.cpp +++ b/src/interfaces/chain.cpp @@ -367,9 +367,9 @@ public: { return MakeUnique<RpcHandlerImpl>(command); } -    void notifyMemoryPoolTransactions(Notifications& notifications) override +    void notifyMemoryPoolTransactions(Notifications& notifications, RecursiveMutex&cs_wallet) override { -        LOCK2(::cs_main, ::mempool.cs); +        LOCK2(::cs_main, cs_wallet);         LOCK(::mempool.cs); for (const CTxMemPoolEntry& entry : ::mempool.mapTx) { notifications.TransactionAddedToMempool(entry.GetSharedTx()); } diff --git a/src/interfaces/chain.h b/src/interfaces/chain.h index 3fa63d83be..b53d170645 100644 --- a/src/interfaces/chain.h +++ b/src/interfaces/chain.h @@ -7,6 +7,7 @@ #include <optional.h>               // For Optional and nullopt #include <primitives/transaction.h> // For CTransactionRef +#include <sync.h> // For RecursiveMutex #include <memory> #include <stddef.h> @@ -271,7 +272,7 @@ public: virtual std::unique_ptr<Handler> handleRpc(const CRPCCommand& command) = 0; //! Notify handler of all memory pool transactions. -    virtual void notifyMemoryPoolTransactions(Notifications& notifications) = 0; +    virtual void notifyMemoryPoolTransactions(Notifications& notifications,RecursiveMutex&cs_wallet) = 0; }; //! Interface to let node manage chain clients (wallets, or maybe tools for diff --git a/src/wallet/wallet.cpp b/src/wallet/wallet.cpp index 554ee62547..d72201679a 100644 --- a/src/wallet/wallet.cpp +++ b/src/wallet/wallet.cpp @@ -4404,7 +4404,7 @@ void CWallet::postInitProcess() ReacceptWalletTransactions(); // Update wallet transactions with current mempool transactions. -    m_chain.notifyMemoryPoolTransactions(*this); +    m_chain.notifyMemoryPoolTransactions(*this, cs_wallet); } bool CWallet::BackupWallet(const std::string& strDest) ::Will do.::I don't like this going in `ReacceptWalletTransactions()` for a couple of reasons: - The name `ReacceptWalletTransactions()` suggests to me that we're reaccepting wallet transactions back into the mempool (which is what the function currently does). Adding functionality to fetch mempool txs back into the wallet changes the definition of this function so that it no longer matches the name. - `ReacceptWalletTransactions()` is called by various import* RPCs, which don't need to refetch the mempool txs into the wallet. I suggest moving this call into `postInitProcessing()` which is only called when a wallet is loaded.::nit: I'd prefer the name `getMempoolTransactions()` or `fetchMempoolTransactions()`. Notify to me signifies that the wallet is subscribing and getting a notification, whereas this interface function is actually used by the wallet to actively fetch the mempool transactions.::Fixed.::> I'd prefer the name `getMempoolTransactions()` or `fetchMempoolTransactions()`. I think these are confusing since the function is void. ::> Notify to me signifies that the wallet is subscribing and getting a notification The ""standard"" for that is `handleX`, like `handleNotifications`.::> I suggest moving this call into `postInitProcessing()` which is only called when a wallet is loaded. This was attempted before but there was a locking order problem, and was for that reason that I've placed `notifyMempoolTransactions` here. I've included 0994e3121 to address that. The important thing to ensure is https://github.com/bitcoin/bitcoin/pull/15652#discussion_r268783330.::re: https://github.com/bitcoin/bitcoin/pull/15652#discussion_r269275899 Agree with John the name is not great. I think I'd probably call it `pushMempoolNotifications`. More importantly, though, I think this needs to have a comment saying how it relates to `handleNotifications`. A good comment might be: ""Synchronously send TransactionAddedToMempool notifications about all current mempool entries to the specified handler. To avoid race conditions where out of date TransactionAddedFromMempool / TransactionRemovedFromMempool asynchronous notifications previously requested through `handleNotifications` would arrive during or after this call, this will block waiting for any previous asynchronous notifications to complete, and prevent new asynchronous notifications from being sent until this returns."" I will say writing this makes me think the interface is overcomplicated. I guess I'd prefer my original suggestion of just sending `TransactionAddedFromMempool` notifications atomically in the same place the handler is registered: https://github.com/bitcoin/bitcoin/pull/15652#discussion_r268675190. Marco pointed out this would be wasteful in the case of `createwallet` calls https://github.com/bitcoin/bitcoin/pull/15652#discussion_r268710750, but the notifications could be optional if the waste is too much.::`requestMempoolTransactions()`? Agree with Russ about adding a comment.::> just sending TransactionAddedFromMempool notifications atomically in the same place the handler is registered I understand it is cleaner but it is weird to receive notifications before `handleNotifications` return. Thanks for the comment! Eeny, meeny, miny, moe `requestMempoolTransactions`, after all we want to be notified of mempool transactions. ::> but it is weird to receive notifications before handleNotifications return This is the current behavior and it isn't weird. Notifications start to arrive when RegisterValidationInterface is called, and can happen before that function returns, much less before handleNotifications returns.::> This is the current behavior Currently `cs_main` and `cs_wallet` are locked when `handleNotifications` is called so that doesn't happen, but otherwise you are right.::re: https://github.com/bitcoin/bitcoin/pull/15652#issuecomment-477271519 > You might need to block waiting for previous notifications. One way to do this: ```c++ void requestMempoolTransactions(Notifications& notifications) override { std::promise<void> promise; CallFunctionInValidationInterfaceQueue([&] { LOCK2(::cs_main, ::mempool.cs); for (const CTxMemPoolEntry& entry : ::mempool.mapTx) { notifications.TransactionAddedToMempool(entry.GetSharedTx()); } promise.set_value(); }); promise.get_future().wait(); } ```::Previous suggestion in https://github.com/bitcoin/bitcoin/pull/15652/files#r269965497 isn't exception safe. Also, cs_main needs to be released before calling this. Probably better: ```c++ void requestMempoolTransactions(Notifications& notifications) override { AssertLockNotHeld(::cs_main); AssertLockNotHeld(::mempool.cs); std::packaged_task<void()> task([&] { LOCK2(::cs_main, ::mempool.cs); for (const CTxMemPoolEntry& entry : ::mempool.mapTx) { notifications.TransactionAddedToMempool(entry.GetSharedTx()); } }); CallFunctionInValidationInterfaceQueue([&] { task(); }); task.get_future().get(); } ```::Thanks @ryanofsky!::Haven't finished but it looks like there will be a lock order issue - cs_main -> mempool.cs -> cs_main -> cs_wallet.::re: https://github.com/bitcoin/bitcoin/pull/15652#discussion_r270050754 > Haven't finished but it looks like there will be a lock order issue - cs_main -> mempool.cs -> cs_main -> cs_wallet. That does seem like a problem. One way to fix it would be to release main and mempool locks before calling TransactionAddedToMempool, by pushing the transactions to a vector, releasing the locks and then looping over the vector. Alternately if you changed the function to `pushMempoolTransactions(std::function<void(std::vector<CTransactionRef> push_fn))` you could release the locks and then send the vector to the wallet directly. Both of these changes would be nice optimizations for #10102, since passing a vector once across the socket is more efficient than calling `TransactionAddedToMempool` repeatedly and requiring lots of roundtrip traffic.::re: https://github.com/bitcoin/bitcoin/pull/15652#discussion_r269965497 Current code looks ok, but I think I was misguided in making this thread because previous code in d94847f20c750d88a0aefa572155d54f8e39c144 was also ok. I think: 1) I was right to point out there's a race condition where normal mempool add/remove notifications triggered before the `requestMempoolTransactions` call could arrive out of order during and after the call 2) I was wrong to assume that the race condition would actually cause a problem. There is no problem if an unknown transaction is removed or an already added transaction is added again. 3) I was wrong to think that my proposed changes would actually prevent add/remove notifications from arriving out of order. In fact, they would only prevent older add/remove notifications from arriving _during_ the `requestMempoolTransactions` call, not _after_ the call. So, I think if you want go back to the simpler implementation in d94847f20c750d88a0aefa572155d54f8e39c144 that would be fine. Or if you did want to prevent obsolete add/remove notifications from arriving _after_ the `requestMempoolTransactions` call in addition to _during_, you'd need acquire the locks before calling `CallFunctionInValidationInterfaceQueue` and also fill the vector at the same time: ```c++ void requestMempoolTransactions(Notifications& notifications) override { std::vector<CTransactionRef> transactions; std::packaged_task<void()> task([&] { for (const CTransactionRef& tx : transactions) { notifications.TransactionAddedToMempool(tx); } }); { LOCK2(::cs_main, ::mempool.cs); for (const CTxMemPoolEntry& entry : ::mempool.mapTx) { transactions.push_back(entry.GetSharedTx()); } CallFunctionInValidationInterfaceQueue([&] { task(); }); } AssertLockNotHeld(::cs_main); AssertLockNotHeld(::mempool.cs); task.get_future().get(); } ```::> I was wrong to assume that the race condition would actually cause a problem. There is no problem if an unknown transaction is removed or an already added transaction is added again. Right, just unnecessary extra work, which is not an issue I think.::In commit ""interfaces: Add Chain::requestMempoolTransactions"" (d94847f20c750d88a0aefa572155d54f8e39c144) Current comment isn't really accurate. Maybe suggest: ```c++ //! Synchronously send TransactionAddedToMempool notifications about all //! current mempool transactions to the specified handler and return after //! the last one is sent. These notifications aren't coordinated with async //! notifications sent by handleNotifications, so out of date async //! notifications from handleNotifications can arrive during and after //! synchronous notifications from requestMempoolTransactions. Clients need //! to be prepared to handle this by ignoring notifications about unknown //! removed transactions and already added new transactions. ```::",0440481c6bf5683eff669c789bdf6a306d99adc5::57908a739ca377d60ef224ce0f565d4412a414f4::2ebf650b2eb7a078ab60c8c4d5c726823686f549::4bf1b1cefa9723bf2cfa8b1a938757abc99bb17b::
https://api.github.com/repos/bitcoin/bitcoin,15575,2019-03-backport-15297-017::0.17,0,merged,Backport::Wallet::,"This PR backports the following pull requests: - #12493 [wallet] Reopen CDBEnv after encryption instead of shutting down - #14350 Add WalletLocation class - #14320 [bugfix] wallet: Fix duplicate fileid detection - #14552 wallet: detecting duplicate wallet by comparing the db filename. - #11911 Free BerkeleyEnvironment instances when not in use - #15297 wallet: Releases dangling files on BerkeleyEnvironment::CloseIn commit ""wallet: Add WalletLocation utility class"" (b35a71827bddf534816f1c5fda83c8e33a18eb63) This does not appear to have been cherry-picked from 01a4c095c87500650663341533f000c6b613e9da correctly. The original commit is not adding any `ListWalletDir` function, so it is unclear where this is coming from. Also the function is being added without being called in this or later commits.::Fixed.::",f455979eb1b65c9822b414aa9e6b04b5c43322a0::048fda2a66df405cd98706612c87b59c2912c441::435df68c62562e30a6d11b0bfc2cf56434dbc4a0::1c98a758d0f43f12d600731373758303cefe7cd7::21693ff0b743f094e73111a81c1c86e2622d937c::16e57594556ac481a32f5d5ed1a988b2772ba804::8965b6ab4753f3223d90d9c1ab03b190f0320dd8::34da2b7c76a023459e46e3a2ca4dc3ecc2b9a438::caf1146b1345d70fbe4cc5f662d8393a79ac6068::7751ea37b65cae2cff766d09b2c95770aa7d71d8::0a9af2d4cb093d254a36d094b8d8ed7603fc9404::f22d02f5371efcaa48a8d5d1b8cd31c65d8235f3::2e9e904a5d58e0d288e9abc1cbc602a8674bc1a2::fe95f84542f81862e9759503416d9da9f67d191b::85c6263ddbde7189bbb52317dd3ad9202b5ebf40::f20513bd71d0530ad9285b9558e3a02733250a63::22cdb6cf590d61668c85c1c08dcc15b4e95921c6::
https://api.github.com/repos/bitcoin/bitcoin,15552,201902_limitrewindinvalidate::0.18,0,merged,Backport::Validation::,"Same repo and branch like  ""Granular invalidateblock and RewindBlockIndex #15402 "", can be merged as is. This saves us all the cherry-picks and review of the backport cherry-picks.Nit: successful.::@jonatack that should go in the original #15402 (though probably won't be fixed in order not to lose existing ACKs)::",9d6dcc52c6cb0cdcda220fddccaabb0ffd40068d::32b2696ab4b079db736074b57bbc24deaee0b3d9::1d342875c21b5d0a17cf4d176063bb14b35b657e::436f7d735f1c37e77d42ff59d4cbb1bd76d5fcfb::880ce7d46b51835c00d77a366ec28f54a05239df::241b2c74ac8c4c3000e778554da1271e3f293e5d::9b1ff5c742dec0a6e0d6aab29b0bb771ad6d8135::9bb32eb571a846b66ed3bac493f55cee11a3a1b9::9ce9c37004440d6a329874dbf66b51666d497dcb::8d220417cd7bc34464e28a4861a885193ec091c2::519b0bc5dc5155b6f7e2362c2105552bb7618ad0::
https://api.github.com/repos/bitcoin/bitcoin,15454,no-default-wallet::master,0,merged,Wallet::,"Instead of automatically creating and loading a default wallet, users should instead explicitly create their wallet or load it on start. Builds on #19754 which provides the `load_on_startup` behavior for the GUI.Unless I'm missing something, this is breaking change. Why not change the behavior from ""load or create each -wallet"" to ""just load each -wallet""? Then to create a wallet there is the option in the GUI and `createwallet` in RPC.::Nit: Redundant initialisation :-)::What if the wallet name has a comma? Would prefer to see rwconf extended to multiple `wallet=` fields...::Should just use `wallet=`?::So would I. I would prefer that #11082 implements it that way instead of requiring me to change it as I am not familiar with that code.::That will cause some problems as is since it would be one string that represents multiple wallets. If/when rwconf allows repeated fields, then it can be `wallet=`.::In commit ""Do not create default wallet"" (6feed9508a225276cc2264b7d19b151a62deecea) Was experimenting with this PR and would suggest the following fixup: 973bb7e652c4ce10ee536e9967a88c80f6dbe2e0 ([tag](https://github.com/ryanofsky/bitcoin/commits/review.15454.2-edit.1)). SoftSet doesn't really work here for a persistent setting. I'll backport this fixup to #15937 so the diff here will be smaller, and the only code change this should have to make is adding ` && WalletLocation("""").Exists()`::re: https://github.com/bitcoin/bitcoin/pull/15454#discussion_r445559622 > Was experimenting with this PR and would suggest the following fixup: [973bb7e](https://github.com/bitcoin/bitcoin/commit/973bb7e652c4ce10ee536e9967a88c80f6dbe2e0) ([tag](https://github.com/ryanofsky/bitcoin/commits/review.15454.2-edit.1)) Feel free to steal updated version of this PR with fix above squashed and newer changes from 15937: https://github.com/ryanofsky/bitcoin/commits/review.15454.2-edit ::wouldn't it be nicer to just make a `open_wallet_button` here like it is done below for the create button? That would save the user a bit of mousing around. Also, it would remove the headache of making sure that `File > Open Wallet` stays consistent with how the menu items are actually called::It would, but the way that opening wallets works now would require more extensive changes with code that I'm not too familiar with. Someone who is more familiar with the GUI can make this nicer in the future.::if this were Javascript, I would simply make a button that clicks the menu item. But I guess that won't fly in Qt :-)::The menu item doesn't open a selection dialog, it opens a submenu listing all of the wallets. That doesn't really work here.::Do you think we should replace the submenu with a dialog?::I suppose this could just be a dropdown listing all of the available wallets. But, as I said, I leave this up to someone more familiar with the GUI to do.::if it were up to me I'd say a simple filepicker would totally suffice. It's self-explanatory and flexible, and the more fancy stuff is still available from the menu for those who want it ::We would need #15204 to do a file picker type thing.::ah, sorry, I somehow thought that was already merged::@flack see https://github.com/bitcoin/bitcoin/pull/15204#issuecomment-539932726. ::Would it better to do: ```diff -    if (!gArgs.IsArgSet(""wallet"")) { +    if (!(gArgs.GetBoolArg(""wallet"", false)) { ```::re: https://github.com/bitcoin/bitcoin/pull/15454#discussion_r490224007 > Would it better to do: > > ```diff > -    if (!gArgs.IsArgSet(""wallet"")) { > +    if (!(gArgs.GetBoolArg(""wallet"", false)) { > ``` This would be bad because it would cause a `-nowallet` setting to load the default wallet.::> Bitcoin Core will no longer create an unnamed `""""` wallet by default. Just stop here. It won't make a default wallet of any kind, whether or not you specify one specifically.::I think you can make an unnamed wallet with `createwallet`::> by default is the key phrase here. It makes nothing by default.::Meh. Release notes can always be edited when they go up on the dev wiki.::Ok we'll just hope our readers are deficient in English ;P::maybe just leave out ""by default""?::",1bee1e6269b76b52b1eab9112d39c245beaa27a2::d26f0648f1c0d1115dcb8d76e57195032b88f400::
https://api.github.com/repos/bitcoin/bitcoin,15315,2019-02-backport-release-notes::0.17,0,merged,Docs::,#15314 removes a release note from master for a doc that is backported to 0.17.  This adds the note to the 0.17 branch.  The only difference in the text is that the `master` in the URL has been changed to `0.17`.,807add9f5d3d4a7d198c3aefd67b195382bb748f::
https://api.github.com/repos/bitcoin/bitcoin,15314,2019-02-monthly-release-notes-update::master,0,merged,Docs::,"Monthly release notes update.  ~~In addition to a few new notes, this removes from the master branch two notes about things that have been backported to the 0.17 branch (though not released yet): `unloadwallet` RPC now being blocking (0.17 has a detached release note for that) and the PSBT doc (0.17 does not have a release note for that; I'll open a PR).~~Shouldn't this link to the public issue tracker?::I didn't like that the previous text left it unspecified how to contact the project (and, since release notes are posted to the protocol dev mailing list, I was worried people would reply there, which seemed off-topic to me).  I chose the website because it lists the following item that seemed like the most appropriate way for individuals and businesses to inform the project about their use of a feature: > For general enquiries and press: contact@bitcoincore.org (not for support). I think people would be more reluctant to open an ""issue"" for something that isn't broken (they're using the feature as designed) and which may require business users to publicly describe how they use the software in a toolchain that may produce normally-unrelayable transactions. However, I don't know who reads the above email or whether they actually want to receive reports about who uses this feature, so I'm happy to switch to the issue tracker if that's preferred. CC: @sdaftuar (who sought the contact from users of the `whitelistforcerelay` option)::Thanks for the reply. I think that makes sense and the contact page also links to the GitHub, so they could choose either email or GitHub issue.::",9ad5ca17d9aaa3f91bf889da51b851622b4cba10::5d35d4384ac9d18dd03f127d45f83635d76a57d0::
https://api.github.com/repos/bitcoin/bitcoin,15277,2019-01-guix::master,0,merged,Build system::,"~~**This post is kept updated as this project progresses. Use this [latest update link](https://github.com/bitcoin/bitcoin/pull/15277#issuecomment-497303718) to see what's new.**~~ Please read the `README.md`. ----- ### Guix Introduction This PR enables building bitcoin in Guix containers. [Guix](https://www.gnu.org/software/guix/manual/en/html_node/Features.html) is a transactional package manager much like Nix, but unlike Nix, it has more of a focus on [bootstrappability](https://www.gnu.org/software/guix/manual/en/html_node/Bootstrapping.html) and [reproducibility](https://www.gnu.org/software/guix/blog/tags/reproducible-builds/) which are attractive for security-sensitive projects like bitcoin. ### Guix Build Walkthrough Please read the `README.md`. [Old instructions no. 4](https://github.com/bitcoin/bitcoin/pull/15277#issuecomment-497303718) [Old instructions no. 3](https://github.com/bitcoin/bitcoin/pull/15277#issuecomment-493827011) [Old instructions no. 2](https://github.com/bitcoin/bitcoin/pull/15277#issuecomment-471658439) <details> <summary>Old instructions no. 1</summary> In this PR, we define a Guix [manifest](https://www.gnu.org/software/guix/manual/en/html_node/Invoking-guix-package.html#profile_002dmanifest) in `contrib/guix/manifest.scm`, which declares what packages we want in our environment. We can then invoke ``` guix environment --manifest=contrib/guix/manifest.scm --container --pure --no-grafts --no-substitutes ``` To have Guix: 1. Build an environment containing the packages we defined in our `contrib/guix/manifest.scm` manifest from the Guix bootstrap binaries (see [bootstrappability](https://www.gnu.org/software/guix/manual/en/html_node/Bootstrapping.html) for more details). 2. Start a container with that environment that has no network access, and no access to the host's filesystem except to the `pwd` that it was started in. 3. Drop you into a shell in that container. > Note: if you don't want to wait hours for Guix to build the entire world from scratch, you can eliminate the `--no-substitutes` option to have Guix download from available binary sources. Note that this convenience doesn't necessarily compromise your security, as you can check that a package was built correctly after the fact using `guix build --check <packagename>` Therefore, we can perform a build of bitcoin much like in Gitian by invoking the following: ``` make -C depends -j""$(nproc)"" download && \ cat contrib/guix/build.sh | guix environment --manifest=contrib/guix/manifest.scm --container --pure --no-grafts --no-substitutes ``` We don't include `make -C depends -j""$(nproc)"" download` inside `contrib/guix/build.sh` because `contrib/guix/build.sh` is run inside the container, which has no network access (which is a good thing). </details> ### Rationale I believe that this represents a substantial improvement for the ""supply chain security"" of bitcoin because: 1. We no longer have to rely on Ubuntu for our build environment for our releases ([oh the horror](https://github.com/bitcoin/bitcoin/blob/72bd4ab867e3be0d8410403d9641c08288d343e3/contrib/gitian-descriptors/gitian-linux.yml#L10)), because Guix builds everything about the container, we can perform this on almost any Linux distro/system. 2. It is now much easier to determine what trusted binaries are in our supply chain, and even make a nice visualization! (see [bootstrappability](https://www.gnu.org/software/guix/manual/en/html_node/Bootstrapping.html)). 3. There is active effort among Guix folks to minimize the number of trusted binaries even further. OriansJ's [stage0](https://github.com/oriansj/stage0), and janneke's [Mes](https://www.gnu.org/software/mes/) all aim to achieve [reduced binary boostrap](http://joyofsource.com/reduced-binary-seed-bootstrap.html) for Guix. In fact, I believe if OriansJ gets his way, we will end up some day with only a single trusted binary: hex0 (a ~500 byte self-hosting hex assembler). ### Steps to Completion - [x] Successfully build bitcoin inside the Guix environment - [x] Make `check-symbols` pass - [x] Do the above but without nasty hacks - [x] Solve some of the more innocuous hacks - [ ] Make it cross-compile (HELP WANTED HERE) - [x] Linux - [x] x86_64-linux-gnu - [x] i686-linux-gnu - [x] aarch64-linux-gnu - [x] arm-linux-gnueabihf - [x] riscv64-linux-gnu - [ ] OS X - [ ] x86_64-apple-darwin14 - [ ] Windows - [ ] x86_64-w64-mingw32 - [ ] Maybe make importer for depends syntax - [ ] Document build process for future releases - [ ] Extra: Pin the revision of Guix that we build with with Guix [inferiors](https://www.gnu.org/software/guix/manual/en/html_node/Inferiors.html) ### Help Wanted [Old content no. 3](https://github.com/bitcoin/bitcoin/pull/15277#issuecomment-483318210) [Old content no. 2](https://github.com/bitcoin/bitcoin/pull/15277#issuecomment-471658439) <details> <summary>Old content no. 1</summary> As of now, the command described above to perform a build of bitcoin a lot like Gitian works, but fails at the `check-symbols` stage. This is because a few dynamic libraries are linked in that shouldn't be. Here's what `ldd src/bitcoind` looks like when built in a Guix container: ``` linux-vdso.so.1 (0x00007ffcc2d90000) libdl.so.2 => /gnu/store/h90vnqw0nwd0hhm1l5dgxsdrigddfmq4-glibc-2.28/lib/libdl.so.2 (0x00007fb7eda09000) librt.so.1 => /gnu/store/h90vnqw0nwd0hhm1l5dgxsdrigddfmq4-glibc-2.28/lib/librt.so.1 (0x00007fb7ed9ff000) libstdc++.so.6 => /gnu/store/4sqps8dczv3g7rwbdibfz6rf5jlk7w90-gcc-5.5.0-lib/lib/libstdc++.so.6 (0x00007fb7ed87c000) libpthread.so.0 => /gnu/store/h90vnqw0nwd0hhm1l5dgxsdrigddfmq4-glibc-2.28/lib/libpthread.so.0 (0x00007fb7ed85b000) libm.so.6 => /gnu/store/h90vnqw0nwd0hhm1l5dgxsdrigddfmq4-glibc-2.28/lib/libm.so.6 (0x00007fb7ed6da000) libgcc_s.so.1 => /gnu/store/4sqps8dczv3g7rwbdibfz6rf5jlk7w90-gcc-5.5.0-lib/lib/libgcc_s.so.1 (0x00007fb7ed6bf000) libc.so.6 => /gnu/store/h90vnqw0nwd0hhm1l5dgxsdrigddfmq4-glibc-2.28/lib/libc.so.6 (0x00007fb7ed506000) /gnu/store/h90vnqw0nwd0hhm1l5dgxsdrigddfmq4-glibc-2.28/lib/ld-linux-x86-64.so.2 => /usr/lib64/ld-linux-x86-64.so.2 (0x00007fb7ee3a0000) ``` And here's what it looks in one of our releases: ``` linux-vdso.so.1 (0x00007ffff52cd000) libpthread.so.0 => /usr/lib/libpthread.so.0 (0x00007f87726b4000) librt.so.1 => /usr/lib/librt.so.1 (0x00007f87726aa000) libm.so.6 => /usr/lib/libm.so.6 (0x00007f8772525000) libgcc_s.so.1 => /usr/lib/libgcc_s.so.1 (0x00007f877250b000) libc.so.6 => /usr/lib/libc.so.6 (0x00007f8772347000) /lib64/ld-linux-x86-64.so.2 => /usr/lib64/ld-linux-x86-64.so.2 (0x00007f8773392000) ``` ~~I suspect it is because my script does not apply the gitian-input patches [described in the release process](https://github.com/bitcoin/bitcoin/blob/master/doc/release-process.md#fetch-and-create-inputs-first-time-or-when-dependency-versions-change) but there is no description as to how these patches are applied.~~ It might also be something else entirely. Edit: It is something else. It appears that the gitian inputs are only used by [`gitian-win-signer.yml`](https://github.com/bitcoin/bitcoin/blob/d6e700e40f861ddd6743f4d13f0d6f6bc19093c2/contrib/gitian-descriptors/gitian-win-signer.yml#L14) </details> ### How to Help 1. Install Guix on your distro either [from source](https://www.gnu.org/software/guix/manual/en/html_node/Requirements.html) or perform a [binary installation](https://www.gnu.org/software/guix/manual/en/html_node/Binary-Installation.html#Binary-Installation) 2. Try out my branch and the command described above!nit: Don't we use `$(PYTHON)` for those?::Good catch!::```suggestion [ -e /usr/bin/file ] || ln -s ""$(command -v file)"" /usr/bin/file ```::Should specify which shell is to be used with shebang line?::Not necessarily. You can limit your shell syntax to the least common denominator of posix syntax supported by the most minimal shells (busybox, dash, etc.) Specify a specific other shell if you want convenience of syntax features of that particular shell?::@practicalswift Didn't see this... But yes @wtogami is right, I try to conform to the common denominator of POSIX sh for portability's sake.::curl shouldn't be necessary in the container if depends is pre-populated. May require editing the depends system?::``` libstdc++.so.6 => /gnu/store/4sqps8dczv3g7rwbdibfz6rf5jlk7w90-gcc-5.5.0-lib/lib/libstdc++.so.6 (0x00007fb7ed87c000) ``` Your ldd output indicates that it isn't static linking libstdc++.::Can you add `export LC_ALL=C` to make [Travis happy](https://travis-ci.org/bitcoin/bitcoin/jobs/488536092#L257).::Looks like the additions of [`--no-same-owner`](https://linux.die.net/man/1/tar) to `tar` commands inside depends is extensive.::@fanquake Yup, should I make it a separate PR?::Hmm, why would we need this?::Resolving as this has been split in to #15581.::@dongcarl ^ ?::``` Missing expected shebang ""#!/usr/bin/env bash"" or ""#!/bin/sh"" in contrib/guix/guix-build.sh::Do we want this to be ""in general"" or a hard rule? Are there exceptions thinkable?::In #16141, `TAR_OPTIONS` has been removed from the gitian descriptor. Do we want to do the same here?::as guix is basically a system for deterministic builds, I'm surprised our own faketime hack is still needed !::I think @theuni mentioned that some of these hacks may be able to be dropped.::Hmmm, I should rebase as this is already merged. But I can't think of any exceptions off the top of my head right now. I thought of the phrasing ""in general"" as in: don't include libtool archives unless it is absolutely necessary. Perhaps next time I touch the file I'll rephrase it that way.::It seems that change breaks a few things... I've made a few cleanups to how we archive in this script that can be cleanly backported to Gitian, so I'll go take a look and fix things up.::Ah... So Guix's normal package build system would set `SOURCE_DATE_EPOCH` and expect packages to follow that and submit patches upstream if they don't (because faketime hacking is a little ugly in the end). However, we are only using Guix's `environment` functionality, which doesn't assume you want to do this. Perhaps it'd be worth setting `SOURCE_DATE_EPOCH` at the start of the script and see what fails to build deterministically. Mostly likely most packages would honor it.::OK, agree that this is something that could be done in a future PR, I was just curious::`     --max-jobs=$(nproc) \` ?::Would be nice to do a rebase, so that changes already merged stop showing up here, no?::That's the plan, Carl has just been afk for the past few days afaik. See discussion in [#bitcoin-builds](http://gnusha.org/bitcoin-builds/2019-06-23.log). > 00:49 < dongcarl> I'm gunna clean up, upstream, document, then we can do last round of hashes!::See my https://github.com/bitcoin/bitcoin/pull/15277#issuecomment-507046880 ::Hey @hebasto! I think you need a: ``` guix pull --url=https://github.com/dongcarl/guix.git \ --branch=2019-05-bitcoin-staging ```::```suggestion # Run the build script 'contrib/guix/libexec/build.sh' in the build container ```::```suggestion - 24GB of free disk space on the partition that the Bitcoin Core git repository resides in ```::Could this be called `bitcoin-core` for clarity? ```suggestion (define-module (bitcoin-core) ```::This seems to default to the ""current python 3.x"" version (https://git.savannah.gnu.org/cgit/guix.git/tree/gnu/packages/python.scm?id=v1.0.1-828-gf434664cc0#n365) We had issues in the past where dictionary keys were sorted differently in different versions of python, so I'd prefer if the versions were somehow pinned. (Same goes for the other packages in this scm)::nit: Is this used somewhere?::Would be nice to explain why three different versions of gcc are used. Why is it not possible to use just one? Maybe the most popular version of gcc, which might be the one in the latest Ubuntu LTS release (we also use that version for gitian builds)::Is this depends change supposed to be in the ""guix"" commit?::Fixed in cd3e947f50db7cfe05c05b368c25742193729a62::Fixed in cd3e947f50db7cfe05c05b368c25742193729a62::Fixed in cd3e947f50db7cfe05c05b368c25742193729a62::Fixed in cd3e947f50db7cfe05c05b368c25742193729a62::Clarified in cd3e947f50db7cfe05c05b368c25742193729a62::Fixed in cd3e947f50db7cfe05c05b368c25742193729a62 Also, because we now do `guix pull` with a commit hash instead of a branch, that python version will never change.::The `CROSS_LIBRARY_PATH` environment variable is Guix-specific, I'm patching it in a way that doesn't break for non-Guix (notice the `?`).::",3e80ec3ea9691c7c89173de922a113e643fe976b::8dff3e48a9e03299468ed3b342642f01f70da9db::cd3e947f50db7cfe05c05b368c25742193729a62::751549b52a9a4cd27389d807ae67f02bbb39cd7f::
https://api.github.com/repos/bitcoin/bitcoin,15081,2019-01-monthly-release-notes-update::master,0,merged,Docs::,"This adds release notes for the changes listed by `git log 11e1ac3...fb52d0684 --merges`, picking up where #14688 left off in my attempt to update the release notes every month or so (reducing the amount of work that needs to be done near release time).  I've excluded changes backported to the 0.17 branch (whether they've been released yet or not).MacOS -> macOS::block chain -> blockchain::is -> has been::returns -> return::Saying `the user` feels weird here. Maybe something like `Instead, it is now impossible to enter a custom feerate below the minimum required`? Also, given that we're in the `GUI` section of the release notes here, I think we could drop `In the GUI's` from each paragraph, and just say `In the Overview tab... ` & `In the Send tab...` etc.::expose RPC -> expose the RPC::ensure you only bind the RPC to your localhost::I'm happy to change this, but is this the repository's policy or just your preference?  In previous (but admittedly dated) discussions I recall about this topic, the use of ""block chain"" (two words) was preferred.  E.g., #1910, #5242, and #6666::@harding I'm not really fussed either way, was more for consistency with the rest of file. All other uses in here are `blockchain`.::""is added"" appears to be [grammatically correct](https://ell.stackexchange.com/questions/17132/difference-between-is-added-and-was-added) and is used 28 times in the current source code per `git grep`.  But, if you insist, I'm happy to change it (I prefer it over alternatives for its brevity).::Why?  We don't typically require the use of an article before the name of a protocol, e.g. ""If you need to expose {HTTP, SMTP, IMAP, SSL, bittorrent, ...} in order to use...""::Fair enough.  Thanks!::",97fbe6794037268667d92c788671fdea60c9b630::f3d7d75e4e80bcd2c6058babb732c9c6cc7522c6::
https://api.github.com/repos/bitcoin/bitcoin,14880,2018-12-backport-14453::0.17,0,merged,Backport::,Backport #14453 to 0.17nit: seems construction would be marginally better https://en.cppreference.com/w/cpp/memory/weak_ptr/weak_ptr https://en.cppreference.com/w/cpp/memory/weak_ptr/operator%3D::I don't think this is an appropriate comment for a backport as this change exists literally in the commit for master: https://github.com/bitcoin/bitcoin/pull/14453/commits/321decffa1fbf213462d97e5372bd0c4eeb99635::,75b5d8c4ead9c41f08fe53f9fffd3ffc984d6684::dcb032dcdf8e8300a84ae8ec6cfde0da5381f56f::
https://api.github.com/repos/bitcoin/bitcoin,14782,bugfix_rpc_getbalance_acctstar-0.17::0.17,0,closed,Backport::RPC/REST/ZMQ::Wallet::,"0.17 backport of #14602, but with named-arg account=""*"" compatibility",73103ea7a09037e90edc6fb9404369605b6b19e5::2141e62b6fc6671b3428a130232a91df38c4b974::c18bd54c759467807194465b9a2ab9170719e4a9::eb013b350cd75e36e0a1da2a745eb5320ab1ba8c::32de31c1dd3255702f655b0746cb4fac3cc1938f::
https://api.github.com/repos/bitcoin/bitcoin,14781,bugfix_rpc_getbalance_acctstar-0.17::master,0,closed,,"0.17 backport of #14602, but with named-arg account=""*"" compatibility",73103ea7a09037e90edc6fb9404369605b6b19e5::2141e62b6fc6671b3428a130232a91df38c4b974::c18bd54c759467807194465b9a2ab9170719e4a9::eb013b350cd75e36e0a1da2a745eb5320ab1ba8c::32de31c1dd3255702f655b0746cb4fac3cc1938f::
https://api.github.com/repos/bitcoin/bitcoin,14720,Mf1811-rpcNameArguments::master,0,merged,Docs::RPC/REST/ZMQ::,"Consistently use the same name to describe arguments in the documentation and add a test that uses the name. By splitting it up, the changes are easier to potentially backport and also make review easier when we switch to `RPCHelpMan`. The tests should pass with or without the changes in `src`. Partly stolen from #14459 (More RPC help description fixes by ch4ot1c)",fa0815c3005c861ba94b96412e7997c25e7f6788::
https://api.github.com/repos/bitcoin/bitcoin,14689,fix-pkh-pubkeys::master,0,merged,Wallet::,"If we do not have the public key for a P2PKH input, we should not continue to attempt to sign for it. This fixes a problem where a PSBT with a P2PKH output would include invalid BIP 32 derivation paths that are missing the public key. I tried to backport, but the test passes even without the code changes. Mind taking a look to backport this?::@MarcoFalke I believe the issue only arose after #14424 (which is also marked for backport), does the test fail if you backport that at the same time?::",6b8d86ddb803d50d8608d95f7e8f791511dec8b9::
https://api.github.com/repos/bitcoin/bitcoin,14666,2018_11_qt_tls_crash_fix_0_17::0.17,0,merged,Backport::GUI::,backports #14403 which fixes a crash on FC29,0242b5afa4ebb381d3a59a7246348a50d3a7fdbe::
https://api.github.com/repos/bitcoin/bitcoin,14563,fix_flake::master,0,closed,,pyflakes dep was ratcheted to 2.0 which seems to have broken a lot of the lint checking: https://gitlab.com/pycqa/flake8/commit/527af5c214ef0eccfde3dd58d7ea15e09c483bd3 Also could use a backport to 0.17.,6fbbad2e1f70d770be188d54a75d7666fd91880d::
https://api.github.com/repos/bitcoin/bitcoin,14472,2018/10/doc-getblocktemplate-segwit::master,0,merged,Docs::Mining::,Make it less likely for new miners to accidentally mine non-SegWit blocks. Suggest backport to 0.17 so the docs on bitcoincore.org get updated at the next minor release.,d562027079622f067e8f647bad7c5ac1d63a30d4::
https://api.github.com/repos/bitcoin/bitcoin,14348,fix-qt-freetype-compat::master,0,merged,Build system::,"Fixes #14339. Thanks to @fanquake for confirming. A few years ago, libfreetype introduced ```FT_Get_Font_Format()``` as an alias for ```FT_Get_X11_Font_Format()```, but ```FT_Get_X11_Font_Format()``` was kept for abi backwards-compatibility. Our qt bump to 5.9 introduced a call to```FT_Get_Font_Format()```. Replace it with ```FT_Get_X11_Font_Format()``` in order to remain compatibile with older freetype, which is still used by e.g. Ubuntu Trusty. Needs 0.17 backport.",430bf6c7a1a24a59050e7c9dac56b64b820edb43::
https://api.github.com/repos/bitcoin/bitcoin,14310,sign_locked_error_reporting::master,0,merged,RPC/REST/ZMQ::Wallet::,"Fixes #14082 Could add a second commit to remove the `restart_node`, which is not required on master, but on 0.17.::done::just need one more change, the signature method must be changed to be 0.16 compliant::now it's properly backported::`signrawtransaction` no longer exists in master. You should change this to `signrawtransactionwithwallet`. This will also fix travis.::ok, fixed, thanks::Could create a transaction that the wallet could actually sign? Without this fix, this test holds: ```py self.nodes[0].generate(101) res = self.nodes[0].createrawtransaction([], {'mpLQjfK79b7CCV4VMJWEWAj5Mpx8Up5zxB': 0.1}) res = self.nodes[0].fundrawtransaction(res) self.nodes[0].encryptwallet(""password"") res = self.nodes[0].signrawtransactionwithwallet(res['hex']) assert_equal(res['errors'][0]['error'], 'Unable to sign input, invalid stack size (possibly missing key)') ```::Yes, this test passes on master and 0.17, but the point of this PR is reporting the correct error *before* signing, so it's sufficient that the tx is well formed.::Yes, just saying because I had to write that to test the change is necessary.::Another way to verify the necessity of the change is to run this PR's ```test_with_lock_outputs``` in the ```0.16``` branch, it will pass. ::",db15805668e923c3493d77122d20926496cf6a1a::20442f617f7f86cbdde1c41c1165e2b750f756c7::
https://api.github.com/repos/bitcoin/bitcoin,14262,2018/09/release_notes_v0_15_2::0.15,0,merged,Docs::,"Semi manual based on [commits since v0.15.1](https://github.com/bitcoin/bitcoin/compare/v0.15.1...0.15), so please sanity check.Do you mean: ``` - #11647 `2eea279` Make AuthServiceProxy.\_batch method usable (Russell Yanofsky) - #11647 `305f768` Limit AuthServiceProxyWrapper.\_\_getattr\_\_ wrapping (Russell Yanofsky) ```::Thanks, added escape characters.::#11662 is a backport of #11554 from TheBlueMatt::#12032 is a backport of #11847 from sdaftuar::",bf47116671c15ab792db2a3242d468ae2fa85cb0::1e3dafcaa7b195d14713ad1a146c2bb2003c91b3::391b2cf0250de44afcaeaaf977e3ef8ec5c4d55f::
https://api.github.com/repos/bitcoin/bitcoin,14249,2018-09-checktransaction-16-backport::0.16,0,merged,Bug::Consensus::,This is a backport of #14247 to 0.16.,d1dee205473140aca34180e5de8b9bbe17c2207d::9bd08fd465c35f08f3aab3c713ce1d70ddc1c492::
https://api.github.com/repos/bitcoin/bitcoin,14248,2018-09-checktransaction-17-backport::0.17,0,merged,Bug::Consensus::,This is a backport of #14247.,833180f538c7fa16b097022c7c0d4b4d2f09688b::0d49c82edd4c2c92f8ebe215c057b0173a258d77::
https://api.github.com/repos/bitcoin/bitcoin,13732,btc_fix-rcc-determinism::master,0,merged,Build system::,"With the update to Qt 5.9 having been merged, Qt's `rcc` tool now embeds a file's last modified time in it's output. Since the build system generates temporary files for all locale translations (`*.qm` files) at build time, the resulting `qrc_bitcoin_locale.cpp` file was always being generated in a non-deterministic way. This is a backport of https://bugreports.qt.io/browse/QTBUG-62511, which is included in Qt versions 5.11+, that allows for an environment variable (`QT_RCC_SOURCE_DATE_OVERRIDE`) to override the behavior described above. This environment variable is in turn set in the gitian descriptors, as that is where determinism is vital for release purposes. Prior to this, the `qt_libbitcoinqt_a-qrc_bitcoin_locale.o` object file (included into `libbitcoinqt.a`) was returning a different `sha256sum` for each and every build, regardless of file contents change, thus breaking determinism in the resulting binaries. This should fix #13731We need to export the variable here as well so that non-gitian builds get stable results. See below where QT_RCC_TEST is set to 1.::QT_RCC_TEST was the variable for this in the past. If QT_RCC_SOURCE_DATE_OVERRIDE is the new one, let's just replace QT_RCC_TEST. I assume there's no need for both. Same goes for the other descriptors as well.::Noted, will add this soon::swapped out the build_env variable further up in this file and didn't notice any break in gitian results determinism.::removed `QT_RCC_TEST=1` from gitian descriptors and didn't notice any break in gitian results determinism.::",6b5506a28632b57c0c75c7cc66c0bc35d419b682::
https://api.github.com/repos/bitcoin/bitcoin,13689,zmq_clang_depends::master,0,merged,Build system::,"This PR ~~backports this libzmq commit https://github.com/zeromq/libzmq/pull/3140/commits/58d13395ece1fa0dd9b0583d736af4ac342c1267 from this merged upstream PR (but unreleased as of today) https://github.com/zeromq/libzmq/pull/3140 as a patch to our zmq 4.2.3 version.~~ passes --disable-Werror when we build zmq. For reference see https://github.com/bitcoin/bitcoin/issues/11844#issuecomment-398406988 ~~This patch~~ A similar patch is already in use in abcore/bitcoin_ndk and needed to build bitcoind for android using NDK or some versions of clang 6+ during cross compilation. This patch won't be necessary once zmqlib releases a 4.2.6+ version including the fix and bitcoin core updates to it but it may be good to [have](https://github.com/bitcoin/bitcoin/pull/13689#issuecomment-405644394) ~~It also reintroduces autogen.sh as it is necessary for the patch to work, otherwise you'll have aclocal issues (see https://travis-ci.org/greenaddress/bitcoin/jobs/404902106). autogen,sh was removed in master only https://github.com/bitcoin/bitcoin/pull/11986 as non-necessary but otherwise unreleased.~~ In the likely case https://github.com/bitcoin/bitcoin/pull/13578 is merged first I rebased the patch for the newer zmq version (4.2.5) in https://github.com/greenaddress/bitcoin/tree/zmq-upgrade-mruddy-patched and i can update the PR accordingly or close and open a new one.",a4ba2388feda0be551daca842984c100f002ea81::
https://api.github.com/repos/bitcoin/bitcoin,13658,rescan-from-time::master,0,merged,Refactoring::Wallet::,"Where the outcome does not depend on the result, apart from a simple success check.Is there any reason why not just leave this here? It could very well be used by the gui or some other interface to the wallet in the future and had to be moved back. Generally, I'd prefer if code was only moved when necessary, since unnecessary code movement/refactoring makes backports easier to mess up and consumes scarce review resources.::This move reduces the surface area of CWallet, which is pretty sprawling at the moment (wallet.cpp is ~4500 lines, the 3rd-largest *.cpp file, and the largest outside `/qt/`), and localizes this code to one implementation file from being more broadly available (wallet.h is included into 26 files). Grant the concerns you note are serious, and we should draw the line somewhere, but if the codebase is to be in play for a long time, it needs to evolve and progress. Moving incrementally toward minimizing scope of code, dependencies, etc. is attractive from that perspective as it should have payoffs in reducing the overall complexity of the codebase, which should ease changes on an ongoing and cumulative basis. Other approaches to making better use of scarce review resources come to mind: * I've thought of implementing a web site to helps rank PRs by ACKs and other indications of importance. Current solutions like: https://github.com/bitcoin/bitcoin/projects/8 are pretty limited and not decentralized and ACKs are not currently well-exposed across PRs in aggregate. * We could add a feature to output the changes between force pushes to the same PR, so that reviewers could review just the incremental subset, and the historical changes are recorded. * We could potentially examine and report changes to the build output to give reviewers a sense of the consequence to the output to the binaries. Seems like these are the sorts of things that will help the project to scale and accelerate.::> I've thought of implementing a web site to helps rank PRs by ACKs and other indications of importance. Current solutions like: https://github.com/bitcoin/bitcoin/projects/8 are pretty limited and not decentralized and ACKs are not currently well-exposed across PRs in aggregate. Are you aware of https://bitcoinacks.com/?desc=1&flt3_label_not_contains=Needs+rebase&flt0_merged_empty=1&flt4_ci_contains=Success&flt1_closed_empty=1&sort=7&flt2_mergeable_contains=Mergeable::Nice, hadn't see that.  ::good to move this locally, it's a really aspecific constant name::",3fe836b78d504942e8850b607453886969f57e27::
https://api.github.com/repos/bitcoin/bitcoin,13049,Mf1804-qa16Backports::0.16,0,merged,Backport::Tests::,"Similar to #12967 this contains all relevant bugfixes and improvements to the functional test suite. I didn't include fixes to make the tests run on Windows, since that is still an ongoing effort and doesn't seem worth to backport. As all of these are clean cherry-picks, I suggest reviewers redo the cherry-picks to get the same branch and then run the extended test suite.",cfebd400ef4b26f5b6c1d8b31c6f5e0f09184dba::1286f3e49a7bdae72ae022ff4f83d0a77e832891::0e98f96e42357ac24322a96f0864b6bfd5e55ffe::4bdb0ce5172b511c1426f5ae839c6b66706d8b62::df38b130d957afbeda8be34a649f6e406f4c79b3::6c26df06adc55ef7c27891a52a8feccec58b4aea::0a76ed232a6c448a8666234a2c190db37e3498e7::7460945e0b663585a7af3cde6c8675cbe21b4111::41c29f6d1df0f78cfeb0b688a0a1750c8b2e5c03::
https://api.github.com/repos/bitcoin/bitcoin,12967,backport-12626::0.16,0,merged,Backport::,"Backports: - #12626 Limit the number of IPs addrman learns from each DNS seeder - #12650 gui: Fix issue: ""default port not shown correctly in settings dialog"" - #12756 [config] Remove blockmaxsize option - #12985 Windows: Avoid launching as admin when NSIS installer ends. - #12946 depends: Fix Qt build with XCode 9.3 - #12998 Default to defining endian-conversion DECLs in compat w/o config - #12999 qt: Show the Window when double clicking the taskbar icon - #13064 List support for BIP173 in bips.md to the 0.16 branch.This setting is now in here twice. Also, I think it would make more sense to backport #12756 instead, since it was already ""removed"" earlier (due to being ignored because of a typo).::",f60e84dba4723bc658ecc70f8b17db2619eb7e20::f118a7a35b8c880740d5ebf6230498a5951bd889::e802c2294718f1e1128f2736842595c3b84a2882::0684cf9b5845e40ba1e1c22bf03cd4786aff398c::e055bc0fdfb2abfc224e9d75db92ae738687502b::1720eb3018e57cc75163c2d2c3f235325a2cc995::7847b926057b46a5c01e1033f64f6f61dbf3d88f::9645aa626230449539423815db6e59ac3cfb57e6::8fca086d69bdcf748b1a7c9827ac2d71752d0b88::
https://api.github.com/repos/bitcoin/bitcoin,11966,ver_full_commit_hash::master,0,merged,Build system::,"git keeps changing the number of digits in abbreviated hashes, resulting in the GitHub archive hash changing because we include it here. To workaround this and avoid hashes that become increasingly ambiguous later on, just include the full commit hash when building from git. This has no effect on tagged releases. (Cleanly mergable back to 0.10 without backport)",a71c56aebbd93b25fcdbc170bd8b451e52a6b4dd::
https://api.github.com/repos/bitcoin/bitcoin,11593,fix-libevent-cb::master,0,merged,RPC/REST/ZMQ::,"A rare race condition may trigger while awaiting the body of a message. This may fix some reported rpc hangs/crashes. This work-around mimics what libevent does internally once a write has started, which is what usually happens, but not always due to the processing happening on a different thread: https://github.com/libevent/libevent/blob/e7ff4ef2b4fc950a765008c18e74281cdb5e7668/http.c#L373 Fixed upstream at: https://github.com/libevent/libevent/commit/5ff8eb26371c4dc56f384b2de35bea2d87814779Are they not going to backport the fix? It looks like they haven't released a 2.2.0?::Why do we now need to copy req where we weren't previously?::Unsure if they'll backport, but it shouldn't hurt anything if they do. The reason for the version check is in case the behavior changes drastically in the future and enabling the read/write may be harmful. 2.2.0 isn't released, but the fix is in master.::std::bind copied in req by value, but passing ""this"" into the lambda and using req would use this->req in the callback, which would blow up because req is set to nullptr a few lines below. This is clunky, but I'm not sure how else to pass a class member into a lambda by value in c++11.::If the lambda were changed to simply say ""req"" (not ""req&"") then it is copied by value (in this case the pointer is copied).::Class members need to be captured with 'this', so unfortunately that doesn't work.::",6b58360f9b64eb0b680a662fdfd590e47f115f44::97932cd2689659addfbb58dc6148928b73af3bd0::
https://api.github.com/repos/bitcoin/bitcoin,11580,2017-10-getheaders-valid-only::master,0,merged,P2P::,"Nowhere else in the protocol do we send headers which are for blocks we have not fully validated except in response to getheaders messages with a null locator. On my public node I have not seen any such request (whether for an invalid block or not) in at least two years of debug.log output, indicating that this should have minimal impact.So it was missing `IsValid(BLOCK_VALID_SCRIPTS)` here?::""Missing"" is a strong word given there isn't exactly a spec for the P2P protocol, but, yes, I'd say it should be there.::Should be tagged backport then?::Now that this function is expected to accept main chain blocks, maybe change the function name to `BlockRequestAllowed`?::Update the function comment to describe this condition.::Meh, dont think it matters too much.::",3788a8479b4efd481f3e91419bcf347113375112::725b79a9cf9d6af3a9a7a31407f2795fe640f3c6::
https://api.github.com/repos/bitcoin/bitcoin,11530,Mf1710-distShare::master,0,merged,Build system::,"As the legacy rpcuser and rpcpassword are deprected since 0.12.0, we should actually include the script to generate the new auth pair in the distributed source code archive. Ref: #6753 (Tagging for backport, since it is a trivial bugfix)",fa81534d068cb5479684ed9fb073dc51532b91ca::
https://api.github.com/repos/bitcoin/bitcoin,11527,remove-seed::master,0,merged,P2P::,keep it up to date. I suggest to consider this for backporting.,132d3225f325b84afc282638c9e99623d249a52c::
https://api.github.com/repos/bitcoin/bitcoin,11447,Mf1710-0151Backports::0.15,0,merged,Backport::,"This mostly backports various commits that fix(ed) bugs and issues. However, it also includes two patches for qt that only fix minor issues, as well as some doc patches.Sorry there was a bad commit-split in #11237 which meant the EOF newline got deleted and readded in the next commit, might want to squash them or just fix this::",9e8aae31c103e1d76365c34ce1fe1dd68e93912b::50bd3f626d7ce35d52543b88a2e512074f9df134::b278a43646c8fb331a1b830b09a60ec2544dd6b6::2cb720ae6122101c83a8836da057a5a7cba5b5df::7310f1f2eb5900a9d07e2c6427a71d161762000a::47c02a8ae8b406a1a7d7004b2a0337a1f32420e9::2e31b1d48d4da31bf32e1e4123c7e5d662490826::921542e0bde120cc5e36e6c400b9fcd486c73cdf::b1a6c946838fb070fe3079084b800836c7d5ddfa::19d63e8a939abb89385fc5758771351cbe650ffe::6642558078deaae2bdf1d85ed2156eb23ba004b0::8d13b4298c1ca83db0a65c8c8a93bd3be9135754::75997c3b35db39031a222e2d63da83e67cc9397c::8b61aee69026b03dfd5ebdb29c8d27a2b87462d1::62d18cdb893fea92680a6f382bb8b3e8ca157bcf::6b4d9f273607bcacaa65a7a030eef5cc9d6bb6e8::0fe2a9a196b2f81fed2ea84a5979e95f37094b22::6a62c745a9ce7d08667ab544ee3627e035e9d0ce::b6c0209aaf372a21090c0a3eed973022af14ece0::a43be5bcdb27a68abe9bb5fec57185a1b6652479::dea3b87dd974edc18961005e66395c9238f0ab16::27e861a9b394857b0005347962ced92ac65e5dac::c94527a973611d7bc230af37d946d0c2d8b3ad13::405e069d3b8c71b0f5161d9dfb2334a0bb988f2e::20cdc2b36c40221a0eec942a1fbdf38ca7c4e005::
https://api.github.com/repos/bitcoin/bitcoin,11445,Mf1710-0151qaBackports::0.15,0,merged,Backport::Tests::,"This includes test related backports for 0.15.1. The motivation is twofold: * Make backporting new tests written for current master easier * Fix the most common test issues that happen(ed) frequently on travis Even though this includes the new TestNode class, which comes with a lot of refactoring, I believe that the issues caused by refactoring are found and fixed by now.",fc2aa09cf382f024f461e103f2500e95ddb692e5::c276c1e1d1fb18771d9efabaf5a476d29c901d5d::1d80d1e319b41e5187d5949b3c22c35df182ba3c::5398f205e3ba1f7542deeba420f9e198bcb635f5::016b9ada2111aaf41f3336c0179a1347355bc9e6::716066dbea0e448b78838a692c4627a9e32fcec2::2a5d099e47c896a7a3bd0015ca179587257b7792::847c75ec6447f58b6c4f3732a10551f1faddbb0b::11a5992c90d4cc9a3823ea08dab2c078bcbf15d2::4d3ba18386c7a09086d06c8b640c19343ff34188::bb5e7cb308b58a1c16db1275dfca1a31e2bba71f::801d2ae9247be5870344c8b4ed5c372ab8930408::82bf6fc6d48a232cc0ceb54b136d86914f49013c::cef03198dcdca63d88bf8f50edcc79fa6b268261::44241765e3c8caa9248949cbe0fbc1c3072319c0::f0b67954f06e71eb2f4df0125b7075d8b36e0c6f::f3f78917769b9bc65c133a160dba7df18a33b27d::eeb24a3a0157c41a0aae1d5561cf490abe378585::812c87004311732da2fc8840a483be80c7a443ca::e0bfd28de28efb1ffa84e89d76c144824dae987f::e38211f5e8900ee9027c671d7c655958e4dbe8e7::2b97b36e5d37c6935dce112f90213f4f49cd88ad::d8dd8e7356b4109cfde48d2667ea4da29c849cf8::b6468d3c420f73627956fc94c9743d26d75af8b0::2e1ac70df97be758a2a9869104a81cb454008174::f1ced0d7761d1316c6b522b2b426e79833e4cbae::f9cf7b589f430b2d7c52e477b6d62f29d748c38e::794a80eee335a10d239aed7fdbdd013bce45161d::2c4ff35a8fce0c40884886a93c1bf12395fb105d::e4605d9dd498a1fa713e6a916347a7c887f2c2b8::2f0b30a58a07a3e30faa82a27525025158754db2::8d2e51d86253881abadb5b11f93b12e3761f6232::a36f3320a94aa70328e133d53146fc1ef57e1e34::a825d4af5e3ca353bce421e966ddcb9fc643075c::806c78f014f6be9e12afb181d85e135f3b44e33e::e169349f8c25d8998492b38500c1fee1074ed6fe::019c492490077a7581ab526b4208439200cbff24::
https://api.github.com/repos/bitcoin/bitcoin,11372,201709_addr_cleanup::master,0,merged,Refactoring::,"This PR contains some of the changes left as TODO in #11167 (and built on top of that PR). They are not intended for backporting. This removes the `CBase58`, `CBitcoinSecret`, `CBitcoinExtKey`, and `CBitcoinExtPubKey` classes, in favor of simple `Encode`/`Decode` functions. Furthermore, all Bitcoin-specific logic (addresses, WIF, BIP32) is moved to `key_io.{h,cpp}`, leaving `base58.{h,cpp}` as a pure utility that implements the base58 encoding/decoding logic.Nit, space after `//`. Same below.::Important: IMO `DecodeBase58Check`should *cleanse* `data`before returning `false`.::Extra: In that case this function could be: ```cpp CKey key; std::vector<unsigned char> data; if (!DecodeBase58Check(str, data)) return key; const auto& prefix = Params().Base58Prefix(CChainParams::SECRET_KEY); int size = data.size() - prefix.size(); if (size == 32 || (size == 33 && data.back() == 1)) { if (std::equal(prefix.begin(), prefix.end(), data.begin())) { ... } } memory_cleanse(data.data(), data.size()); return key; ```::Side note: Another option is to create a PR to use custom allocator for all containers that are `memory_cleanse`.::This is initialized with false. I assume you'd also have to check for `key1.IsValid()`?::nit: `bad_key`::Fixed.::Fixed.::naming: Should say prefix_size or size_prefix, current name has no meaning.::",32e69fa0df8fc1cfc8ac4f8381bc54b8f33e1c38::ebfe217b15d21656a173e5c102f826d17c6c8be4::119b0f85e2c8b9729228aad5d946144d57ad0f5b::92f1f8b3197c2ba3cf65556070509838098975a4::
https://api.github.com/repos/bitcoin/bitcoin,11289,201709_add_help_text::master,0,merged,Docs::RPC/REST/ZMQ::,"Closes https://github.com/bitcoin/bitcoin/issues/11243 Adds ""Requires a new wallet backup"" text to `addwitnessaddress`, `importprivkey`, `importmulti`, `importaddress`, `importpubkey`, and `addmultisigaddress`. Also adds a warning to `dumpwallet` that backing up the seed alone is not sufficient to back up non-HD addressesUnrelated whitespace change.::Unrelated whitespace change.::I mentioned that in the PR, is it an issue?::I isn't really a problem, but you should try to avoid making such changes. Atom can be set to not make any whitespace changes at all.::It is a problem, as it often breaks backporting cherry-picks.::Fixed.::This leaves me confused. The things I need to back up *are* in dumpwallet, just not the master key listed in dump wallet, right? So just the dumpwallet file is a sufficient backup (with rescan, including imported segwit addresses and p2sh redeemScripts?), but not only the master key?::@TheBlueMatt would changing this string to something like `Dumps all wallet derived keys in a human-readable format.` help cleanup the confusion?::I've changed it, lmk what you think now::Note that you may want to wrap this line.::""nrequired-to-sign multisignature"" Only comment, I'm assuming this isn't a typo, and is a reference to the number of required signatures needed for the multisig address?::Correct :) And note that that text is not changed in this PR, it was there before::Ok sweet, yeah I saw that it wasn't a change from this commit, but wasn't sure so figured I'd ask. Thanks! Is it typically frowned upon to comment on things not directly changed by the PR/Commit/Issue in question?::No, if something looks wrong then feel free to point it out :) I was just clarifying ::Awesome, thanks again.::",a38bfbc51d0b98fffd8d79457f31c6fb196ff580::c098c581968fa23b2a1987c127c47e04d13fb5c8::
https://api.github.com/repos/bitcoin/bitcoin,11145,fixrounding::master,0,merged,Wallet::,"Thanks to @juscamarena for reporting this. Please backport to 0.15. There was a potential rounding error where the fee for the change added to the fee for the original tx could be less than the fee for the tx including change. This is fixed in the first commit.  The second commit adds one more snippet of information in the fee calculation report.  I actually realized that there is more information that would be nice to report, but we can add that post 0.15. An open question is whether we should be returning failure if the test in line 2885 is hit or just resetting pick_new_inputs and continuing.  Originally I made it a failure to avoid any possible infinite loops.  But the case hit here is an example of where that logic possibly backfired.",a54c7b94f8825e9b52fec9066fe7c1d5b6f53482::6af49dddeaeec7f134e86d6f8cf839c55870b7ab::
https://api.github.com/repos/bitcoin/bitcoin,11117,201708_nocbitcoinaddress::master,0,merged,Wallet::,"This patch removes the need for the intermediary Base58 type `CBitcoinAddress`, by providing {`Encode`,`Decode`,`IsValid`}`Destination` functions that directly operate on the conversion between `std::string`s and `CTxDestination`. As a side, it also fixes a number of indentation issues, and removes probably several unnecessary implicit `CTxDestination`<->`CBitcoinAddress` conversions. This change is far from complete. In follow-ups I'd like to: * Split off the specific address and key encoding logic from base58.h, and move it to a address.h or so. * Replace `CTxDestination` with a non-`boost::variant` version (which can be more efficient as `boost::variant` allocates everything on the heap, and remove the need for `boost::get<...>` and `IsValidDestination` calls everywhere). * Do the same for `CBitcoinSecret`, `CBitcoinExtKey`, and `CBitcoinExtPubKey`. However, I've tried to keep this patch to be minimally invasive, but still enough to support non-Base58 addresses. Perhaps a smaller patch is possible to hack Bech32 support into `CBitcoinAddress`, but I would consider that a move in the wrong direction. Block instead? ```cpp if (...) { throw ...; } ```::Change to ```cpp if (!destinations.insert(destination).second) { ```::Nit, kind of unrelated, use `.find()` to avoid 2nd lookup below.::Follow up, should the error message be `Invalid destination address`? ::Replace with `.insert().second` like above.::An address is just the string-encoded form of a CTxDestination, so no. I think the ""destination"" name should be internal.::Trying to keep this as much of a straightforward change as possible, as it may need backporting.::Off topic, just `Invalid address` as it seems irrelevant to have `Bitcoin` in the error message?::Oh, sure!::I've stared at this for 5 min now. What trickery made this work before?::!keyID::Maybe add a quick comment that this is CNoDestination so it comes up when grepping for future changes.::got it. ignore last nit.::heh.::Good catch.::It was creating a temporary of type CBitcoinAddress by converting the CTxDestination initializer, using the implicit `CBitcoinAddress(const CTxDestination &dest)` constructor. That temporary's lifetime was then extended by taking a reference to it, named `address`.::It took me a while to figure out what this `CBitcoinAddress` was doing. Answer: nothing at all.::Wow, thanks :S::Interesting, I didn't know an implicit conversion could be done when extending the lifetime of a const ref. Scary!::Nit, sort.::Nit, fix braces.::Could use `currentAddress = request.params[0].get_str();`?::Fixed.::Not going to reflow this entire function in a PR intended for backporting.::There may be reasons not to do that. Bech32 addresses (added in a later PR) can be uppercase or lowercase, but we always want to store and look up in lowercase form. This is an easy way of doing that, and we should probably check that it's done consistently elsewhere too.::Agree, I'm +1 for clear data validation and/or sanitization. Although `encode(decode(data))` is a obscure way of doing it, not to mention `encode(decode(data))` should equal `data`?::This incur in a double decoding since above `IsValidDestination` also decodes. Maybe swap: ```cpp CTxDestination address = DecodeDestination(rec->address); if (IsValidDestination(address)) { ``` This is how it's done multiples times in this PR.::Could use `!(operator==)` instead?::nit: Any reason why this was changed from ""Invalid Bitcoin address"" to ""Invalid address"" and the other places left as is. This is part of a error string, so shouldn't break anything I guess.::@achow101 regarding the need for error testing.::",5c8ff0d448ffdc6340b195ddfa2128d5f21a839b::864cd278741ab0e17e7d93eedee39417d4797b37::
https://api.github.com/repos/bitcoin/bitcoin,10516,0.14.2_fixes::0.14,0,merged,Backport::,"Sorry this is late. It should have backports of everything from PRs 10234..10495, except for #10318, 965a12442746e99247e5ce0f43fba8e3e149cae4, and 513da90cdd8463964e8c430b25f4326defc0bc96 which seem too complex for a trivial backport.",c5adf8f267b2b4b633af2738c8f21005d4382496::e2073424fd5a185781750347fbfbb0c108ef66fd::96c7f2c3458950061b057fcd3daaf47b57e6bac7::3e4d7bfcb7d9f6d88b6120f44bb6cb7fa93d7adf::7abe7bbf61d90dc003647f2cc5019e4652182399::d28d58382076c77dc7f8ec59997c5ce2fde99f70::71463a7d18bb143da62e790f9194193dfaf8f320::ef810c4cd440dec00a651b944d74ed4ae85603c2::c94e262d4bf64f75e97d478a5a2e8d75067d43e3::2ea035832f0ba56db046eff318d3b91f097e1ca4::e9a0d89bf7593a1ae7ac9b059793281f0b754540::6ad45b8f8bd1f33842160d109d391deae0d615e7::3ad00b4b32842e005af6378fd71eb9e293804cef::fe51c8924e62bf146a722f632324c99c2f97bc75::18c109ddb10e8f2e1075ee4078519cfefd4de47d::4943d7a9feb8e4f5461622f548032e53eb714175::f5efe82a832a050d1e8f483904913d238dde2e93::c25d0a8739cfcb736ddbf4a5204f25830842eb46::5bc75bb8eea566258ddd9c858e2cf6361318d777::bfd1cf6713f1f44b88b135c995b9ddb9e99ff7aa::74653a41fee027b1c85b229a2d7460bb862c6b02::99e5dbd0aa4304918b4fcfe125c4479c04eede40::98bd0c338b1886d12ea3d90597ab0438acbc07ff::04226938a3c675faaca81906ae9ff7a936bcb6a7::d289b564e3ae125cb54c3d9157a13e7bad48c5f5::ee1a60d15609930954b1b85da7f33774711123cd::e05799a381191d603f697225d7a972a735ec8608::aca4b6dbcb1c2b7f0c3808fd8ad3eb7dce158555::77de9bbc57a76c52f6f30e6c336869f0540cf6bf::1b864c9820abc0ba05093b97b813f4719584759b::a40d69e0b85af4cafa81db38f1e36f8cf5f86b3f::e23cef0c9469cc360e603a614bb3f0b22c6656bf::ff13f592c5813b18340a6e9e65abb4e356aac400::28b8b8b6038c45ce2dc2e7dc11f88dc834ddd19a::87a21d5922f3cdc7a7e21090dc7078e0774c1c1f::692dbb0288d6582e311a47951ff4afd63ea9d90c::3612219f9a18a2bd1ddebb1b90f556aa29586bfd::d2ec96909acc3eda76ee507456d8f3722a965921::12adedff0bf813f2a2e790f422e41cc8d84cfc99::76f9cf9ac9916f9a29b3f236225d49501ccf230a::ff274d3b00737d9f93c85c0bcff51f1f548354b6::
https://api.github.com/repos/bitcoin/bitcoin,10441,serviceflags-required::master,0,merged,P2P::,This ensures that future flags can be turned off after being enabled without causing all outbound nodes to refuse to connect to it in the future for lack of expected services. Should probably be backported to 0.14 as well.I think this else branch is unnecessary?::It possibly downgrades the requirement from [line 1799](https://github.com/bitcoin/bitcoin/pull/10441/files#diff-9a82240fe7dfe86564178691cc57f2f1R1799).::Indeed!::,b6fbfc228236947eaea5c14dda299f5a01810e92::
https://api.github.com/repos/bitcoin/bitcoin,10424,notnodenone::master,0,merged,P2P::,"Previously if we didn't have any local addresses, GetLocalAddress would return 0.0.0.0 and then we'd swap in a peer's notion of our address in AdvertiseLocal, but then nServices would never get set. This would prevent a node behind a NAT from having its nServices set in addr messages gossiped between peers and could lead to no incoming connections. This should be backported to 0.14 (and 0.13 if we do that) I can't promise that I've fully understood all the implications here.",307013469f9a3b8f13d3eb9dbeea419a55148493::
https://api.github.com/repos/bitcoin/bitcoin,10204,rename_disconnect_node_argument::master,0,merged,,"split off from #10143 for backport The fact that this argument is currently called 'node' and the help text says `(string, required) The node (see getpeerinfo for nodes)` is misleading at best. It currently only accepts a string which must match on the CNode::addrName, which is the IP address/port.",883154cbcb306dcc6205fe349c7056ced1f6c5fc::
https://api.github.com/repos/bitcoin/bitcoin,10157,test-0.14.1rc1::0.14,0,merged,Tests::,The backport of the mempool_packages.py test from #10144 to the 0.14 branch required a change due to the prioritisetransaction api changing from 0.14 to master. This fixes the test for the 0.14 branch.,39febb8c6dbe286946773630d0484027307e5f42::
https://api.github.com/repos/bitcoin/bitcoin,10143,disconnect_node_by_id::master,0,merged,RPC/REST/ZMQ::,"The disconnectnode RPC can currently only be called with the IP address/port of the node the user wishes to connect. This commit allows the node to be disconnected using the nodeid returned by getpeerinfo().Concept ACK, but please make this API explicit. - APIs that switch based on magic heuristics on how a value 'looks'. Initially this seems user friendly, but it will quickly grow to maintainable, insecure monsters of obscure rules. It should be made completely explicit. - Also: do not encode integers as strings and use functions like std::stoi. Just use .get_int() if you need an int value and leave the encoding of values up to the RPC mechanism. The most straightforward way would be to just add a function `disconnectnodebyid`.::Yes, I agree that APIs shouldn't be magic. I thought it wouldn't be too problematic here because there can't be any ambiguity at all between nodeIds and IP addresses (and `disconnectnode()` is already a bit magic - it can take either IPv4 or IPv6 addresses). I don't like the proliferation of additional RPCs that perform a very small function if we can avoid it. How about we add a new argument to this RPC called ""nodeId""? The RPC can be called with strictly one of the arguments. There's no magic or ambiguity, and the node disconnection logic is contained within one RPC.::> How about we add a new argument to this RPC called ""nodeId""? The RPC can be called with strictly one of the arguments. There's no magic or ambiguity, and the node disconnection logic is contained within one RPC. Sounds reasonable to me. To be clear: anything that doesn't encode the integer as a string is more reasonable to me than this (another reason: because it allows passing the 'id' value literally without having to string-encode it in the client). I don't have a strong opinion whether it should be one or multiple RPCs.::Second argument is missing here ::Thanks. Help text now fixed. I'll squash the commit when this is ready for merge.::This is yet another breaking change. Needs rationale and mention in the release notes. Maybe backport. ``` JSONRPCException: Unknown named parameter address (-8)::Please mention in the documentation that only one of either can be provided, and the other one needs to be null (or missing, in case of the second argument, I guess). Also I'd prefer a space after `ID` before `(` otherwise it looks like a parametrized something::Use `address` here?::What about `disconnectnode(""address"", null)`?::`get_int64`::Right, I also wondered about that. My recommendation, also for readability, would be to structure this symmetrically e.g. ```c++ const UniValue &address_arg = request.params[0]; const UniValue &id_arg = request.params.size() < 2 ? NullUniValue : request.params[1]; ... if (!address_arg.IsNull() && id_arg.IsNull()) { /* handle kick-by-address */ std::string address = address_arg.get_str(); } else if (!id_arg.IsNull() && address_arg.IsNull()) { /* handle kick-by-id */ NodeId nodeid = (NodeId) id_arg.get_int64(); } else { throw JSONRPCError(RPC_INVALID_PARAMS, ""Only one of adress and nodeid should be provided.""); } ```::General advice when designing new RPC APIs: please try to treat IsNull arguments the same as missing arguments, both in the middle as at the end. I know a lot of the current RPCs don't heed that advice, but that's something that needs to be improved to prevent unexpected behavior when switching to using named arguments.::Thanks @laanwj. That's good advice. I've rewritten this function based on your suggested structure.::This doesn't convey that address is also optional.::s/int/number/ JSON doesn't have ints.::",23e6e64a247ef61388f9b8902bc448f0c6159e0e::d6564a26f4afc28d7d1a24b94946916387c9bf24::e367ad5b441d44479d40d6b04a270a571d073a65::395561becfa612fedec74fd841cb4f28afdc23d7::2077fdacd32adae8d118f019628ecdaa24632550::12de2f252c8f48e05c579cb679866a68af8c660e::5cc3ee24d29397737f2746d78b19a2509c0dedbb::d54297f1a85612dab100c473ad04c4f9d279f473::
https://api.github.com/repos/bitcoin/bitcoin,9955,2017-03-mining-segwit-changes::master,0,merged,Mining::,"Segwit's version bit will be signalled for all invocations of CreateNewBlock, and not specifying segwit only will cause CreateNewBlock to skip transactions with witness from being selected. (Note that CreateNewBlock's performance may suffer if the mempool has witness transactions that are being skipped, so this is not a recommended configuration.) Originally we didn't signal segwit unless the getblocktemplate caller explicitly indicated support, in order to prevent segwit from activating before any miners actually had support for the witness commitment.  Now that many blocks are signalling segwit already, this is not a material concern. Also, I need to figure out how to add a test to segwit.py to check that witness transactions would in fact be skipped. As per IRC discussion, I think we should consider this for backport to the 0.14 branch.Should test that witness tx can't sneak in as an ancestor of non-witness, too.::Use `fMineWitnessTransactions` here?::This is cached across calls, so it requires a bit more complexity.::I concur.::Addressed in 24428bd.::I think I fixed this in 24428bd.::Done in 7db565c::",abe7b3d3abe10e3554b770f40824174b3b217490::c85ffe6d8d57132c1825c16a572d3847419030a6::
https://api.github.com/repos/bitcoin/bitcoin,9879,2017-02-bips-doc-bip90::master,0,merged,Docs::,I guess this should be backported to the 0.14 branch as well...?,fe71661ae16abe09dcf245ee2eb4c55c5655b219::
https://api.github.com/repos/bitcoin/bitcoin,9485,python3zmq::master,0,merged,RPC/REST/ZMQ::,"As is says on the tin.  This example is functionally identical to the polling 2.7 zmq example, but uses the fancy new non-blocking asyncio of python 3.5.This function definition syntax is specific to Python 3.5 and throws an exception in Python 3.4. Perhaps a ```from __future__ import``` option exists that will allow compatibility with all Python 3 minor versions?::Asyncio was only introduced in 3.5 including these syntax enhancements and was ""provisional"".  It's now final that 3.6 was released a week ago, and backported (as final) to 3.5 point releases.  3.4 doesn't have it and never will.  But, it doesn't have anywhere near the user base of 2.7 and I don't think is worth supporting long term. I tried to install 3.4 while testing this, it's not even provided anymore by Ubuntu. http://stackoverflow.com/questions/30191556/coroutine-in-python-between-3-4-and-3-5-how-can-i-keep-backwords-compatibility::FYI the ""yield from"" syntax of 3.4 has been entirely deprecated.::Useful to know and thanks for the info & link @mcelrath Python 3.5 will undoubtedly become the de facto standard, as you imply. In providing example scripts it seems reasonable that Bitcoin cater to the common denominator. It's probably safe to assume that most nodes out there are not running on the latest OS versions and that Ubuntu 14.04 and even 12.04 (in some cases) are the majority. From this perspective catering for Python 3.4 is useful since it is both repository standard and supported. Your 3.5 approach using asyncio is great. My comments are really just thinking about ease of use and compatibility, hence the suggestion to cater for 3.4 and the inevitable 3.5 future::nit: I'd like to see a module-level docstring describing what this does (which can include the comment block below about the pre-2.7 version)::nit: I don't think this import array is actually used?::nit: prefer imports to be on individual line (PEP8 E401), and listed individually.::Ubuntu 14.04 LTS is supported until April 2019, and currently ships Python 3.4.3, so I also think it makes sense to provide examples compatible with Python 3.4.::",5ea5368b3a71ab91032ed08b919a4bf740cd676b::5406d510678cf4b1191f1b9a1838524fe5fa13da::4bb7d1bc4dd388255a8c14b22948b33378359b60::b471daf85b07d0ca072a8d7ec482a25401a67399::
https://api.github.com/repos/bitcoin/bitcoin,9471,depends-0-14-0-libevent::master,0,merged,Build system::,"See #8867 for discussion around moving to libevent 2.1.x . We can drop both of our patches with the switch to the 2.1.x branch. The libevent-2-fixes patch (https://github.com/bitcoin/bitcoin/pull/8730), was already included in the 2.1.6beta release, so can be removed. The reuseaddr patch was introduced [here](https://github.com/bitcoin/bitcoin/pull/5677/commits/4be0b082b97062be4df20e9c45dafa577b05b07c). Looking through the 2.17 code, it looks like it might have been a backport from the 2.1.x branch, and so can also be dropped. libevent 2.1.7-rc [changelog](https://raw.githubusercontent.com/libevent/libevent/release-2.1.7-rc/ChangeLog) Closes #8867 Minor note: This hash is not guaranteed to be constant, I think.::Hm but not checking the hash at all would not be acceptable. ::Of course, but we need to keep a backup of the GitHub generated zip file. (Which reminds me we already do so on bitcoincore.org/)::I may be off track, but if the hash changes for the given release, doesn't that mean we WANT the build system to explode in everyone's faces so people react? I can only imagine a hash change for the same package version would be due to some serious issue being hot-fixed upstream. Keeping and using a backup would mean that hot-fix goes unnoticed.::> I can only imagine a hash change for the same package version would be due to some serious issue being hot-fixed upstream This would require a new release of libevent. What I was referring to, is that the hash changes after GitHub purges its caches for zipped downloads of git tags/commits. (Note the above zip is not provided/signed by libevent but generated by GitHub for convenience.) I could image that GitHub does not deterministically generate zips.::@MarcoFalke I remember dealing with this at one point already, and I seem to remember github fixing the downloads to be deterministic, but I can't find any reference to that now. It looks like our native_cctools comes from a similar link, so I assume that we would've noticed new hashes by now. @kallewoof You're very much on-track. The issue (if I recall) is that github always serves the same .tar, but the gzipped result can change if it's been regenerated.::Wouldn't it be possible to have a checksum check for the decompressed .tar then?::@sipa Sure, if that's necessary. Given that we have similar downloads atm that aren't causing issues though, I suspect this is no longer an issue.::Let's just take the chance then and merge this.::Looks like they just released the stable version, so we could use that, maybe.::That's annoying, we delay this update for months in the expectation that there will be a new stable version any time, and after we merge this there suddenly it is, the new stable version.::",8217bd1d4cb9415dd507739b9040714677f9e8e8::
https://api.github.com/repos/bitcoin/bitcoin,9322,Mf1612-qaSerial::master,0,merged,RPC/REST/ZMQ::Tests::,"When merged, this will merge #9292 as well. I created a new pull, so 0.13.2 isn't blocked by this.Maybe define a constant for the max valid RPC serialize version?::Which would imply the default is not always the max. It is not clear from the comments if this is desired. Edit: Anyway, fixing this nit is irrelevant for backport. Either we merge/backport this and bikeshed later or we close the pull based on luke-jr's rationale.::",80d073c9bca4521d512ea14ff7919d4609647b6d::fa615d39b53a9309ef480c41ec073354c4371f40::
https://api.github.com/repos/bitcoin/bitcoin,9293,9053_backport::0.13,0,merged,Consensus::Refactoring::,"This is a backport of PR #9053 -- we passed on backporting it right after it was merged, but it's been in master for over a month now with no issue. This resolves some frequent annoying misbehavior on testnet (in theory the problems it solves are also possible on mainnet but aren't likely there without miner funny business).",4c71fc42fbf32d8994f4d2488ac4bafad93226a1::ad20cddce2097c6561202777fccd257deb1a9810::5b93eeebb4f7fce10a12f2e83f771bc23002c224::5998a09546b033e8d55f2a45d35a6161b2cdc288::
https://api.github.com/repos/bitcoin/bitcoin,9262,toolong::master,0,merged,Mempool::Wallet::,"This does a few extra possible runs of SelectCoinsMinConf, each with larger allowable mempool ancestor numbers, up to the acceptable mempool limit. As long as each input is not above this value, it passes. This means the sum of the history could actually be larger. This is why I then catch the transaction at the end of CreateTransaction, and directly check. It simply fails, and does not retry. This logic is gated by a new command line argument `-rejectlongwalletchains` to regain previous behavior. We can most likely remove this check once we have better rebroadcasting systems.Since we've already checked that pcoin is in the mempool, we don't need to do any of this -- we can just use the cached values.  (I think the only way the calculation you do below can fail is if the limits are violated during a reorg.) ::nit: add documentation to this function that the tx must be in the mempool in order to call?::Perhaps worth a comment here that we're assuming `AvailableCoins()` has already filtered out any unconfirmed and not-in-mempool coins?::nit: perhaps this comment should be ""Lastly, ensure this tx will pass the mempool's chain limits""::The errString filled in by CMPA might be useful for debugging issues (eg a LogPrintf() so that someone debugging could inspect), though i see we don't log any info about the transaction we tried to generate, so maybe not worth it...::I think you need the pcoin->InMempool() check you had before, in case you're looking at in-chain coins?::Inequality here is wrong, should be `>=` I believe. This will never fire as-is. I should be able to easily test this fix.::@morcos and I were discussing, I think this would make more sense to limit based on both ancestor and descendant count, something like: ``` if (pcoin->InMempool() && max(pcoin->GetMempoolAncestorCount(), pcoin->GetMempoolDescendantCount()) >= nMaxChain) continue; ```` Otherwise, if you have an unspent output with 1 ancestor but 25 descendants, you (needlessly) could fail on one of the early calls.::Instead of N/4, N/2, and N for the ancestor/chain limit passed in to SCMC, how about: 2, 4, N/2, N?  (And set N = min(limitancestorcount, limitdescendantcount), assuming we go with ancestor and descendant limiting as I mentioned in another comment.)  This way we first try utxo's from transactions that have no ancestors or descendants, which should provide a strong preference for not creating long chains.::Specifying const for a pass-by-value argument has no effect in the declaration. You can add const in the function definition if you want to protect yourself from accidentally modifying the variable even when the definition doesn't have const.::What if nLimitAncestors is less than 4?::Can you abstract this fragment out, and turn it into a CTxMempool method?::It calls Selectmincoins redundantly a bit... this doesn't seem like a big deal to me.::I don't think is likely to save us many lines seeing as CMPA is called with these parameters exactly once elsewhere(and we'd still have to pass entry), and further this block may get removed if https://github.com/bitcoin/bitcoin/pull/9290 or something like it happens is merged.::Overall I find this test a bit hard to follow.  I wonder if you could make it a bit clearer. It does a good job of testing that the send failures don't leave funds unavailable (b/c the transaction isn't committed), but I'm not sure that's even what @gmaxwell wants, although I do think it is a good idea.   But it doesn't test the hopefully more optimal behavior of being less likely to create these long chains. Also, please , please, please, please don't use getbalance(""*""), you can use getbalance() + getunconfirmedbalance() if you need the total including mempool transactions...::Particularly I was interested in checking it errors out when, and how. So I build two long chains, start checking that sending will fail due to final checks when combining the chains, not ""lack of coins"", then once it gets long enough, both coins are already too long to include. This test might be too obscure/specific, but it helped convince me that the code is doing what I wanted it to do. I should probably add a simple test like @sdaftuar 's where it shows it preferentially choosing shorter chained outputs first. >please don't use getbalance(""*"") Leftover, sorry. Will fix.::So now when nLimitAncestors is set to 3 it will violate it here?::Perhaps just pick larger denominators? n/10, n/5, n/2, n(or inf).::@gmaxwell We're already not guaranteed to find an optimal spend, this is just best-efforts anyway, so in my opinion it's not worth trying to optimize further for users using unusual values of these policy limits, which we already discourage changes to by hiding away in help-debug. At any rate I think having explicit small values here is overall a win, in case someone were using non-default arguments for nLimitAncestors -- this ensures that the coin selection is always first going to try coins that have no ancestors/descendants.::0, (N+1)/4, (N+1)/2, N (or inf)   gives all unique results for everything except 1 and 2... so the user would waste some computation for 1,2.::Restating my suggestion:  It's better to have more small number attempts because the large attempts will intermix chains and trash your short chains.  So  min(2,limit/4), min(4, limit/3), limit/2, limit would be a better pick... for example::ok sounds good to me::done::These seem like they would be more appropriate on CTxMemPool?::Why would we compare the descendant count to the max *ancestors*? Shouldn't it be compared to max descendants?::Probably should capitalise the 'R' in the var name.::Shouldn't `nLimitAncestors` here be `(nLimitAncestors - 1)`, because otherwise the new transaction would be 1 beyond the limit?::Even if `frejectLongChains` is set, shouldn't we prefer coins <nLimitAncestors when possible?::Might be best to have the default const, variable, and argument be more closely matched. Suggest `DEFAULT_WALLET_REJECT_LONG_CHAINS`, `fRejectLongChains`, and `-walletrejectlongchains`::Might make sense to make a `bool CalculateMemPoolAncestors(const CTxMemPoolEntry &entry, setEntries &setAncestors, std::string &errString, bool fSearchForParents = true) const;` for this common code. OTOH, we should probably split the policy logic out of ATMP, so this refactoring may not make sense long-term.::misnomer, nMaxAncestors is the minimum of the two parameters. Will fix.::the count counts the coin itself in the chain length, so I think it's right as-is. `>=` is the check to reject.::I don't think it makes sense to expose such a detail to every user. (Note that all the `-limit<whatever>` options are only displayed to advanced users.)::In light of search for a general solution to the problem, you might want to consider introducing an option that makes the wallet ignore whatever mempool policies are in place right now. When this option is enabled, we get the current behavior, i.e. transactions might not be accepted to the mempool and might not be relayed. However, when the option is disabled and the mempool policy is considered during transaction creation, every transaction that is created also is accepted to the mempool. If no such transaction can be created, the call fails.::I believe the consensus is to have all temporary failures return a txid, and rebroadcast the transaction when it can, entering it into the mempool. re:detailing to every user, fair enough. I've moved it under `showDebug`, which I believe is what you meant.::Given that we don't hold `mempool.cs` here, the transaction could be removed from the mempool in between the `pcoin->InMempool()` and `pcoin->GetMempoolAncestorCount()` calls, causing a segfault in the latter. Please abstract this whole conditional out into a method on `CTxMempool`, which takes the limit value and the txid, and returns whether the transaction is in the pool and satisfies the limits.::Agree with @luke-jr, but I think we need something higher-level anyway (see further).::I don't care that it's called only once - this just doesn't seem like code that belongs in the wallet (which shouldn't need to know about the mempool's policy limits as much as possible). Having it abstracted probably makes it usable for other purposes too. Also, #9290 does not mean we can't do belt and suspender checks to avoid producing long chains. Not adding such a transaction to the wallet (and mempool) is still superior to just adding it to the wallet and relying on retransmit to get it to go through at a later point in time.::Why false?::Should we call this something other than **Coin**WithinLimit?  Seems like coins are not something that the mempool is aware of.::`TransactionWithinChainLimit`?::It is the least change in behavior, so makes sense in case this is still considered for backport.::You're doing 3 map lookups here. What about ```c++ auto it = mapTx.find(txid); return it != mapTx.end() && it->GetCountWithAncestors() < chainLimit && it->GetCountWithDescendants() < chainLimit; ``` ::nit: you forgot to const-ify the first two ints which you did in the .cpp::Agreed, though in the interest of backporting and getting 0.13.2 out cleaing up the interface here probably isnt the priority. Lets do it in another pr.::Note that by not filling in the sigOpsCost here we dont have that information for the virtual transaction size, so you could still run over the limit here. I don't think its a big deal, but we should fix when we clean things up in 0.14 as suggested two lines up.::This really should be indented.::",0b2294a980319cbffa8612ce993e0ecaa26fa509::5882c099d9af6e8566d0bf46fb1da424a4373bf8::af9bedbff68b8aac64f2dbdf396409a541865188::cee16123f550f6baad0205f776831f39d026758b::
https://api.github.com/repos/bitcoin/bitcoin,9189,alwayscommit::master,0,merged,P2P::,"As a consistency check, it is useful to see whether GBT clients are ready for segwit deployment before segwit is actually used on the network (and even before it activates). The earlier behaviour only inserted a `default_witness_commitment` field in the GBT response whenever actual witness transactions were present. This PR changes it to do whenever 1) the GBT client claims to support segwit and 2) a segwit softfork is defined (which is effectively always in the current codebase, but may not be true for backports).I'd forgotten how this test worked and it took me a little while to track down why this is needed.  In case other reviewers are wondering: the blocks generated here won't have valid proof-of-work if we change the contents, because of the hardcoded nonces up above. ::",ad04d1cb35b9612d36078c62213bdbb13f56d73d::95f4a03777ec2ad82a94a3e2890192a93ad83509::
https://api.github.com/repos/bitcoin/bitcoin,9075,net_processing_4::master,0,merged,Refactoring::,"Yet another step towards splitting main.cpp. After this and #8930 (which I will rebase after this is merged to clean it up a ton), we're ready to do the big code moves :). This PR focuses on mapBlockSource, removing references to it from ProcessNewBlock and moving it to callsites, cleaning up logic in the process. Built on #9026 to avoid conflicts and simplify the backporting (#9048).This does not actually remove a duplicate. If there is a reorganization, and some block within it is invalid, `InvalidChainFound` will be called with the tip of the chain, rather than the block that failed. This may have an effect on the large fork detection logic. ::Nit: You can use std::map::emplace here to avoid two searches (the bool returned in the pair tells you whether an insert occurred or now). You could also remember the created iterator and pass it to mapBlockSource.erase below. (and likewise above) ::So glad to see this duplication go! ::Eek! Youre right. Just removed the commit...it wasnt important anyway. ::Fixed ::Stale comment? Or am I not seeing the race? ::Race if multiple nodes send you something near the same time you might send the DoS/Reject to the ""wrong"" node, of course we dont really care because we'll get to them next time they send us a block (and someone will still get it). ::I assumed this just referred to the fact that we drop the cs_main lock between here and the call to `ProcessNewBlock` below, so in theory mapBlockSource could be modified in between, and we'd lose the expected callbacks. ::Thanks. After discussion on IRC, I'm good with this. Though the comment could be a bit more descriptive, it makes the issue seem like more than it is. ::not sure why this shouldn't be `if (fAccepted && !sc.found)` ::you don't need to duplicate  CValidationState state, you can move the first declaration out of the locked context. ::Personally I like making it clear that this CValidationState is unrelated to the other one; it was confusing in the old code that validation errors from different blocks might get put in the same CValidationState (which would get cleared out in ActivateBestChainStep). ::If it is not accepted, there will certainly have been a callback to signal what was invalid about it. Thus, not having had a signal implies it was accepted. ::Not a big deal anyway. ::Technically this is a change in behavior...previously: if you got an error (disk space, etc) during connection you would print it in the BIP22 result function, after this patch (though, indeed, adding an fAccepted check wouldnt help) you will no longer print that, and your node will just exit (probably after retuning ""success"" from this function. ::",e2e069dabcd7e61e14bb7bceda6c19ec3afa358a::7c98ce584ec23bcddcba8cdb33efa6547212f6ef::ae223576077448bd4ec250c73f5d8fe5e9a9ac7d::
https://api.github.com/repos/bitcoin/bitcoin,9015,osx-disable107::master,0,merged,macOS::,libc++ on 10.7 causes too many issues. See #8577 for discussion/details. Needs backport to 0.13. No change on my 10.11 machine. Looks like this on 10.7: ![10 7disabled](https://cloud.githubusercontent.com/assets/417043/19699057/bc553292-9abf-11e6-89f1-2dbfd966b376.png) And when trying to run it: ![10 7disabled2](https://cloud.githubusercontent.com/assets/417043/19699062/c2f9d35a-9abf-11e6-975b-6ad7ec1b5519.png),339c4b6c3a8e68e4bba1969d144e413a462b68f1::
https://api.github.com/repos/bitcoin/bitcoin,8949,more_agressive_witness_connect::master,0,merged,P2P::,"Currently, we make 40 requests to addrman for peers with our relevant services then give up and take a node without them.  When relevant services are rare in our addrman data this means we can get all 8 peers up without them. If they happen to be reliable peers they may stay up filling our connection slots for months, even though our addrman has since been populated with plenty of relevant peers. To avoid this this PR changes the behavior to be only willing to ignore relevant services until half the outbound connections are up. Also, dnsseed does not fire if we have at least two connections (in or out) 11 seconds after startup. It currently doesn't perform any sanity checking of the connections-- they could be two lite-client inbound peers that will never send us addr message and our addrman might be filled with stupidity. To improve that somewhat, we check that they at least send the relevant service flags before deciding to not request dnsseeding. Why not C++11 range-based for? ::This is meant for backport, so no cpp11 ::Only backport to 0.13 though, which does have c++11? ::",9583477288072e203541b747fcffe8d50cfefb8d::46304791353d2bb61004a035869612620c30b4eb::
https://api.github.com/repos/bitcoin/bitcoin,8927,findanddeletetest::master,0,merged,Tests::,"This adds `FindAndDelete` tests for pre-segwit and segwit scripts, to show that `FindAndDelete` is performed only in pre-segwit scripts. The transaction is generated in an unconventional way: the public key is generated with key recovery, using a fixed signature (committed in prevout) and a known sighash. Also edited the comments in interpreter.cpp since the rationale of dropping the signature was wrong. No harm to backport but I don't feel this is needed. This is more important for alt-implementations to make sure they won't fork accidentally by incorrectly implementing BIP143.",acf853df910339412bafb1743f42af1774f5b910::
https://api.github.com/repos/bitcoin/bitcoin,8866,Mf1610-013backp::0.13,0,merged,Backport::Docs::RPC/REST/ZMQ::Tests::,Several test and rpc related backports. (Minor non blocking fixes) Created with the backport script by @luke-jr,375437c26bba95e9c25b758a186a3370f1d5e15d::9bbe66e5929b47f3990a916787f1b145556fd665::2a8bca465dfd24cb7722d63d41bd67b0ba3dcb5c::62886598dbed82a6ce2d987ad345ebf710751d26::83ad563ade3c7db887b12f7aaf6d5ad9c20f208a::1dd1783873db0a438a0141e908a9d08f1774e6e3::d87227d6d2d6e06af1ef4ad13e2b15f1d4d43600::eb18cc1272e1f29b2caccf08aedee3de6fc3c437::31ab2f862ad48e89314611faa0debc916317cb16::3e4abb5025f4b7415fa57d576efebe1d45fd204e::624a007f476027457b32e0bd42584e67bb003317::1f60d455048b7c0af6a5fdc032022d3fac37e790::794b007896aae7b180bdfc771bb4e1656a3e3329::0bee740845b9c7599e041b0be7111c8debaff63b::cbc3fe59c4d92784411f5d40207ddde61fa5a892::b98734843520bc09d11ab76842de420479468801::b73f0653f30168db84b4521e5f315e53804feced::d6c83b95cff2ff290533593719d6501ecf128f13::5e0dd9e07c02422a263cc14a173d4ee21a7c1393::
https://api.github.com/repos/bitcoin/bitcoin,8862,fix-disconnect-send::master,0,merged,P2P::,"Noticed these in #8708, which turns them into crashes. PRing separately here as I believe it needs a 0.13.1 backport.",905bc68d05595f41cca36b3df83accd10c00cc48::
https://api.github.com/repos/bitcoin/bitcoin,8815,2016_09_backports_0_13_1::0.13,0,merged,Backport::,Backport the remaining 0.13.1-backport tagged pulls. See individual commits for original pull information.,1672225670cd34e21e397968433d47e6997f9a5f::b394a96396ce166bf2b519190fdc2a124f57eb5e::a5ec2483235d5585e985715a5f66d41dbe1c424e::23feab1f38cd63f55631a1b5125ef1bd5ce049df::198494ce5323cafbf90a7b543d1b07355eb3db6c::ff893aa5574f5c422b72dd10b00eac805fc737e5::4295a7aea55be34c95a0624e95ea0b9587e644b6::f6be478b0aa0d48dbb9ed40f97f59a740214b7e5::fb8706ebd748e8b99e3d08a49da9fdc8e800806b::cef633ce63937eea37048fe07da2488fefb4ec7c::9dfa0c8d90177a12c3a3b1ac59c32727077d6803::
https://api.github.com/repos/bitcoin/bitcoin,8772,backports-0.13::0.13,0,merged,Backport::,"Bugfixes, QA, and copyright headers (checked that no old/removed code needed approval) One thing it's missing is removal of the qt4.6 depends package. Not sure if that should be backported or not. Current to master as of 1c24d5f637201b46a621f6e8e0247bc8bdc52f6a",c6a629100b4b2afa1ad0cf71ba7ef21908ceda02::733760a700ac97e59a3e3ae5565ba45616aa079e::3606b6b3a7fed177d8039f3b8f45eb0e48e9db92::a114a0208b2c01d85f413e48569edc4f5ec0951a::6b07362b375feab71f0d0d3ed00a5b16944f4d12::8e0338227979eb619da2dcacc505f4f229b67da0::091cdebfb823734559f9694c4c45eba1598b05ff::147003c73edb5a949ca403ecf8883c1b8bfaa6c1::8a7d7ffe650d719b0a0ab17d60607e4400dc5408::03b01966fa4b864c82a7543de0ed52a2c69ed38a::1f21d161a590d5f0aaf77ea01cd9d80c33be0a54::f70be14f8fe4fd72f77d57d05c6c4d4f1e28b7f9::69d1cd202d432bd6b8a6cda2187c148bcf1f6c2e::e111904a76774c9912189f29ad82ad3424905507::bea02dc3b664d77745f6701ba7c425b1f9f737cd::a7aa3ccc4f6a80bc23a8f7a419d72d0f1a33dfe1::8bb1efd9859726e992e4bf21de19f954d2bb2ab0::9b0097976f4e593103cdf4594eb68de9bf9d60b3::30eac2d79a05b4d7bcb708f59ff6b92c742c02f4::3b354d213f99b89a1baf9a2c5895f172e4b351c3::fc349288cbcfe3df20d91cc16149b973eb14e272::749c8a565532ee4480d8f3edd83ca08f437767a4::8b0bdd392317851b47bb62e90e1f6d28b47427ec::fa5b2498cac2c3c036ea89d07284aa5095ed1ced::156e305dc17b952dd869f76863d3ee70364c9234::4e5fc31ae69076224c58dbe41bbd62497510de7d::befe654f0f6a4384f25bd8af317ef95919a0ece9::a27cdd8edf9083dd38cdb39b4067286ea20e15ea::b17a3f9e5af0a97a4d744bcbdac11fcb19de546c::464dedd6ab496bb520cc8a5b1b69ca7ebdcdf815::305d8ac90b5c1301ec243024a5c68880f7a27ccc::75d548475dcf74fc0e69c4e5a4a6a0c213950cde::cb07f19e90951fc47604a12b500514ff08742c31::c493f436218b473e11eac3786222b53430ef592b::863ae74a1fdc11aec2e94167b30c1d7f7b6fd1e7::4f84082a74fcddda425344cb3444418856ea75e4::9556745dc2f3bda3a91be799fd4d92ba50ed3c95::c18a9ca7886ada5dfc43787631c578a32f7dc5bf::486650ae6a8ab44c0ac4f8a935b51629c04c1282::752fbae697db0a255999695e83d163f21d2ebc15::0a35573534ee81d98d7389a1fc8c6f1c5856f07e::ea51b0f5ddd705dd955eb5220253c6e325279609::42ea51a65fdacc9a0bf687474bc3839b854c726f::da94272e3c3f344660c274b41cbff2f402b5ae0c::0e2c6bdf78d5ddb374061f5b6b5c62a15ee53940::5e15fce30c7b406c1ace6f5f6df5c24b8050a8b6::d31ac725cfab15d086362124c3c18f5bcccebca7::e34374e252b2545eb510d26b752c5d00bba1f2f6::084cae9ca57a263d7b768b2854614bc9a2c26a28::9a903f9f003d743242d4ac41b4a4045559f1ff4c::ea2a6bef858049a5fc47a1f67bbfc8ab78d7348d::a60d7cc97d5f91b4157bdc8af0451f44149436fd::702fd2ee21c17bfbc56d2fe6d3fad982fb8412a0::b70b4a24e645e4602df310263390964ceda64a8f::
https://api.github.com/repos/bitcoin/bitcoin,8754,osx-protobuf-doc::master,0,merged,Docs::macOS::,"Homebrew now installs Protobuf version 3 by default, which doesn't currently compile. So we should recommend installing Protobuf 2.6.x from the versions tap instead. Should probably be backported to the 0.13 branch. Discussion in #8741",b16a7f609fdb2efa9a8a1b82f09748b95b5ae4f6::
https://api.github.com/repos/bitcoin/bitcoin,8739,fix-cb-test::master,0,merged,Tests::,"Apparently the way lambda's were being used in the first test done by p2p-compactblocks.py was busted, which was masking several bugs in the test. So I redid it a different way that seems to work correctly (I verified that passing in negated predicates causes test failure, which wasn't the case before), and fixed a few other bugs that came up: - sendcmpct messages need to be synchronized with RPC calls to generate() - headers must be synced in order for bitcoind to announce compact blocks - The last sendcmpct test omitted sending a sendcmpct message (so the test shouldn't have been passing as it was written). I think this should be tagged for backport.",157254a4bfdfc4ca3ad5bf2d84e82f290bd0c7f2::
https://api.github.com/repos/bitcoin/bitcoin,8504,2016_08_jexit::master,0,merged,Build system::Tests::,"There is a growing number of issues with it, and no one is really maintaining it anymore. From https://github.com/bitcoin/bitcoin/issues/4545#issuecomment-209938408: > Seems I'll just have to set a deadline: I'm going to remove use of the unmaintained java-based comparison framework after the 0.13 branch-off (projected  2016-07-06, see #7679). I hope the Python framework will be a full replacement by then, but as this is holding up progress in other areas, that will not affect the decision. @MarcoFalke worded it quite well too: > If they don't and no one knows how to fix, we can remove them right now. Because the only thing they'd be doing then, is slowing down travis. - The effort of porting the java comparison tool to Python is going very well, see e.g. #8141. If there is something left to do, I'm sure it can be resolved before the 0.14 release. - The test is blocking changes such as #7093 (Address mempool information leak and resource wasting attacks). - This test takes quite a while and is holding up enabling the tests for win32: #8227. -  [comparison tool support seems to have been dropped from the v0.14](https://github.com/bitcoinj/bitcoinj/commit/1eaf05cacf35ebdf8e716eb84f0d5d0c051b3398) release of bitcoinj (discovered @droark) This removes all the support for the tool, and removes it from depends (and hopefully all other references to it). Not to be backported to 0.13.",3c5251daeb29902b051502dd20030ce25aeccdf2::eb0c52ec1d3ffd4e2d78b2044c1c3d62de7711d3::
https://api.github.com/repos/bitcoin/bitcoin,8489,bugfix_gbt_sigops_presegwit::master,0,merged,Consensus::,"We are currently giving BIP141 sigop values in block templates even before BIP141 is active. This is broken in 0.13 and will need a backport. (although not sure it's worth delaying 0.13.0 over?) Includes RPC test improvements to catch the issue, which now pass with the fix.",160f895a80660e4e3904a2624e4110960d051902::239cbd2e5c2a36843b45b356e9aea6e8d35f0968::
https://api.github.com/repos/bitcoin/bitcoin,8412,0.13-consensus-bip112-flag::master,0,merged,Consensus::,"We added the segwit one, but we forgot CHECKSEQUENCEVERIFY. @laanwj this needs backport to 0.13, right? In fact, I'm thinking that this should have been included in 0.12.1... Ping @sipa @TheBlueMatt ~~Bikeshedding: I removed ""FLAGS_"" in this one and added ""_BIP112"" at the end instead because I believe it's more useful. I'm happy to change the name of the flag.~~ EDIT: Note that the bit positions have to correspond with those in the flags for scripts in script/interpreter.h.",d12b732ac287a1ed7543481b79801c9afc333b7f::
https://api.github.com/repos/bitcoin/bitcoin,8392,fixactivatewait::master,0,merged,Refactoring::,"Fixes #8117 There were several issues: - `InitBlockIndex` was still calling `ActivateBestChain` (intended so the genesis block would be activated), which caused the full chain activate to occur immediately (before the node was fully started and RPC was enabled). Remove this, as this is dealt with during the background import thread now. - Use a signal and a condition variable to make AppInit2 wait for the genesis block to activate, rather than a sleep-and-test loop (which needs the heavily contended cs_main at that point). - Introduce an extra init message after loading the banlist (which is confusing). - Do a block space check earlier. If accepted, I propose that the first commit is backported to 0.13. The second needs extra translation, unfortunately. I'm not familiar with this code so I may be wrong. However, it seems you are locking `cs_GenesisWait` waiting for `fHaveGenesis` to be true, while at the same time, the code responsible to make `fHaveGenesis` true at https://github.com/bitcoin/bitcoin/pull/8392/files#diff-c865a8939105e6350a50af02766291b7R521 need the same  `cs_GenesisWait` lock. Seems deadlock ? ::@NicolasDorier Waiting on a condition variable releases the lock temporarily. ::This line was only just added in May by Patrick! Is the loss of sensitivity to a shutdown request intentional? ::",0fd2a33648ccde4b989f1d69529daea4d88b14a2::aa59f2ed3f378c02159e41ff3ae2df76ef850577::9d4eb9ad99f7c3abf7abaeaf7ea51f98f9445e75::
https://api.github.com/repos/bitcoin/bitcoin,8373,biplist-determinism::master,0,merged,Build system::,I believe this is all that's necessary to fix the 0.13rc1 osx determinism issue. Obviously needs backport to 0.13 branch.,3b3ce25df6cc84cd1e75a7ec20fc7da8d2ef76e0::
https://api.github.com/repos/bitcoin/bitcoin,8366,2016/07/hd_minversion::0.13,0,merged,Backport::Wallet::,"0.13 backport of #8343 --- In current master, you could run a 0.13 HD wallet in a non HD compatible 0.12 client, resulting in a mix of HD and non HD key. You could even refill the wallets keypool running a 0.12 client and use it on 0.13 which would lead to a getnewaddress call in 0.13 responding a non HD address. This PR ensures that HD wallets will at least require version ~~0.12.99~~0.13. This only affects newly created wallets and only if the user had not passed -usehd=0 (old <0.13 created wallets will still run on <0.13 clients once they where opened in 0.13). ---",3b38a6a96a955d7b0192ece6ddcc7d750e155d81::
https://api.github.com/repos/bitcoin/bitcoin,8364,fix-mempool-sigops::master,0,closed,Mempool::,"The new ""bytespersigop"" limit introduced the side effect of making most multisig transactions non-standard. This fixes #8079 by accurately counting the sigops cost, solely for the newly introduced check. As alternative I see two options: - revert #7081 which introduced this bug - raise `DEFAULT_BYTES_PER_SIGOP` significally so that there is no longer a side effect This should be backported to earlier versions, and especially for 0.13, as soon as possible the path is clear.",7f66701020efbb6898278cf75e1e0712c78316a4::
https://api.github.com/repos/bitcoin/bitcoin,8328,0.12.99-consensus-rename::master,0,closed,Refactoring::,"It seems to me that version.h shouldn't be used by libconsensus, so I left that out. amount.cpp is not used by libconsensus (see #7820 ), also left out of the rename for now. Although pow.o and versionbits.o still depend on chain.o (dependent on storage) and can't be moved to the consensus package, they can be moved to the directory already, so they are moved. Although @laanwj believes that the best time to do this kind of refactoring would be right after forking 0.13, I believe that doing it right before has negligible risks and would simplify future backports of consensus code to the 0.13 branch.",1e1db2f26ca79a5b48b131a103f3a7b99dd49b85::c078fd157a094859b95a46750bae810a69bdf347::
https://api.github.com/repos/bitcoin/bitcoin,8305,fix-relay-2hr-rule::master,0,merged,P2P::,"I found a situation on testnet where a peer could send a header that wouldn't be accepted locally, because of the 2-hour-in-the-future rule.  This would then cause BIP-130 headers sync to fail, because the sender doesn't realize that the recipient didn't accept the header, and so continues to send headers (one-by-one) that build on top of the rejected header, until eventually the sender is disconnected. This PR tries to improve upon the situation: if the first header in a received headers message doesn't connect, try once to request connecting headers. If we get two headers messages in a row that don't connect, give up on trying to request connecting headers (to avoid infinite looping with the remote peer), until our peer delivers a headers message that does connect. If this approach is acceptable, I think we should backport to 0.12 (looks like it doesn't merge cleanly, but I can open a new PR for the backport). cc: @TheBlueMatt @sipa Print a log message here? ::Can you please stop ask basic programming questions? You can learn these things online, or on various other forums (including stackoverflow or chat channels) that don't require the developers of the project to waste their time teaching you. You're free to ask for rationale behind design decisions, but this is getting unreasonable. One last time: it's generally good style to use accessors instead of field variables directly. No, we don't do that everywhere yet. No, that doesn't mean we should continue that practice. No, that also doesn't mean we'll always complain when someone access the field directly. ::",96fa95361f68dd8169fa60e73290afae47445299::e91cf4b210db72ed020612a04b55e9715d8f9831::
https://api.github.com/repos/bitcoin/bitcoin,8284,build-oot-0.12::0.12,0,closed,Backport::Build system::,These are backported via cherry-pick from the branch by @theuni that was merged in #8133.  Only minor fixups were needed in two of the seven commits. 'make check' tests pass but so far this has only been tested on Ubuntu 16.04; we'll see what Travis has to say. You're missing the removal of leveldb here. This is unnecessary now that the files are enumerated in Makefile.leveldb.include ::,450cd57ea17c782d54999edb9049a64db995aaa1::b83755c9ac35ef5c6d747f71e65eebf4d1918b89::3718096965a4d23c1b3395ea99b477b7338c0afb::dcece24d9903c423f3ea998916a60545e069db32::927877171275f56532cdc75ad68f7fac783af35d::b835bd7d4dc95ad334c3b608fb052a7864ca89c2::91e14fbfa7f8e604c6017dccf3d4198409d8dd34::
https://api.github.com/repos/bitcoin/bitcoin,8270,master::master,0,merged,Build system::Scripts and tools::Tests::,"These changes should also be backported to the stable releases so that they build and test on systems which don't install python to /usr It also changes python scripts which are not related to tests because it was easier not to have grep discriminate. Couldn't this say `#!/usr/bin/env python`, since #7723? ::Yes, `security-check` works with python 3 too. The build system calls all these scripts by passing them to the python interpreter, so it doesn't care what is on the first line. ::I made no attempt to check for portability of the python scripts between python releases, just a straight s/// on all *.py files ::Can you remove the trailing 2's according to the pull request I linked above? ::There are 5 files using python2, only security-check.py and symbol-check.py (notably not test-security-check.py) have been changed in #7723. Accordingly I've changed only the same two files. contrib/devtools/security-check.py:#!/usr/bin/env python2 contrib/devtools/symbol-check.py:#!/usr/bin/env python2 contrib/devtools/test-security-check.py:#!/usr/bin/env python2 contrib/zmq/zmq_sub.py:#!/usr/bin/env python2 share/rpcuser/rpcuser.py:#!/usr/bin/env python2 I'm happy to abandon this PR in favour of incorporating the changes directly in #7723 if it simplifies things. ::Did we actually test that this works on python3? ::@petertodd See @laanwj's comment https://github.com/bitcoin/bitcoin/pull/8270#discussion_r68552510 ::",873e81f89b3197580aca3dd4a591d00e41696a89::7b01ce254cfa0e8ae7e57a72c57e8ae89f3c1829::
https://api.github.com/repos/bitcoin/bitcoin,8048,2016_05_doc_noqt4::master,0,merged,Docs::,"This text is aimed at users installing the binaries. Now that Qt5 is linked statically, there is no need to install Qt as a run-time dependency. Needs backport to 0.12.x. There is no `bin/32`? There are different tars for each arch? ::Yes, good catch, that needs updating too. ::",e5764e69cbd0bf4eb98c96eeb31c94349bbe7b7c::6075bc4d67bcd5f95561dc6d53b4fdbaf2c63f4b::
https://api.github.com/repos/bitcoin/bitcoin,8023,interruptible-thread::master,0,closed,Refactoring::,"The intention here is to create a drop-in replacement for: boost::thread boost::thread_group boost::condition_variable boost::this_thread These are just interruptible wrappers around the c++11 std:: versions. There are no dependencies, and afaik it's completely portable. This allows us to move away from boost threads (which block the movement of other things like mutexes, function, bind, chrono, etc), without having to worry about refactoring to cope with our dependence on interruption points, interruptible condition variables, and interruptible sleeps. For the places that don't require interruption, they can just move directly to std::. The code needs some refinements, comments, and more tests, but I'd like to get a few concept ack's before continuing. Obviously the next step is to start plugging it all in. Also, to avoid conflicting with segwit changes and backporting, it may be easier to replace things in some places and not others. The condition_variable is actually an implementation of condition_variable_any, which means that it will accept any Lockable. So we can mix and match boost::mutex/boost::unique_lock/std::mutex/std::unique_lock without any trouble, if that eases the migration. The loop spins after timeout. Should this test be `if (ret)`? ::yep! ::This needs to be at least `memory_order_acquire` so it happens before the notify. Locking the mutex is only an acquire operation and won't act as a suitable fence. ::Yep, thanks. This and the load should've both been marked for TODO, as I don't understand their interaction with the notify well enough. The orderings seem like pure voodoo :) ::Yeah, it's wild stuff. I don't really understand it either. The synchronization effects of `notify` on non-`condition_variable` values aren't specified, so I think we have to be conservative. One approach would be a release fence after the store and an acquire load operation. There may be marginally better-performing options on the store side, but this has the benefit that acquire/release pairs are relatively comprehensible. The load could technically be relaxed and the compiler still ""should"" make sure thread that's doing the loads sees the update ""in a reasonable amount of time"", but the compiler can hoist relaxed loads out of loops if it sees fit and who knows what's a reasonable amount of time to a compiler. Acquire and release are both cheap on x86 and anyway, interrupt points are going to be places that we expect time consuming operations to be happening, not in tight loops. ::I've been thinking about this... I think it was actually fine as is. The store and the notify don't need to be ordered relative to each other because the release of the lock at the exit of the scope is synchronized-with the acquire of the lock that `wait` must perform before returning. ::",483103590f42b609c266c54d439ddc71f0001a19::33dd6c85b92e1d09048329c31e70141fb0eef42c::bb31ffbda5e9fc4c5c854a51d72754b72ef63c50::383e087c48d11b88510a0fd563589a2b5a2e50bc::584cd8ce9723ba57c7cf4bcecd84c68c283b6dd5::64133202a7b927839bd706e6a957e8f43797f4b8::
https://api.github.com/repos/bitcoin/bitcoin,7938,Mf1604-012backp::0.12,0,merged,Backport::,"This includes the commits which were tagged with ""needs backport"".",90955940d5bbe037d512699c1bfca2689018daea::a9e73f71d4a622708a7f2f8b77e491adc74160e3::64fd0ce1d92f6dbd40f755edbbe8353a8ee3f353::1c3d38bde7be181a87c7c73e26c079e285a6fe96::66d54085598205de2182c04739cc418e2d15543c::21b2f82eb743757f2971ce2e1fc97e8a6171e5c7::52c101158f31a0112837488f46e4a4fc09735e4e::a5bc6a1bc4696ddda26a75f5ee1d6dc6817ca675::d3ead9bcb6d9c8dd59c299db914006d26382816d::5583a3d0a7ace48076a6675014172431b7356f22::7e71785c40a891c17a9ef912ef6007f0b83b3b2d::06c73a1751b346726f549c2780bc1b2a19035db9::43c14acf14ee191d946de070615bed93a0601dfa::c3d1bc33b598c19c6dab4de032953b770991098b::
https://api.github.com/repos/bitcoin/bitcoin,7935,gbt_bip9::master,0,merged,Mining::,"Versionbits was released in 0.12.1, but only included updates for the consensus layer. Due to the low-level design of GBT, it is currently not possible to use in practice, since the client has no way to identify the meaning of the block version anymore. Miners and pools can as a hack override/ignore the block version entirely, but this is not really a solution. This change adds the necessary versionbits information to GBT so that miners can implement it safely. It also detects when the client is outdated, but can still safely use the template as-is, and uses the GBT version/force and/or rules/force mutability flags to indicate that. This enables older miners that only support at least BIP 34 (block v2) to work with the newer bitcoind. Obviously this is a very short-term benefit in practice, since segwit necessarily will break such miners, but will become useful again as soon as the next simple softfork is deployed (in which case clients need only support segwit). - Corresponding BIP changes: bitcoin/bips#365 - Corresponding libblkmaker changes: bitcoin/libblkmaker#3 (0.4.x) and bitcoin/libblkmaker#4 (0.5.x) - Corresponding 0.12 backport: _TODO following review of this PR_ Tangential nit (just so I don't forget): DeploymentPos should become a strongly typed enum edit: ThresholdState too. ::Should I be iterating over them some other way? ::std::array here would be much nicer. Hooray for c++11! ::Aligning indices everywhere is a bit clunky, and will get worse with more deployments. Just return a `std::map<DeploymentPos,ThresholdState>` ? Then the caller can iterate cleanly. ::See below. I think returning a map would make this more clear. ::Whatever we're doing with C++11 in 0.13 doesn't help here, since this needs to be backported to 0.11 and 0.12. ::need to make sure this was found before get_int64()? ::Is a binary forced/not-forced enough? Taking segwit as an example, post-activation, what would `gbt_force = true mean`? should I expect ""segwit"" to be always forced and transactions filtered? Forced if an commitment isn't required and an error otherwise? Isn't this a per-block property? As gbt rules aren't necessarily static, I'm not sure that a simple flag makes sense. Or maybe I'm missing the bigger picture. Do you have that part coded up somewhere already, by chance? ::This is just an internal detail to bitcoind, so we can change it in the future if needed. See how rpc/mining applies it in this PR... ::Understood, I was just making the point that it's not really defining much so it's somewhat misleading. No problem making it more dynamic once that's required, though. ::NACK on this; this class will be needed inside abstracted consensus logic, which shouldn't do its own locking. VersionBitsCache is intended to be a black box data type locked by the user (main, in this case) but only accessed through functions in versionbits.cpp. ::Bike-shedding: Can you call this var consensusParams for consistency with other parts of the code? ::For deployments where `gbt_force == False`, we should clear the bit if the client hasn't signaled support, to prevent activation of proposed soft forks that require software changes downstream. ::Redid this logic (finding and fixing a few more bugs in the process) - how's it look now? ::Does this need to be with the consensus code? Couldn't it be moved to miner.o or somewhere else? ::Possibly. @sdaftuar was thinking maybe we should move the bit assignments here, however... ::I mean, I would say the only reason for not having versionbits.o in the consensus package already is because it still depends on chain.o (which is storage-dependent). ::more than a small formatting nit here :) ::LOL, how did that happen? >_< ::VersionBitsDeploymentInfo ::",d3df40e51a29bd98830043dd19829126390d1bc4::72cd6b20cae3d1eda2f917f1608a8ae7f1e606f7::98790608a43e60b8025346034d28ff1f58cebab0::12c708a4b3a799478fbb3f93fda696706177a824::
https://api.github.com/repos/bitcoin/bitcoin,7919,fix-sendheaders-edge-case::master,0,merged,P2P::,"Previously we would assert that if every block in `vBlockHashesToAnnounce` is in `chainActive`, then the blocks to be announced must connect.  However, there are edge cases where this assumption could be violated (eg using invalidateblock / reconsiderblock), so just check for this case and revert to inv-announcement instead. FYI I encountered this bug once while running `mempool_packages.py`, and was able to reproduce reliably by repeatedly invoking `invalidateblock`/`reconsiderblock` on the tip. Perhaps we should backport this to 0.12 as well?",3a99fb2cb14955f5e029d315041a093e957e6c3e::
https://api.github.com/repos/bitcoin/bitcoin,7835,CSV-relay-after-softfork::master,0,merged,Validation::,"Before activation, such transactions might not be reliably mined, so don't allow into the mempool. Please tag for backport to 0.12.1 Can you move this to the top of the function (other parts of the function before this also call Params() and could use the variable in the future)? ::Nothing above in this function calls Params(); I guess I didn't check the functions called from here to see if they call Params(), but can we please fix that later when we change those functions?  This has many ACKs now and is holding up 0.12.1. ::@sdaftuar I agree, it's not important for this pull. ::Sorry, I was in another branch, You are right for master. If you need to change the code for any other reason, I would appreciate moving this line too though. ::",e4ba9f6b0402cf7a2ad0d74f617c434a26c6e124::5cb1d8a2071d05beb9907a423178895fd8a5c359::da5fdbb3a2778523cce70d635c1aa2b31a693bc6::
https://api.github.com/repos/bitcoin/bitcoin,7741,alert0::0.12,0,merged,,Set `-alert=0` by default. This feature is removed entirely as of 0.13.0 Please backport to 0.11 I still think this section goes up to where it says ``` md Example item --------------------------------------- ``` (The space down here is reserved for pull numbers?) ::fixed ::,c0fe2c9e0301f9b046b51fd78bb89ed8f6946eb8::
https://api.github.com/repos/bitcoin/bitcoin,7658,curl::master,0,merged,Build system::,curl is required to fetch dependencies requires backport to all branches [ci skip],ce41cf082c861cc8d333b811b3101d52d06f50ec::
https://api.github.com/repos/bitcoin/bitcoin,7619,gitian-sudo::master,0,merged,Build system::,Missing sudo entry in gitian setup results in unwanted password prompt. See the discussion [here](https://botbot.me/freenode/bitcoin-core-dev/2016-02-18/?msg=60419903&page=3). Probably should backport to `0.12`. [ci skip],f41927e2c033ab5044b203bda8ddfbc747e61526::
https://api.github.com/repos/bitcoin/bitcoin,7617,Mf1602-trivial9::master,0,merged,Docs::,"- Fix three minor issues in the 0.12 historical release notes. - Fix some links - Yet another  #6497 Oops, yes, this was a backport ::Are you sure this is correct? I think this was supposed to be un-terminated, because other message-related commands continue the logging. ::I remember I saw at least one instance which was wrong but I can't recall which one as I have deleted the `debug.log` in the meantime. I have reverted for now and will look into this later. ::",fa06ce09498707d5e82633f1e1b034675e552628::fa97f95c15a7aee15feea500571a10a90f22ea8b::fa266524592cc18c789cc587d738fb0e548fd23a::
https://api.github.com/repos/bitcoin/bitcoin,7529,bugfix_descendantfees::master,0,closed,RPC/REST/ZMQ::,"#7062 changed the meaning of ""descendantfees"" without changing the name. ~~""descendantfees"" with the previous (and expected) meaning is about to be released in 0.12, so this will  be a regression in 0.13.~~ ~~If #7062 is indeed a relevant fix, it should be backported to 0.12, but~~ either way IMO this needs to be renamed to convey what it actually is (~~if~~ #7062 is backported, this should be as well).",ab1d1cbbcaf719f6f4d7aff1dbdfe80ec1305ea8::da1ab6abaf74ec5de386ef5e4483102d72aed9c6::
https://api.github.com/repos/bitcoin/bitcoin,7482,fix-download-timeouts::master,0,merged,P2P::,"This should be backported to 0.12. Now that we're using headers announcements for new blocks, this makes sure that nQueuedValidatedHeaders is properly decremented when a peer disconnects.",301bc7bc7e83f4c268c1722558b07dbb5b55fa92::
https://api.github.com/repos/bitcoin/bitcoin,7381,Mf1601-walletdbKeyparserFix::master,0,merged,Bug::Wallet::,"This needs backport to all versions of bitcoin/altcoins after merge. A dump may look like: ``` VERSION=3 format=bytevalue database=main type=btree db_pagesize=4096 HEADER=END <{Data}> DATA=END ``` So the current parser gives us odd data like: `keyHex=""DATA=END"";` `valueHex="""";` (sometimes the other way round) Where does this value come from? If from berkeleydb itself: Is it documented, or available as some kind of constant? ::`db_dump ~/.bitcoin/regtest/wallet.dat` https://docs.oracle.com/cd/E17275_01/html/api_reference/C/db_dump.html http://web.deu.edu.tr/doc/berkeley/berkeleyDB/ref/dumpload/format.html ::We could probably make it a constant for our sakes anyway. ::",fa6d4cc09575de30386bfbc5c8c3858cd7a2f42a::
https://api.github.com/repos/bitcoin/bitcoin,7373,fix-blockchain-py::master,0,merged,Tests::,"`blockchain.py` is failing on master and 0.12, due to a subtle merge conflict when #7194 was merged. @laanwj Needs backport",4a0487937877484f14476716c3643de7a31c32da::
https://api.github.com/repos/bitcoin/bitcoin,7368,fix-package-test::master,0,merged,Tests::,"I noticed intermittent failures in the `mempool_packages.py` RPC test; turns out I introduced a race condition in a recent pull (#7062). Before this change, node1 could either be in sync or out of sync with node0 after `invalidateblock` was called, depending on how fast that happened.  The test would fail if they were out of sync.  This fixes the test by enforcing that their tips stay synced up. @laanwj Note that this bug is in 0.12, in case you think this should be backported or included in the next 0.12 release candidate.",4d10d2e16fb837abe304e0a5d3bc0a41941d917a::
https://api.github.com/repos/bitcoin/bitcoin,7351,patch-1::master,0,closed,Build system::,"Please tag with [backport] for `0.12`, `0.11` & `0.10`",d6854f4e8021e0c5528350e9c06efe8d15544b23::
https://api.github.com/repos/bitcoin/bitcoin,7342,gitian-quickfix::master,0,merged,Build system::,"It is unneeded after the last toolchain update, and missing from Trusty. This is required for attaching the rc1 signature. Obviously needs a (non-conflicted) backport to 0.12.",3503a78670d0eacf39c618b45b08581dfb3ed68f::
https://api.github.com/repos/bitcoin/bitcoin,7319,2016/01/bp_qtintrodatadirsize::0.12,0,merged,GUI::,I think a backport of #7298 for 0.12 should not harm and it's relatively risk-free. IMO it's a bugfix because enabling `-prune` should not tell users that 20GB free space is required.,b1a8374aaa82e08de8ac9353e76be3cdf43cd3d5::
https://api.github.com/repos/bitcoin/bitcoin,7309,Mf1601-releaseNotes0.12::0.12,0,merged,Docs::,"- Transaction memory pool limiting - Priority transactions - Wallet transaction fees This would require e420a1b (#7296) ::Related to  #7084 ::This would require 995b9f3 (part of #7296 and imo a mandatory backport for 0.12) ::s/massive amounts of/a large number of ::Should priority transactions be in quotes as well? ::s/was/has been ::s/impromements were/improvements have been made to ::I think this is the ""official"" term. ::Thx! ::its ::",fabba1c1a4f2dd1cf96f4787f2d154482c29daa7::fa4ba40d8cc4c496a6a1d11803d58076034d5ce5::fa0a391b35eacb01678eedbf489a457da90435d4::fab88af4d5d2f74dba3d1b7082de89b2cf1b4a6b::
https://api.github.com/repos/bitcoin/bitcoin,7298,Mf1601-qtDataDir::master,0,merged,GUI::,"Required space depends on the user's choice: `-prune=0` `-prune=<n>` It would be nice of the required disk space would be bold. Would something like `setText(ui->sizeWarningLabel->text().arg(QString(""<strong>%1</strong>"").arg(requiredSpace))` work? ::Shouldn't  we check for `if (pruneTarget < MIN_DISK_SPACE_FOR_BLOCK_FILES)` or something like `std::min(MIN_DISK_SPACE_FOR_BLOCK_FILES, pruneTarget)`? ::I don't see a valid reason to use `-prune=1000000` etc. A warning might be appropriate but clearly it should not be silently ignored, so the user does not even notice. ::> I don't see a valid reason to use -prune=1000000 etc. A warning might be appropriate but clearly it should not be silently ignored, so the user does not even notice. Right. But `-prune=1` should fall back to `MIN_DISK_SPACE_FOR_BLOCK_FILES` (currently 550MB). Otherwise  i guess  you calculate the wrong min space requirement? ::I can't test right now but `-prune=1` and `-prune=550` should display the same required space. (3 GB) ::`-prune=1` will fail anyway (after you click OK) but I didn't plan to fix this within this pull ::> I can't test right now but -prune=1 and -prune=550 should display the same required space. (3 GB) Right. But what if we change the constants. `-prune=1` only results in 3GB because you use `std::ceil` and a chainstate size of 2GB. I just think the require space should be calculated with respecting the MIN_DISK_SPACE_FOR_BLOCK_FILES, otherwise we give wrong promises to the users (even if it fails afterwards). ::Works, but GB is not bold: ![screenshot from 2016-01-06 18-03-22](https://cloud.githubusercontent.com/assets/6399679/12148659/fc4f4650-b49f-11e5-8c52-254828561e13.png) ::Could/should we take the `GB` out of the translation string and place it in the source code directly? ::Makes sense. What about merging this as is and then backport to 0.12, so translators don't have to go through all translations to update two chars. Afterward, we can apply your proposed changes to this in 0.13 and maybe additionally add another sentence to the translation which tells that pruning is enabled? ::",faf3299b73ccb5044b7eaced229ac0c904aa25f5::
https://api.github.com/repos/bitcoin/bitcoin,7103,FixSettxfee::master,0,merged,Bug::Wallet::,"This comes without the GUI changes, so it should be easier to review and backport. GUI: #7096 Does removing the extra zeroes here make any difference? ::hmm.. is forming a byte arrayreally necessary? Would `len(hex_string)/2` not be sufficient? ::I considered that nit, but right now it checks it is a valid hex string, which is kind of useful for a test ::``` >>> Decimal(""0.100"") == Decimal("".1"") True ``` But the diff is larger. So removed this. ::",4b89f01d727433f02cc8ff72799e0d0a7e6ceafe::fa506c0c9b3928843704c666909c0b0c5af2f9a0::
https://api.github.com/repos/bitcoin/bitcoin,6975,note-0.11.2-orig-prs::0.11,0,merged,Docs::,"As mentioned in https://github.com/bitcoin/bitcoin/pull/6968#issuecomment-154931904, my PR adding the first-draft nodes referenced the backport PR numbers rather than the original PRs where all the discussion occurred.  This commit corrects that. I did leave in the backport commit ids, which I thought might make it easier for anyone running `git log v0.11.1..v0.11.2rc1` .  However, I can also update those to the commits on master if desired. If this looks good, I'll also port it to the 0.10.4 notes.",ab6ff126e2e577b9f0f0f55415942c11a99ac167::
https://api.github.com/repos/bitcoin/bitcoin,6970,2015_11_rpc_validateaddress_crash::master,0,merged,Bug::RPC/REST/ZMQ::,Fix a null pointer dereference in validateaddress with -disablewallet. Also add a regression testcase. Problem reported here: https://github.com/bitcoin/bitcoin/issues/6963#issuecomment-154548880 I think this needs to be backported to 0.11 as well.,2980a18572dbe6173c41afc037b0cefe367d935c::
https://api.github.com/repos/bitcoin/bitcoin,6919,2015_10_backport_chainstate_obfuscation::0.11,0,closed,,"This is a direct backport of #6650 and its follow-up, #6777 and #6865",11d88c2ca2b14966b3e71e5810add25893a1a216::a8d781f863c0776eac58cee19ef09d8307ae183c::ba03d14234d0e41154fac924340cc6256e2986a9::775d01d4e1ad43331e773dd9ddb1cea592a7826d::8b7354bf2c946e022aab6453d3a41f49d2eb4b99::8d043126ca8d68899ecf7b3613ebe4c37c363944::
https://api.github.com/repos/bitcoin/bitcoin,6883,cltv-release-notes-v0.12.0::master,0,merged,Docs::,"@luke-jr Would you please advise on what the release notes should say re: libblkmaker? Should we mention something about SPV clients here? ::Given the BIP mentions it, I don't think we need to here. ::Wouldn't it be sufficient to just use libblkmaker >= 0.5.1? Remove the ""FIXME""? ::Sure, but if Luke-Jr is going to release a backport, I'd like to know! ::",c939792baaaa5f34ee4079b871d56054e36fb26b::
https://api.github.com/repos/bitcoin/bitcoin,6856,noPruneDuringReindex::master,0,merged,Block storage::,"It's not safe to prune during a reindex, as there may be blocks in earlier files that have not yet been processed if they were out of order.  Those files could be accidentally deleted. Since undo files are regenerated during reindex, this allocation of disk space could cause pruning to be triggered. @laanwj I thought I was just adding a belt and suspenders check here, but turns out it can and will happen.  This should be backported to 0.11. Also, clarify startup message that an initial pruning of the block store doesn't happen if reindexing.",d3b09f6bac738958b6bf5711bcb5291049b7466d::
https://api.github.com/repos/bitcoin/bitcoin,6841,fixPruningRPC::master,0,merged,Tests::,This broke when we raised the min relay rate.  This should probably be backported to 0.11. Fixes #6834.,b6d5e32e0e5b038c6ff7e2ab5221b10727722341::
https://api.github.com/repos/bitcoin/bitcoin,6797,patch-13::0.10,0,closed,,This is a backport of #6545 for 0.10.,40bd04fac219d4056898bfe98ff3cc5375b3c587::
https://api.github.com/repos/bitcoin/bitcoin,6795,2015_10_disable_upnp_default::master,0,merged,P2P::,"Common sentiment is that the miniupnpc codebase likely contains further vulnerabilities (context: #6789). I'd prefer to get rid of the dependency completely, but a compromise for now is to at least disable it by default, to prevent UPnP vulnerabilities being a structural danger to the network. ~~Also get rid of the confusing `--[enable|disable]-upnp-default`autoconf and define magic.~~ Edit: needs backport to 0.11 and 0.10",21d27ebad5721bc61c62bc72dc3ab3197f9da268::
https://api.github.com/repos/bitcoin/bitcoin,6793,2015_10_bump_minrelaytxfee::master,0,merged,TX fees and policy::,"Bump minrelaytxfee default to bridge the time until a dynamic method for determining this fee is merged. This is especially aimed at the stable releases (0.10, 0.11) because full mempool limiting, as will be in 0.12, is too invasive and risky to backport. The specific value (currently 0.00005) is open for discussion. Ping @gmaxwell @morcos Context: https://github.com/bitcoin/bitcoin/blob/v0.11.0/doc/release-notes.md#transaction-flooding",28e3249e53b8ef7516636df0f1406466a513095d::4e2efb3c5fde4b1e332cc032e3dc4082ec4e3cac::
https://api.github.com/repos/bitcoin/bitcoin,6789,2015_10_mitigate_upnp_buffer_overflow::master,0,merged,Build system::,This version of miniupnpc fixes a buffer overflow in the XML (ugh) parser during initial network discovery. http://talosintel.com/reports/TALOS-2015-0035/ The commit fixing the vulnerability is: https://github.com/miniupnp/miniupnp/commit/79cca974a4c2ab1199786732a67ff6d898051b78 Reported by timothy on IRC. Needs backport to 0.10 and 0.11. Edit: complete diff between current version miniupnp 1.9.20150730 and 1.9.20151008 : https://gist.github.com/laanwj/6caebd77a1c253a486e4,0cca0248f030ea32bd8de778b5a2782e0d191978::
https://api.github.com/repos/bitcoin/bitcoin,6785,already_have_0.11::0.11,0,merged,P2P::,Fills a gap in recent reject tracking (backport #6750). This is #6588 in master.,36f14bf2e770220a3878da45722352553eb665cc::
https://api.github.com/repos/bitcoin/bitcoin,6707,cltv-soft-fork-v0.11::0.11,0,merged,Consensus::,"Everything required to backport CLTV to v0.11, including the soft-fork itself.",684636ba67c3eba145a0af8890ed9a7a15deb60a::6ec08db33805ba5688917e6da73cf19cdb64721e::4fa7a048d1cc2309b64a58fdf4ecb593058d5ed6::6ea5ca4b4e067cac3ad8de2027266bc62a8cb106::5e82e1c8f534f8685fb72a34e47c3beb36738783::c5a27f4fb392fd6444d92ecbb78658516c91a6f2::70a427b2b5b68f64e8a3b5266d40f8a636c20f3e::ba1da90b33fbab2565cbdbcc6a0895aa94f65cf4::6af25b0f64cb67ba7db04dd49383f7aed42def1a::
https://api.github.com/repos/bitcoin/bitcoin,6706,cltv-soft-fork-v0.10::0.10,0,merged,Consensus::,"Everything required to backport CLTV to v0.10, including the soft-fork itself.",689746841afd0f2076a7d93d30974c2f7d29cd83::750d54f9510d784c2a502089754241986fb1338a::6d0132520c6944a2f9f0d571e88d7fd57f805c38::0e01d0f89d4f24eac7c8a21a6779e7956ad13a87::41372485ce2ebd172ba067d401f24259b014fad5::6a1343b47010362e48a36a05227e8b3ddb70ebdf::5dc72f8bb0bf5447227aaf5da5fc6e0969e96bdb::
https://api.github.com/repos/bitcoin/bitcoin,6704,backport-bugfixes-to-0.10-20150920::0.10,0,merged,Bug::,"dependancies, huh :-) This is just a backport, but I wonder why the other word spelling wasn't fixed. ::",8b59079b8d7eda6f44988649d9c716fec3aad397::04507de3b7af34c2fcb1b90f405b2e8a9c35ebe9::3861f0fa21c5ecb39e0b89377bf55e7bd5a387ef::4e5ea71bd513ba1a5d19afbdfb545ed36560c546::843469ee15be64070eaf01c34b4590185be18db3::28d76d2aea6508e26def7e59a6ff006d0cad6b86::65426acb4dfdbcda03337cb68e8fa8854bc76e17::bdf2542787314bce0c5cc39f03df0a0b27eb31cb::0194bddde48cffe21d8ed57777e576e9187e2cbe::c9ad65e5fafc47ea74399e8057e445e0e0435101::0dfcdd41ebf82aa409ec203deeabc900d996c413::2ede6b7142cb57c422126722f845b36da7d3c4ef::ceba0f8c7e0b62c16c15ec507da721be6e2c7dee::5e6d8936505da29d60b88eed7fd9aa6abdae5d92::
https://api.github.com/repos/bitcoin/bitcoin,6618,fee_estimate_patch::master,0,closed,TX fees and policy::,"Fee estimation uses a threshold for the fraction of recent transactions of a given fee rate that must have been confirmed within the target number of blocks in order for that fee rate to be considered high enough such that a new transaction with that fee rate will be likely to be confirmed within the target. This patch changes the threshold to 95% (from 85%) for all targets other than 1 block. 85% was previously used because higher thresholds were too hard to meet for a target of 1. However the recent stress test has shown that 85% is not conservative enough, so a target of 1 is special cased and a higher threshold is used. This is a simple change that is meant to be backported to 0.11. Further improvements for fee estimation will hopefully be possible for 0.12. EDIT:  Please note that this will in general cause higher fee estimates to be returned.",b10b2a18085372a3fc6d7aca86aef120d8be4f9d::f84fd7d5844038c879a6ae80736ee1be0b0bc47c::
https://api.github.com/repos/bitcoin/bitcoin,6571,openssl-consensus-threads::master,0,merged,Bug::Utils/log/libs::,"tl;dr: EC_KEY_new_by_curve_name() affects global state in some versions/configs of openssl, leading to crashes when called by multiple threads. Avoid the issue by only calling it once at startup and caching the resulting group. This is likely unnecessary for master with libsecp256k1-verification landing soon, but I think it makes sense for backports. This is a real-world issue for libbitcoinconsensus as reported by Tamas Blummer here: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2015-August/010219.html When calling EC_KEY_new_by_curve_name(), openssl internally checks to see how to setup the curve's EC_METHOD (simple, montgomery, or nist). Unfortunately, in all released OpenSSL versions (as far as I can tell master is the only branch that has fixed this issue), it's tested like so: - Try a method. If it fails, set a global error and return. - If the global error is set, try a different method. Prior to OpenSSL 1.0.0, these were tested in the order: EC_GFp_nist_method -> EC_GFp_mont_method. The secp256k1 curve fails the ec_GFp_nist_group_set_curve test and sets the global error. That error is then checked for failure, and EC_GFp_mont_method is tried (and succeeds). Obviously that global error usage is dangerous, especially since it happens for _each_ transaction verification in libbitcoinconsensus. In a multi-threaded environment, a crash is guaranteed within a few seconds. However, OpenSSL 1.0.1 reversed the order, trying EC_GFp_mont_method first, so that the global error doesn't end up being used: https://github.com/openssl/openssl/commit/17674bfdf75bffa4e225f8328b9d42cb74504005 This was backported from master back to 1.0.1, but not to 1.0.0 or 0.9.8. So that change (accidentally) ""solved"" the problem. As you can see, it's still possible to hit the reversed order in the !defined(OPENSSL_BN_ASM_MONT) case. That's easily tested by building OpenSSL with the -no-asm config option. It's probably also the case for obscure architectures and OSs, but I haven't looked deeply into that. In that case, it's reasonable to assume that this crash would likely occur on such platforms. Also, OSX, even the latest version (10.10 as of now), still ships with OpenSSL 0.9.8. Which is how Tamas ran into it. Is it ok that this static initialization happens before 'official' OpenSSL initialization, even before main()? What will happen if secp256k1 is not built into OpenSSL? I don't think it will reach the sanity check anymore. ::",1d1073c2d3231a9de4adbc2bc46846fc20b34f9e::
https://api.github.com/repos/bitcoin/bitcoin,6470,surplusTrim::master,0,closed,Mempool::,"@sipa @sdaftuar @jtimon @petertodd OK, this is the best combination of approaches I could put together. I took #6455 and I removed the floating relay fee commit.  I really like that idea, but it needs to be much slower acting I think and not subject to potential abuse.  That can be a later improvement. I added 3 things: - Reserved space between the soft cap and hard cap.  The soft cap is currently set to 70% of the hard cap.  Once the soft cap is hit, you first try to evict as in 6455, but if you fail, you have another chance to get in if you are still under the hard cap.  There are 10 ""rate zones"" between the hard cap and soft cap and the effective minRelayRate to get into the mempool doubles for each additional zone. - Any required minRelayFee for your transaction alone is considered inside the StageTrimToSize loop. - Periodically (once a second) we use the knowledge that surplus fees over the minRelayRate must have been paid if the size of the mempool is over the soft cap.  We use these fees in aggregate to try to trim from the bottom of the mempool.  This allows us to aggregate many small high fee transactions to evict a low paying large transaction or long chain. The reject rates in my test setup have dropped to 0.3% for 30k feerate tx's and 0.05% for 60k feerate tx's. (See other results in #6455). I made an attempt to tweak the looping parameters in StageTrimToSize to something that I think made sense, but with the contrived test setup, and only one set of simulation data, they are probably best evaluated on the basis of intuition and not relying entirely on the resulting rejection rates. It turns out the slowest part of StageTrimToSize was GetRand() by a long shot, so I hacked it out, but I'm sure @sipa will want to replace my hack with something nicer. The code works as is, but could still use some work, but I think its time to get more eyes on this suggestion for a plan forward. Can't `- GetArg(""-mempoolexpiry"", DEFAULT_MEMPOOL_EXPIRY) * 60 * 60` be inside pool.Expire?, it may become an attribute of the txmempool in the future or something. ::s/mempool/pool don't use the global when you have the parameter ::Can't all this code around pool.addUnchecked be moved to a new mempool method that internally calls pool.addUnchecked ? You could go further. stagedelete and nFeesDeleted could just be ctxmempool attributes so that you don't need to pass it to pool.RemoveStagedAndAddUnchecked (or whatever you want to call the method) and pool.StageTrimToSize (or whatever you want to call the method) ::Can't all this new code be part of  mempool.StageTrimToSize ? In fact, I would go further and take anything that depends on nFeesDeleted to txmempool as well (including `csFreeLimiter` `GetBoolArg(""-relaypriority"", true)` and `GetMinRelayFee`). I would also move https://github.com/bitcoin/bitcoin/blob/master/src/main.cpp#L785 there and have all mempool-replacement-related things in one place: txmempool. We could also move some things directly to policy/fees but I'm not going to ask for that much. I'm sorry but I won't push my nits as branches with fixup! commits anymore on this subject. I guess I'll have to wait the ages that will take to move the code later and accept that nobody else but me cares about  the movement being better-than-free right now. I won't miss the chance to beg you though. Please, try some of my movement suggestions and if takes you too long to adapt the parameter too recompile or you don't like what my suggestions are doing to the number of parameters in pool.StageTrimToSize just stop it. And I guess I can just add/maintain all those things in my tomove list. It seems I'm the only one that doesn't love the fact that most of our changes conflict with each other in main.cpp. But I understand, moving things out of main so that things don't need to conflict and don't need to be prioritized is not a priority. @sipa I must be getting something wrong or I've been communicating poorly around this. Maybe code doesn't talk as much as I thought after all. ::I would prefer not doing that, and keeping CTxMempool as much as possible a dumb data structure - the decisions about what happens to it (policy?) should stay out of it, IMHO. EDIT: We're already failing at that pretty badly anyway, it seems, with the feerate index and the trim code inside CTxMempool. Too bad, but disregard this comment. ::@jtimon Let's first find a solution to the problem at hand. Code movement that goes into the master branch conflicts with everything, so complicates changes that we want in backports too. ::Agree. ::Storing attributes inside CTxMempool just to avoid passing them around seems ugly. It would be incompatible with some multithreaded modifications, for example. A cleaner way to do this is having a separate TxMempoolStagedChange class for example that is calculated from an add/delete, kept by AcceptToMemoryPool during validation, and finally applied to the mempool or thrown away. ::Please use { } around the then block. ::This comment is technically no longer true since the majority of transactions are being skipped. Maybe the code should be removed altogether now, or does it still offer a benefit? In any case, the comment needs addressing. ::Comment should say 10, not 32 - or just refer to the failmax variable. ::Agree the comment needs changing, but the check is still valuable.  No reason to continue checking further transactions at this point, even if we haven't used up all of our fails. ::@morcos If this method call returns false, do we need to wipe stagedelete/nFeesDeleted, or are they guaranteed to be empty/zero? ::@sipa   Neither is the answer.  Perhaps it needs commenting though.  If the transaction is accepted into the reserve space and stagedelete is non-empty then it is both safe and desirable to evict any transactions that were staged.   If the transaction is not accepted into the reserve space, then as before we return failure from ATMP before we have a chance to evict anything. The one slight caveat is in the case where you pass entry into the reserve space, but then you fail the rate limiter code directly below it.  In that case, it probably wasn't very fair that your feesDeleted were causing you to be counted as a free transaction.  It's overly conservative and rare behavior though.  I was planning on suggesting a fix but I wanted to see if there were any thoughts on the free relay code remaining in place here before I complicated it.  The suggested fix is that if the transaction is entering the mempool via the reserve space, and then it fails the rate limiter code, you let it in anyway but just wipe stagedelete.  Note that if stagedelete were empty then the tx by definition wouldn't have been subject to the rate limit test because it has a multiple of the minRelayFee. ::ACK, understood. That seems fine, but could probably use a comment. ::Do you mind turning these into arguments, that get passed from the 2 callsites instead? ::No objection to changing, but just want to understand what the style request is related to this.   All then blocks should have braces or only because the else block is multi-line?  A single-line then block without braces appears as example code in developer-notes.md. ::Oh, I thought we changed that. Never mind then. I personally dislike those, as they easily lead to mistakes when merging different patches (see the OSX SSL bug that was likely the result of it), but I shouldn't ask that as long as our notes use it. ::The fact is that braces are not necessary in our clang style. And btw, when they're used, the shouldn't be in the next line but in the same line as the if/for/while. I'm happy changing the style, but that's in clang-format. ::It is just as easy to move things from txmempool to the policy dir than it is from main (if not easier, given that main is always the part with more development conflicts [unrelated things in theory conflict in code there]). But whatever, I guess it will be a new global in main... ::With or without attributes, this code could be just a single-line call to a method in the pool (for example, a modified version of addUnchecked): ``` +        // Delete staged transactions to actually make space in mempool +        if (!stagedelete.empty()) { +            LogPrint(""mempool"", ""Removing %u transactions (%d fees) from the mempool to make space for %s\n"", stagedelete.size(), nFeesDeleted, tx.GetHash().ToString()); +            pool.RemoveStaged(stagedelete); +        } + // Store transaction in memory pool.addUnchecked(hash, entry, !IsInitialBlockDownload()); + +        // Try to use excess relay fees paid by txs above the soft cap to trim in aggregate +        int64_t timeNow = GetTime(); +        size_t curUsage = pool.DynamicMemoryUsage(); +        size_t trimGoal = 1000000; //Try to trim up to 1MB worth of transactions at a time +        if (curUsage > softcap + trimGoal && timeNow > lastSurplusTrimTime) { +            // Require at least 1M at highest fee rate we'll try to trim at, and try to trim 1MB +            lastSurplusTrimTime = timeNow; +            int rateZone = (curUsage - softcap - trimGoal)/capstep + 1; +            int rateMultForTrim = 1 << rateZone; +            std::set<uint256> stageTrimDelete; +            if (pool.SurplusTrim(rateMultForTrim-1, minRelayTxFee, trimGoal, stageTrimDelete)) { +                size_t oldUsage = curUsage; +                size_t txsToDelete = stageTrimDelete.size(); +                pool.RemoveStaged(stageTrimDelete); +                curUsage = pool.DynamicMemoryUsage(); +                LogPrint(""mempool"", ""Removing %u transactions (%ld total usage) using periodic trim from reserve size\n"", txsToDelete, oldUsage - curUsage); +            } +        } ``` ::Ok, moving existing code is one thing. But putting new code in txmempool instead of main doesn't make things harder to backport. It feels like I'm always trying to control main.cpp's diet, but when I look somewhere else everybody gives him candy in high quantity. If we keep doing this, main.cpp is always going to be fat no matter how many things I move out of it. ::",bb93e2cb5dfbcfa5e20c9771f9638364775d8357::9dc4e7051c2d4e6569f90d9c7e047fb7f0d60d9c::04cf4baeae0a187cffb771ceb4eac78a4bcdfdb0::dac64967038944b4f041b1fa1b7240e8cd098146::9297953cde2c7a53645acdba7b2994427243f37c::988131646665654d7758b48dafe5b6ad39745134::2dd1b4ddd9333d5d247f720dfc2cf7bf905fca35::40c38f895838651aba327c63db277f2924d4d3d9::6e8d3dd36cc82921f312458e17168788016ceee2::
https://api.github.com/repos/bitcoin/bitcoin,6439,patch-1::master,0,merged,Build system::,"Since Debian 8 was released, this download moved to the archive. This patch should be backported to other branches too.",09d4ddf1c5841b757c2676d508a68baa2dbdc4c7::
https://api.github.com/repos/bitcoin/bitcoin,6354,gitian-winsign-normalize::master,0,merged,Build system::,"Sorry for yet another PR here. This one includes @michagogo's suggestions and doc changes. It replaces #6343 and #6342. Teach gitian to output a _-win-unsigned.tar.gz similar to OSX. The signer will attempt to combine any ""_-unsigned.exe"" with a matching ""*-unsigned.exe.pem"" from the detatched signature repo. Also note that the new target signature dir for windows has changed from ""${VERSION}-win"" to ""${VERSION}-win-unsigned"". Tested with a phony tag and signature. Safe for backport, should be good to go for rc3.",a3ba9a553acefd567ccb304b8600d2149ffab9aa::6e849b8309558ec83710d86c0f784566996da58b::
https://api.github.com/repos/bitcoin/bitcoin,6351,cltv-is-super-majority-soft-fork::master,0,merged,Validation::,"Final step towards CLTV deployment on mainnet. I've copied the logic and tests from the previous BIP66 (DERSIG) soft-fork line-by-line for ease of review; any code review applicable to BIP66 should be applicable to BIP65. Once merged I'll prepare a backport of the soft-fork logic for the v0.10.x branch as well. Line 70 should be: Failed to mine a version=4 block ::In order to fill out the test for this ""not enforced"" TODO, you'll need to add a testable transaction to the 750th v4 block. As in your other script, you'd want to check that the new CLTV rules are not enforced on the 750th v4 block and that they are enforced on the 751st v4 block. ::minor nit, just noticed that the copyright header was different in this file than the other ::Fixed. ::I still don't know why we wait for 75% to start using a policy rule. I would do it from the start but only enforce it as a consensus rule after 95%. I don't want to slow this down since it is a general softfork question (even if I'm right it can be solved after this PR), but I haven't been able to find an answer anywhere. ::This is not a policy rule. ::While individual miners apply it but still not enforce it as a consensus rule (ie reject blocks that don't apply it), it is just mining policy. What am I missing? ::Seriously, what am I missing here? Why wait for 75% for enforcing the new rule in your own blocks (which by the way you are marking as being version 4)? ::This code is executed against all blocks, not just blocks you created. If another miner creates a nVersion=4 block with an invalid use of CHECKLOCKTIMEVERIFY if you reject it without a majority of hashing power also rejecting it you'll get forked. In fact, it might be a good idea to go the other way and remove the 75% rule, accepting invalid nVersion=4 blocks until 95% ::Thanks, for some reason I was fixated on this 75% threshold only affecting your own blocks, but this is ConnectBlock so it obviously affects all blocks. Yes, I wouldn't oppose to wait for the 95% here too. But with versionbits this disappears so is probably not worth to discuss this much. ::Yeah, I probably would have changed it to remove 75% a year ago... but at this stage I think it's harmless to leave in. ::",287f54fc90c29301faede8d4ac2ea24a91441917::cde7ab2d4ea7fbf71497c42edc1a82b9c8e6c91d::65ef3723024881b7b21597bb784503094a323fb4::
https://api.github.com/repos/bitcoin/bitcoin,6333,2015_06_seed_update::master,0,merged,P2P::,"- Moved all seed related scripts to contrib/seeds for consistency - Updated `makeseeds.py` to handle IPv6 and onions, fix regular expression for recent Bitcoin Core versions - Fixed a bug in `generate-seeds.py` with regard to IPv6 parsing - Ran scripts, produced new `chainparamsseeds.h` Source data: https://dev.visucore.com/bitcoin/seeds-20150624.txt.xz  retrieved 2015-06-24 09:28:55 +0200 from http://bitcoin.sipa.be/seeds.txt Needs backport to 0.11.",ccd4369a23ca78cc348bc66a7a8c69a971ffcbf7::884454aebe9e20964643b70ff8c41f47709380bc::b9329536cd8a6c152b41c9276f1def14b4d2442d::
https://api.github.com/repos/bitcoin/bitcoin,6269,osx-sigs-git::master,0,merged,Build system::,"Rather than fetching a signature.tar.gz from somewhere on the net, instruct Gitian to use a signature from a tag in the bitcoin-detached-sigs repository which corresponds to the tag of the release being built. Gitian should then be run something like: ``` bash ./bin/gbuild --commit signature=v0.11.0rc2 ../bitcoin/contrib/gitian-descriptors/gitian-osx-signer.yml ``` This changes detached-sig-apply.sh to take a dirname rather than a tarball as an argument, though detached-sig-create.sh still outputs a tarball for convenience. The dir structure was also altered to add an 'osx' prefix, so that detached win signatures may be added in the future without clashing. I've successfully tested by creating tags in local bitcoin/bitcoin-detached-sigs repos and walking through the build process like a real release. Safe for 0.11 backport.",c110575a92ebe2e9a58b53d56aafa1f1ae37dbb2::
https://api.github.com/repos/bitcoin/bitcoin,6226,2015_06_json_trailing_garbage::master,0,merged,RPC/REST/ZMQ::,"Change `read_string` to fail when not the entire input has been consumed. This avoids unexpected, even dangerous behavior (fixes #6223). The new JSON parser adapted in #6121 also solves this problem so in master this is a temporary fix, but should be backported to older releases. Also adds tests for the new behavior. This now errors as expected: ``` $ src/bitcoin-cli -testnet sendtoaddress msj42CCGruhRsFrGATiUuh25dtxYtnpbTx 1.0dsfs error: Error parsing JSON:1.0dsfs ``` Needs backport to 0.10 and 0.11. I don't think older versions are affected, as they did manual parsing of bitcoin-cli arguments. _Note_: normally I wouldn't change json_spirit directly as it is an upstream library, but it is going to be dropped anyway, so doing the straightforward fix makes sense",4e157fc60dae5ca69933ea4c1585a2a078b4d957::
https://api.github.com/repos/bitcoin/bitcoin,6218,master-deploy-updates::master,0,merged,,"The first two should be backported to 0.11, but the cache dir for 0.11 needs the obvious change. I'll PR that separately.",c3cdd7b31201e1f3f78f816d8456d04c00e06418::be656283f98896df0bc8634d446b2873f9fed573::960e99404ff7337a5eefac9086dd2843fd70f24a::
https://api.github.com/repos/bitcoin/bitcoin,6176,first-seen-safe-rbf::master,0,closed,Mempool::,"Replaces transactions already in the mempool if a new transaction is seen with a higher fee, provided that the replacement transaction's outputs pay all previous outputs an equal or greater amount. This preserves the ""first seen"" behavior of the mempool, in the sense that a transaction will never be replaced in a fashion that prevents an address from receiving funds that it otherwise would have. In short, zero-conf transactions are unaffected. (beyond the usual breakage for any mempool behavior change) To prevent replacements from being used as a DoS attack mechanism a replacement only happens if the new transaction has a higher fee, pays a higher fee/KB rate, and the fee increase is sufficient to pay for the bandwidth consumed in relaying the replacement. Includes stand-alone unittests for regtest in qa/replace-by-fee/ (implemented w/ python-bitcoinlib as I've been asked for a backport of this to v0.10/v0.9) You can easily try out the behavior using https://github.com/petertodd/replace-by-fee-tools bump-fee.py with the -s first-seen-safe mode switch. CC: @aalness @coblee re: https://github.com/petertodd/bitcoin/pull/3 Would it not be possible to rewrite/adapt this test so it would conform to other `qa/rpc-tests/*` and would therefore use the same framework? ::Sure, but that framework kinda sucks due to the lack of a good python Bitcoin library. Also, like I said above, I know I'll be backporting it so I needed a stand-alone set of tests that I could test the backports against. ::Empty code block? ::Lol, I must be blind... That's stub code replaced by the lines just below it; fixed, thanks! ::I believe it shouldn't be possible for there to be more than one transaction in `ltxConflicted` here, is that right?  Perhaps clarifying the comment at line 1155 (or adding an assertion about the size of this list) would be helpful. ::The mempool isn't locked the whole time, so I believe there's a small chance there could be more than one conflicting transaction. (never mind future design changes!) Updated comment. ::Mostly an fyi after looking at this more: despite the mempool lock not being held the whole time, cs_main is held, and that seems important for a preventing a race condition (otherwise the result of `view.HaveInputs()` at line 1029 could have changed by the time you get to `pool.addUnchecked()` at line 1182)...  Anyway, I don't think there can be more than one conflicting transaction. ::You could avoid checking each vout sequentially by checking mapNextTx.lower_bound(COutPoint(hashConflicting, 0)) ::I may be wrong here, but wouldn't your previous check (no new inputs are in the mempool) already catch this case? ::Ah, yeah, that's true now that it's been changed to require new inputs to be confirmed. Good catch. ::As in, check if the mapNextTx.lower_bound() hash == hashConflicting or the lower_bound() returns mapNextTx.end()? Seems reasonable, though the way that depends on which way COutPoint's is sorted bothers me slightly. ::@ashleyholman Switched to lower_bound(), thanks! Mind checking the new code over? ::Removed this check and replaced it with a comment describing how it's needed if we ever allow the new inputs to be unconfirmed. ::@sdaftuar other policies can replace more than one conflicting transaction. But, yeah, since this code doesn't, an assert with a comment along the lines ""disable multiple replacement feature for now"" wouldn't hurt. ::",f3044fd191505253e7914916c784235698514e1e::
https://api.github.com/repos/bitcoin/bitcoin,5780,fix-0.9-build::0.9,0,merged,,This is a very minor build fix. A simple backport from 0.10. Fixes #5064 again.,8438074997097c673ba856ce8526ee94bb668bba::
https://api.github.com/repos/bitcoin/bitcoin,5671,qt-font-fix::master,0,merged,GUI::,"Fixes #5657 and likely #5165. The default font changed again. The real fix is to compile qt against a >= 10.8 sdk, but this is simple enough to backport to 0.10 to avoid having to do that there. Note: NSAppKitVersionNumber is a double and there's no official value for NSAppKitVersionNumber10_10. Since == isn't reliable for doubles, use Apple's guidelines for testing versions here: https://developer.apple.com/library/mac/releasenotes/AppKit/RN-AppKit/ Why we substitute the default Font with `Helvetica`? Looks good but leads to new problems (see other comment). ![bildschirmfoto-2015-01-17-um-08 45 03](https://cloud.githubusercontent.com/assets/178464/5788120/76dbadc4-9e25-11e4-84f5-bf9e19f45251.png) ::",f5ad78b34af8f50e12fab63b331768b96ec2c779::52954e6efd373c14736237c4c79769bf00f5dfb8::73cd4edb4f1ff98c20549a609e96fa40834f5e73::
https://api.github.com/repos/bitcoin/bitcoin,5586,fix-depends-major-bug::master,0,merged,Build system::,"This is included in #5582, but I'm PRing separately because it is a badly needed fix. It also needs backport to 0.10. Unfortunately, this will force all dependencies to be rebuilt. I'll accept lashings as penance... Will rebase #5882 after merge. Broken hash logic caused all depends on some platforms (osx at least) to end up with the same build-id. Without this fix, nothing will be rebuilt when recipes or dependencies change. The 'cut' was put in the wrong place, so rather than hashing the hashes, it hashed the filename which was always ""-"" (stdin). Probably a stupid c/p mistake.",d57b303e1e5b3fc31da0769b14b01fdcc19b1f7a::
https://api.github.com/repos/bitcoin/bitcoin,5569,deterministic-dmg-gitian-fixup::master,0,merged,Build system::,"I've verified that the process works by manually extracting the signature from rc1 and running it through the re-attaching procedure. Updated the docs and descriptors to fix versioning. Rather than bumping the version for each build, make the inputs version-less. Obviously they must match anyway. In case anyone wishes to test (I've verified that the dmg works fine) The detached signature can be found here: https://bitcoincore.org/cfields/bitcoin-0.10.0rc1/signature.tar.gz And the final deterministic dmg is here: https://bitcoincore.org/cfields/bitcoin-0.10.0rc1/bitcoin-0.10.0rc1-osx-signed.dmg Needs backport to 0.10.",0d50c2fd81ee7239570954e6eacb3dbbfe3bb5fe::
https://api.github.com/repos/bitcoin/bitcoin,5536,gitian-tarball-determinism::master,0,merged,,"Needs 0.10 backport. Rebuilding v0.10.0rc1 with these changes yields: ``` e4b60408c8917c3a1420529b6b4d9eff6fe080e4c7db86240effd0903f341dda  bitcoin-0.10.0-osx-unsigned.dmg 8cf94292cd7b936aa8f70cc3a550120842206e577cb22d448211093a57b95a48  bitcoin-0.10.0-osx-unsigned.tar.gz 26f5aa7914e2a25112b01bb5920d87e003e49c806c9a489ab80edbe7e1e47595  bitcoin-0.10.0-osx64.tar.gz b074c4ba6c03b6045de61e521c6d47b2764a33a6c7d4f102dcdb72a9fec75601  src/bitcoin-0.10.0.tar.gz 504b6cb989b2f6967e3aa9ef1fd9ec15aaa28b060351f064323f3972cc199320  bitcoin-0.10.0-win32-setup.exe 24a94035641cbb84d9f8d04e290e1aa008346fc8b867029717475e2991d510a6  bitcoin-0.10.0-win32.zip 835559d963cb7d1e6fb594f15e19b4c46b811deb6b78afa25621f62af8be73ae  bitcoin-0.10.0-win64-setup.exe d89d976778c8c1fd752e1171a4221bdfa26c626b342a9d5c21570c66903ea76f  bitcoin-0.10.0-win64.zip b074c4ba6c03b6045de61e521c6d47b2764a33a6c7d4f102dcdb72a9fec75601  src/bitcoin-0.10.0.tar.gz bad06e24032c6aafaeae21a44a1001de5d049191a86f61261e046c4b92796767  bitcoin-0.10.0-linux32.tar.gz f1d016975a99910c7a7037fca0b3837446e56f17675f160597e10c5ef2c81a5d  bitcoin-0.10.0-linux64.tar.gz b074c4ba6c03b6045de61e521c6d47b2764a33a6c7d4f102dcdb72a9fec75601  src/bitcoin-0.10.0.tar.gz ``` I'm testing locally with lxc, but it'd be nice to have someone else with lxc confirm they match.",566c6cb8a2a277d9c5e4897ad02c5bb15786523c::
https://api.github.com/repos/bitcoin/bitcoin,5039,osx-qt5-brew-backport::0.9.3,0,merged,,"Original PR: #5026 Qt5 is bottled, so configure won't find it without some help. Use brew to find out its prefix. Also, qt5 added the host_bins variable to pkg-config, use it. @gavinandresen In order to deploy 0.9.3 successfully, I also needed to backport 502972f16bae79cf025bf9b63ec8276bc4a236bb and d16f6f87e1c15bd686e0e74ddb671da95a916c6d, though this was a quick local build and not gitian. It probably makes sense to just leave them alone if deploy/sign currently work for you, just thought I'd mention.",5b9f78d69ccf189bebe894b1921e34417103a046::
https://api.github.com/repos/bitcoin/bitcoin,4874,tablet-fix::master,0,merged,,This backports the relevant parts of: https://codereview.qt-project.org/#/c/82689/,21f139b4a622f07679f1d1c30ad32e2b40a2617e::
https://api.github.com/repos/bitcoin/bitcoin,3753,mempool-janitor::master,0,closed,Feature::Mempool::Refactoring::,"The mempool janitor (""poolman"") is a thread that runs every -janitorinterval seconds.  The janitor scans and removes memory pool transactions older than current time minus -janitorexpire seconds. By default, janitor runs every 24 hrs, expiring TXs older than 72 hrs [and have failed to make it into a block in that time]. IsMine() transactions are not touched. This is _intentionally crude_: easily reviewed, reasoned and tested; fitting easily within the current framework, or being backported to an older bitcoind.  A key goal was _not_ rewriting mempool. Comments: - One alternative implementation was considered: ``` while (mempool byte size > limit) expire oldest !ismine ``` This would work, but require a sort step, as mempool is not time-ordered.  There is also the question of how often to run such a while{} loop, likely leading to some sort of high-water/low-water system. The sweep implementation presented seemed more straightforward. I'd rather have that the wallets let the mempool know that a transaction is precious (with a flag), than having the mempool manager poll the main wallet. If you want to do it this way (poolman -> wallets) please use the RegisterWallet / UnregisterWallet machinery from main.cpp, and add a CWalletInterface method for this. ::Agree. ::You also need to remove everything that depends on a wallet transaction. ::Thank you ::Can you ensure these new commands are alphabetically ordered in the help message list. May I also suggest to add a DEFAULT_JANITORINTERVAL, DEFAULT_JANITOREXPIRE and use that here and in the `GetArg()`. It IMHO nice to use this in the help strings, because when changing a default we don't need to change the help string (and don't need to re-translate). See e.g. -blockmaxsize=<n> in init.cpp. ::Nit: Could you switch these two and place them above `-listen` please. Also @luke-jr A few weeks ago changed all strings in help messages to use `strprintf(_())` as that makes life for translators easier. ::This allows negative numbers, is this intended? Perhaps just use unsigned. ::Missing license :). ::Also misses license and correct header define `#ifndef BITCOIN_POOLMAN_H` (and at the file end). ::Nit: Is this correct help text formating? ::change to poolbeing.h \ ::change to poolbeing.cpp \ ::change to ""poolbeing.h"" ::see notes on changes from poolman to poolbeing (languaging basically) above ::should be changed from poolman.h to poolbeing.h ::poolbeing -> wallets ::poolman.h to be changed to poolbeing.h ::",f55882fb41d34bd43c358f0a81e1c776c44cff43::b5d216a7b3dd68b784601973ff95e15cdfd13ebf::
https://api.github.com/repos/bitcoin/bitcoin,3426,2013_12_corrupt_wallet_emptytx::master,0,merged,,The current transaction loading code is not exception safe. An exception during deserialization causes an empty transaction to be left behind in the wallet. Fix this by building the transaction separately and adding it only to the wallet at the end. Fixes #3333. Should also be backported to 0.8.7 if we roll one.,16ec9044d1f2eda7c5c86fcb73c839e17fb35db3::
https://api.github.com/repos/bitcoin/bitcoin,2985,included-tests::master,0,merged,,"This is the first in a line of PRs to address some of the concerns laid out in #2979. Rather than adding more trickery to deduce where test data should be found, I believe that this is the more reliable solution. This uses the same mechanism as QT to include their assets in the resulting binary rather than reading it from the disk at runtime. Untested as-yet on OSX, but I believe it should work fine there. Copied from the main commit: ``` Advantages: - Tests become distributable. - Cross-compile friendly. Build on one machine and execute in an arbitrary location on another. - Easier testing for backports. Users can verify that tests pass without having to track down corresponding test data. - More trustworthy test results and easier quality assurance as tests make fewer assumptions about their environment. - Tests could theoretically run at client/daemon startup and exit on failure. Disadvantages: - Required 'hexdump' build-dependency. This is a standard bsd tool that should be usable everywhere. It is likely already installed on all build-machines. - Tests can no longer be fudged after build by altering test-data. ```",08081e393b6d3249c19395f91537a7d824ec7333::152e51c7af2624831cc4796e06bf3b72787cc85f::
https://api.github.com/repos/bitcoin/bitcoin,2453,txstats::master,0,merged,,"As these were not updated when 'backporting' the 225430 checkpoint into head. Additionally, also report verification progress in debug.log, and tweak the sigcheck-verification-speed-factor a bit.",92a129980fb9b506da6c7f876aa8adb405c88e17::
https://api.github.com/repos/bitcoin/bitcoin,1935,master::master,0,merged,,"This script downloads the SHA256SUMS.asc file from SourceForge for a given release (version can be specified on the command line), which contains Gavin's signature of the hashes of the Bitcoin binaries. It verifies that the signature is valid, downloads the files specified in the signature file, and checks that the hashes of these files match with those signed by Gavin. Not all releases are signed by Gavin (notably stable/backport releases are not), and users probably shouldn't be expected to setup the key themselves anyway. There are a bunch of PGP keys in git already for verifying against - any way to use those easily? ::0.7.0 is signed by Gavin. Is that not a stable release? I considered including installation of the key in the script, but I figured it was preferable to let the users install these by themselves. But now that you point it out, I'm not sure why the script shouldn't just install if it reaches the line above. Where are those PGP keys in git that you mention? Also, I'd have to know who signs what with which keys in order to know how to use them. It would be better if all the heavily involved developers sign the executables. That way it'd be even harder for an attacker to somehow get past this (by getting hold of Gavin's key, for example). ::0.7.0 is a first-time stable release: it's built off master, not a stable branch. I wouldn't suggest touching the user's PGP setup, but verifying without touching it. If GPG really needs to keep keys somewhere, ~/.bitcoin/.gnupg or similar makes sense. contrib/gitian-downloader contains PGP keys. There's also a git repository here on GitHub with signatures of multiple developers for most releases which would be better to use than the SHA256SUMS file (which can only have one signature). ::... but we don't want Runek to end up reinventing gitian-downloader, and I hate making 'perfect the enemy of the good'. So I vote this gets pulled as-is, because it is much better than the nothing we have now. ::> I wouldn't suggest touching the user's PGP setup, but verifying without touching it. If GPG really needs to keep keys somewhere, ~/.bitcoin/.gnupg or similar makes sense. OK. Then I misunderstood you. So you're saying the script should pull in a public key from a remote location and use that to verify? That makes sense. This would create another point of attack though. I figured the best way was to let the users who run the script store the keys themselves, so these can't be modified easily by an adversary. > contrib/gitian-downloader contains PGP keys. There's also a git repository here on GitHub with signatures of multiple developers for most releases which would be better to use than the SHA256SUMS file (which can only have one signature). The threat that this script tries to mitigate is that of an adversary replacing the binaries on SourceForge (I made it after reading this thread: https://bitcointalk.org/index.php?topic=113018.0). So the devs in question need to sign the binaries that are linked to on bitcoin.org. Is this the case wrt. to the git repo you're referencing? As far as I can see, this is not what is signed in this repo at least: https://github.com/bitcoin/gitian.sigs/ - is this the repository you're talking about? ::No, since this script is going into the git repository, it should be able to assume it has the PGP keys in that directory already. I just mean touching the user's personal PGP key library is probably a bad idea. https://github.com/bitcoin/gitian.sigs should match the binaries on SF: the installers as-is, and the contents of the ZIP files and tarballs. @gavinandresen ACK, you're right this would probably end up equivalent and doesn't do any harm to pull as-is. ::",de91ea0c0c2fead60bfe9a531558cbe1c562346e::
https://api.github.com/repos/bitcoin/bitcoin,1590,txfee::master,0,merged,,"Modify CreateNewBlock so that instead of processing all transactions in priority order, process the first 27K of transactions in priority order and then process the rest in fee-per-kilobyte order. This is the first, minimal step towards better a better fee-handling system for both miners and end-users; this patch should be easy to backport to the old versions of Bitcoin, and accomplishes the most important goal-- allow users to ""buy their way in"" to blocks using transaction fees. Four params give miners control over the transaction selection process: -blockmaxsize  : maximum size of blocks created (default: 250000) -blockprioritysize : how much of the block to set aside for high-priority-maybe-free transactions (default: 27000) -blockminsize : minimum size of blocks created (default: 0) -mintxfee : transactions that pay below this many bitcoins-per-kilobyte are considered ""free"" (default: 0.0005) Discussion thread in the Mining forums:  https://bitcointalk.org/index.php?topic=95837",c555400ca134991e39d5e3a565fcd2215abe56f6::e0e54740b10e28dac2fe7aa9b461e956452e9649::
https://api.github.com/repos/bitcoin/bitcoin,975,versioncheck::master,0,merged,,"When a 0.6 wallet with compressed pubkeys is created, it writes a minversion record to prevent older clients from reading it. If the 0.5 loading it sees a key record before seeing the minversion record however, it will fail with DB_CORRUPT instead of DB_TOO_NEW. This is more needed in backports than in mainline for now, but it's code improvement in any case.",ef12c2184d926eea25cc804a75bc4068f9f81891::
https://api.github.com/repos/bitcoin/bitcoin,748,pay_to_script_hash::master,0,merged,,"This implements BIP 16, the replacement for pay-to-script hash. https://en.bitcoin.it/wiki/BIP_0016 Tested mostly on testnet-in-a-box, but I did spend time today generating transactions on the testnet as a final sanity test: Testnet block 43561 has 3 Pay-to-script-hash transactions and the /P2SH/ string in it's coinbase: http://blockexplorer.com/testnet/block/000000000182cc0764d6c6b2b43a009fc9dc0cb03e9002249e7e865b7189acf8 The next block has a transaction that spends one of them: http://blockexplorer.com/testnet/tx/cff697a07fa21780b2553c6e86bf956cb42838b0e9b226da2c6b3cd7754da736 I'll be producing/testing backports for miners running old software in the next few days.",d11a58a2d39b90dfe27d3a696b3977b87d7c8113::922e8e2929a2e78270868385aa46f96002fbcff3::8d7849b6db5f54dc32fe4f8c6c7283068473cd21::4063460534768e2062585573548c293b39313a41::9e8818ec9d01b3cf9e4aa601a96785c4fdc3f9b7::
