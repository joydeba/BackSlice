"def test_issue42383(self):
    with os_helper.temp_cwd() as cwd:
        with open('foo.py', 'w') as f:
            s = textwrap.dedent(""""""
                print('The correct file was executed')
                import os
                os.chdir(""subdir"")
            """""")
            f.write(s)
        subdir = os.path.join(cwd, 'subdir')
        os.mkdir(subdir)
        os.mkdir(os.path.join(subdir, 'subdir'))
        wrong_file = os.path.join(subdir, 'foo.py')
        with open(wrong_file, 'w') as f:
            f.write('print(""The wrong file was executed"")')
        stdout, stderr = self._run_pdb(['foo.py'], 'c\nc\nq')
        expected = '(Pdb) The correct file was executed'
        self.assertEqual(stdout.split('\n')[6].rstrip('\r'), expected)
"
-------------------------------------------------------------------------
"def test_issue42383(self):
    with support.temp_cwd() as cwd:
        with open('foo.py', 'w') as f:
            s = textwrap.dedent(""""""
                print('The correct file was executed')
                import os
                os.chdir(""subdir"")
            """""")
            f.write(s)
        subdir = os.path.join(cwd, 'subdir')
        os.mkdir(subdir)
        os.mkdir(os.path.join(subdir, 'subdir'))
        wrong_file = os.path.join(subdir, 'foo.py')
        with open(wrong_file, 'w') as f:
            f.write('print(""The wrong file was executed"")')
        stdout, stderr = self._run_pdb(['foo.py'], 'c\nc\nq')
        expected = '(Pdb) The correct file was executed'
        self.assertEqual(stdout.split('\n')[6].rstrip('\r'), expected)"
-------------------------------------------------------------------------
"def test_issue42383(self):
    with support.temp_cwd() as cwd:
        with open('foo.py', 'w') as f:
            s = textwrap.dedent(""""""
                print('The correct file was executed')
                import os
                os.chdir(""subdir"")
            """""")
            f.write(s)
        subdir = os.path.join(cwd, 'subdir')
        os.mkdir(subdir)
        os.mkdir(os.path.join(subdir, 'subdir'))
        wrong_file = os.path.join(subdir, 'foo.py')
        with open(wrong_file, 'w') as f:
            f.write('print(""The wrong file was executed"")')
        stdout, stderr = self._run_pdb(['foo.py'], 'c\nc\nq')
        expected = '(Pdb) The correct file was executed'
        self.assertEqual(stdout.split('\n')[6].rstrip('\r'), expected)
"
-------------------------------------------------------------------------
"Recom
PRs: 23412, 24323"
-------------------------------------------------------------------------
=========================================================================
"def test_issue42383(self):
    with os_helper.temp_cwd() as cwd:
        with open('foo.py', 'w') as f:
            s = textwrap.dedent(""""""
                print('The correct file was executed')
                import os
                os.chdir(""subdir"")
            """""")
            f.write(s)
        subdir = os.path.join(cwd, 'subdir')
        os.mkdir(subdir)
        os.mkdir(os.path.join(subdir, 'subdir'))
        wrong_file = os.path.join(subdir, 'foo.py')
        with open(wrong_file, 'w') as f:
            f.write('print(""The wrong file was executed"")')
        stdout, stderr = self._run_pdb(['foo.py'], 'c\nc\nq')
        expected = '(Pdb) The correct file was executed'
        self.assertEqual(stdout.split('\n')[6].rstrip('\r'), expected)
"
-------------------------------------------------------------------------
"def test_issue42383(self):
    with tempfile.TemporaryDirectory() as tmpdirname:
        with open(os.path.join(tmpdirname, 'foo.py'), 'w') as f:
            s = textwrap.dedent(""""""
                print('The correct file was executed')
                import os
                os.chdir(""subdir"")
            """""")
            f.write(s)
        subdir = os.path.join(tmpdirname, 'subdir')
        os.mkdir(subdir)
        os.mkdir(os.path.join(subdir, 'subdir'))
        wrong_file = os.path.join(subdir, 'foo.py')
        with open(wrong_file, 'w') as f:
            f.write('print(""The wrong file was executed"")')
        stdout, stderr = self._run_pdb([os.path.join(tmpdirname, 'foo.py')], 'c\nc\nq')
        expected = '(Pdb) The correct file was executed'
        self.assertEqual(stdout.split('\n')[6].rstrip('\r'), expected)"
-------------------------------------------------------------------------
"def test_issue42383(self):
    with support.temp_cwd() as cwd:
        with open('foo.py', 'w') as f:
            s = textwrap.dedent(""""""
                print('The correct file was executed')
                import os
                os.chdir(""subdir"")
            """""")
            f.write(s)
        subdir = os.path.join(cwd, 'subdir')
        os.mkdir(subdir)
        os.mkdir(os.path.join(subdir, 'subdir'))
        wrong_file = os.path.join(subdir, 'foo.py')
        with open(wrong_file, 'w') as f:
            f.write('print(""The wrong file was executed"")')
        stdout, stderr = self._run_pdb(['foo.py'], 'c\nc\nq')
        expected = '(Pdb) The correct file was executed'
        self.assertEqual(stdout.split('\n')[6].rstrip('\r'), expected)
"
-------------------------------------------------------------------------
"Recom
PRs: 23412, 24322"
-------------------------------------------------------------------------
=========================================================================
"invalidation_mode=None, *, stripdir=None,
"
-------------------------------------------------------------------------
"def compile_dir(dir, maxlevels=None, ddir=None, force=False,
                 rx=None, quiet=0, legacy=False, optimize=-1, workers=1,
                 prependdir=None, limit_sl_dest=None, invalidation_mode=None,
                 *, stripdir=None):
     """"""Byte-compile all modules in the given directory tree."
-------------------------------------------------------------------------
"yield fullname, ddir
"
-------------------------------------------------------------------------
"Recom
PRs: 18676, 18718"
-------------------------------------------------------------------------
=========================================================================
"if ddir is not None and (stripdir is not None or prependdir is not None):
    raise ValueError((""Destination dir (ddir) cannot be used ""
                      ""in combination with stripdir or prependdir""))
if ddir is not None:
    stripdir = dir
    prependdir = ddir
    ddir = None
"
-------------------------------------------------------------------------
"if ddir is not None:
    if stripdir is not None or prependdir is not None:
        raise ValueError(""Destination dir (ddir) cannot be used in combination with stripdir or prependdir"")
    else:
        stripdir = dir
        prependdir = ddir
        ddir = None"
-------------------------------------------------------------------------
"files_and_ddirs = _walk_dir(dir, quiet=quiet, maxlevels=maxlevels,
                            ddir=ddir)
        results = executor.map(
                partial(_compile_file_tuple,
                        force=force, rx=rx, quiet=quiet,
                        legacy=legacy, optimize=optimize,
                        invalidation_mode=invalidation_mode,
                    ),
                files_and_ddirs)
    for file, dfile in files_and_ddirs:
        if not compile_file(file, dfile, force, rx, quiet,
_compile_file_tuple(file_and_dfile, **kwargs):
""""""Needs to be toplevel for ProcessPoolExecutor.""""""
file, dfile = file_and_dfile
return compile_file(file, dfile, **kwargs)
"
-------------------------------------------------------------------------
"Recom
PRs: 18676, 18718"
-------------------------------------------------------------------------
=========================================================================
"import marshal
"
-------------------------------------------------------------------------
"import os
import os.path
from pathlib import Path, PurePath
from importlib import abc, machinery, util, invalidate_caches"
-------------------------------------------------------------------------
"import marshal
"
-------------------------------------------------------------------------
"Recom
PRs: 18676, 18718"
-------------------------------------------------------------------------
=========================================================================
"def get_code_from_pyc(pyc_path):
    """"""Reads a pyc file and returns the unmarshalled code object within.
    No header validation is performed.
    """"""
    with open(pyc_path, 'rb') as pyc_f:
        pyc_f.seek(16)
        return marshal.load(pyc_f)
"
-------------------------------------------------------------------------
"def get_code_from_pyc(pyc_path):
    """"""Reads a pyc file and returns the unmarshalled code object within.
    No header validation is performed.
    """"""
    with open(pyc_path, 'rb') as pyc_f:
        pyc_f.seek(16)
        return marshal.load(pyc_f)"
-------------------------------------------------------------------------
"def _get_code_from_pyc(pyc_path):
    """"""Reads a pyc file and returns the unmarshalled code object within.
    No header validation is performed.
    """"""
    with open(pyc_path, 'rb') as pyc_f:
        pyc_f.seek(16)
        return marshal.load(pyc_f)
"
-------------------------------------------------------------------------
"Recom
PRs: 18676, 18718"
-------------------------------------------------------------------------
=========================================================================
"import copy
from functools import partial
"
-------------------------------------------------------------------------
"import copy
import functools.partial"
-------------------------------------------------------------------------
"import copy
import pickle
import sys
"
-------------------------------------------------------------------------
"Recom
PRs: 9106, 9133"
-------------------------------------------------------------------------
=========================================================================
"def check(actual, expected):
    self.assertEqual(actual, expected)
    self.assertEqual(actual.is_safe, expected.is_safe)
with support.swap_item(sys.modules, 'uuid', self.uuid):
    for is_safe in self.uuid.SafeUUID:
        u = self.uuid.UUID('d82579ce6642a0de7ddf490a7aec7aa5',
                           is_safe=is_safe)
        check(copy.copy(u), u)
        check(copy.deepcopy(u), u)
        for proto in range(pickle.HIGHEST_PROTOCOL  1):
            with self.subTest(protocol=proto):
                check(pickle.loads(pickle.dumps(u, proto)), u)
def check(actual, expected):
    self.assertEqual(actual, expected)
    self.assertEqual(actual.is_safe, expected.is_safe)
pickled_uuids = [
    # Python 2.7, protocol 0
    b'ccopy_reg\n_reconstructor\n(cuuid\nUUID\nc__builtin__\nobject\nN'
    b'tR(dS\'int\'\nL287307832597519156748809049798316161701L\nsb.',
    # Python 2.7, protocol 1
    b'ccopy_reg\n_reconstructor\n(cuuid\nUUID\nc__builtin__\nobject\nN'
    b'tR}U\x03intL287307832597519156748809049798316161701L\nsb.',
    # Python 2.7, protocol 2
    b'\x80\x02cuuid\nUUID\n)\x81}U\x03int\x8a\x11\xa5z\xecz\nI\xdf}'
    b'\xde\xa0Bf\xcey%\xd8\x00sb.',
    # Python 3.6, protocol 0
    b'ccopy_reg\n_reconstructor\n(cuuid\nUUID\nc__builtin__\nobject\nN'
    b'tR(dVint\nL287307832597519156748809049798316161701L\nsb.',
    # Python 3.6, protocol 1
    b'ccopy_reg\n_reconstructor\n(cuuid\nUUID\nc__builtin__\nobject\nN'
    b'tR}X\x03\x00\x00\x00intL287307832597519156748809049798316161701L'
    b'\nsb.',
    # Python 3.6, protocol 2
    b'\x80\x02cuuid\nUUID\n)\x81}X\x03\x00\x00\x00int\x8a\x11\xa5z\xec'
    b'z\nI\xdf}\xde\xa0Bf\xcey%\xd8\x00sb.',
    # Python 3.6, protocol 3
    b'\x80\x03cuuid\nUUID\n)\x81}X\x03\x00\x00\x00int\x8a\x11\xa5z\xec'
    b'z\nI\xdf}\xde\xa0Bf\xcey%\xd8\x00sb.',
    # Python 3.6, protocol 4
    b'\x80\x04\x95\x00\x00\x00\x00\x00\x00\x00\x8c\x04uuid\x8c\x04UUI'
    b'D\x93)\x81}\x8c\x03int\x8a\x11\xa5z\xecz\nI\xdf}\xde\xa0Bf\xcey%'
    b'\xd8\x00sb.',
    # Python 3.7, protocol 0
    b'ccopy_reg\n_reconstructor\n(cuuid\nUUID\nc__builtin__\nobject\nN'
    b'tR(dVint\nL287307832597519156748809049798316161701L\nsVis_safe\n'
    b'cuuid\nSafeUUID\n(NtRsb.',
    # Python 3.7, protocol 1
    b'ccopy_reg\n_reconstructor\n(cuuid\nUUID\nc__builtin__\nobject\nN'
    b'tR}(X\x03\x00\x00\x00intL287307832597519156748809049798316161701'
    b'L\nX\x07\x00\x00\x00is_safecuuid\nSafeUUID\n(NtRub.',
    # Python 3.7, protocol 2
    b'\x80\x02cuuid\nUUID\n)\x81}(X\x03\x00\x00\x00int\x8a\x11\xa5z'
    b'\xecz\nI\xdf}\xde\xa0Bf\xcey%\xd8\x00X\x07\x00\x00\x00is_safecuu'
    b'id\nSafeUUID\nN\x85Rub.',
    # Python 3.7, protocol 3
    b'\x80\x03cuuid\nUUID\n)\x81}(X\x03\x00\x00\x00int\x8a\x11\xa5z'
    b'\xecz\nI\xdf}\xde\xa0Bf\xcey%\xd8\x00X\x07\x00\x00\x00is_safecuu'
    b'id\nSafeUUID\nN\x85Rub.',
    # Python 3.7, protocol 4
    b'\x80\x04\x95F\x00\x00\x00\x00\x00\x00\x00\x8c\x04uuid\x94\x8c'
    b'\x04UUID\x93)\x81}(\x8c\x03int\x8a\x11\xa5z\xecz\nI\xdf}\xde\xa0'
    b'Bf\xcey%\xd8\x00\x8c\x07is_safeh\x00\x8c\x08SafeUUID\x93N\x85Rub'
    b'.',
]
pickled_uuids_safe = [
    # Python 3.7, protocol 0
    b'ccopy_reg\n_reconstructor\n(cuuid\nUUID\nc__builtin__\nobject\nN'
    b'tR(dVint\nL287307832597519156748809049798316161701L\nsVis_safe\n'
    b'cuuid\nSafeUUID\n(I0\ntRsb.',
    # Python 3.7, protocol 1
    b'ccopy_reg\n_reconstructor\n(cuuid\nUUID\nc__builtin__\nobject\nN'
    b'tR}(X\x03\x00\x00\x00intL287307832597519156748809049798316161701'
    b'L\nX\x07\x00\x00\x00is_safecuuid\nSafeUUID\n(K\x00tRub.',
    # Python 3.7, protocol 2
    b'\x80\x02cuuid\nUUID\n)\x81}(X\x03\x00\x00\x00int\x8a\x11\xa5z'
    b'\xecz\nI\xdf}\xde\xa0Bf\xcey%\xd8\x00X\x07\x00\x00\x00is_safecuu'
    b'id\nSafeUUID\nK\x00\x85Rub.',
    # Python 3.7, protocol 3
    b'\x80\x03cuuid\nUUID\n)\x81}(X\x03\x00\x00\x00int\x8a\x11\xa5z'
    b'\xecz\nI\xdf}\xde\xa0Bf\xcey%\xd8\x00X\x07\x00\x00\x00is_safecuu'
    b'id\nSafeUUID\nK\x00\x85Rub.',
    # Python 3.7, protocol 4
    b'\x80\x04\x95G\x00\x00\x00\x00\x00\x00\x00\x8c\x04uuid\x94\x8c'
    b'\x04UUID\x93)\x81}(\x8c\x03int\x8a\x11\xa5z\xecz\nI\xdf}\xde\xa0'
    b'Bf\xcey%\xd8\x00\x8c\x07is_safeh\x00\x8c\x08SafeUUID\x93K\x00'
    b'\x85Rub.',
pickled_uuids_unsafe = [
    # Python 3.7, protocol 0
    b'ccopy_reg\n_reconstructor\n(cuuid\nUUID\nc__builtin__\nobject\nN'
    b'tR(dVint\nL287307832597519156748809049798316161701L\nsVis_safe\n'
    b'cuuid\nSafeUUID\n(I-1\ntRsb.',
    # Python 3.7, protocol 1
    b'ccopy_reg\n_reconstructor\n(cuuid\nUUID\nc__builtin__\nobject\nN'
    b'tR}(X\x03\x00\x00\x00intL287307832597519156748809049798316161701'
    b'L\nX\x07\x00\x00\x00is_safecuuid\nSafeUUID\n(J\xff\xff\xff\xfftR'
    b'ub.',
    # Python 3.7, protocol 2
    b'\x80\x02cuuid\nUUID\n)\x81}(X\x03\x00\x00\x00int\x8a\x11\xa5z'
    b'\xecz\nI\xdf}\xde\xa0Bf\xcey%\xd8\x00X\x07\x00\x00\x00is_safecuu'
    b'id\nSafeUUID\nJ\xff\xff\xff\xff\x85Rub.',
    # Python 3.7, protocol 3
    b'\x80\x03cuuid\nUUID\n)\x81}(X\x03\x00\x00\x00int\x8a\x11\xa5z'
    b'\xecz\nI\xdf}\xde\xa0Bf\xcey%\xd8\x00X\x07\x00\x00\x00is_safecuu'
    b'id\nSafeUUID\nJ\xff\xff\xff\xff\x85Rub.',
    # Python 3.7, protocol 4
    b'\x80\x04\x95J\x00\x00\x00\x00\x00\x00\x00\x8c\x04uuid\x94\x8c'
    b'\x04UUID\x93)\x81}(\x8c\x03int\x8a\x11\xa5z\xecz\nI\xdf}\xde\xa0'
    b'Bf\xcey%\xd8\x00\x8c\x07is_safeh\x00\x8c\x08SafeUUID\x93J\xff'
    b'\xff\xff\xff\x85Rub.',
u = self.uuid.UUID('d82579ce6642a0de7ddf490a7aec7aa5')
u_safe = self.uuid.UUID('d82579ce6642a0de7ddf490a7aec7aa5',
                        is_safe=self.uuid.SafeUUID.safe)
u_unsafe = self.uuid.UUID('d82579ce6642a0de7ddf490a7aec7aa5',
                          is_safe=self.uuid.SafeUUID.unsafe)
with support.swap_item(sys.modules, 'uuid', self.uuid):
    for pickled in pickled_uuids:
        # is_safe was added in 3.7.  When unpickling values from older
        # versions, is_safe will be missing, so it should be set to
        # SafeUUID.unknown.
        check(pickle.loads(pickled), u)
    for pickled in pickled_uuids_safe:
        check(pickle.loads(pickled), u_safe)
    for pickled in pickled_uuids_unsafe:
        check(pickle.loads(pickled), u_unsafe)
"
-------------------------------------------------------------------------
"def test_check(self, actual, expected):
    self.assertEqual(actual, expected)
    self.assertEqual(getattr(actual, ""is_safe"", self.uuid.SafeUUID.unknown), getattr(expected, ""is_safe"", self.uuid.SafeUUID.unknown))

def test_pickle_roundtrip(self):
    pickled_uuids = [
        # Python 2.7, protocol 0
        b'...',
        # Python 2.7, protocol 1
        b'...',
        # Python 2.7, protocol 2
        b'...',
        # Python 3.6, protocol 0
        b'...',
        # Python 3.6, protocol 1
        b'...',
        # Python 3.6, protocol 2
        b'...',
        # Python 3.6, protocol 3
        b'...',
        # Python 3.6, protocol 4
        b'...',
        # Python 3.7, protocol 0
        b'...',
        # Python 3.7, protocol 1
        b'...',
        # Python 3.7, protocol 2
        b'...',
        # Python 3.7, protocol 3
        b'...',
        # Python 3.7, protocol 4
        b'...',
    ]
    pickled_uuids_safe = [
        # Python 3.7, protocol 0
        b'...',
        # Python 3.7, protocol 1
        b'...',
        # Python 3.7, protocol 2
        b'...',
        # Python 3.7, protocol 3
        b'...',
        # Python 3.7, protocol 4
        b'...',
    ]
    pickled_uuids_unsafe = [
        # Python 3.7, protocol 0
        b'...',
        # Python 3.7, protocol 1
        b'...',
        # Python 3.7, protocol 2
        b'...',
        # Python 3.7, protocol 3
        b'...',
        # Python 3.7, protocol 4
        b'...',
    ]
    u = self.uuid.UUID('d82579ce6642a0de7ddf490a7aec7aa5')
    u_safe = self.uuid.UUID('d82579ce6642a0de7ddf490a7aec7aa5', is_safe=self.uuid.SafeUUID.safe)
    u_unsafe = self.uuid.UUID('d82579ce6642a0de7ddf490a7aec7aa5', is_safe=self.uuid.SafeUUID.unsafe)
    with support.swap_item(sys.modules, 'uuid', self.uuid):
        for pickled in pickled_uuids:
            test_check(self, pickle.loads(pickled), u)
        for pickled in pickled_uuids_safe:
            test_check(self, pickle.loads(pickled), u_safe)
        for pickled in pickled_uuids_unsafe:
            test_check(self, pickle.loads(pickled), u_unsafe)"
-------------------------------------------------------------------------
"def test_pickle_roundtrip(self):
    def check(actual, expected):
        self.assertEqual(actual, expected)
        self.assertEqual(actual.is_safe, expected.is_safe)
    with support.swap_item(sys.modules, 'uuid', self.uuid):
        for is_safe in self.uuid.SafeUUID:
            u = self.uuid.UUID('d82579ce6642a0de7ddf490a7aec7aa5',
                               is_safe=is_safe)
            check(copy.copy(u), u)
            check(copy.deepcopy(u), u)
            for proto in range(pickle.HIGHEST_PROTOCOL  1):
                with self.subTest(protocol=proto):
                    check(pickle.loads(pickle.dumps(u, proto)), u)
def test_unpickle_previous_python_versions(self):
    def check(actual, expected):
        self.assertEqual(actual, expected)
        self.assertEqual(actual.is_safe, expected.is_safe)
    pickled_uuids = [
        # Python 2.7, protocol 0
        b'ccopy_reg\n_reconstructor\n(cuuid\nUUID\nc__builtin__\nobject\nN'
        b'tR(dS\'int\'\nL287307832597519156748809049798316161701L\nsb.',
        # Python 2.7, protocol 1
        b'ccopy_reg\n_reconstructor\n(cuuid\nUUID\nc__builtin__\nobject\nN'
        b'tR}U\x03intL287307832597519156748809049798316161701L\nsb.',
        # Python 2.7, protocol 2
        b'\x80\x02cuuid\nUUID\n)\x81}U\x03int\x8a\x11\xa5z\xecz\nI\xdf}'
        b'\xde\xa0Bf\xcey%\xd8\x00sb.',
        # Python 3.6, protocol 0
        b'ccopy_reg\n_reconstructor\n(cuuid\nUUID\nc__builtin__\nobject\nN'
        b'tR(dVint\nL287307832597519156748809049798316161701L\nsb.',
        # Python 3.6, protocol 1
        b'ccopy_reg\n_reconstructor\n(cuuid\nUUID\nc__builtin__\nobject\nN'
        b'tR}X\x03\x00\x00\x00intL287307832597519156748809049798316161701L'
        b'\nsb.',
        # Python 3.6, protocol 2
        b'\x80\x02cuuid\nUUID\n)\x81}X\x03\x00\x00\x00int\x8a\x11\xa5z\xec'
        b'z\nI\xdf}\xde\xa0Bf\xcey%\xd8\x00sb.',
        # Python 3.6, protocol 3
        b'\x80\x03cuuid\nUUID\n)\x81}X\x03\x00\x00\x00int\x8a\x11\xa5z\xec'
        b'z\nI\xdf}\xde\xa0Bf\xcey%\xd8\x00sb.',
        # Python 3.6, protocol 4
        b'\x80\x04\x95\x00\x00\x00\x00\x00\x00\x00\x8c\x04uuid\x8c\x04UUI'
        b'D\x93)\x81}\x8c\x03int\x8a\x11\xa5z\xecz\nI\xdf}\xde\xa0Bf\xcey%'
        b'\xd8\x00sb.',
        # Python 3.7, protocol 0
        b'ccopy_reg\n_reconstructor\n(cuuid\nUUID\nc__builtin__\nobject\nN'
        b'tR(dVint\nL287307832597519156748809049798316161701L\nsVis_safe\n'
        b'cuuid\nSafeUUID\n(NtRsb.',
        # Python 3.7, protocol 1
        b'ccopy_reg\n_reconstructor\n(cuuid\nUUID\nc__builtin__\nobject\nN'
        b'tR}(X\x03\x00\x00\x00intL287307832597519156748809049798316161701'
        b'L\nX\x07\x00\x00\x00is_safecuuid\nSafeUUID\n(NtRub.',
        # Python 3.7, protocol 2
        b'\x80\x02cuuid\nUUID\n)\x81}(X\x03\x00\x00\x00int\x8a\x11\xa5z'
        b'\xecz\nI\xdf}\xde\xa0Bf\xcey%\xd8\x00X\x07\x00\x00\x00is_safecuu'
        b'id\nSafeUUID\nN\x85Rub.',
        # Python 3.7, protocol 3
        b'\x80\x03cuuid\nUUID\n)\x81}(X\x03\x00\x00\x00int\x8a\x11\xa5z'
        b'\xecz\nI\xdf}\xde\xa0Bf\xcey%\xd8\x00X\x07\x00\x00\x00is_safecuu'
        b'id\nSafeUUID\nN\x85Rub.',
        # Python 3.7, protocol 4
        b'\x80\x04\x95F\x00\x00\x00\x00\x00\x00\x00\x8c\x04uuid\x94\x8c'
        b'\x04UUID\x93)\x81}(\x8c\x03int\x8a\x11\xa5z\xecz\nI\xdf}\xde\xa0'
        b'Bf\xcey%\xd8\x00\x8c\x07is_safeh\x00\x8c\x08SafeUUID\x93N\x85Rub'
        b'.',
    ]
    pickled_uuids_safe = [
        # Python 3.7, protocol 0
        b'ccopy_reg\n_reconstructor\n(cuuid\nUUID\nc__builtin__\nobject\nN'
        b'tR(dVint\nL287307832597519156748809049798316161701L\nsVis_safe\n'
        b'cuuid\nSafeUUID\n(I0\ntRsb.',
        # Python 3.7, protocol 1
        b'ccopy_reg\n_reconstructor\n(cuuid\nUUID\nc__builtin__\nobject\nN'
        b'tR}(X\x03\x00\x00\x00intL287307832597519156748809049798316161701'
        b'L\nX\x07\x00\x00\x00is_safecuuid\nSafeUUID\n(K\x00tRub.',
        # Python 3.7, protocol 2
        b'\x80\x02cuuid\nUUID\n)\x81}(X\x03\x00\x00\x00int\x8a\x11\xa5z'
        b'\xecz\nI\xdf}\xde\xa0Bf\xcey%\xd8\x00X\x07\x00\x00\x00is_safecuu'
        b'id\nSafeUUID\nK\x00\x85Rub.',
        # Python 3.7, protocol 3
        b'\x80\x03cuuid\nUUID\n)\x81}(X\x03\x00\x00\x00int\x8a\x11\xa5z'
        b'\xecz\nI\xdf}\xde\xa0Bf\xcey%\xd8\x00X\x07\x00\x00\x00is_safecuu'
        b'id\nSafeUUID\nK\x00\x85Rub.',
        # Python 3.7, protocol 4
        b'\x80\x04\x95G\x00\x00\x00\x00\x00\x00\x00\x8c\x04uuid\x94\x8c'
        b'\x04UUID\x93)\x81}(\x8c\x03int\x8a\x11\xa5z\xecz\nI\xdf}\xde\xa0'
        b'Bf\xcey%\xd8\x00\x8c\x07is_safeh\x00\x8c\x08SafeUUID\x93K\x00'
        b'\x85Rub.',
    ]
    pickled_uuids_unsafe = [
        # Python 3.7, protocol 0
        b'ccopy_reg\n_reconstructor\n(cuuid\nUUID\nc__builtin__\nobject\nN'
        b'tR(dVint\nL287307832597519156748809049798316161701L\nsVis_safe\n'
        b'cuuid\nSafeUUID\n(I-1\ntRsb.',
        # Python 3.7, protocol 1
        b'ccopy_reg\n_reconstructor\n(cuuid\nUUID\nc__builtin__\nobject\nN'
        b'tR}(X\x03\x00\x00\x00intL287307832597519156748809049798316161701'
        b'L\nX\x07\x00\x00\x00is_safecuuid\nSafeUUID\n(J\xff\xff\xff\xfftR'
        b'ub.',
        # Python 3.7, protocol 2
        b'\x80\x02cuuid\nUUID\n)\x81}(X\x03\x00\x00\x00int\x8a\x11\xa5z'
        b'\xecz\nI\xdf}\xde\xa0Bf\xcey%\xd8\x00X\x07\x00\x00\x00is_safecuu'
        b'id\nSafeUUID\nJ\xff\xff\xff\xff\x85Rub.',
        # Python 3.7, protocol 3
        b'\x80\x03cuuid\nUUID\n)\x81}(X\x03\x00\x00\x00int\x8a\x11\xa5z'
        b'\xecz\nI\xdf}\xde\xa0Bf\xcey%\xd8\x00X\x07\x00\x00\x00is_safecuu'
        b'id\nSafeUUID\nJ\xff\xff\xff\xff\x85Rub.',
        # Python 3.7, protocol 4
        b'\x80\x04\x95J\x00\x00\x00\x00\x00\x00\x00\x8c\x04uuid\x94\x8c'
        b'\x04UUID\x93)\x81}(\x8c\x03int\x8a\x11\xa5z\xecz\nI\xdf}\xde\xa0'
        b'Bf\xcey%\xd8\x00\x8c\x07is_safeh\x00\x8c\x08SafeUUID\x93J\xff'
        b'\xff\xff\xff\x85Rub.',
    ]
    u = self.uuid.UUID('d82579ce6642a0de7ddf490a7aec7aa5')
    u_safe = self.uuid.UUID('d82579ce6642a0de7ddf490a7aec7aa5',
                            is_safe=self.uuid.SafeUUID.safe)
    u_unsafe = self.uuid.UUID('d82579ce6642a0de7ddf490a7aec7aa5',
                              is_safe=self.uuid.SafeUUID.unsafe)
    with support.swap_item(sys.modules, 'uuid', self.uuid):
        for pickled in pickled_uuids:
            # is_safe was added in 3.7.  When unpickling values from older
            # versions, is_safe will be missing, so it should be set to
            # SafeUUID.unknown.
            check(pickle.loads(pickled), u)
        for pickled in pickled_uuids_safe:
            check(pickle.loads(pickled), u_safe)
        for pickled in pickled_uuids_unsafe:
            check(pickle.loads(pickled), u_unsafe)
"
-------------------------------------------------------------------------
"Recom
PRs: 9106, 9133"
-------------------------------------------------------------------------
=========================================================================
"d = {'int': self.int}
if self.is_safe != SafeUUID.unknown:
    # is_safe is a SafeUUID instance.  Return just its value, so that
    # it can be un-pickled in older Python versions without SafeUUID.
    d['is_safe'] = self.is_safe.value
object.__setattr__(self, 'int', state['int'])
# is_safe was added in 3.7; it is also omitted when it is ""unknown""
object.__setattr__(self, 'is_safe',
                   SafeUUID(state['is_safe'])
                   if 'is_safe' in state else SafeUUID.unknown)
"
-------------------------------------------------------------------------
"d = {'int': self.int}
if self.is_safe != SafeUUID.unknown:
    d['is_safe'] = self.is_safe.value
object.__setattr__(self, 'int', state['int'])
object.__setattr__(self, 'is_safe',
                   SafeUUID(state['is_safe'])
                   if 'is_safe' in state else SafeUUID.unknown)"
-------------------------------------------------------------------------
"def __getstate__(self):
    state = self.__dict__
    if self.is_safe != SafeUUID.unknown:
        # is_safe is a SafeUUID instance.  Return just its value, so that
        # it can be un-pickled in older Python versions without SafeUUID.
        state = state.copy()
        state['is_safe'] = self.is_safe.value
    return state
def __setstate__(self, state):
    self.__dict__.update(state)
    # is_safe was added in 3.7; it is also omitted when it is ""unknown""
    self.__dict__['is_safe'] = (
        SafeUUID(state['is_safe'])
        if 'is_safe' in state else SafeUUID.unknown
    )
"
-------------------------------------------------------------------------
"Recom
PRs: 9106, 9133"
-------------------------------------------------------------------------
=========================================================================
"# bpo-32502: UUID1 requires a 48-bit identifier, but hardware identifiers
# need not necessarily be 48 bits (e.g., EUI-64).
def test_uuid1_eui64(self):
    # Confirm that uuid.getnode ignores hardware addresses larger than 48
    # bits. Mock out each platform's *_getnode helper functions to return
    # something just larger than 48 bits to test. This will cause
    # uuid.getnode to fall back on uuid._random_getnode, which will
    # generate a valid value.
    too_large_getter = lambda: 1 << 48
    with unittest.mock.patch.multiple(
        self.uuid,
        _node=None,  # Ignore any cached node value.
        _NODE_GETTERS_WIN32=[too_large_getter],
        _NODE_GETTERS_UNIX=[too_large_getter],
    ):
        node = self.uuid.getnode()
    self.assertTrue(0 < node < (1 << 48), '%012x' % node)
    # Confirm that uuid1 can use the generated node, i.e., the that
    # uuid.getnode fell back on uuid._random_getnode() rather than using
    # the value from too_large_getter above.
    try:
        self.uuid.uuid1(node=node)
    except ValueError as e:
        self.fail('uuid1 was given an invalid node ID')
"
-------------------------------------------------------------------------
"# bpo-32502: UUID1 requires a 48-bit identifier, but hardware identifiers
# need not necessarily be 48 bits (e.g., EUI-64).
def test_getnode(self):
    too_large_getter = lambda: 1 << 48
    with unittest.mock.patch.multiple(
        self.uuid,
        _node=None,  # Ignore any cached node value.
        _NODE_GETTERS_WIN32=[too_large_getter],
        _NODE_GETTERS_UNIX=[too_large_getter],
    ):
        node1 = self.uuid.getnode()
    self.assertTrue(0 < node1 < (1 << 48), '%012x' % node1)
    # Confirm that uuid.getnode ignores hardware addresses larger than 48
    # bits. Mock out each platform's *_getnode helper functions to return
    # something just larger than 48 bits to test. This will cause
    # uuid.getnode to fall back on uuid._random_getnode, which will
    # generate a valid value.
    def test_uuid1_eui64(self):
        equal = self.assertEqual
        node2 = self.uuid.getnode()
        equal(node1, node2, '%012x != %012x' % (node1, node2))"
-------------------------------------------------------------------------
"# bpo-32502: UUID1 requires a 48-bit identifier, but hardware identifiers
# need not necessarily be 48 bits (e.g., EUI-64).
def test_uuid1_eui64(self):
    # Confirm that uuid.getnode ignores hardware addresses larger than 48
    # bits. Mock out each platform's *_getnode helper functions to return
    # something just larger than 48 bits to test. This will cause
    # uuid.getnode to fall back on uuid._random_getnode, which will
    # generate a valid value.
    too_large_getter = lambda: 1 << 48
    with unittest.mock.patch.multiple(
        uuid,
        _node=None,  # Ignore any cached node value.
        _NODE_GETTERS_WIN32=[too_large_getter],
        _NODE_GETTERS_UNIX=[too_large_getter],
    ):
        node = uuid.getnode()
    self.assertTrue(0 < node < (1 << 48), '%012x' % node)
    # Confirm that uuid1 can use the generated node, i.e., the that
    # uuid.getnode fell back on uuid._random_getnode() rather than using
    # the value from too_large_getter above.
    try:
        uuid.uuid1(node=node)
    except ValueError as e:
        self.fail('uuid1 was given an invalid node ID')
"
-------------------------------------------------------------------------
"Recom
PRs: 5254, 5290"
-------------------------------------------------------------------------
=========================================================================
"_NODE_GETTERS_WIN32 = [_windll_getnode, _netbios_getnode, _ipconfig_getnode]
_NODE_GETTERS_UNIX = [_unix_getnode, _ifconfig_getnode, _ip_getnode,
                      _arp_getnode, _lanscan_getnode, _netstat_getnode]
def getnode(*, getters=None):
"
-------------------------------------------------------------------------
"_NODE_GETTERS_WIN32 = [_windll_getnode, _netbios_getnode, _ipconfig_getnode]
_NODE_GETTERS_UNIX = [_unix_getnode, _ifconfig_getnode, _ip_getnode,
                      _arp_getnode, _lanscan_getnode, _netstat_getnode]
def _random_getnode(*, getters=None):
"
-------------------------------------------------------------------------
"_NODE_GETTERS_WIN32 = [_windll_getnode, _netbios_getnode, _ipconfig_getnode]
_NODE_GETTERS_UNIX = [_unixdll_getnode, _ifconfig_getnode, _ip_getnode,
                      _arp_getnode, _lanscan_getnode, _netstat_getnode]
"
-------------------------------------------------------------------------
"Recom
PRs: 5254, 5290"
-------------------------------------------------------------------------
=========================================================================
"getters = _NODE_GETTERS_WIN32
getters = _NODE_GETTERS_UNIX
if (_node is not None) and (0 <= _node < (1 << 48)):
rt False, '_random_getnode() returned invalid value: {}'.format(_node)
"
-------------------------------------------------------------------------
"getters = _NODE_GETTERS_WIN32
getters = _NODE_GETTERS_UNIX

if (_node is not None) and (0 <= _node < (1 << 48)):
    return False, '_random_getnode() returned invalid value: {}'.format(_node)"
-------------------------------------------------------------------------
"getters = _NODE_GETTERS_WIN32
getters = _NODE_GETTERS_UNIX
if (_node is not None) and (0 <= _node < (1 << 48)):
rt False, '_random_getnode() returned invalid value: {}'.format(_node)
"
-------------------------------------------------------------------------
"Recom
PRs: 5254, 5290"
-------------------------------------------------------------------------
=========================================================================
"folded.stickyspace = str(ws)
"
-------------------------------------------------------------------------
folded.sticky_space = str(ws)
-------------------------------------------------------------------------
"folded.stickyspace = str(ws)
"
-------------------------------------------------------------------------
"Recom
PRs: 1892, 2592"
-------------------------------------------------------------------------
=========================================================================
"def test_long_filename_attachment(self):
    folded = self.policy.fold('Content-Disposition', 'attachment; filename=""TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TES.txt""')
    self.assertEqual(
        'Content-Disposition: attachment;\n filename=""TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TES.txt""\n',
        folded
    )
    folded = self.policy.fold('Content-Disposition', 'attachment; filename=""TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_T.txt""')
    self.assertEqual(
        'Content-Disposition: attachment;\n filename=""TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_T.txt""\n',
        folded
    )
"
-------------------------------------------------------------------------
"def test_long_filename_attachment(self):
    folded = self.policy.fold('Content-Disposition', 'attachment; filename=""TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TES.txt""')
    self.assertEqual(
        'Content-Disposition: attachment;\n filename=""TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TES.txt""\n',
        folded
    )
    folded = self.policy.fold('Content-Disposition', 'attachment; filename=""TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_T.txt""')
    self.assertEqual(
        'Content-Disposition: attachment;\n filename=""TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_T.txt""\n',
        folded
    )"
-------------------------------------------------------------------------
"def test_long_filename_attachment(self):
    folded = self.policy.fold('Content-Disposition', 'attachment; filename=""TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TES.txt""')
    self.assertEqual(
        'Content-Disposition: attachment;\n filename=""TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TES.txt""\n',
        folded
    )
    folded = self.policy.fold('Content-Disposition', 'attachment; filename=""TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_T.txt""')
    self.assertEqual(
        'Content-Disposition: attachment;\n filename=""TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_T.txt""\n',
        folded
    )
"
-------------------------------------------------------------------------
"Recom
PRs: 1892, 2592"
-------------------------------------------------------------------------
=========================================================================
"folded.stickyspace = str(ws)
"
-------------------------------------------------------------------------
folded.stickyspace = str(ws) 
-------------------------------------------------------------------------
"folded.stickyspace = str(ws)
"
-------------------------------------------------------------------------
"Recom
PRs: 1892, 2591"
-------------------------------------------------------------------------
=========================================================================
"def test_long_filename_attachment(self):
    folded = self.policy.fold('Content-Disposition', 'attachment; filename=""TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TES.txt""')
    self.assertEqual(
        'Content-Disposition: attachment;\n filename=""TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TES.txt""\n',
        folded
    )
    folded = self.policy.fold('Content-Disposition', 'attachment; filename=""TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_T.txt""')
    self.assertEqual(
        'Content-Disposition: attachment;\n filename=""TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_T.txt""\n',
        folded
    )
"
-------------------------------------------------------------------------
"def test_long_filename_attachment(self):
    folded = self.policy.fold('Content-Disposition', 'attachment; filename=""TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TES.txt""')
    self.assertEqual(
        'Content-Disposition: attachment;\n filename=""TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TES.txt""\n',
        folded
    )
    folded = self.policy.fold('Content-Disposition', 'attachment; filename=""TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_T.txt""')
    self.assertEqual(
        'Content-Disposition: attachment;\n filename=""TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_T.txt""\n',
        folded
    )"
-------------------------------------------------------------------------
"def test_long_filename_attachment(self):
    folded = self.policy.fold('Content-Disposition', 'attachment; filename=""TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TES.txt""')
    self.assertEqual(
        'Content-Disposition: attachment;\n filename=""TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TES.txt""\n',
        folded
    )
    folded = self.policy.fold('Content-Disposition', 'attachment; filename=""TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_T.txt""')
    self.assertEqual(
        'Content-Disposition: attachment;\n filename=""TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_TEST_T.txt""\n',
        folded
    )
"
-------------------------------------------------------------------------
"Recom
PRs: 1892, 2591"
-------------------------------------------------------------------------
=========================================================================
"import abc
"
-------------------------------------------------------------------------
"```python
import abc
```"
-------------------------------------------------------------------------
"import abc
"
-------------------------------------------------------------------------
"Recom
PRs: 678, 1979"
-------------------------------------------------------------------------
=========================================================================
"if not isinstance(object, type):
    return False
if object.__flags__ & TPFLAGS_IS_ABSTRACT:
    return True
if not issubclass(type(object), abc.ABCMeta):
    return False
if hasattr(object, '__abstractmethods__'):
    # It looks like ABCMeta.__new__ has finished running;
    # TPFLAGS_IS_ABSTRACT should have been accurate.
    return False
# It looks like ABCMeta.__new__ has not finished running yet; we're
# probably in __init_subclass__. We'll look for abstractmethods manually.
for name, value in object.__dict__.items():
    if getattr(value, ""__isabstractmethod__"", False):
        return True
for base in object.__bases__:
    for name in getattr(base, ""__abstractmethods__"", ()):
        value = getattr(object, name, None)
        if getattr(value, ""__isabstractmethod__"", False):
            return True
return False
"
-------------------------------------------------------------------------
"def isabstract(object):
    """"""Return true if the object is an abstract base class (ABC).""""""
        
    if not isinstance(object, type):
        return False
    if object.__flags__ & TPFLAGS_IS_ABSTRACT:
        return True
    if not issubclass(type(object), abc.ABCMeta):
        return False
    if hasattr(object, '__abstractmethods__'):
        # It looks like ABCMeta.__new__ has finished running;
        # TPFLAGS_IS_ABSTRACT should have been accurate.
        return False
    # It looks like ABCMeta.__new__ has not finished running yet; we're
    # probably in __init_subclass__. We'll look for abstractmethods manually.
    for name, value in object.__dict__.items():
        if getattr(value, ""__isabstractmethod__"", False):
            return True
    for base in object.__bases__:
        for name in getattr(base, ""__abstractmethods__"", ()):
            value = getattr(object, name, None)
            if getattr(value, ""__isabstractmethod__"", False):
                return True
    return False"
-------------------------------------------------------------------------
"if not isinstance(object, type):
    return False
if object.__flags__ & TPFLAGS_IS_ABSTRACT:
    return True
if not issubclass(type(object), abc.ABCMeta):
    return False
if hasattr(object, '__abstractmethods__'):
    # It looks like ABCMeta.__new__ has finished running;
    # TPFLAGS_IS_ABSTRACT should have been accurate.
    return False
# It looks like ABCMeta.__new__ has not finished running yet; we're
# probably in __init_subclass__. We'll look for abstractmethods manually.
for name, value in object.__dict__.items():
    if getattr(value, ""__isabstractmethod__"", False):
        return True
for base in object.__bases__:
    for name in getattr(base, ""__abstractmethods__"", ()):
        value = getattr(object, name, None)
        if getattr(value, ""__isabstractmethod__"", False):
            return True
return False
"
-------------------------------------------------------------------------
"Recom
PRs: 678, 1979"
-------------------------------------------------------------------------
=========================================================================
"def test_isabstract_during_init_subclass(self):
    from abc import ABCMeta, abstractmethod
    isabstract_checks = []
    class AbstractChecker(metaclass=ABCMeta):
        def __init_subclass__(cls):
            isabstract_checks.append(inspect.isabstract(cls))
    class AbstractClassExample(AbstractChecker):
        @abstractmethod
        def foo(self):
            pass
    class ClassExample(AbstractClassExample):
        def foo(self):
            pass
    self.assertEqual(isabstract_checks, [True, False])
    isabstract_checks.clear()
    class AbstractChild(AbstractClassExample):
        pass
    class AbstractGrandchild(AbstractChild):
        pass
    class ConcreteGrandchild(ClassExample):
        pass
    self.assertEqual(isabstract_checks, [True, True, False])
"
-------------------------------------------------------------------------
"def foo(self):
    self.assertFalse(inspect.isabstract(int))
    self.assertFalse(inspect.isabstract(5))
    from abc import ABCMeta, abstractmethod
    isabstract_checks = []
    class AbstractChecker(metaclass=ABCMeta):
        def __init_subclass__(cls):
            isabstract_checks.append(inspect.isabstract(cls))
    class AbstractClassExample(AbstractChecker):
        @abstractmethod
        def foo(self):
            pass
    class ClassExample(AbstractClassExample):
        def foo(self):
            pass
    self.assertEqual(isabstract_checks, [True, False])
    isabstract_checks.clear()
    class AbstractChild(AbstractClassExample):
        pass
    class AbstractGrandchild(AbstractChild):
        pass
    class ConcreteGrandchild(ClassExample):
        pass
    self.assertEqual(isabstract_checks, [True, True, False])"
-------------------------------------------------------------------------
"def test_isabstract_during_init_subclass(self):
    from abc import ABCMeta, abstractmethod
    isabstract_checks = []
    class AbstractChecker(metaclass=ABCMeta):
        def __init_subclass__(cls):
            isabstract_checks.append(inspect.isabstract(cls))
    class AbstractClassExample(AbstractChecker):
        @abstractmethod
        def foo(self):
            pass
    class ClassExample(AbstractClassExample):
        def foo(self):
            pass
    self.assertEqual(isabstract_checks, [True, False])
    isabstract_checks.clear()
    class AbstractChild(AbstractClassExample):
        pass
    class AbstractGrandchild(AbstractChild):
        pass
    class ConcreteGrandchild(ClassExample):
        pass
    self.assertEqual(isabstract_checks, [True, True, False])
"
-------------------------------------------------------------------------
"Recom
PRs: 678, 1979"
-------------------------------------------------------------------------
=========================================================================
"self.close()
"
-------------------------------------------------------------------------
self.close()
-------------------------------------------------------------------------
"self.close()
"
-------------------------------------------------------------------------
"Recom
PRs: 1700, 1790"
-------------------------------------------------------------------------
=========================================================================
"self.close()
"
-------------------------------------------------------------------------
self.quit()
-------------------------------------------------------------------------
"self.close()
"
-------------------------------------------------------------------------
"Recom
PRs: 1700, 1789"
-------------------------------------------------------------------------
=========================================================================
"flags = re.sub(r'-arch\s\w\s', ' ', flags, flags=re.ASCII)
"
-------------------------------------------------------------------------
"flags = re.sub(r'-arch\s\w\s', ' ', flags, flags=re.ASCII | re.UNICODE)"
-------------------------------------------------------------------------
"flags = re.sub(r'-arch\s\w\s', ' ', flags, flags=re.ASCII)
"
-------------------------------------------------------------------------
"Recom
PRs: 1134, 1137"
-------------------------------------------------------------------------
=========================================================================
"flags = re.sub(r'-arch\s\w\s', ' ', flags, flags=re.ASCII)
"
-------------------------------------------------------------------------
"flags = re.sub(r'-arch\s\w\s', ' ', flags, flags=re.ASCII)"
-------------------------------------------------------------------------
"flags = re.sub(r'-arch\s\w\s', ' ', flags, flags=re.ASCII)
"
-------------------------------------------------------------------------
"Recom
PRs: 1134, 1135"
-------------------------------------------------------------------------
=========================================================================
"co_argcount         number of arguments (not including *, ** args
                    or keyword only arguments)
co_code             string of raw compiled bytecode
co_cellvars         tuple of names of cell variables
co_consts           tuple of constants used in the bytecode
co_filename         name of file in which this code object was created
co_firstlineno      number of first line in Python source code
co_flags            bitmap: 1=optimized | 2=newlocals | 4=*arg | 8=**arg
                    | 16=nested | 32=generator | 64=nofree | 128=coroutine
                    | 256=iterable_coroutine | 512=async_generator
co_freevars         tuple of names of free variables
co_kwonlyargcount   number of keyword only arguments (not including ** arg)
co_lnotab           encoded mapping of line numbers to bytecode indices
co_name             name with which this code object was defined
co_names            tuple of names of local variables
co_nlocals          number of local variables
co_stacksize        virtual machine stack space required
co_varnames         tuple of names of arguments and local variables""""""
"
-------------------------------------------------------------------------
"co_argcount         number of arguments (not including *, ** args)
co_code             string of raw compiled bytecode
co_cellvars         tuple of names of cell variables
co_consts           tuple of constants used in the bytecode
co_filename         name of file in which this code object was created
co_firstlineno      number of first line in Python source code
co_flags            bitmap: 1=optimized | 2=newlocals | 4=*arg | 8=**arg | 16=nested | 32=generator | 64=nofree | 128=coroutine | 256=iterable_coroutine | 512=async_generator
co_freevars         tuple of names of free variables
co_kwonlyargcount   number of keyword only arguments (not including ** arg)
co_lnotab           encoded mapping of line numbers to bytecode indices
co_name             name with which this code object was defined
co_names            tuple of names of local variables
co_nlocals          number of local variables
co_stacksize        virtual machine stack space required
co_varnames         tuple of names of arguments and local variables"
-------------------------------------------------------------------------
"co_argcount         number of arguments (not including *, ** args
                    or keyword only arguments)
co_code             string of raw compiled bytecode
co_cellvars         tuple of names of cell variables
co_consts           tuple of constants used in the bytecode
co_filename         name of file in which this code object was created
co_firstlineno      number of first line in Python source code
co_flags            bitmap: 1=optimized | 2=newlocals | 4=*arg | 8=**arg
                    | 16=nested | 32=generator | 64=nofree | 128=coroutine
                    | 256=iterable_coroutine
co_freevars         tuple of names of free variables
co_kwonlyargcount   number of keyword only arguments (not including ** arg)
co_lnotab           encoded mapping of line numbers to bytecode indices
co_name             name with which this code object was defined
co_names            tuple of names of local variables
co_nlocals          number of local variables
co_stacksize        virtual machine stack space required
co_varnames         tuple of names of arguments and local variables""""""
"
-------------------------------------------------------------------------
"Recom
PRs: 1090, 1100"
-------------------------------------------------------------------------
=========================================================================
"co_argcount         number of arguments (not including *, ** args
                    or keyword only arguments)
co_code             string of raw compiled bytecode
co_cellvars         tuple of names of cell variables
co_consts           tuple of constants used in the bytecode
co_filename         name of file in which this code object was created
co_firstlineno      number of first line in Python source code
co_flags            bitmap: 1=optimized | 2=newlocals | 4=*arg | 8=**arg
                    | 16=nested | 32=generator | 64=nofree | 128=coroutine
                    | 256=iterable_coroutine | 512=async_generator
co_freevars         tuple of names of free variables
co_kwonlyargcount   number of keyword only arguments (not including ** arg)
co_lnotab           encoded mapping of line numbers to bytecode indices
co_name             name with which this code object was defined
co_names            tuple of names of local variables
co_nlocals          number of local variables
co_stacksize        virtual machine stack space required
co_varnames         tuple of names of arguments and local variables""""""
"
-------------------------------------------------------------------------
"```python
def iscode(object):
    """"""Return true if the object is a code object.

    Code objects provide these attributes:
    """"""
    return isinstance(object, types.CodeType)
```"
-------------------------------------------------------------------------
"co_argcount         number of arguments (not including *, ** args
                    or keyword only arguments)
co_code             string of raw compiled bytecode
co_cellvars         tuple of names of cell variables
co_consts           tuple of constants used in the bytecode
co_filename         name of file in which this code object was created
co_firstlineno      number of first line in Python source code
co_flags            bitmap: 1=optimized | 2=newlocals | 4=*arg | 8=**arg
                    | 16=nested | 32=generator | 64=nofree | 128=coroutine
                    | 256=iterable_coroutine | 512=async_generator
co_freevars         tuple of names of free variables
co_kwonlyargcount   number of keyword only arguments (not including ** arg)
co_lnotab           encoded mapping of line numbers to bytecode indices
co_name             name with which this code object was defined
co_names            tuple of names of local variables
co_nlocals          number of local variables
co_stacksize        virtual machine stack space required
co_varnames         tuple of names of arguments and local variables""""""
"
-------------------------------------------------------------------------
"Recom
PRs: 1090, 1099"
-------------------------------------------------------------------------
=========================================================================
"if wrap_exception and func is not _helper_reraises_exception:
"
-------------------------------------------------------------------------
         if wrap_exception and func is not _helper_reraises_exception:
-------------------------------------------------------------------------
"if wrap_exception and func is not _helper_reraises_exception:
"
-------------------------------------------------------------------------
"Recom
PRs: 693, 884"
-------------------------------------------------------------------------
=========================================================================
"def _helper_reraises_exception(ex):
    'Pickle-able helper function for use by _guarded_task_generation.'
    raise ex
"
-------------------------------------------------------------------------
"```
def _helper_reraises_exception(ex):
    raise ex
```"
-------------------------------------------------------------------------
"def _helper_reraises_exception(ex):
    'Pickle-able helper function for use by _guarded_task_generation.'
    raise ex
"
-------------------------------------------------------------------------
"Recom
PRs: 693, 884"
-------------------------------------------------------------------------
=========================================================================
"def _guarded_task_generation(self, result_job, func, iterable):
    '''Provides a generator of tasks for imap and imap_unordered with
    appropriate handling for iterables which throw exceptions during
    iteration.'''
    try:
        i = -1
        for i, x in enumerate(iterable):
            yield (result_job, i, func, (x,), {})
    except Exception as e:
        yield (result_job, i1, _helper_reraises_exception, (e,), {})
"
-------------------------------------------------------------------------
"def _guarded_task_generation(self, result_job, func, iterable):
    '''
    Provides a generator of tasks for imap and imap_unordered with
    appropriate handling for iterables which throw exceptions during
    iteration.
    '''
    try:
        i = -1
        for i, x in enumerate(iterable):
            yield (result_job, i, func, (x,), {})
    except Exception as e:
        yield (result_job, i, _helper_reraises_exception, (e,), {})"
-------------------------------------------------------------------------
"def _guarded_task_generation(self, result_job, func, iterable):
    '''Provides a generator of tasks for imap and imap_unordered with
    appropriate handling for iterables which throw exceptions during
    iteration.'''
    try:
        i = -1
        for i, x in enumerate(iterable):
            yield (result_job, i, func, (x,), {})
    except Exception as e:
        yield (result_job, i1, _helper_reraises_exception, (e,), {})
"
-------------------------------------------------------------------------
"Recom
PRs: 693, 884"
-------------------------------------------------------------------------
=========================================================================
"self._taskqueue.put(
    (
        self._guarded_task_generation(result._job, func, iterable),
        result._set_length
    ))
self._taskqueue.put(
    (
        self._guarded_task_generation(result._job,
                                      mapstar,
                                      task_batches),
        result._set_length
    ))
"
-------------------------------------------------------------------------
"self._taskqueue.put(
    (
        self._guarded_task_generation(result._job, func, iterable),
        result._set_length
    ))
self._taskqueue.put(
    (
        self._guarded_task_generation(result._job,
                                      func,
                                      iterable),
        result._set_length
    ))"
-------------------------------------------------------------------------
"self._taskqueue.put(
    (
        self._guarded_task_generation(result._job, func, iterable),
        result._set_length
    ))
self._taskqueue.put(
    (
        self._guarded_task_generation(result._job,
                                      mapstar,
                                      task_batches),
        result._set_length
    ))
"
-------------------------------------------------------------------------
"Recom
PRs: 693, 884"
-------------------------------------------------------------------------
=========================================================================
"self._taskqueue.put(
    (
        self._guarded_task_generation(result._job, func, iterable),
        result._set_length
    ))
self._taskqueue.put(
    (
        self._guarded_task_generation(result._job,
                                      mapstar,
                                      task_batches),
        result._set_length
    ))
"
-------------------------------------------------------------------------
"self._taskqueue.put(
    (
        self._guarded_task_generation(result._job, func, iterable),
        result._set_length
    ))
self._taskqueue.put(
    (
        self._guarded_task_generation(result._job,
                                      imap_unordered,
                                      task_batches),
        result._set_length
    ))"
-------------------------------------------------------------------------
"self._taskqueue.put(
    (
        self._guarded_task_generation(result._job, func, iterable),
        result._set_length
    ))
self._taskqueue.put(
    (
        self._guarded_task_generation(result._job,
                                      mapstar,
                                      task_batches),
        result._set_length
    ))
"
-------------------------------------------------------------------------
"Recom
PRs: 693, 884"
-------------------------------------------------------------------------
=========================================================================
"self._taskqueue.put(([(result._job, 0, func, args, kwds)], None))
"
-------------------------------------------------------------------------
"self._taskqueue.put(([(result._job, 0, func, args, kwds)], None))"
-------------------------------------------------------------------------
"self._taskqueue.put(([(result._job, 0, func, args, kwds)], None))
"
-------------------------------------------------------------------------
"Recom
PRs: 693, 884"
-------------------------------------------------------------------------
=========================================================================
"self._taskqueue.put(
    (
        self._guarded_task_generation(result._job,
                                      mapper,
                                      task_batches),
        None
    )
)
"
-------------------------------------------------------------------------
"pyqueue.put(
            (
                self._guarded_task_generation(result._job,
                                              mapper,
                                              task_batches),
                None
            )
        )"
-------------------------------------------------------------------------
"self._taskqueue.put(
    (
        self._guarded_task_generation(result._job,
                                      mapper,
                                      task_batches),
        None
    )
)
"
-------------------------------------------------------------------------
"Recom
PRs: 693, 884"
-------------------------------------------------------------------------
=========================================================================
"# iterating taskseq cannot fail
for task in taskseq:
        job, idx = task[:2]
            cache[job]._set(idx, (False, e))
        idx = task[1] if task else -1
        set_length(idx  1)
"
-------------------------------------------------------------------------
"# iterating taskseq cannot fail
for task in taskseq:
    job, idx = task[:2]
    cache[job]._set(idx, (False, e))
    idx = task[1] if task else -1
    set_length(idx + 1)"
-------------------------------------------------------------------------
"# iterating taskseq cannot fail
for task in taskseq:
        job, idx = task[:2]
            cache[job]._set(idx, (False, e))
        idx = task[1] if task else -1
        set_length(idx  1)
"
-------------------------------------------------------------------------
"Recom
PRs: 693, 884"
-------------------------------------------------------------------------
=========================================================================
"if when == -1:
    raise SayWhenError(""Somebody said when"")
"
-------------------------------------------------------------------------
"Change the line to: 

```python
if when == -1:
    raise SayWhenError(""Somebody said when"")
```"
-------------------------------------------------------------------------
"if when == -1:
    raise SayWhenError(""Somebody said when"")
"
-------------------------------------------------------------------------
"Recom
PRs: 693, 884"
-------------------------------------------------------------------------
=========================================================================
"def test_map_handle_iterable_exception(self):
    if self.TYPE == 'manager':
        self.skipTest('test not appropriate for {}'.format(self.TYPE))
    # SayWhenError seen at the very first of the iterable
    with self.assertRaises(SayWhenError):
        self.pool.map(sqr, exception_throwing_generator(1, -1), 1)
    # again, make sure it's reentrant
    with self.assertRaises(SayWhenError):
        self.pool.map(sqr, exception_throwing_generator(1, -1), 1)
    with self.assertRaises(SayWhenError):
        self.pool.map(sqr, exception_throwing_generator(10, 3), 1)
    class SpecialIterable:
        def __iter__(self):
            return self
        def __next__(self):
            raise SayWhenError
        def __len__(self):
            return 1
    with self.assertRaises(SayWhenError):
        self.pool.map(sqr, SpecialIterable(), 1)
    with self.assertRaises(SayWhenError):
        self.pool.map(sqr, SpecialIterable(), 1)
"
-------------------------------------------------------------------------
"def test_map_handle_iterable_exception(self):
    if self.TYPE == 'manager':
        self.skipTest('test not appropriate for {}'.format(self.TYPE))
    # SayWhenError seen at the very first of the iterable
    with self.assertRaises(SayWhenError):
        self.pool.map(sqr, exception_throwing_generator(1, -1), 1)
    # again, make sure it's reentrant
    with self.assertRaises(SayWhenError):
        self.pool.map(sqr, exception_throwing_generator(1, -1), 1)
    with self.assertRaises(SayWhenError):
        self.pool.map(sqr, exception_throwing_generator(10, 3), 1)
    class SpecialIterable:
        def __iter__(self):
            return self
        def __next__(self):
            raise SayWhenError
        def __len__(self):
            return 1
    with self.assertRaises(SayWhenError):
        self.pool.map(sqr, SpecialIterable(), 1)
    with self.assertRaises(SayWhenError):
        self.pool.map(sqr, SpecialIterable(), 1)"
-------------------------------------------------------------------------
"def test_map_handle_iterable_exception(self):
    if self.TYPE == 'manager':
        self.skipTest('test not appropriate for {}'.format(self.TYPE))
    # SayWhenError seen at the very first of the iterable
    with self.assertRaises(SayWhenError):
        self.pool.map(sqr, exception_throwing_generator(1, -1), 1)
    # again, make sure it's reentrant
    with self.assertRaises(SayWhenError):
        self.pool.map(sqr, exception_throwing_generator(1, -1), 1)
    with self.assertRaises(SayWhenError):
        self.pool.map(sqr, exception_throwing_generator(10, 3), 1)
    class SpecialIterable:
        def __iter__(self):
            return self
        def __next__(self):
            raise SayWhenError
        def __len__(self):
            return 1
    with self.assertRaises(SayWhenError):
        self.pool.map(sqr, SpecialIterable(), 1)
    with self.assertRaises(SayWhenError):
        self.pool.map(sqr, SpecialIterable(), 1)
"
-------------------------------------------------------------------------
"Recom
PRs: 693, 884"
-------------------------------------------------------------------------
=========================================================================
"# SayWhenError seen at the very first of the iterable
it = self.pool.imap(sqr, exception_throwing_generator(1, -1), 1)
self.assertRaises(SayWhenError, it.__next__)
# again, make sure it's reentrant
it = self.pool.imap(sqr, exception_throwing_generator(1, -1), 1)
self.assertRaises(SayWhenError, it.__next__)
"
-------------------------------------------------------------------------
"it = self.pool.imap(sqr, exception_throwing_generator(1, -1), 1)
self.assertRaises(SayWhenError, it.__next__)

# make sure it's reentrant
it = self.pool.imap(sqr, exception_throwing_generator(1, -1), 1)
self.assertRaises(SayWhenError, it.__next__)"
-------------------------------------------------------------------------
"# SayWhenError seen at the very first of the iterable
it = self.pool.imap(sqr, exception_throwing_generator(1, -1), 1)
self.assertRaises(SayWhenError, it.__next__)
# again, make sure it's reentrant
it = self.pool.imap(sqr, exception_throwing_generator(1, -1), 1)
self.assertRaises(SayWhenError, it.__next__)
"
-------------------------------------------------------------------------
"Recom
PRs: 693, 884"
-------------------------------------------------------------------------
=========================================================================
"# SayWhenError seen at the very first of the iterable
it = self.pool.imap_unordered(sqr,
                              exception_throwing_generator(1, -1),
                              1)
self.assertRaises(SayWhenError, it.__next__)
# again, make sure it's reentrant
it = self.pool.imap_unordered(sqr,
                              exception_throwing_generator(1, -1),
                              1)
self.assertRaises(SayWhenError, it.__next__)
"
-------------------------------------------------------------------------
"# SayWhenError seen at the very first of the iterable
it = self.pool.imap_unordered(sqr,
                              exception_throwing_generator(1, -1),
                              1)
self.assertRaises(SayWhenError, it.__next__)
# again, make sure it's reentrant
it = self.pool.imap_unordered(sqr,
                              exception_throwing_generator(1, -1),
                              1)
self.assertRaises(SayWhenError, it.__next__)"
-------------------------------------------------------------------------
"# SayWhenError seen at the very first of the iterable
it = self.pool.imap_unordered(sqr,
                              exception_throwing_generator(1, -1),
                              1)
self.assertRaises(SayWhenError, it.__next__)
# again, make sure it's reentrant
it = self.pool.imap_unordered(sqr,
                              exception_throwing_generator(1, -1),
                              1)
self.assertRaises(SayWhenError, it.__next__)
"
-------------------------------------------------------------------------
"Recom
PRs: 693, 884"
-------------------------------------------------------------------------
=========================================================================
"self.fail('expected RuntimeError')
"
-------------------------------------------------------------------------
"self.assertIs(type(exc), RuntimeError)"
-------------------------------------------------------------------------
"self.fail('expected RuntimeError')
"
-------------------------------------------------------------------------
"Recom
PRs: 693, 884"
-------------------------------------------------------------------------
=========================================================================
"# _helper_reraises_exception should not make the error
# a remote exception
with self.Pool(1) as p:
    try:
        p.map(sqr, exception_throwing_generator(1, -1), 1)
    except Exception as e:
        exc = e
    else:
        self.fail('expected SayWhenError')
    self.assertIs(type(exc), SayWhenError)
    self.assertIs(exc.__cause__, None)
"
-------------------------------------------------------------------------
"# _helper_reraises_exception should not make the error
# a remote exception
with self.Pool(1) as p:
    try:
        p.map(sqr, exception_throwing_generator(1, -1), 1)
    except Exception as e:
        exc = e
    else:
        self.fail('expected SayWhenError')
    self.assertIs(type(exc), SayWhenError)
    self.assertIs(exc.__cause__, None)"
-------------------------------------------------------------------------
"# _helper_reraises_exception should not make the error
# a remote exception
with self.Pool(1) as p:
    try:
        p.map(sqr, exception_throwing_generator(1, -1), 1)
    except Exception as e:
        exc = e
    else:
        self.fail('expected SayWhenError')
    self.assertIs(type(exc), SayWhenError)
    self.assertIs(exc.__cause__, None)
"
-------------------------------------------------------------------------
"Recom
PRs: 693, 884"
-------------------------------------------------------------------------
=========================================================================
"if wrap_exception and func is not _helper_reraises_exception:
"
-------------------------------------------------------------------------
if wrap_exception and func.__name__ != '_helper_reraises_exception':
-------------------------------------------------------------------------
"if wrap_exception and func is not _helper_reraises_exception:
"
-------------------------------------------------------------------------
"Recom
PRs: 693, 882"
-------------------------------------------------------------------------
=========================================================================
"def _helper_reraises_exception(ex):
    'Pickle-able helper function for use by _guarded_task_generation.'
    raise ex
"
-------------------------------------------------------------------------
"def _helper_reraises_exception(ex):
    'Pickle-able helper function for use by _guarded_task_generation.'
    raise ex"
-------------------------------------------------------------------------
"def _helper_reraises_exception(ex):
    'Pickle-able helper function for use by _guarded_task_generation.'
    raise ex
"
-------------------------------------------------------------------------
"Recom
PRs: 693, 882"
-------------------------------------------------------------------------
=========================================================================
"def _guarded_task_generation(self, result_job, func, iterable):
    '''Provides a generator of tasks for imap and imap_unordered with
    appropriate handling for iterables which throw exceptions during
    iteration.'''
    try:
        i = -1
        for i, x in enumerate(iterable):
            yield (result_job, i, func, (x,), {})
    except Exception as e:
        yield (result_job, i1, _helper_reraises_exception, (e,), {})
"
-------------------------------------------------------------------------
"def _guarded_task_generation(self, result_job, func, iterable):
    '''Provides a generator of tasks for imap and imap_unordered with
    appropriate handling for iterables which throw exceptions during
    iteration.'''
    try:
        i = -1
        for i, x in enumerate(iterable):
            yield (result_job, i, func, (x,), {})
    except Exception as e:
        yield (result_job, i, _helper_reraises_exception, (e,), {})"
-------------------------------------------------------------------------
"def _guarded_task_generation(self, result_job, func, iterable):
    '''Provides a generator of tasks for imap and imap_unordered with
    appropriate handling for iterables which throw exceptions during
    iteration.'''
    try:
        i = -1
        for i, x in enumerate(iterable):
            yield (result_job, i, func, (x,), {})
    except Exception as e:
        yield (result_job, i1, _helper_reraises_exception, (e,), {})
"
-------------------------------------------------------------------------
"Recom
PRs: 693, 882"
-------------------------------------------------------------------------
=========================================================================
"self._taskqueue.put(
    (
        self._guarded_task_generation(result._job, func, iterable),
        result._set_length
    ))
self._taskqueue.put(
    (
        self._guarded_task_generation(result._job,
                                      mapstar,
                                      task_batches),
        result._set_length
    ))
"
-------------------------------------------------------------------------
"self._taskqueue.put(
    (
        self._guarded_task_generation(result._job, func, iterable),
        result._set_length
    ))
self._taskqueue.put(
    (
        self._guarded_task_generation(result._job,
                                     func,
                                     task_batches),
        result._set_length
    ))"
-------------------------------------------------------------------------
"self._taskqueue.put(
    (
        self._guarded_task_generation(result._job, func, iterable),
        result._set_length
    ))
self._taskqueue.put(
    (
        self._guarded_task_generation(result._job,
                                      mapstar,
                                      task_batches),
        result._set_length
    ))
"
-------------------------------------------------------------------------
"Recom
PRs: 693, 882"
-------------------------------------------------------------------------
=========================================================================
"self._taskqueue.put(
    (
        self._guarded_task_generation(result._job, func, iterable),
        result._set_length
    ))
self._taskqueue.put(
    (
        self._guarded_task_generation(result._job,
                                      mapstar,
                                      task_batches),
        result._set_length
    ))
"
-------------------------------------------------------------------------
"self._taskqueue.put(
    (
        self._guarded_task_generation(result._job, func, iterable),
        result._set_length
    ))
self._taskqueue.put(
    (
        self._guarded_task_generation(result._job,
                                      imapstar,
                                      task_batches),
        result._set_length
    ))"
-------------------------------------------------------------------------
"self._taskqueue.put(
    (
        self._guarded_task_generation(result._job, func, iterable),
        result._set_length
    ))
self._taskqueue.put(
    (
        self._guarded_task_generation(result._job,
                                      mapstar,
                                      task_batches),
        result._set_length
    ))
"
-------------------------------------------------------------------------
"Recom
PRs: 693, 882"
-------------------------------------------------------------------------
=========================================================================
"self._taskqueue.put(([(result._job, 0, func, args, kwds)], None))
"
-------------------------------------------------------------------------
"self._taskqueue.put(([(result._job, 0, func, args, kwds)], None))"
-------------------------------------------------------------------------
"self._taskqueue.put(([(result._job, 0, func, args, kwds)], None))
"
-------------------------------------------------------------------------
"Recom
PRs: 693, 882"
-------------------------------------------------------------------------
=========================================================================
"self._taskqueue.put(
    (
        self._guarded_task_generation(result._job,
                                      mapper,
                                      task_batches),
        None
    )
)
"
-------------------------------------------------------------------------
"self._taskqueue.put(
    (
        self._guarded_task_generation(result._job,
                                      mapper,
                                      task_batches),
        None,
        None
    )
)"
-------------------------------------------------------------------------
"self._taskqueue.put(
    (
        self._guarded_task_generation(result._job,
                                      mapper,
                                      task_batches),
        None
    )
)
"
-------------------------------------------------------------------------
"Recom
PRs: 693, 882"
-------------------------------------------------------------------------
=========================================================================
"# iterating taskseq cannot fail
for task in taskseq:
        job, idx = task[:2]
            cache[job]._set(idx, (False, e))
        idx = task[1] if task else -1
        set_length(idx  1)
"
-------------------------------------------------------------------------
"# iterating taskseq cannot fail
for task in taskseq:
        job, idx = task[:2]
        try:
            cache[job]._set(idx, (False, e))
        except Exception as e:
            pass
        idx = task[1] if task else -1
        if set_length:
            util.debug('doing set_length()')"
-------------------------------------------------------------------------
"# iterating taskseq cannot fail
for task in taskseq:
        job, idx = task[:2]
            cache[job]._set(idx, (False, e))
        idx = task[1] if task else -1
        set_length(idx  1)
"
-------------------------------------------------------------------------
"Recom
PRs: 693, 882"
-------------------------------------------------------------------------
=========================================================================
"if when == -1:
    raise SayWhenError(""Somebody said when"")
"
-------------------------------------------------------------------------
"if when == -1:
    raise SayWhenError(""Somebody said when"")"
-------------------------------------------------------------------------
"if when == -1:
    raise SayWhenError(""Somebody said when"")
"
-------------------------------------------------------------------------
"Recom
PRs: 693, 882"
-------------------------------------------------------------------------
=========================================================================
"def test_map_handle_iterable_exception(self):
    if self.TYPE == 'manager':
        self.skipTest('test not appropriate for {}'.format(self.TYPE))
    # SayWhenError seen at the very first of the iterable
    with self.assertRaises(SayWhenError):
        self.pool.map(sqr, exception_throwing_generator(1, -1), 1)
    # again, make sure it's reentrant
    with self.assertRaises(SayWhenError):
        self.pool.map(sqr, exception_throwing_generator(1, -1), 1)
    with self.assertRaises(SayWhenError):
        self.pool.map(sqr, exception_throwing_generator(10, 3), 1)
    class SpecialIterable:
        def __iter__(self):
            return self
        def __next__(self):
            raise SayWhenError
        def __len__(self):
            return 1
    with self.assertRaises(SayWhenError):
        self.pool.map(sqr, SpecialIterable(), 1)
    with self.assertRaises(SayWhenError):
        self.pool.map(sqr, SpecialIterable(), 1)
"
-------------------------------------------------------------------------
"def test_map_handle_iterable_exception(self):
    if self.TYPE == 'manager':
        self.skipTest('test not appropriate for {}'.format(self.TYPE))
    # SayWhenError seen at the very first of the iterable
    with self.assertRaises(SayWhenError):
        self.pool.map(sqr, exception_throwing_generator(1, -1), chunksize=1)
    # again, make sure it's reentrant
    with self.assertRaises(SayWhenError):
        self.pool.map(sqr, exception_throwing_generator(1, -1), chunksize=1)
    with self.assertRaises(SayWhenError):
        self.pool.map(sqr, exception_throwing_generator(10, 3), chunksize=1)
    class SpecialIterable:
        def __iter__(self):
            return self
        def __next__(self):
            raise SayWhenError
        def __len__(self):
            return 1
    with self.assertRaises(SayWhenError):
        self.pool.map(sqr, SpecialIterable(), chunksize=1)
    with self.assertRaises(SayWhenError):
        self.pool.map(sqr, SpecialIterable(), chunksize=1)"
-------------------------------------------------------------------------
"def test_map_handle_iterable_exception(self):
    if self.TYPE == 'manager':
        self.skipTest('test not appropriate for {}'.format(self.TYPE))
    # SayWhenError seen at the very first of the iterable
    with self.assertRaises(SayWhenError):
        self.pool.map(sqr, exception_throwing_generator(1, -1), 1)
    # again, make sure it's reentrant
    with self.assertRaises(SayWhenError):
        self.pool.map(sqr, exception_throwing_generator(1, -1), 1)
    with self.assertRaises(SayWhenError):
        self.pool.map(sqr, exception_throwing_generator(10, 3), 1)
    class SpecialIterable:
        def __iter__(self):
            return self
        def __next__(self):
            raise SayWhenError
        def __len__(self):
            return 1
    with self.assertRaises(SayWhenError):
        self.pool.map(sqr, SpecialIterable(), 1)
    with self.assertRaises(SayWhenError):
        self.pool.map(sqr, SpecialIterable(), 1)
"
-------------------------------------------------------------------------
"Recom
PRs: 693, 882"
-------------------------------------------------------------------------
=========================================================================
"# SayWhenError seen at the very first of the iterable
it = self.pool.imap(sqr, exception_throwing_generator(1, -1), 1)
self.assertRaises(SayWhenError, it.__next__)
# again, make sure it's reentrant
it = self.pool.imap(sqr, exception_throwing_generator(1, -1), 1)
self.assertRaises(SayWhenError, it.__next__)
"
-------------------------------------------------------------------------
"# SayWhenError seen at the very first of the iterable
it = self.pool.imap(sqr, exception_throwing_generator(1, -1), 1)
self.assertEqual(next(it), 0) # Exception raised at first element

# again, make sure it's reentrant
it = self.pool.imap(sqr, exception_throwing_generator(1, -1), 1)
self.assertEqual(next(it), 0) # Exception raised at first element"
-------------------------------------------------------------------------
"# SayWhenError seen at the very first of the iterable
it = self.pool.imap(sqr, exception_throwing_generator(1, -1), 1)
self.assertRaises(SayWhenError, it.__next__)
# again, make sure it's reentrant
it = self.pool.imap(sqr, exception_throwing_generator(1, -1), 1)
self.assertRaises(SayWhenError, it.__next__)
"
-------------------------------------------------------------------------
"Recom
PRs: 693, 882"
-------------------------------------------------------------------------
=========================================================================
"# SayWhenError seen at the very first of the iterable
it = self.pool.imap_unordered(sqr,
                              exception_throwing_generator(1, -1),
                              1)
self.assertRaises(SayWhenError, it.__next__)
# again, make sure it's reentrant
it = self.pool.imap_unordered(sqr,
                              exception_throwing_generator(1, -1),
                              1)
self.assertRaises(SayWhenError, it.__next__)
"
-------------------------------------------------------------------------
"# SayWhenError seen at the very first of the iterable
it = self.pool.imap_unordered(sqr,
                              exception_throwing_generator(1, -1),
                              1)
self.assertRaises(SayWhenError, it.__next__)
# again, make sure it's reentrant
it = self.pool.imap_unordered(sqr,
                              exception_throwing_generator(1, -1),
                              1)
self.assertRaises(SayWhenError, it.__next__)"
-------------------------------------------------------------------------
"# SayWhenError seen at the very first of the iterable
it = self.pool.imap_unordered(sqr,
                              exception_throwing_generator(1, -1),
                              1)
self.assertRaises(SayWhenError, it.__next__)
# again, make sure it's reentrant
it = self.pool.imap_unordered(sqr,
                              exception_throwing_generator(1, -1),
                              1)
self.assertRaises(SayWhenError, it.__next__)
"
-------------------------------------------------------------------------
"Recom
PRs: 693, 882"
-------------------------------------------------------------------------
=========================================================================
"self.fail('expected RuntimeError')
"
-------------------------------------------------------------------------
"self.assertIs(type(exc), RuntimeError)"
-------------------------------------------------------------------------
"self.fail('expected RuntimeError')
"
-------------------------------------------------------------------------
"Recom
PRs: 693, 882"
-------------------------------------------------------------------------
=========================================================================
"# _helper_reraises_exception should not make the error
# a remote exception
with self.Pool(1) as p:
    try:
        p.map(sqr, exception_throwing_generator(1, -1), 1)
    except Exception as e:
        exc = e
    else:
        self.fail('expected SayWhenError')
    self.assertIs(type(exc), SayWhenError)
    self.assertIs(exc.__cause__, None)
"
-------------------------------------------------------------------------
"# _helper_reraises_exception should not make the error
# a remote exception
with self.Pool(1) as p:
try:
    p.map(sqr, exception_throwing_generator(1, -1), 1)
except Exception as e:
    exc = e
else:
    self.fail('expected SayWhenError')
self.assertIsInstance(exc, SayWhenError)
self.assertIsNone(exc.__cause)"
-------------------------------------------------------------------------
"# _helper_reraises_exception should not make the error
# a remote exception
with self.Pool(1) as p:
    try:
        p.map(sqr, exception_throwing_generator(1, -1), 1)
    except Exception as e:
        exc = e
    else:
        self.fail('expected SayWhenError')
    self.assertIs(type(exc), SayWhenError)
    self.assertIs(exc.__cause__, None)
"
-------------------------------------------------------------------------
"Recom
PRs: 693, 882"
-------------------------------------------------------------------------
=========================================================================
"Raised by process_tokens() if detecting an ambiguous indent.
"
-------------------------------------------------------------------------
"class AmbiguousIndentationError(Exception):
    """"""
    Raised by process_tokens() if detecting an ambiguous indent.
    """""""
-------------------------------------------------------------------------
"Raised by process_tokens() if detecting an ambiguous indent.
"
-------------------------------------------------------------------------
"Recom
PRs: 759, 763"
-------------------------------------------------------------------------
=========================================================================
"Raised by process_tokens() if detecting an ambiguous indent.
"
-------------------------------------------------------------------------
Raised by process_tokens() if detecting an ambiguous indent.
-------------------------------------------------------------------------
"Raised by process_tokens() if detecting an ambiguous indent.
"
-------------------------------------------------------------------------
"Recom
PRs: 759, 762"
-------------------------------------------------------------------------
=========================================================================
"v = self[i]
if v is value or v == value:
"
-------------------------------------------------------------------------
"i = start
        while stop is None or i < stop:
            try:
                v = self[i]
                if v is value or v == value:
                    return i
            except IndexError:
                break"
-------------------------------------------------------------------------
"v = self[i]
if v is value or v == value:
"
-------------------------------------------------------------------------
"Recom
PRs: 503, 553"
-------------------------------------------------------------------------
=========================================================================
"return sum(1 for v in self if v is value or v == value)
"
-------------------------------------------------------------------------
return sum(1 for v in self if v is value or v == value)
-------------------------------------------------------------------------
"return sum(1 for v in self if v is value or v == value)
"
-------------------------------------------------------------------------
"Recom
PRs: 503, 553"
-------------------------------------------------------------------------
=========================================================================
"class CustomSequence(Sequence):
    def __init__(self, seq):
        self._seq = seq
    def __getitem__(self, index):
        return self._seq[index]
    def __len__(self):
        return len(self._seq)
seq = CustomSequence([nan, obj, nan])
    seq,
self.assertEqual(seq.index(nan), 0)
self.assertEqual(seq.index(obj), 1)
self.assertEqual(seq.count(nan), 2)
self.assertEqual(seq.count(obj), 1)
"
-------------------------------------------------------------------------
"class CustomSequence(Sequence):
    def __init__(self, seq):
        self._seq = seq
    def __getitem__(self, index):
        return self._seq[index]
    def __len__(self):
        return len(self._seq)

seq = CustomSequence([nan, obj, nan])
self.assertEqual(seq.index(nan), 0)
self.assertEqual(seq.index(obj), 1)
self.assertEqual(seq.count(nan), 2)
self.assertEqual(seq.count(obj), 1)"
-------------------------------------------------------------------------
"class CustomSequence(Sequence):
    def __init__(self, seq):
        self._seq = seq
    def __getitem__(self, index):
        return self._seq[index]
    def __len__(self):
        return len(self._seq)
seq = CustomSequence([nan, obj, nan])
    seq,
self.assertEqual(seq.index(nan), 0)
self.assertEqual(seq.index(obj), 1)
self.assertEqual(seq.count(nan), 2)
self.assertEqual(seq.count(obj), 1)
"
-------------------------------------------------------------------------
"Recom
PRs: 503, 553"
-------------------------------------------------------------------------
=========================================================================
"def test_host_resolution_bad_address(self):
    # These are all malformed IP addresses and expected not to resolve to
    # any result.  But some ISPs, e.g. AWS, may successfully resolve these
    # IPs.
    explanation = (
        ""resolving an invalid IP address did not raise OSError; ""
        ""can be caused by a broken DNS server""
    )
    for addr in ['0.1.1.~1', '1.1.1.1', '::1q', '::1::2',
                 '1:1:1:1:1:1:1:1:1']:
        with self.assertRaises(OSError):
            socket.gethostbyname(addr)
        with self.assertRaises(OSError, msg=explanation):
            socket.gethostbyaddr(addr)
"
-------------------------------------------------------------------------
"def test_host_resolution_bad_address(self):
    # These are all malformed IP addresses and expected not to resolve to
    # any result.  But some ISPs, e.g. AWS, may successfully resolve these
    # IPs.
    explanation = (
        ""resolving an invalid IP address did not raise OSError; ""
        ""can be caused by a broken DNS server""
    )
    for addr in ['0.1.1.~1', '1.1.1.1', '::1q', '::1::2', '1:1:1:1:1:1:1:1:1']:
        with self.assertRaises(OSError):
            socket.gethostbyname(addr)
            with self.assertRaises(OSError, msg=explanation):
                socket.gethostbyaddr(addr)"
-------------------------------------------------------------------------
"def test_host_resolution_bad_address(self):
    # These are all malformed IP addresses and expected not to resolve to
    # any result.  But some ISPs, e.g. AWS, may successfully resolve these
    # IPs.
    explanation = (
        ""resolving an invalid IP address did not raise OSError; ""
        ""can be caused by a broken DNS server""
    )
    for addr in ['0.1.1.~1', '1.1.1.1', '::1q', '::1::2',
                 '1:1:1:1:1:1:1:1:1']:
        with self.assertRaises(OSError):
            socket.gethostbyname(addr)
        with self.assertRaises(OSError, msg=explanation):
            socket.gethostbyaddr(addr)
"
-------------------------------------------------------------------------
"Recom
PRs: 412, 531"
-------------------------------------------------------------------------
=========================================================================
"file_object = builtins.open(f, 'rb')
try:
    self.initfp(file_object)
except:
    file_object.close()
    raise
:
# assume it is an open file object already
self.initfp(f)
"
-------------------------------------------------------------------------
"file_object = f
try:
    self.initfp(file_object)
except:
    file_object.close()
    raise"
-------------------------------------------------------------------------
"if isinstance(f, basestring):
    try:
        self.initfp(f)
    except:
        f.close()
        raise
else:
    # assume it is an open file object already
    self.initfp(f)
"
-------------------------------------------------------------------------
"Recom
PRs: 162, 356"
-------------------------------------------------------------------------
=========================================================================
"file_object = builtins.open(f, 'wb')
try:
    self.initfp(file_object)
except:
    file_object.close()
    raise
# treat .aiff file extensions as non-compressed audio
if f.endswith('.aiff'):
    self._aifc = 0
# assume it is an open file object already
self.initfp(f)
"
-------------------------------------------------------------------------
"```python
if isinstance(f, str):
    if f.endswith('.aiff'):
        self._aifc = 0
    file_object = builtins.open(f, 'wb')
    try:
        self.initfp(file_object)
    except:
        file_object.close()
        raise
else:
    self.initfp(f)
```"
-------------------------------------------------------------------------
"_file = None  # Set here since __del__ checks it
"
-------------------------------------------------------------------------
"Recom
PRs: 162, 356"
-------------------------------------------------------------------------
=========================================================================
"""""""Return the number of loops and time taken so that total time >= 0.2.
"
-------------------------------------------------------------------------
"            Calls the timeit method with increasing numbers from the sequence
            1, 2, 5, 10, 20, 50, ... until the time taken is at least 0.2
"
-------------------------------------------------------------------------
"""""""Return the number of loops and time taken so that total time >= 0.2.
"
-------------------------------------------------------------------------
"Recom
PRs: 331, 353"
-------------------------------------------------------------------------
=========================================================================
"#Issue 29376
self.assertTrue(threading._active[tid].is_alive())
self.assertRegex(repr(threading._active[tid]), '_DummyThread')
"
-------------------------------------------------------------------------
"# Issue 29376
self.assertIn(tid, threading._active)
self.assertIsInstance(threading._active[tid], threading._DummyThread)"
-------------------------------------------------------------------------
"#Issue 29376
self.assertTrue(threading._active[tid].is_alive())
self.assertRegex(repr(threading._active[tid]), '_DummyThread')
"
-------------------------------------------------------------------------
"Recom
PRs: 236, 330"
-------------------------------------------------------------------------
=========================================================================
"def is_alive(self):
    assert not self._is_stopped and self._started.is_set()
    return True
"
-------------------------------------------------------------------------
"def is_alive(self):
    __sys.stderr.write(""AssertionError: cannot check the aliveness of a dummy thread\n"")
    __sys.excepthook(__AssertionError, None, __format_exc())
    return False"
-------------------------------------------------------------------------
"def is_alive(self):
    assert not self._is_stopped and self._started.is_set()
    return True
"
-------------------------------------------------------------------------
"Recom
PRs: 236, 330"
-------------------------------------------------------------------------
=========================================================================
"#Issue 29376
self.assertTrue(threading._active[tid].is_alive())
self.assertRegex(repr(threading._active[tid]), '_DummyThread')
"
-------------------------------------------------------------------------
"```python
self.assertTrue(threading.get_ident() in threading._active)
self.assertIsInstance(threading._active[threading.get_ident()], threading._DummyThread)
```"
-------------------------------------------------------------------------
"#Issue 29376
self.assertTrue(threading._active[tid].is_alive())
self.assertRegex(repr(threading._active[tid]), '_DummyThread')
"
-------------------------------------------------------------------------
"Recom
PRs: 236, 329"
-------------------------------------------------------------------------
=========================================================================
"def is_alive(self):
    assert not self._is_stopped and self._started.is_set()
    return True
"
-------------------------------------------------------------------------
"def is_alive(self):
        assert not self._stop and self._started.is_set()
        return True"
-------------------------------------------------------------------------
"def is_alive(self):
    assert not self._is_stopped and self._started.is_set()
    return True
"
-------------------------------------------------------------------------
"Recom
PRs: 236, 329"
-------------------------------------------------------------------------
=========================================================================
