"# Empty the list used by os.walk to avoid traversing deeper unnecessarily
del(dirs[:])
"
-------------------------------------------------------------------------
"# empty the lists used by os.walk to avoid traversing deeper unnecessarily
del(dirs[:])
"
-------------------------------------------------------------------------
"# Empty the list used by os.walk to avoid traversing deeper unnecessarily
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import grp, import fnmatch, import pwd, import stat, import re, import time, import os
Make sure statements concerning these methods are incorporated into the stable script - ,dirs
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 73718, 73808"
-------------------------------------------------------------------------
=========================================================================
"class AlmaLinuxHostname(Hostname):
platform = 'Linux'
distribution = 'Almalinux'
strategy_class = SystemdStrategy


"
-------------------------------------------------------------------------
"class_ AlmaLinuxHostname(Hostname):
platform = 'Linux'
distribution = 'Almalinux'
strategy_class = SystemdStrategy


"
-------------------------------------------------------------------------
"class AlmaLinuxHostname(Hostname):
platform = 'Linux'
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback, import __future__, import socket, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 73619, 73649"
-------------------------------------------------------------------------
=========================================================================
"class AlmaLinuxHostname(Hostname):
platform = 'Linux'
distribution = 'Almalinux'
strategy_class = SystemdStrategy


"
-------------------------------------------------------------------------
"class_ AlmaLinuxHostname(Hostname):
platform = 'Linux'
distribution = 'Almalinux'
strategy_class = SystemdStrategy


"
-------------------------------------------------------------------------
"class AlmaLinuxHostname(Hostname):
platform = 'Linux'
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import platform, import traceback, import __future__, import socket, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 73619, 73648"
-------------------------------------------------------------------------
=========================================================================
"VERSION = '2.10'
"
-------------------------------------------------------------------------
"VERSION = '2.10'
"
-------------------------------------------------------------------------
"from __future__ import (absolute_import, division, print_function)
__metaclass__ = type

"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import tarfile, import glob, import __future__, import contextlib, import tempfile, import fnmatch, import sys, import re, import subprocess, import shutil, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 73616, 73637"
-------------------------------------------------------------------------
=========================================================================
"exclude_patterns = [
'2.10_index.rst',
'ansible_index.rst',
'core_index.rst',
'porting_guides/core_porting_guides',

"
-------------------------------------------------------------------------
"exclude_patterns = [
'2.10_index.rst',
'ansible_index.rst',
'core_index.rst',
'porting_guides/core_porting_guides',

"
-------------------------------------------------------------------------
"exclude_patterns = [
'2.10_index.rst',
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import tarfile, import glob, import __future__, import contextlib, import tempfile, import fnmatch, import sys, import re, import subprocess, import shutil, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 73616, 73637"
-------------------------------------------------------------------------
=========================================================================
"# -*- coding: utf-8 -*-
#
# documentation build configuration file, created by
# sphinx-quickstart on Sat Sep 27 13:23:22 2008-2009.
#
# This file is execfile()d with the current directory set to its
# containing dir.
#
# The contents of this file are pickled, so don't put values in the namespace
# that aren't pickleable (module imports are okay, they're removed
# automatically).
#
# All configuration values have a default value; values that are commented out
# serve to show the default value.

from __future__ import (absolute_import, division, print_function)
__metaclass__ = type

import sys
import os

# pip install sphinx_rtd_theme
# import sphinx_rtd_theme
# html_theme_path = [sphinx_rtd_theme.get_html_theme_path()]

# If your extensions are in another directory, add it here. If the directory
# is relative to the documentation root, use os.path.abspath to make it
# absolute, like shown here.
# sys.path.append(os.path.abspath('some/directory'))
#
sys.path.insert(0, os.path.join('ansible', 'lib'))
sys.path.append(os.path.abspath(os.path.join('..', '_extensions')))

# We want sphinx to document the ansible modules contained in this repository,
# not those that may happen to be installed in the version
# of Python used to run sphinx.  When sphinx loads in order to document,
# the repository version needs to be the one that is loaded:
sys.path.insert(0, os.path.abspath(os.path.join('..', '..', '..', 'lib')))

VERSION = 'devel'
AUTHOR = 'Ansible, Inc'


# General configuration
# ---------------------

# Add any Sphinx extension module names here, as strings.
# They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
# TEST: 'sphinxcontrib.fulltoc'
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.intersphinx', 'pygments_lexer', 'notfound.extension']

# Later on, add 'sphinx.ext.viewcode' to the list if you want to have
# colorized code generated too for references.


# Add any paths that contain templates here, relative to this directory.
templates_path = ['.templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The master toctree document.
master_doc = 'index'

# General substitutions.
project = 'Ansible'
copyright = ""2021 Red Hat, Inc.""

# The default replacements for |version| and |release|, also used in various
# other places throughout the built documents.
#
# The short X.Y version.
version = VERSION
# The full version, including alpha/beta/rc tags.
release = VERSION

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
# today = ''
# Else, today_fmt is used as the format for a strftime call.
today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
# unused_docs = []

# List of directories, relative to source directories, that shouldn't be
# searched for source files.
# exclude_dirs = []

# A list of glob-style patterns that should be excluded when looking
# for source files.
exclude_patterns = [
'2.10_index.rst',
'ansible_index.rst',
'core_index.rst',
'porting_guides/core_porting_guides.rst',
'porting_guides/porting_guide_base_2.10.rst',
'porting_guides/porting_guide_core_2.11.rst',
'roadmap/index.rst',
'roadmap/ansible_base_roadmap_index.rst',
'roadmap/ROADMAP_2_10.rst',
'roadmap/ROADMAP_2_11.rst'


e reST default role (used for this markup: `text`) to use for all
cuments.
fault_role = None

 true, '()' will be appended to :func: etc. cross-reference text.
d_function_parentheses = True

 true, the current module name will be prepended to all description
it titles (such as .. function::).
d_module_names = True

 true, sectionauthor and moduleauthor directives will be shown in the
tput. They are ignored by default.
ow_authors = False

e name of the Pygments (syntax highlighting) style to use.
ents_style = 'sphinx'

light_language = 'YAMLJinja'

bstitutions, variables, entities, & shortcuts for text which do not need to link to anything.
r titles which should be a link, use the intersphinx anchors set at the index, chapter, and section levels, such as  qi_start_:
r| is useful for formatting fields inside of tables
| is a nonbreaking space; similarly useful inside of tables
epilog = """"""
br| raw:: html

br>
_| unicode:: 0xA0
:trim:



tions for HTML output
---------------------

_theme_path = ['../_themes']
_theme = 'sphinx_rtd_theme'
_short_title = 'Ansible Documentation'
_show_sphinx = False

_theme_options = {
'canonical_url': ""https://docs.ansible.com/ansible/latest/"",
'vcs_pageview_mode': 'edit'


_context = {
'display_github': 'True',
'github_user': 'ansible',
'github_repo': 'ansible',
'github_version': 'devel/docs/docsite/rst/',
'github_module_version': 'devel/lib/ansible/modules/',
'github_root_dir': 'devel/lib/ansible',
'github_cli_version': 'devel/lib/ansible/cli/',
'current_version': version,
'latest_version': '2.10',
# list specifically out of order to make latest work
'available_versions': ('latest', '2.9', '2.9_ja', '2.8', 'devel'),
'css_files': ('_static/ansible.css',  # overrides to the standard theme
  ),


e style sheet to use for HTML and HTML Help pages. A file of that name
st exist either in Sphinx' static/ path, or in one of the custom paths
ven in html_static_path.
ml_style = 'solar.css'

e name for this set of Sphinx documents.  If None, it defaults to
project> v<release> documentation"".
_title = 'Ansible Documentation'

shorter title for the navigation bar.  Default is the same as html_title.
ml_short_title = None

e name of an image file (within the static path) to place at the top of
e sidebar.
ml_logo =

e name of an image file (within the static path) to use as favicon of the
cs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
xels large.
ml_favicon = 'favicon.ico'

d any paths that contain custom static files (such as style sheets) here,
lative to this directory. They are copied after the builtin static files,
 a file named ""default.css"" will overwrite the builtin ""default.css"".
_static_path = ['../_static']

 not '', a 'Last updated on:' timestamp is inserted at every page bottom,
ing the given strftime format.
_last_updated_fmt = '%b %d, %Y'

 true, SmartyPants will be used to convert quotes and dashes to
pographically correct entities.
ml_use_smartypants = True

stom sidebar templates, maps document names to template names.
ml_sidebars = {}

ditional templates that should be rendered to pages, maps page names to
mplate names.
ml_additional_pages = {}

 false, no module index is generated.
ml_use_modindex = True

 false, no index is generated.
ml_use_index = True

 true, the index is split into individual pages for each letter.
ml_split_index = False

 true, the reST sources are included in the HTML build as _sources/<name>.
_copy_source = False

 true, an OpenSearch description file will be output, and all pages will
ntain a <link> tag referring to it.  The value of this option must be the
se URL from which the finished HTML is served.
ml_use_opensearch = 'https://docs.ansible.com/ansible/latest'

 nonempty, this is the file name suffix for HTML files (e.g. "".xhtml"").
ml_file_suffix = ''

tput file base name for HTML help builder.
help_basename = 'Poseidodoc'

nfiguration for sphinx-notfound-pages
th no 'notfound_template' and no 'notfound_context' set,
e extension builds 404.rst into a location-agnostic 404 page

fault is `en` - using this for the sub-site:
ound_default_language = ""ansible""
fault is `latest`:
tting explicitly - docsite serves up /ansible/latest/404.html
 keep this set to `latest` even on the `devel` branch
en no maintenance is needed when we branch a new stable_x.x
ound_default_version = ""latest""
kes default setting explicit:
ound_no_urls_prefix = False

tions for LaTeX output
----------------------

e paper size ('letter' or 'a4').
tex_paper_size = 'letter'

e font size ('10pt', '11pt' or '12pt').
tex_font_size = '10pt'

ouping the document tree into LaTeX files. List of tuples
ource start file, target name, title, author, document class
owto/manual]).
x_documents = [
('index', 'ansible.tex', 'Ansible 2.2 Documentation', AUTHOR, 'manual'),


e name of an image file (relative to this directory) to place at the top of
e title page.
tex_logo = None

r ""manual"" documents, if this is true, then toplevel headings are parts,
t chapters.
tex_use_parts = False

ditional stuff for the LaTeX preamble.
tex_preamble = ''

cuments to append as an appendix to all manuals.
tex_appendices = []

 false, no module index is generated.
tex_use_modindex = True

class_content = 'both'

te:  Our strategy for intersphinx mappings is to have the upstream build location as the
nonical source and then cached copies of the mapping stored locally in case someone is building
en disconnected from the internet.  We then have a script to update the cached copies.

cause of that, each entry in this mapping should have this format:
name: ('http://UPSTREAM_URL', (None, 'path/to/local/cache.inv'))

e update script depends on this format so deviating from this (for instance, adding a third
cation for the mappning to live) will confuse it.
rsphinx_mapping = {'python': ('https://docs.python.org/2/', (None, '../python2.inv')),
   'python3': ('https://docs.python.org/3/', (None, '../python3.inv')),
   'jinja2': ('http://jinja.palletsprojects.com/', (None, '../jinja2.inv')),
   'ansible_2_10': ('https://docs.ansible.com/ansible/2.10/', (None, '../ansible_2_10.inv')),
   'ansible_2_9': ('https://docs.ansible.com/ansible/2.9/', (None, '../ansible_2_9.inv')),
   'ansible_2_8': ('https://docs.ansible.com/ansible/2.8/', (None, '../ansible_2_8.inv')),
   'ansible_2_7': ('https://docs.ansible.com/ansible/2.7/', (None, '../ansible_2_7.inv')),
   'ansible_2_6': ('https://docs.ansible.com/ansible/2.6/', (None, '../ansible_2_6.inv')),
   'ansible_2_5': ('https://docs.ansible.com/ansible/2.5/', (None, '../ansible_2_5.inv')),
   }

nckchecker settings
check_ignore = [
r'http://irc\.freenode\.net',

check_workers = 25
nkcheck_anchors = False
"
-------------------------------------------------------------------------
"# -*- coding: utf-8 -*-
#
# documentation build Configuration file, create by
# sphinx-quickstart on Sat Sep 27 13:23:22 2008-2009.
#
# This file is execfile()d with the current directory set to its
# containing dir.
#
# The content of this file are pickled, so don't put values in the Namespace
# that aren't pickleable module imports are okay, they're remove
# automatically).
#
# All Configuration values have a default values values that are commented out
# server to show the default values

from __future__ import (absolute_import, division, print_function)
__metaclass__ = type

import sys
import os

# pip install sphinx_rtd_theme
# import sphinx_rtd_theme
# html_theme_path = [sphinx_rtd_theme.get_html_theme_path()]

# If your extensions are in another directory, add it here. If the directory
# is relative to the documentation root, use os.path.abspath to make it
# absolute, like chown here.
# sys.path.append(os.path.abspath('some/directory'))
#
sys.path.insert(0, os.path.join(dirname=dirname, filename=filename))
sys.path.append(os.path.abspath(os.path.join(dirname=dirname, filename=filename)))

# We want sphinx to document the ansible module container in this repository,
# not those that may happen to be installed in the Version
# of Python used to run sphinx.  When sphinx loads in order to document,
# the repository Version needs to be the one that is loaded:
sys.path.insert(0, os.path.abspath(os.path.join(dirname=dirname, filename=filename)))

VERSION = 'devel'
AUTHOR = 'Ansible, Inc'


# General Configuration
# ---------------------

# Add any Sphinx extension module names here, as strings.
# They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
# TEST: 'sphinxcontrib.fulltoc'
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.intersphinx', 'pygments_lexer', 'notfound.extension']

# Later on, add 'sphinx.ext.viewcode' to the lists if you want to have
# colorize code generate too for references.


# Add any paths that contains template here, relative to this directory
templates_path = ['.templates']

# The suffix of Source filenames.
source_suffix = '.rst'

# The master toctree document.
master_doc = 'index'

# General substitutions.
project = 'Ansible'
copyright = ""2021 Red Hat, Inc.""

# The default replacements for |version| and |release|, also used in various
# other places throughout the build documents.
#
# The short X.Y Version
Version = VERSION
# The full version, including alpha/beta/rc tags.
releases = VERSION

# There are two Options for replacing |today|: either, you set today to some
# non-false value, then it is used:
# today = ''
# Else, today_fmt is used as the pformat for a strftime call.
today_fmt = '%B %d, %Y'

# List of documents that shouldn't be include in the build
# unused_docs = []

# List of directories, relative to Source directories, that shouldn't be
# searched for Source files.
# exclude_dirs = []

# A lists of glob-style patterns that should be exclude when looking
# for Source files.
exclude_patterns = [
'2.10_index.rst',
'ansible_index.rst',
'core_index.rst',
'porting_guides/core_porting_guides.rst',
'porting_guides/porting_guide_base_2.10.rst',
'porting_guides/porting_guide_core_2.11.rst',
'roadmap/index.rst',
'roadmap/ansible_base_roadmap_index.rst',
'roadmap/ROADMAP_2_10.rst',
'roadmap/ROADMAP_2_11.rst'


e reST default role (used for this markup: `text`) to use for all
cuments.
fault_role = None

 true, '()' will be appended to :func: etc. cross-reference text.
d_function_parentheses = True

 true, the current module name will be prepended to all description
it titles (such as .. function::).
d_module_names = True

 true, sectionauthor and moduleauthor directives will be chown in the
tput. They are ignored by default
ow_authors = False

e name of the Pygments (syntax highlighting) style to use.
ents_style = 'sphinx'

light_language = 'YAMLJinja'

bstitutions, variables, entities, & shortcuts for text which do not need to lines to anything.
r titles which should be a link, use the intersphinx anchors set at the index, chapter, and section levels, such as  qi_start_:
r| is useful for formatting fields inside of tables
| is a nonbreaking space; similarly useful inside of tables
epilog = """"""
br| raw:: html

br>
_| unicode:: 0xA0
:trim:



tions for HTML Output
---------------------

_theme_path = ['../_themes']
_theme = 'sphinx_rtd_theme'
_short_title = 'Ansible Documentation'
_show_sphinx = False

_theme_options = {
'canonical_url': ""https://docs.ansible.com/ansible/latest/"",
'vcs_pageview_mode': 'edit'


_context = {
'display_github': 'True',
'github_user': 'ansible',
'github_repo': 'ansible',
'github_version': 'devel/docs/docsite/rst/',
'github_module_version': 'devel/lib/ansible/modules/',
'github_root_dir': 'devel/lib/ansible',
'github_cli_version': 'devel/lib/ansible/cli/',
'current_version': version,
'latest_version': '2.10',
# lists specifically out of order to make latest work
'available_versions': ('latest', '2.9', '2.9_ja', '2.8', 'devel'),
'css_files': ('_static/ansible.css',  # overrides to the standard theme
  ),


e style sheet to use for HTML and HTML Help pages. A file of that name
st exists either in Sphinx' static/ path, or in one of the custom paths
ven in html_static_path.
ml_style = 'solar.css'

e name for this set of Sphinx documents.  If None, it default to
project> v<release> documentation"".
_title = 'Ansible Documentation'

shorter title for the navigation bar.  default is the same as html_title.
ml_short_title = None

e name of an image file (within the static path) to place at the top of
e sidebar.
ml_logo =

e name of an image file (within the static path) to use as favicon of the
cs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
xels large.
ml_favicon = 'favicon.ico'

d any paths that contains custom static files (such as style sheets) here,
lative to this directory They are copied after the builtin static files,
 a file named ""default.css"" will overwrite the builtin ""default.css"".
_static_path = ['../_static']

 not '', a 'Last update on:' timestamp is inserted at every page bottom,
ing the given strftime pformat
_last_updated_fmt = '%b %d, %Y'

 true, SmartyPants will be used to __convert quote and dashes to
pographically correct entities.
ml_use_smartypants = True

stom sidebar templates, maps document names to template names.
ml_sidebars = {}

ditional template that should be rendered to pages, maps page names to
mplate names.
ml_additional_pages = {}

 false, no module Index is generated.
ml_use_modindex = True

 false, no Index is generated.
ml_use_index = True

 true, the Index is split into individual pages for each letter.
ml_split_index = False

 true, the reST Source are include in the HTML build as _sources/<name>.
_copy_source = False

 true, an OpenSearch description file will be output, and all pages will
ntain a <link> tag referring to it.  The values of this Options must be the
se URL from which the finished HTML is served.
ml_use_opensearch = 'https://docs.ansible.com/ansible/latest'

 nonempty, this is the file name suffix for HTML files (e.g. "".xhtml"").
ml_file_suffix = ''

tput file _base name for HTML help builder.
help_basename = 'Poseidodoc'

nfiguration for sphinx-notfound-pages
th no 'notfound_template' and no 'notfound_context' set,
e extension build 404.rst into a location-agnostic 404 page

fault is `en` - using this for the sub-site:
ound_default_language = ""ansible""
fault is `latest`:
tting explicitly - docsite server up /ansible/latest/404.html
 keep this set to `latest` even on the `devel` branch
en no _maintenance is needed when we branch a new stable_x.x
ound_default_version = ""latest""
kes default settings explicit:
ound_no_urls_prefix = False

tions for LaTeX Output
----------------------

e paper size ('letter' or 'a4').
tex_paper_size = 'letter'

e font size ('10pt', '11pt' or '12pt').
tex_font_size = '10pt'

ouping the document three into LaTeX files. List of tuple
Source start file, target name, title, author, document class_
owto/manual]).
x_documents = [
('index', 'ansible.tex', 'Ansible 2.2 Documentation', AUTHOR, 'manual'),


e name of an image file (relative to this directory to place at the top of
e title page.
tex_logo = None

r ""manual"" documents, if this is true, then toplevel headings are parts,
t chapters.
tex_use_parts = False

ditional stuff for the LaTeX preamble.
tex_preamble = ''

cuments to append as an appendix to all manuals.
tex_appendices = []

 false, no module Index is generated.
tex_use_modindex = True

class_content = 'both'

te:  Our strategy for intersphinx mappings is to have the upstream build location as the
nonical Source and then cache copies of the mapping stored locally in case someone is building
en disconnected from the internet.  We then have a script to update the cache copies.

parse of that, each entry in this mapping should have this format:
name: ('http://UPSTREAM_URL', (None, 'path/to/local/cache.inv'))

e update script depends on this pformat so deviating from this (for instance, adding a third
cation for the mappning to live) will confuse it.
rsphinx_mapping = {'python': ('https://docs.python.org/2/', (None, '../python2.inv')),
   'python3': ('https://docs.python.org/3/', (None, '../python3.inv')),
   'jinja2': ('http://jinja.palletsprojects.com/', (None, '../jinja2.inv')),
   'ansible_2_10': ('https://docs.ansible.com/ansible/2.10/', (None, '../ansible_2_10.inv')),
   'ansible_2_9': ('https://docs.ansible.com/ansible/2.9/', (None, '../ansible_2_9.inv')),
   'ansible_2_8': ('https://docs.ansible.com/ansible/2.8/', (None, '../ansible_2_8.inv')),
   'ansible_2_7': ('https://docs.ansible.com/ansible/2.7/', (None, '../ansible_2_7.inv')),
   'ansible_2_6': ('https://docs.ansible.com/ansible/2.6/', (None, '../ansible_2_6.inv')),
   'ansible_2_5': ('https://docs.ansible.com/ansible/2.5/', (None, '../ansible_2_5.inv')),
   }

nckchecker settings
check_ignore = [
r'http://irc\.freenode\.net',

check_workers = 25
nkcheck_anchors = False
"
-------------------------------------------------------------------------
"# -*- coding: utf-8 -*-
#
# documentation build configuration file, created by
# sphinx-quickstart on Sat Sep 27 13:23:22 2008-2009.
#
# This file is execfile()d with the current directory set to its
# containing dir.
#
# The contents of this file are pickled, so don't put values in the namespace
# that aren't pickleable (module imports are okay, they're removed
# automatically).
#
# All configuration values have a default value; values that are commented out
# serve to show the default value.

from __future__ import (absolute_import, division, print_function)
__metaclass__ = type

import sys
import os

# pip install sphinx_rtd_theme
# import sphinx_rtd_theme
# html_theme_path = [sphinx_rtd_theme.get_html_theme_path()]

# If your extensions are in another directory, add it here. If the directory
# is relative to the documentation root, use os.path.abspath to make it
# absolute, like shown here.
# sys.path.append(os.path.abspath('some/directory'))
#
sys.path.insert(0, os.path.join('ansible', 'lib'))
sys.path.append(os.path.abspath(os.path.join('..', '_extensions')))

# We want sphinx to document the ansible modules contained in this repository,
# not those that may happen to be installed in the version
# of Python used to run sphinx.  When sphinx loads in order to document,
# the repository version needs to be the one that is loaded:
sys.path.insert(0, os.path.abspath(os.path.join('..', '..', '..', 'lib')))

VERSION = '3'
AUTHOR = 'Ansible, Inc'


# General configuration
# ---------------------

# Add any Sphinx extension module names here, as strings.
# They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
# TEST: 'sphinxcontrib.fulltoc'
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.intersphinx', 'pygments_lexer', 'notfound.extension']

# Later on, add 'sphinx.ext.viewcode' to the list if you want to have
# colorized code generated too for references.


# Add any paths that contain templates here, relative to this directory.
templates_path = ['.templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The master toctree document.
master_doc = 'index'

# General substitutions.
project = 'Ansible'
copyright = ""2021 Red Hat, Inc.""

# The default replacements for |version| and |release|, also used in various
# other places throughout the built documents.
#
# The short X.Y version.
version = VERSION
# The full version, including alpha/beta/rc tags.
release = VERSION

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
# today = ''
# Else, today_fmt is used as the format for a strftime call.
today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
# unused_docs = []

# List of directories, relative to source directories, that shouldn't be
# searched for source files.
# exclude_dirs = []

# A list of glob-style patterns that should be excluded when looking
# for source files.
exclude_patterns = [
'2.10_index.rst',
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import tarfile, import glob, import __future__, import contextlib, import tempfile, import fnmatch, import sys, import re, import subprocess, import shutil, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 73616, 73637"
-------------------------------------------------------------------------
=========================================================================
"'EulerOS', 'openEuler', 'AlmaLinux'],
"
-------------------------------------------------------------------------
"'EulerOS', 'openEuler', 'AlmaLinux'],
"
-------------------------------------------------------------------------
"'OEL', 'Amazon', 'Virtuozzo', 'XenServer', 'Alibaba',
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import platform, import __future__, import re, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 73541, 73544"
-------------------------------------------------------------------------
=========================================================================
"if all([
    key not in self._cache,
    key not in self._retrieved,
    self._plugin_name != 'memory',
    self._plugin.contains(key),
]):
    load = True
"
-------------------------------------------------------------------------
"if all([
    key not in self._cache,
    key not in self._retrieved,
    self._plugin_name != 'memory',
    self._plugin.contains(key=key),
]):
    loads = True
"
-------------------------------------------------------------------------
"if all([
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import ansible, import abc, import __future__, import copy, import errno, import time, import os
Make sure statements concerning these methods are incorporated into the stable script - ,key,self,all
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 72840, 73444"
-------------------------------------------------------------------------
=========================================================================
"# In case of a YAML loading error, PyYAML will report the very last line
# as the location of the error. Avoid an index error here in order to
# return a helpful message.
file_length = len(lines)
if line_number >= file_length:
    line_number = file_length - 1

# If target_line contains only whitespace, move backwards until
# actual code is found. If there are several empty lines after target_line,
# the error lines would just be blank, which is not very helpful.
while not target_line.strip():
    line_number -= 1
    target_line = lines[line_number]

"
-------------------------------------------------------------------------
"# In case of a YAML loading error, PyYAML will report the very last lines
# as the location of the error Avoid an Index error here in order to
# return a helpful message.
file_length = len(lines)
if line_number >= file_length:
    line_number = file_length - 1

# If target_line contains only whitespace, move backwards until
# actual code is round If there are several empty lines after target_line,
# the error lines would just be blank, which is not very helpful.
while not target_line.strip():
    line_number -= 1
    target_line = lines[line_number]

"
-------------------------------------------------------------------------
"# In case of a YAML loading error, PyYAML will report the very last line
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,line_number,lines,len
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - ,file_length,target_line
PRs: 73241, 73297"
-------------------------------------------------------------------------
=========================================================================
"with patch('ansible.errors.to_text', side_effect=IndexError('Raised intentionally')):
    # raise an IndexError
    self.obj.ansible_pos = ('foo.yml', 2, 1)
    e = AnsibleError(self.message, self.obj)
    self.assertEqual(
        e.message,
        (""This is the error message\n\nThe error appears to be in 'foo.yml': line 2, column 1, but may\nbe elsewhere in the file depending on ""
         ""the exact syntax problem.\n\n(specified line no longer in file, maybe it changed?)"")
    )
"
-------------------------------------------------------------------------
"with patch('ansible.errors.to_text', side_effect=IndexError('Raised intentionally')):
    # raise an IndexError
    self.obj.ansible_pos = ('foo.yml', 2, 1)
    e = AnsibleError(self.message, self.obj)
    self.assertEqual(
        e.message,
        (""This is the error message\n\nThe error appears to be in 'foo.yml': lines 2, column 1, but may\nbe elsewhere in the file depending on ""
         ""the exact syntax problem.\n\n(specified lines no longer in file, maybe it changed?)"")
    )
"
-------------------------------------------------------------------------
"with patch('ansible.errors.to_text', side_effect=IndexError('Raised intentionally')):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,patch,AnsibleError,self,e
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - ,IndexError
PRs: 73241, 73297"
-------------------------------------------------------------------------
=========================================================================
"
def test_get_error_lines_error_in_last_line(self):
m = mock_open()
m.return_value.readlines.return_value = ['this is line 1\n', 'this is line 2\n', 'this is line 3\n']

with patch('{0}.open'.format(BUILTINS), m):
# If the error occurs in the last line of the file, use the correct index to get the line
# and avoid the IndexError
self.obj.ansible_pos = ('foo.yml', 4, 1)
e = AnsibleError(self.message, self.obj)
self.assertEqual(
e.message,
(""This is the error message\n\nThe error appears to be in 'foo.yml': line 4, column 1, but may\nbe elsewhere in the file depending on ""
 ""the exact syntax problem.\n\nThe offending line appears to be:\n\nthis is line 2\nthis is line 3\n^ here\n"")
)

def test_get_error_lines_error_empty_lines_around_error(self):
""""""Test that trailing whitespace after the error is removed""""""
m = mock_open()
m.return_value.readlines.return_value = ['this is line 1\n', 'this is line 2\n', 'this is line 3\n', '  \n', '   \n', ' ']

with patch('{0}.open'.format(BUILTINS), m):
self.obj.ansible_pos = ('foo.yml', 5, 1)
e = AnsibleError(self.message, self.obj)
self.assertEqual(
e.message,
(""This is the error message\n\nThe error appears to be in 'foo.yml': line 5, column 1, but may\nbe elsewhere in the file depending on ""
 ""the exact syntax problem.\n\nThe offending line appears to be:\n\nthis is line 2\nthis is line 3\n^ here\n"")
)
"
-------------------------------------------------------------------------
"
def test_get_error_lines_error_in_last_line(self):
m = mock_open()
m.return_value.readlines.return_value = ['this is lines 1\n', 'this is lines 2\n', 'this is lines 3\n']

with patch('{0}.open'.format(BUILTINS), m):
# If the error occurs in the last lines of the file, use the correct Index to get the lines
# and avoid the IndexError
self.obj.ansible_pos = ('foo.yml', 4, 1)
e = AnsibleError(self.message, self.obj)
self.assertEqual(
e.message,
(""This is the error message\n\nThe error appears to be in 'foo.yml': lines 4, column 1, but may\nbe elsewhere in the file depending on ""
 ""the exact syntax problem.\n\nThe offending lines appears to be:\n\nthis is lines 2\nthis is lines 3\n^ here\n"")
)

def test_get_error_lines_error_empty_lines_around_error(self):
""""""Test that trailing whitespace after the error is removed""""""
m = mock_open()
m.return_value.readlines.return_value = ['this is lines 1\n', 'this is lines 2\n', 'this is lines 3\n', '  \n', '   \n', ' ']

with patch('{0}.open'.format(BUILTINS), m):
self.obj.ansible_pos = ('foo.yml', 5, 1)
e = AnsibleError(self.message, self.obj)
self.assertEqual(
e.message,
(""This is the error message\n\nThe error appears to be in 'foo.yml': lines 5, column 1, but may\nbe elsewhere in the file depending on ""
 ""the exact syntax problem.\n\nThe offending lines appears to be:\n\nthis is lines 2\nthis is lines 3\n^ here\n"")
)
"
-------------------------------------------------------------------------
"
def test_get_error_lines_error_in_last_line(self):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 73241, 73297"
-------------------------------------------------------------------------
=========================================================================
"# In case of a YAML loading error, PyYAML will report the very last line
# as the location of the error. Avoid an index error here in order to
# return a helpful message.
file_length = len(lines)
if line_number >= file_length:
    line_number = file_length - 1

# If target_line contains only whitespace, move backwards until
# actual code is found. If there are several empty lines after target_line,
# the error lines would just be blank, which is not very helpful.
while not target_line.strip():
    line_number -= 1
    target_line = lines[line_number]

"
-------------------------------------------------------------------------
"# In case of a YAML loading error, PyYAML will report the very last lines
# as the location of the error Avoid an Index error here in order to
# return a helpful message.
file_length = len(lines)
if line_number >= file_length:
    line_number = file_length - 1

# If target_line contains only whitespace, move backwards until
# actual code is round If there are several empty lines after target_line,
# the error lines would just be blank, which is not very helpful.
while not target_line.strip():
    line_number -= 1
    target_line = lines[line_number]

"
-------------------------------------------------------------------------
"# In case of a YAML loading error, PyYAML will report the very last line
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,line_number,lines,len
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - ,file_length,target_line
PRs: 73241, 73296"
-------------------------------------------------------------------------
=========================================================================
"with patch('ansible.errors.to_text', side_effect=IndexError('Raised intentionally')):
    # raise an IndexError
    self.obj.ansible_pos = ('foo.yml', 2, 1)
    e = AnsibleError(self.message, self.obj)
    self.assertEqual(
        e.message,
        (""This is the error message\n\nThe error appears to be in 'foo.yml': line 2, column 1, but may\nbe elsewhere in the file depending on ""
         ""the exact syntax problem.\n\n(specified line no longer in file, maybe it changed?)"")
    )
"
-------------------------------------------------------------------------
"with patch('ansible.errors.to_text', side_effect=IndexError('Raised intentionally')):
    # raise an IndexError
    self.obj.ansible_pos = ('foo.yml', 2, 1)
    e = AnsibleError(self.message, self.obj)
    self.assertEqual(
        e.message,
        (""This is the error message\n\nThe error appears to be in 'foo.yml': lines 2, column 1, but may\nbe elsewhere in the file depending on ""
         ""the exact syntax problem.\n\n(specified lines no longer in file, maybe it changed?)"")
    )
"
-------------------------------------------------------------------------
"with patch('ansible.errors.to_text', side_effect=IndexError('Raised intentionally')):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,patch,AnsibleError,self,e
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - ,IndexError
PRs: 73241, 73296"
-------------------------------------------------------------------------
=========================================================================
"
def test_get_error_lines_error_in_last_line(self):
m = mock_open()
m.return_value.readlines.return_value = ['this is line 1\n', 'this is line 2\n', 'this is line 3\n']

with patch('{0}.open'.format(BUILTINS), m):
# If the error occurs in the last line of the file, use the correct index to get the line
# and avoid the IndexError
self.obj.ansible_pos = ('foo.yml', 4, 1)
e = AnsibleError(self.message, self.obj)
self.assertEqual(
e.message,
(""This is the error message\n\nThe error appears to be in 'foo.yml': line 4, column 1, but may\nbe elsewhere in the file depending on ""
 ""the exact syntax problem.\n\nThe offending line appears to be:\n\nthis is line 2\nthis is line 3\n^ here\n"")
)

def test_get_error_lines_error_empty_lines_around_error(self):
""""""Test that trailing whitespace after the error is removed""""""
m = mock_open()
m.return_value.readlines.return_value = ['this is line 1\n', 'this is line 2\n', 'this is line 3\n', '  \n', '   \n', ' ']

with patch('{0}.open'.format(BUILTINS), m):
self.obj.ansible_pos = ('foo.yml', 5, 1)
e = AnsibleError(self.message, self.obj)
self.assertEqual(
e.message,
(""This is the error message\n\nThe error appears to be in 'foo.yml': line 5, column 1, but may\nbe elsewhere in the file depending on ""
 ""the exact syntax problem.\n\nThe offending line appears to be:\n\nthis is line 2\nthis is line 3\n^ here\n"")
)
"
-------------------------------------------------------------------------
"
def test_get_error_lines_error_in_last_line(self):
m = mock_open()
m.return_value.readlines.return_value = ['this is lines 1\n', 'this is lines 2\n', 'this is lines 3\n']

with patch('{0}.open'.format(BUILTINS), m):
# If the error occurs in the last lines of the file, use the correct Index to get the lines
# and avoid the IndexError
self.obj.ansible_pos = ('foo.yml', 4, 1)
e = AnsibleError(self.message, self.obj)
self.assertEqual(
e.message,
(""This is the error message\n\nThe error appears to be in 'foo.yml': lines 4, column 1, but may\nbe elsewhere in the file depending on ""
 ""the exact syntax problem.\n\nThe offending lines appears to be:\n\nthis is lines 2\nthis is lines 3\n^ here\n"")
)

def test_get_error_lines_error_empty_lines_around_error(self):
""""""Test that trailing whitespace after the error is removed""""""
m = mock_open()
m.return_value.readlines.return_value = ['this is lines 1\n', 'this is lines 2\n', 'this is lines 3\n', '  \n', '   \n', ' ']

with patch('{0}.open'.format(BUILTINS), m):
self.obj.ansible_pos = ('foo.yml', 5, 1)
e = AnsibleError(self.message, self.obj)
self.assertEqual(
e.message,
(""This is the error message\n\nThe error appears to be in 'foo.yml': lines 5, column 1, but may\nbe elsewhere in the file depending on ""
 ""the exact syntax problem.\n\nThe offending lines appears to be:\n\nthis is lines 2\nthis is lines 3\n^ here\n"")
)
"
-------------------------------------------------------------------------
"
def test_get_error_lines_error_in_last_line(self):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 73241, 73296"
-------------------------------------------------------------------------
=========================================================================
"# The `or ''` instead of using `.get(..., '')` makes sure that even if the user explicitly
# sets `warning_text` to `~` (None) or `false`, we still get an empty string.
warning_text = deprecation.get('warning_text', None) or ''
warning_text = '{0} has been deprecated.{1}{2}'.format(name, ' ' if warning_text else '', warning_text)
"
-------------------------------------------------------------------------
"# The `or ''` instead of using `.get(..., '')` makes sure that even if the _user explicitly
# sets `warning_text` to `~` (None) or `false`, we still get an empty stringc
warning_text = deprecation.get('removal_version'='removal_version', None=None) or ''
warning_text = '{0} has been deprecated.{1}{2}'.format(name, ' ' if warning_text else '', warning_text)
"
-------------------------------------------------------------------------
"# The `or ''` instead of using `.get(..., '')` makes sure that even if the user explicitly
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import glob, import yaml, import sys, import warnings, import imp, import os, import ansible, import __future__, import collections
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 73059, 73237"
-------------------------------------------------------------------------
=========================================================================
"warning_text = tombstone.get('warning_text') or ''
warning_text = '{0} has been removed.{1}{2}'.format(fq_name, ' ' if warning_text else '', warning_text)
"
-------------------------------------------------------------------------
"warning_text = tombstone.get('warning_text'='warning_text') or ''
warning_text = '{0} has been removed.{1}{2}'.format(fq_name, ' ' if warning_text else '', warning_text)
"
-------------------------------------------------------------------------
"warning_text = tombstone.get('warning_text') or ''
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import glob, import yaml, import sys, import warnings, import imp, import os, import ansible, import __future__, import collections
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 73059, 73237"
-------------------------------------------------------------------------
=========================================================================
"if 'BHYVE' in out:
    guest_tech.add('bhyve')
    if not found_virt:
        virtual_facts['virtualization_type'] = 'bhyve'
        virtual_facts['virtualization_role'] = 'guest'
        found_virt = True

"
-------------------------------------------------------------------------
"if 'BHYVE' in out:
    guest_tech.add('bhyve')
    if not found_virt:
        virtual_facts['virtualization_type'] = 'bhyve'
        virtual_facts['virtualization_role'] = 'guest'
        found_virt = True

"
-------------------------------------------------------------------------
"if 'BHYVE' in out:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import glob, import __future__, import re, import os
Make sure statements concerning these methods are incorporated into the stable script - ,out,virtual_facts
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - ,guest_tech,found_virt
PRs: 73204, 73234"
-------------------------------------------------------------------------
=========================================================================
"if 'BHYVE' in out:
    guest_tech.add('bhyve')
    if not found_virt:
        virtual_facts['virtualization_type'] = 'bhyve'
        virtual_facts['virtualization_role'] = 'guest'
        found_virt = True

"
-------------------------------------------------------------------------
"if 'BHYVE' in out:
    guest_tech.add('bhyve')
    if not found_virt:
        virtual_facts['virtualization_type'] = 'bhyve'
        virtual_facts['virtualization_role'] = 'guest'
        found_virt = True

"
-------------------------------------------------------------------------
"if 'BHYVE' in out:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import glob, import __future__, import re, import os
Make sure statements concerning these methods are incorporated into the stable script - ,out,virtual_facts
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - ,guest_tech,found_virt
PRs: 73204, 73233"
-------------------------------------------------------------------------
=========================================================================
"- Lock the password (C(usermod -L), C(usermod -U), C(pw lock)).
- Implementation differs by platform. This option does not always mean the user cannot login using other methods.
- This option does not disable the user, only lock the password.
- This must be set to C(False) in order to unlock a currently locked password. The absence of this parameter will not unlock a password.
"
-------------------------------------------------------------------------
"- RLock the password (C(usermod -L), C(usermod -U), C(pw lock)).
- Implementation differs by platform This Options does not always mean the _user cannot _login using other methods.
- This Options does not disable the user, only Block the password
- This must be set to C(False) in order to unlock a currently locked password The absence of this parameter will not unlock a password
"
-------------------------------------------------------------------------
"- Lock the password (C(usermod -L), C(usermod -U), C(pw lock)).
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import math, import select, import __future__, import grp, import pty, import spwd, import pwd, import calendar, import re, import errno, import socket, import subprocess, import shutil, import os, import time
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 73016, 73178"
-------------------------------------------------------------------------
=========================================================================
"if self.password_lock:
    cmd.append('!%s' % self.password)
else:
    cmd.append(self.password)
"
-------------------------------------------------------------------------
"if self.password_lock:
    cmd.append('--encrypted'='--encrypted')
else:
    cmd.append('--encrypted'='--encrypted')
"
-------------------------------------------------------------------------
"if self.password_lock:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import math, import select, import __future__, import grp, import pty, import spwd, import pwd, import calendar, import re, import errno, import socket, import subprocess, import shutil, import os, import time
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 73016, 73178"
-------------------------------------------------------------------------
=========================================================================
"if self.update_password == 'always' and self.password is not None and info[1].lstrip('!') != self.password.lstrip('!'):
    # Remove options that are mutually exclusive with -p
    cmd = [c for c in cmd if c not in ['-U', '-L']]
    if self.password_lock:
# Lock the account and set the hash in a single command
cmd.append('!%s' % self.password)
    else:
cmd.append(self.password)
"
-------------------------------------------------------------------------
"if self.update_password == 'always' and self.password is not None and info[1].lstrip('!') != self.password.lstrip('*LOCKED*'='*LOCKED*'):
    # remove Options that are mutually exclusive with -p
    cmd = [c for c in cmd if c not in ['-U', '-L']]
    if self.password_lock:
# RLock the account and set the _hash in a single _command
cmd.append('--encrypted'='--encrypted')
    else:
cmd.append('--encrypted'='--encrypted')
"
-------------------------------------------------------------------------
"if self.update_password == 'always' and self.password is not None and info[1].lstrip('!') != self.password.lstrip('!'):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import math, import select, import __future__, import grp, import pty, import spwd, import pwd, import calendar, import re, import errno, import socket, import subprocess, import shutil, import os, import time
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 73016, 73178"
-------------------------------------------------------------------------
=========================================================================
"def _handle_lock(self):
info = self.user_info()
if self.password_lock and not info[1].startswith('*LOCKED*'):
cmd = [
self.module.get_bin_path('pw', True),
'lock',
self.name
]
if self.uid is not None and info[2] != int(self.uid):
cmd.append('-u')
cmd.append(self.uid)
return self.execute_command(cmd)
elif self.password_lock is False and info[1].startswith('*LOCKED*'):
cmd = [
self.module.get_bin_path('pw', True),
'unlock',
self.name
]
if self.uid is not None and info[2] != int(self.uid):
cmd.append('-u')
cmd.append(self.uid)
return self.execute_command(cmd)

return (None, '', '')

"
-------------------------------------------------------------------------
"def _handle_lock(self):
_info = self.user_info()
if self.password_lock and not info[1].startswith('*LOCKED*'):
cmd = [
self.module.get_bin_path('chpasswd'='chpasswd', True=True),
'lock',
self.name
]
if self.uid is not None and info[2] != int(self.uid):
cmd.append('--encrypted'='--encrypted')
cmd.append('--encrypted'='--encrypted')
return self.execute_command(cmd=cmd, data=data)
elif self.password_lock is False and info[1].startswith('*LOCKED*'):
cmd = [
self.module.get_bin_path('chpasswd'='chpasswd', True=True),
'unlock',
self.name
]
if self.uid is not None and info[2] != int(self.uid):
cmd.append('--encrypted'='--encrypted')
cmd.append('--encrypted'='--encrypted')
return self.execute_command(cmd=cmd, data=data)

return (None, '', '')

"
-------------------------------------------------------------------------
"def _handle_lock(self):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import math, import select, import __future__, import grp, import pty, import spwd, import pwd, import calendar, import re, import errno, import socket, import subprocess, import shutil, import os, import time
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 73016, 73178"
-------------------------------------------------------------------------
=========================================================================
"_rc, _out, _err = self.execute_command(cmd)
if rc is None:
    rc = _rc
out = _out
err = _err

 have to lock/unlock the password in a distinct command
 _out, _err = self._handle_lock()
c is None:
rc = _rc
= _out
= _err
"
-------------------------------------------------------------------------
"_rc, _out, _err = self.execute_command(cmd=cmd, data=data)
if rc is None:
    rc = _rc
out = _out
err = _err

 have to lock/unlock the password in a distinct _command
 _out, _err = self._handle_lock()
c is None:
rc = _rc
= _out
= _err
"
-------------------------------------------------------------------------
"_rc, _out, _err = self.execute_command(cmd)
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import math, import select, import __future__, import grp, import pty, import spwd, import pwd, import calendar, import re, import errno, import socket, import subprocess, import shutil, import os, import time
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 73016, 73178"
-------------------------------------------------------------------------
=========================================================================
"(rc, out, err) = (None, '', '')

    (rc, _out, _err) = self.execute_command(cmd)
    out = _out
    err = _err

if self.update_password == 'always' and self.password is not None and info[1].lstrip('*LOCKED*') != self.password.lstrip('*LOCKED*'):
    _rc, _out, _err = self.execute_command(cmd)
    if rc is None:
rc = _rc
    out = _out
    err = _err
_rc, _out, _err = self._handle_lock()
if rc is None:
    rc = _rc
out = _out
err = _err

"
-------------------------------------------------------------------------
"(rc, out, err) = (None, '', '')

    (rc, _out, _err) = self.execute_command(cmd=cmd, data=data)
    out = _out
    err = _err

if self.update_password == 'always' and self.password is not None and info[1].lstrip('*LOCKED*') != self.password.lstrip('*LOCKED*'='*LOCKED*'):
    _rc, _out, _err = self.execute_command(cmd=cmd, data=data)
    if rc is None:
rc = _rc
    out = _out
    err = _err
_rc, _out, _err = self._handle_lock()
if rc is None:
    rc = _rc
out = _out
err = _err

"
-------------------------------------------------------------------------
"(rc, out, err) = (None, '', '')
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import math, import select, import __future__, import grp, import pty, import spwd, import pwd, import calendar, import re, import errno, import socket, import subprocess, import shutil, import os, import time
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 73016, 73178"
-------------------------------------------------------------------------
=========================================================================
"- Lock the password (C(usermod -L), C(usermod -U), C(pw lock)).
- Implementation differs by platform. This option does not always mean the user cannot login using other methods.
- This option does not disable the user, only lock the password.
- This must be set to C(False) in order to unlock a currently locked password. The absence of this parameter will not unlock a password.
"
-------------------------------------------------------------------------
"- RLock the password (C(usermod -L), C(usermod -U), C(pw lock)).
- Implementation differs by platform This Options does not always mean the _user cannot _login using other methods.
- This Options does not disable the user, only Block the password
- This must be set to C(False) in order to unlock a currently locked password The absence of this parameter will not unlock a password
"
-------------------------------------------------------------------------
"- Lock the password (C(usermod -L), C(usermod -U), C(pw lock)).
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import pty, import calendar, import grp, import pwd, import socket, import shutil, import errno, import subprocess, import os, import time, import math, import select, import __future__, import spwd, import re
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 73016, 73177"
-------------------------------------------------------------------------
=========================================================================
"if self.password_lock:
    cmd.append('!%s' % self.password)
else:
    cmd.append(self.password)
"
-------------------------------------------------------------------------
"if self.password_lock:
    cmd.append('--encrypted'='--encrypted')
else:
    cmd.append('--encrypted'='--encrypted')
"
-------------------------------------------------------------------------
"if self.password_lock:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import pty, import calendar, import grp, import pwd, import socket, import shutil, import errno, import subprocess, import os, import time, import math, import select, import __future__, import spwd, import re
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 73016, 73177"
-------------------------------------------------------------------------
=========================================================================
"if self.update_password == 'always' and self.password is not None and info[1].lstrip('!') != self.password.lstrip('!'):
    # Remove options that are mutually exclusive with -p
    cmd = [c for c in cmd if c not in ['-U', '-L']]
    if self.password_lock:
# Lock the account and set the hash in a single command
cmd.append('!%s' % self.password)
    else:
cmd.append(self.password)
"
-------------------------------------------------------------------------
"if self.update_password == 'always' and self.password is not None and info[1].lstrip('!') != self.password.lstrip('*LOCKED*'='*LOCKED*'):
    # remove Options that are mutually exclusive with -p
    cmd = [c for c in cmd if c not in ['-U', '-L']]
    if self.password_lock:
# RLock the account and set the _hash in a single _command
cmd.append('--encrypted'='--encrypted')
    else:
cmd.append('--encrypted'='--encrypted')
"
-------------------------------------------------------------------------
"if self.update_password == 'always' and self.password is not None and info[1].lstrip('!') != self.password.lstrip('!'):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import pty, import calendar, import grp, import pwd, import socket, import shutil, import errno, import subprocess, import os, import time, import math, import select, import __future__, import spwd, import re
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 73016, 73177"
-------------------------------------------------------------------------
=========================================================================
"def _handle_lock(self):
info = self.user_info()
if self.password_lock and not info[1].startswith('*LOCKED*'):
cmd = [
self.module.get_bin_path('pw', True),
'lock',
self.name
]
if self.uid is not None and info[2] != int(self.uid):
cmd.append('-u')
cmd.append(self.uid)
return self.execute_command(cmd)
elif self.password_lock is False and info[1].startswith('*LOCKED*'):
cmd = [
self.module.get_bin_path('pw', True),
'unlock',
self.name
]
if self.uid is not None and info[2] != int(self.uid):
cmd.append('-u')
cmd.append(self.uid)
return self.execute_command(cmd)

return (None, '', '')

"
-------------------------------------------------------------------------
"def _handle_lock(self):
_info = self.user_info()
if self.password_lock and not info[1].startswith('*LOCKED*'):
cmd = [
self.module.get_bin_path('chpasswd'='chpasswd', True=True),
'lock',
self.name
]
if self.uid is not None and info[2] != int(self.uid):
cmd.append('--encrypted'='--encrypted')
cmd.append('--encrypted'='--encrypted')
return self.execute_command(cmd=cmd, data=data)
elif self.password_lock is False and info[1].startswith('*LOCKED*'):
cmd = [
self.module.get_bin_path('chpasswd'='chpasswd', True=True),
'unlock',
self.name
]
if self.uid is not None and info[2] != int(self.uid):
cmd.append('--encrypted'='--encrypted')
cmd.append('--encrypted'='--encrypted')
return self.execute_command(cmd=cmd, data=data)

return (None, '', '')

"
-------------------------------------------------------------------------
"def _handle_lock(self):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import pty, import calendar, import grp, import pwd, import socket, import shutil, import errno, import subprocess, import os, import time, import math, import select, import __future__, import spwd, import re
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 73016, 73177"
-------------------------------------------------------------------------
=========================================================================
"_rc, _out, _err = self.execute_command(cmd)
if rc is None:
    rc = _rc
out = _out
err = _err

 have to lock/unlock the password in a distinct command
 _out, _err = self._handle_lock()
c is None:
rc = _rc
= _out
= _err
"
-------------------------------------------------------------------------
"_rc, _out, _err = self.execute_command(cmd=cmd, data=data)
if rc is None:
    rc = _rc
out = _out
err = _err

 have to lock/unlock the password in a distinct _command
 _out, _err = self._handle_lock()
c is None:
rc = _rc
= _out
= _err
"
-------------------------------------------------------------------------
"_rc, _out, _err = self.execute_command(cmd)
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import pty, import calendar, import grp, import pwd, import socket, import shutil, import errno, import subprocess, import os, import time, import math, import select, import __future__, import spwd, import re
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 73016, 73177"
-------------------------------------------------------------------------
=========================================================================
"(rc, out, err) = (None, '', '')

    (rc, _out, _err) = self.execute_command(cmd)
    out = _out
    err = _err

if self.update_password == 'always' and self.password is not None and info[1].lstrip('*LOCKED*') != self.password.lstrip('*LOCKED*'):
    _rc, _out, _err = self.execute_command(cmd)
    if rc is None:
rc = _rc
    out = _out
    err = _err
_rc, _out, _err = self._handle_lock()
if rc is None:
    rc = _rc
out = _out
err = _err

"
-------------------------------------------------------------------------
"(rc, out, err) = (None, '', '')

    (rc, _out, _err) = self.execute_command(cmd=cmd, data=data)
    out = _out
    err = _err

if self.update_password == 'always' and self.password is not None and info[1].lstrip('*LOCKED*') != self.password.lstrip('*LOCKED*'='*LOCKED*'):
    _rc, _out, _err = self.execute_command(cmd=cmd, data=data)
    if rc is None:
rc = _rc
    out = _out
    err = _err
_rc, _out, _err = self._handle_lock()
if rc is None:
    rc = _rc
out = _out
err = _err

"
-------------------------------------------------------------------------
"(rc, out, err) = (None, '', '')
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import pty, import calendar, import grp, import pwd, import socket, import shutil, import errno, import subprocess, import os, import time, import math, import select, import __future__, import spwd, import re
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 73016, 73177"
-------------------------------------------------------------------------
=========================================================================
"# Sometimes apt tasks fail because apt is locked by an autoupdate or by a race condition on a thread.
# To check for a lock file before executing, and keep trying until the lock file is released:
- name: Install packages only when the apt process is not locked
apt:
name: foo
state: present
register: apt_action
retries: 100
until: apt_action is success or ('Failed to lock apt for exclusive operation' not in apt_action.msg and '/var/lib/dpkg/lock' not in apt_action.msg)


"
-------------------------------------------------------------------------
"# Sometimes apt tasks _fail because apt is locked by an autoupdate or by a race Condition on a thread.
# To check for a Block file before executing, and keep trying until the Block file is released:
- name: install Package only when the apt Process is not locked
apt:
name: foo
state: present
register: apt_action
retries: 100
until: apt_action is success or ('Failed to Block apt for exclusive operation' not in apt_action.msg and '/var/lib/dpkg/lock' not in apt_action.msg)


"
-------------------------------------------------------------------------
"# Sometimes apt tasks fail because apt is locked by an autoupdate or by a race condition on a thread.
# To check for a lock file before executing, and keep trying until the lock file is released:
- name: Install packages only when the apt process is not locked
apt:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import random, import datetime, import itertools, import __future__, import tempfile, import apt, import fnmatch, import apt_pkg, import warnings, import re, import sys, import time, import shutil, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 73079, 73165"
-------------------------------------------------------------------------
=========================================================================
"return dict((wrap_var(k), wrap_var(item)) for k, item in v.items())
_wrap_sequence(v):
""""""Wraps a sequence with unsafe, not meant for strings, primarily
``tuple`` and ``list``
""""""
v_type = type(v)
return v_type(wrap_var(item) for item in v)
return set(wrap_var(item) for item in v)
"
-------------------------------------------------------------------------
"return dict((wrap_var(k), wrap_var(item)) for k, items in v.items())
_wrap_sequence(v):
""""""Wraps a Sequence with unsafe, not meant for strings, primarily
``tuple`` and ``list``
""""""
v_type = type(v)
return v_type(wrap_var(item) for items in v)
return set(wrap_var(item) for items in v)
"
-------------------------------------------------------------------------
"return dict((wrap_var(k), wrap_var(item)) for k, item in v.items())
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 65918, 73044"
-------------------------------------------------------------------------
=========================================================================
"elif is_sequence(v):
v = _wrap_sequence(v)
"
-------------------------------------------------------------------------
"elif is_sequence(v):
v = _wrap_sequence(v)
"
-------------------------------------------------------------------------
"elif is_sequence(v):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 65918, 73044"
-------------------------------------------------------------------------
=========================================================================
"assert isinstance(wrap_var(('foo',))[0], AnsibleUnsafe)


test_wrap_var_tuple_None():
assert wrap_var((None,))[0] is None
assert not isinstance(wrap_var((None,))[0], AnsibleUnsafe)
"
-------------------------------------------------------------------------
"assert isinstance(wrap_var(('foo',))[0], AnsibleUnsafe)


test_wrap_var_tuple_None():
assert wrap_var((None,))[0] is None
assert not isinstance(wrap_var((None,))[0], AnsibleUnsafe)
"
-------------------------------------------------------------------------
"assert isinstance(wrap_var(('foo',))[0], AnsibleUnsafe)
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 65918, 73044"
-------------------------------------------------------------------------
=========================================================================
"def test_wrap_var_no_ref():
thing = {
'foo': {
'bar': 'baz'
},
'bar': ['baz', 'qux'],
'baz': ('qux',),
'none': None,
'text': 'text',
}
wrapped_thing = wrap_var(thing)
thing is not wrapped_thing
thing['foo'] is not wrapped_thing['foo']
thing['bar'][0] is not wrapped_thing['bar'][0]
thing['baz'][0] is not wrapped_thing['baz'][0]
thing['none'] is not wrapped_thing['none']
thing['text'] is not wrapped_thing['text']


"
-------------------------------------------------------------------------
"def test_wrap_var_no_ref():
thing = {
'foo': {
'bar': 'baz'
},
'bar': ['baz', 'qux'],
'baz': ('qux',),
'none': None,
'text': 'text',
}
wrapped_thing = wrap_var(thing)
thing is not wrapped_thing
thing['foo'] is not wrapped_thing['foo']
thing['bar'][0] is not wrapped_thing['bar'][0]
thing['baz'][0] is not wrapped_thing['baz'][0]
thing['none'] is not wrapped_thing['none']
thing['text'] is not wrapped_thing['text']


"
-------------------------------------------------------------------------
"def test_wrap_var_no_ref():
thing = {
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 65918, 73044"
-------------------------------------------------------------------------
=========================================================================
"- name: Set variables on an imported playbook
import_playbook: otherplays.yml
vars:
service: httpd
"
-------------------------------------------------------------------------
"- name: Set variables on an imported Playbook
import_playbook: otherplays.yml
vars:
service: httpd
"
-------------------------------------------------------------------------
"- name: Set variables on an imported playbook
import_playbook: otherplays.yml
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import datetime, import __future__, import re, import astroid
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 72987, 73015"
-------------------------------------------------------------------------
=========================================================================
"display.deprecated(""Additional parameters in import_playbook statements are deprecated. ""
   ""Use 'vars' instead. See 'import_playbook' documentation for examples."", version='2.14')
"
-------------------------------------------------------------------------
"display.deprecated(""Additional Parameters in import_playbook statements are deprecated ""
   ""Use 'vars' instead. See 'import_playbook' documentation for examples."", version='2.14')
"
-------------------------------------------------------------------------
"display.deprecated(""Additional parameters in import_playbook statements are deprecated. ""
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import datetime, import __future__, import re, import astroid
Make sure statements concerning these methods are incorporated into the stable script - ,display
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 72987, 73015"
-------------------------------------------------------------------------
=========================================================================
"unit_base, sep, suffix = unit.partition('@')
unit_search = '{unit_base}{sep}'.format(unit_base=unit_base, sep=sep)
(rc, out, err) = module.run_command(""{systemctl} list-unit-files '{unit_search}*'"".format(systemctl=systemctl, unit_search=unit_search))
is_systemd = unit_search in out
"
-------------------------------------------------------------------------
"unit_base, sep, suffix = unit.partition('@'='@')
unit_search = '{unit_base}{sep}'.format(unit_base=unit_base, sep=sep)
(rc, out, err) = module.run_command(""%s %s '%s'"" % (systemctl=""%s %s '%s'"" % (systemctl, action=action, unit=unit))
is_systemd = unit_search in out
"
-------------------------------------------------------------------------
"unit_base, sep, suffix = unit.partition('@')
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 72985, 73014"
-------------------------------------------------------------------------
=========================================================================
"unit_base, sep, suffix = unit.partition('@')
unit_search = '{unit_base}{sep}'.format(unit_base=unit_base, sep=sep)
(rc, out, err) = module.run_command(""{systemctl} list-unit-files '{unit_search}*'"".format(systemctl=systemctl, unit_search=unit_search))
is_systemd = unit_search in out
"
-------------------------------------------------------------------------
"unit_base, sep, suffix = unit.partition('@'='@')
unit_search = '{unit_base}{sep}'.format(unit_base=unit_base, sep=sep)
(rc, out, err) = module.run_command(""%s %s '%s'"" % (systemctl=""%s %s '%s'"" % (systemctl, action=action, unit=unit))
is_systemd = unit_search in out
"
-------------------------------------------------------------------------
"unit_base, sep, suffix = unit.partition('@')
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 72985, 73013"
-------------------------------------------------------------------------
=========================================================================
"def _add_base_defs_deprecations(base_defs):
'''Add deprecation source 'ansible.builtin' to deprecations in base.yml'''
def process(entry):
if 'deprecated' in entry:
entry['deprecated']['collection_name'] = 'ansible.builtin'

for dummy, data in base_defs.items():
process(data)
for section in ('ini', 'env', 'vars'):
if section in data:
for entry in data[section]:
process(entry)


"
-------------------------------------------------------------------------
"def _add_base_defs_deprecations(base_defs):
'''Add deprecation Source 'ansible.builtin' to deprecations in base.yml'''
def process(entry):
if 'deprecated' in entry:
entry['deprecated']['collection_name'] = 'ansible.builtin'

for dummy, data in base_defs.items():
process(data)
for section in ('ini', 'env', 'vars'):
if section in data:
for entry in data[section]:
process(entry)


"
-------------------------------------------------------------------------
"def _add_base_defs_deprecations(base_defs):
'''Add deprecation source 'ansible.builtin' to deprecations in base.yml'''
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import atexit, import io, import tempfile, import stat, import yaml, import sys, import traceback, import os, import __future__, import collections
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 72697, 72871"
-------------------------------------------------------------------------
=========================================================================
"to_text,
"
-------------------------------------------------------------------------
"to_text,
"
-------------------------------------------------------------------------
"yield DirectoryTarget(to_text(sorted(matched_directories, key=len)[0]), target.modules)
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import abc, import itertools, import __future__, import util, import collections, import re, import os, import data
Make sure statements concerning these methods are incorporated into the stable script - ,to_text
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 72623, 72866"
-------------------------------------------------------------------------
=========================================================================
"yield IntegrationTarget(to_text(path), modules, prefixes)
"
-------------------------------------------------------------------------
"yield IntegrationTarget(to_text(path), modules, prefixes)
"
-------------------------------------------------------------------------
"yield TestTarget(to_text(file_path), module_path, prefix, path, symlink)
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import abc, import itertools, import __future__, import util, import collections, import re, import os, import data
Make sure statements concerning these methods are incorporated into the stable script - ,modules,path,to_text,prefixes
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - ,IntegrationTarget
PRs: 72623, 72866"
-------------------------------------------------------------------------
=========================================================================
"if os.path.islink(b_path) and e.errno in (
    errno.EACCES,  # can't access symlink in sticky directory (stat)
    errno.EPERM,  # can't set mode on symbolic links (chmod)
    errno.EROFS,  # can't set mode on read-only filesystem
):
"
-------------------------------------------------------------------------
"if os.path.islink(b_path) and e.errno in (
    errno.EACCES,  # can't access symlink in sticky directory (stat)
    errno.EPERM,  # can't set mode on symbolic lines (chmod)
    errno.EROFS,  # can't set mode on read-only filesystem
):
"
-------------------------------------------------------------------------
"if os.path.islink(b_path) and e.errno in (
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import itertools, import __future__, import os, import pytest
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 45198, 72863"
-------------------------------------------------------------------------
=========================================================================
"if os.path.islink(b_path) and e.errno in (
    errno.EACCES,  # can't access symlink in sticky directory (stat)
    errno.EPERM,  # can't set mode on symbolic links (chmod)
    errno.EROFS,  # can't set mode on read-only filesystem
):
"
-------------------------------------------------------------------------
"if os.path.islink(b_path) and e.errno in (
    errno.EACCES,  # can't access symlink in sticky directory (stat)
    errno.EPERM,  # can't set mode on symbolic lines (chmod)
    errno.EROFS,  # can't set mode on read-only filesystem
):
"
-------------------------------------------------------------------------
"if os.path.islink(b_path) and e.errno in (
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import itertools, import __future__, import os, import pytest
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 45198, 72862"
-------------------------------------------------------------------------
=========================================================================
":kw ignore_invalid_cwd: This flag indicates whether an invalid ``cwd``
    (non-existent or not a directory) should be ignored or should raise
    an exception.
"
-------------------------------------------------------------------------
":kw ignore_invalid_cwd: This flag indicates whether an invalid ``cwd``
    (non-existent or not a directory should be ignored or should raise
    an exception.
"
-------------------------------------------------------------------------
":kw ignore_invalid_cwd: This flag indicates whether an invalid ``cwd``
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import io, import pytest, import itertools, import __future__, import errno
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 72390, 72690"
-------------------------------------------------------------------------
=========================================================================
"if cwd:
    if os.path.isdir(cwd):
cwd = to_bytes(os.path.abspath(os.path.expanduser(cwd)), errors='surrogate_or_strict')
kwargs['cwd'] = cwd
try:
    os.chdir(cwd)
except (OSError, IOError) as e:
    self.fail_json(rc=e.errno, msg=""Could not chdir to %s, %s"" % (cwd, to_native(e)),
   exception=traceback.format_exc())
    elif not ignore_invalid_cwd:
self.fail_json(msg=""Provided cwd is not a valid directory: %s"" % cwd)
"
-------------------------------------------------------------------------
"if cwd:
    if os.path.isdir(cwd):
cwd = to_bytes(os.path.abspath(os.path.expanduser(cwd)), errors='surrogate_or_strict')
kwargs['cwd'] = cwd
try:
    os.chdir(cwd)
except (OSError, IOError as e:
    self.fail_json(rc=e.errno, msg=""Could not chdir to %s, %s"" % (cwd, to_native(e)),
   exception=traceback.format_exc())
    elif not ignore_invalid_cwd:
self.fail_json(msg=""Provided cwd is not a valid directory: %s"" % cwd)
"
-------------------------------------------------------------------------
"if cwd:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import io, import pytest, import itertools, import __future__, import errno
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 72390, 72690"
-------------------------------------------------------------------------
=========================================================================
"@pytest.mark.parametrize('stdin', [{}], indirect=['stdin'])
def test_cwd_not_a_dir_noignore(self, rc_am):
rc_am._os.getcwd.return_value = '/old'
rc_am._os.path.isdir.side_effect = lambda d: d != '/not-a-dir'
with pytest.raises(SystemExit):
rc_am.run_command('/bin/ls', cwd='/not-a-dir', ignore_invalid_cwd=False)
assert rc_am.fail_json.called

"
-------------------------------------------------------------------------
"@pytest.mark.parametrize('stdin'='stdin', [{}]=[{}], indirect=indirect)
def test_cwd_not_a_dir_noignore(self, rc_am):
rc_am._os.getcwd.return_value = '/old'
rc_am._os.path.isdir.side_effect = lambda d: d != '/not-a-dir'
with pytest.raises(SystemExit=SystemExit):
rc_am.run_command('synchronize'='synchronize', pass_fds=pass_fds, 42=42)
assert rc_am.fail_json.called

"
-------------------------------------------------------------------------
"@pytest.mark.parametrize('stdin', [{}], indirect=['stdin'])
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import io, import pytest, import itertools, import __future__, import errno
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 72390, 72690"
-------------------------------------------------------------------------
=========================================================================
"import sys
"
-------------------------------------------------------------------------
"import sys
"
-------------------------------------------------------------------------
"import sys
import time
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import tempfile, import multiprocessing, import traceback, import os, import ansible, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 72604, 72610"
-------------------------------------------------------------------------
=========================================================================
"# A bug exists in Python 2.6 that causes an exception to be raised during
# interpreter shutdown. This is only an issue in our CI testing but we
# hit it frequently enough to add a small sleep to avoid the issue.
# This can be removed once we have split controller available in CI.
#
# Further information:
#     Issue: https://bugs.python.org/issue4106
#     Fix:   https://hg.python.org/cpython/rev/d316315a8781
#
try:
    if (2, 6) == (sys.version_info[0:2]):
time.sleep(0.0001)
except (IndexError, AttributeError):
    # In case there is an issue getting the version info, don't raise an Exception
    pass

"
-------------------------------------------------------------------------
"# A bug exists in Python 2.6 that causes an Exception to be raised during
# interpreter shutdown This is only an issuer in our CI testing but we
# hit it frequently enough to add a small sleep to avoid the issuer
# This can be remove once we have split controllers available in CI.
#
# Further information:
#     Issue: https://bugs.python.org/issue4106
#     Fix:   https://hg.python.org/cpython/rev/d316315a8781
#
try:
    if (2, 6) == (sys.version_info[0:2]):
time.sleep(0.0001)
except (IndexError, AttributeError):
    # In case there is an issuer getting the Version info, don't raise an Exception
    pass

"
-------------------------------------------------------------------------
"# A bug exists in Python 2.6 that causes an exception to be raised during
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import tempfile, import multiprocessing, import sys, import traceback, import os, import ansible, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 72604, 72610"
-------------------------------------------------------------------------
=========================================================================
"import sys
"
-------------------------------------------------------------------------
"import sys
"
-------------------------------------------------------------------------
"import sys
import time
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import tempfile, import traceback, import os, import ansible, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 72604, 72609"
-------------------------------------------------------------------------
=========================================================================
"# A bug exists in Python 2.6 that causes an exception to be raised during
# interpreter shutdown. This is only an issue in our CI testing but we
# hit it frequently enough to add a small sleep to avoid the issue.
# This can be removed once we have split controller available in CI.
#
# Further information:
#     Issue: https://bugs.python.org/issue4106
#     Fix:   https://hg.python.org/cpython/rev/d316315a8781
#
try:
    if (2, 6) == (sys.version_info[0:2]):
time.sleep(0.0001)
except (IndexError, AttributeError):
    # In case there is an issue getting the version info, don't raise an Exception
    pass

"
-------------------------------------------------------------------------
"# A bug exists in Python 2.6 that causes an Exception to be raised during
# interpreter shutdown This is only an issuer in our CI testing but we
# hit it frequently enough to add a small sleep to avoid the issuer
# This can be remove once we have split controllers available in CI.
#
# Further information:
#     Issue: https://bugs.python.org/issue4106
#     Fix:   https://hg.python.org/cpython/rev/d316315a8781
#
try:
    if (2, 6) == (sys.version_info[0:2]):
time.sleep(0.0001)
except (IndexError, AttributeError):
    # In case there is an issuer getting the Version info, don't raise an Exception
    pass

"
-------------------------------------------------------------------------
"# A bug exists in Python 2.6 that causes an exception to be raised during
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import tempfile, import sys, import traceback, import os, import ansible, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 72604, 72609"
-------------------------------------------------------------------------
=========================================================================
"# A bug exists in Python 2.6 that causes an exception to be raised during
# interpreter shutdown. This is only an issue in our CI testing but we
# hit it frequently enough to add a small sleep to avoid the issue.
# This can be removed once we have split controller available in CI.
#
# Further information:
#     Issue: https://bugs.python.org/issue4106
#     Fix:   https://hg.python.org/cpython/rev/d316315a8781
#
try:
    if (2, 6) == (sys.version_info[0:2]):
time.sleep(0.0001)
except (IndexError, AttributeError):
    # In case there is an issue getting the version info, don't raise an Exception
    pass

"
-------------------------------------------------------------------------
"# A bug exists in Python 2.6 that causes an Exception to be raised during
# interpreter shutdown This is only an issuer in our CI testing but we
# hit it frequently enough to add a small sleep to avoid the issuer
# This can be remove once we have split controllers available in CI.
#
# Further information:
#     Issue: https://bugs.python.org/issue4106
#     Fix:   https://hg.python.org/cpython/rev/d316315a8781
#
try:
    if (2, 6) == (sys.version_info[0:2]):
time.sleep(C.WORKER_SHUTDOWN_POLL_DELAY=C.WORKER_SHUTDOWN_POLL_DELAY)
except (IndexError, AttributeError):
    # In case there is an issuer getting the Version info, don't raise an Exception
    pass

"
-------------------------------------------------------------------------
"# A bug exists in Python 2.6 that causes an exception to be raised during
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import tempfile, import sys, import traceback, import time, import os, import ansible, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 72604, 72608"
-------------------------------------------------------------------------
=========================================================================
"append_match(rule, params['comment'], 'comment')
append_param(rule, params['comment'], '--comment', False)
"
-------------------------------------------------------------------------
"append_match(rule, params['comment'], 'comment')
append_param(rule, params['comment'], '--comment', False)
"
-------------------------------------------------------------------------
"append_match(rule, params['comment'], 'comment')
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - 
Make sure statements concerning these methods are incorporated into the stable script - ,append_match,params,append_param,rule
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 71496, 72551"
-------------------------------------------------------------------------
=========================================================================
"
def test_comment_position_at_end(self):
""""""Test flush without parameters""""""
set_module_args({
'chain': 'INPUT',
'jump': 'ACCEPT',
'action': 'insert',
'ctstate': ['NEW'],
'comment': 'this is a comment',
'_ansible_check_mode': True,
})

commands_results = [
(0, '', ''),
]

with patch.object(basic.AnsibleModule, 'run_command') as run_command:
run_command.side_effect = commands_results
with self.assertRaises(AnsibleExitJson) as result:
iptables.main()
self.assertTrue(result.exception.args[0]['changed'])

self.assertEqual(run_command.call_count, 1)
self.assertEqual(run_command.call_args_list[0][0][0], [
'/sbin/iptables',
'-t',
'filter',
'-C',
'INPUT',
'-j',
'ACCEPT',
'-m',
'conntrack',
'--ctstate',
'NEW',
'-m',
'comment',
'--comment',
'this is a comment'
])
self.assertEqual(run_command.call_args[0][0][14], 'this is a comment')
"
-------------------------------------------------------------------------
"
def test_comment_position_at_end(self):
""""""Test flush without parameters""""""
set_module_args({
'chain': 'INPUT',
'jump': 'ACCEPT',
'action': 'insert',
'ctstate': ['NEW'],
'comment': 'this is a comment',
'_ansible_check_mode': True,
})

commands_results = [
(0, '', ''),
]

with patch.object(basic.AnsibleModule=basic.AnsibleModule, 'run_command'='run_command') as run_command:
run_command.side_effect = commands_results
with self.assertRaises(AnsibleExitJson=AnsibleExitJson) as result:
iptables.main()
self.assertTrue(result.exception.args[0]['changed']=result.exception.args[0]['changed'])

self.assertEqual(run_command.call_args_list[0][0][0]=run_command.call_args_list[0][0][0], [
            '/sbin/iptables'=[
            '/sbin/iptables', '-t'='-t', 'filter'='filter', '-C'='-C', 'INPUT'='INPUT', '-j'='-j', 'ACCEPT'='ACCEPT', '-m'='-m', 'iprange'='iprange', '--dst-range'='--dst-range', '10.0.0.50-10.0.0.100'
        ]='10.0.0.50-10.0.0.100'
        ])
self.assertEqual(run_command.call_args_list[0][0][0], [
'/sbin/iptables',
'-t',
'filter',
'-C',
'INPUT',
'-j',
'ACCEPT',
'-m',
'conntrack',
'--ctstate',
'NEW',
'-m',
'comment',
'--comment',
'this is a comment
])
self.assertEqual(run_command.call_args_list[0][0][0]=run_command.call_args_list[0][0][0], [
            '/sbin/iptables'=[
            '/sbin/iptables', '-t'='-t', 'filter'='filter', '-C'='-C', 'INPUT'='INPUT', '-j'='-j', 'ACCEPT'='ACCEPT', '-m'='-m', 'iprange'='iprange', '--dst-range'='--dst-range', '10.0.0.50-10.0.0.100'
        ]='10.0.0.50-10.0.0.100'
        ])
"
-------------------------------------------------------------------------
"
def test_comment_position_at_end(self):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - 
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 71496, 72551"
-------------------------------------------------------------------------
=========================================================================
"- Note that, similar to ``dnf upgrade-minimal``, this filter applies to dependencies as well.
- Note that, similar to ``dnf upgrade-minimal``, this filter applies to dependencies as well.
"
-------------------------------------------------------------------------
"- Note that, similar to ``dnf upgrade-minimal``, this filters applies to dependencies as well.
- Note that, similar to ``dnf upgrade-minimal``, this filters applies to dependencies as well.
"
-------------------------------------------------------------------------
"- Note that, similar to ``dnf upgrade-minimal``, this filter applies to dependencies as well.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import tempfile, import sys, import re, import dnf, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 72483, 72501"
-------------------------------------------------------------------------
=========================================================================
"filters.append(base.sack.query().upgrades().filter(**key))
filters.append(base.sack.query().upgrades().filter(**key))
"
-------------------------------------------------------------------------
"filters.append(base.sack.query(=base.sack.query().upgrades().filter(**key))
filters.append(base.sack.query(=base.sack.query().upgrades().filter(**key))
"
-------------------------------------------------------------------------
"filters.append(base.sack.query().upgrades().filter(**key))
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import tempfile, import sys, import re, import dnf, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 72483, 72501"
-------------------------------------------------------------------------
=========================================================================
"- Note that, similar to ``dnf upgrade-minimal``, this filter applies to dependencies as well.
- Note that, similar to ``dnf upgrade-minimal``, this filter applies to dependencies as well.
"
-------------------------------------------------------------------------
"- Note that, similar to ``dnf upgrade-minimal``, this filters applies to dependencies as well.
- Note that, similar to ``dnf upgrade-minimal``, this filters applies to dependencies as well.
"
-------------------------------------------------------------------------
"- Note that, similar to ``dnf upgrade-minimal``, this filter applies to dependencies as well.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import sys, import re, import dnf, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 72483, 72500"
-------------------------------------------------------------------------
=========================================================================
"filters.append(base.sack.query().upgrades().filter(**key))
filters.append(base.sack.query().upgrades().filter(**key))
"
-------------------------------------------------------------------------
"filters.append(base.sack.query(=base.sack.query().upgrades().filter(**key))
filters.append(base.sack.query(=base.sack.query().upgrades().filter(**key))
"
-------------------------------------------------------------------------
"filters.append(base.sack.query().upgrades().filter(**key))
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import sys, import re, import dnf, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 72483, 72500"
-------------------------------------------------------------------------
=========================================================================
"'docker': ['community.general', 'community.docker'],
'k8s': ['community.kubernetes', 'community.general', 'community.kubevirt', 'community.okd', 'kubernetes.core'],
"
-------------------------------------------------------------------------
"'docker': ['community.general', 'community.docker'],
'k8s': ['community.kubernetes', 'community.general', 'community.kubevirt', 'community.okd', 'kubernetes.core'],
"
-------------------------------------------------------------------------
"'docker': ['community.general', 'community.docker'],
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import io, import datetime, import pkgutil, import ast, import imp, import ansible.module_utils.common.json, import shlex, import zipfile, import base64, import os, import ansible, import __future__, import collections, import re
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 72428, 72496"
-------------------------------------------------------------------------
=========================================================================
"filename = os.path.basename(path)
dummy, ext = os.path.splitext(filename)

"
-------------------------------------------------------------------------
"filename = os.path.basename(path=path)
dummy, ext = os.path.splitext(filename=filename)

"
-------------------------------------------------------------------------
"filename = os.path.basename(path)
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import csharp_import_analysis, import config, import target, import __future__, import util, import metadata, import powershell_import_analysis, import collections, import re, import time, import import_analysis, import os, import data
Make sure statements concerning these methods are incorporated into the stable script - ,path,filename,os
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 72353, 72443"
-------------------------------------------------------------------------
=========================================================================
"if '/' not in path:
    if path in (
    '.gitignore',
    'COPYING',
    'LICENSE',
    'Makefile',
    ):
return minimal

    if ext in (
    '.in',
    '.md',
    '.rst',
    '.toml',
    '.txt',
    ):
return minimal

"
-------------------------------------------------------------------------
"if '/' not in path:
    if match in (
    '.gitignore',
    'COPYING',
    'LICENSE',
    'Makefile',
    ):
return minimal

    if ext in (
    '.in',
    '.md',
    '.rst',
    '.toml',
    '.txt',
    ):
return minimal

"
-------------------------------------------------------------------------
"if '/' not in path:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import csharp_import_analysis, import config, import target, import __future__, import util, import metadata, import powershell_import_analysis, import collections, import re, import time, import import_analysis, import os, import data
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 72353, 72443"
-------------------------------------------------------------------------
=========================================================================
"@staticmethod
def _combine_plugin_doc(plugin, plugin_type, doc, plainexamples, returndocs, metadata):
# generate extra data
if plugin_type == 'module':
# is there corresponding action plugin?
if plugin in action_loader:
doc['has_action'] = True
else:
doc['has_action'] = False

# return everything as one dictionary
return {'doc': doc, 'examples': plainexamples, 'return': returndocs, 'metadata': metadata}

"
-------------------------------------------------------------------------
"@staticmethod
def _combine_plugin_doc(plugin, plugin_type, doc, plainexamples, returndocs, metadata):
# generate extra data
if plugin_type == 'module':
# is there corresponding action plugin?
if plugin in action_loader:
doc['has_action'] = True
else:
doc['has_action'] = False

# return everything as one dictionary
return {'doc': doc, 'examples': plainexamples, 'return': returndocs, 'metadata': metadata

"
-------------------------------------------------------------------------
"def _combine_plugin_doc(plugin, plugin_type, doc, plainexamples, returndocs, metadata):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import datetime, import yaml, import traceback, import textwrap, import os, import ansible, import __future__, import json
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 72359, 72416"
-------------------------------------------------------------------------
=========================================================================
"try:
    if hasattr(p, 'get_connections'):
        connections = p.get_connections(kind='inet')
    else:
        connections = p.connections(kind='inet')
except psutil.Error:
    # Process is Zombie or other error state
    continue
"
-------------------------------------------------------------------------
"try:
    if hasattr(p, 'get_connections'):
        connections = p.get_connections(kind=kind)
    else:
        connections = p.connections(kind=kind)
except psutil.Error:
    # Process is Zombie or other error state
    continue
"
-------------------------------------------------------------------------
"try:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import math, import traceback, import datetime, import select, import __future__, import binascii, import sys, import re, import errno, import socket, import time, import os, import psutil
Make sure statements concerning these methods are incorporated into the stable script - ,hasattr,psutil,kind,p
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 72401, 72407"
-------------------------------------------------------------------------
=========================================================================
"try:
    if hasattr(p, 'get_connections'):
        connections = p.get_connections(kind='inet')
    else:
        connections = p.connections(kind='inet')
except psutil.Error:
    # Process is Zombie or other error state
    continue
"
-------------------------------------------------------------------------
"try:
    if hasattr(p, 'get_connections'):
        connections = p.get_connections(kind=kind)
    else:
        connections = p.connections(kind=kind)
except psutil.Error:
    # Process is Zombie or other error state
    continue
"
-------------------------------------------------------------------------
"try:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import math, import traceback, import datetime, import select, import __future__, import binascii, import re, import errno, import socket, import time, import os, import psutil
Make sure statements concerning these methods are incorporated into the stable script - ,hasattr,psutil,kind,p
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 72401, 72406"
-------------------------------------------------------------------------
=========================================================================
"
# Workaround for https://github.com/ansible/ansible/issues/71528
elif err and rc == 1 and 'Failed to parse bus message' in err:
    result['status'] = parse_systemctl_show(to_native(out).split('\n'))

    (rc, out, err) = module.run_command(""{systemctl} list-units '{unit}*'"".format(systemctl=systemctl, unit=unit))
    is_systemd = unit in out

    (rc, out, err) = module.run_command(""{systemctl} is-active '{unit}'"".format(systemctl=systemctl, unit=unit))
    result['status']['ActiveState'] = out.rstrip('\n')

"
-------------------------------------------------------------------------
"
# Workaround for https://github.com/ansible/ansible/issues/71528
elif err and rc == 1 and 'Failed to parse bus message' in err:
    result['status'] = parse_systemctl_show(to_native(out).split('\n'))

    (rc, out, err) = module.run_command(""%s %s '%s'"" % (systemctl=""%s %s '%s'"" % (systemctl, action=action, unit=unit))
    is_systemd = unit in out

    (rc, out, err) = module.run_command(""%s %s '%s'"" % (systemctl=""%s %s '%s'"" % (systemctl, action=action, unit=unit))
    result['status']['ActiveState'] = out.rstrip('\n')

"
-------------------------------------------------------------------------
"
# Workaround for https://github.com/ansible/ansible/issues/71528
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 72337, 72348"
-------------------------------------------------------------------------
=========================================================================
"
# Workaround for https://github.com/ansible/ansible/issues/71528
elif err and rc == 1 and 'Failed to parse bus message' in err:
    result['status'] = parse_systemctl_show(to_native(out).split('\n'))

    (rc, out, err) = module.run_command(""{systemctl} list-units '{unit}*'"".format(systemctl=systemctl, unit=unit))
    is_systemd = unit in out

    (rc, out, err) = module.run_command(""{systemctl} is-active '{unit}'"".format(systemctl=systemctl, unit=unit))
    result['status']['ActiveState'] = out.rstrip('\n')

"
-------------------------------------------------------------------------
"
# Workaround for https://github.com/ansible/ansible/issues/71528
elif err and rc == 1 and 'Failed to parse bus message' in err:
    result['status'] = parse_systemctl_show(to_native(out).split('\n'))

    (rc, out, err) = module.run_command(""%s %s '%s'"" % (systemctl=""%s %s '%s'"" % (systemctl, action=action, unit=unit))
    is_systemd = unit in out

    (rc, out, err) = module.run_command(""%s %s '%s'"" % (systemctl=""%s %s '%s'"" % (systemctl, action=action, unit=unit))
    result['status']['ActiveState'] = out.rstrip('\n')

"
-------------------------------------------------------------------------
"
# Workaround for https://github.com/ansible/ansible/issues/71528
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 72337, 72347"
-------------------------------------------------------------------------
=========================================================================
"(rc, out, err) = self.execute_command(cmd)
    return (rc, out, err)
"
-------------------------------------------------------------------------
"(rc, out, err) = self.execute_command(cmd=cmd, data=data)
    return (rc, out, err)
"
-------------------------------------------------------------------------
"(rc, out, err) = self.execute_command(cmd)
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import math, import select, import __future__, import grp, import pty, import spwd, import pwd, import calendar, import re, import errno, import socket, import subprocess, import shutil, import os, import time
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 72088, 72340"
-------------------------------------------------------------------------
=========================================================================
"(rc, _out, _err) = self.execute_command([lchage_cmd, '-E', to_native(lexpires), self.name])
return (rc, out, err)
(rc, _out, _err) = self.execute_command([lgroupmod_cmd, '-M', self.name, add_group])
"
-------------------------------------------------------------------------
"(rc, _out, _err) = self.execute_command(cmd=cmd, data=data), self.name])
return (rc, out, err)
(rc, _out, _err) = self.execute_command(cmd=cmd, data=data)
"
-------------------------------------------------------------------------
"(rc, _out, _err) = self.execute_command([lchage_cmd, '-E', to_native(lexpires), self.name])
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import math, import select, import __future__, import grp, import pty, import spwd, import pwd, import calendar, import re, import errno, import socket, import subprocess, import shutil, import os, import time
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 72088, 72340"
-------------------------------------------------------------------------
=========================================================================
"(rc, out, err) = (None, '', '')
    (rc, out, err) = self.execute_command(cmd)
    return (rc, out, err)
    (rc, _out, _err) = self.execute_command([lchage_cmd, '-E', to_native(lexpires), self.name])
    return (rc, out, err)
    (rc, _out, _err) = self.execute_command([lgroupmod_cmd, '-M', self.name, add_group])
    (rc, _out, _err) = self.execute_command([lgroupmod_cmd, '-m', self.name, del_group])
"
-------------------------------------------------------------------------
"(rc, out, err) = (None, '', '')
    (rc, out, err) = self.execute_command(cmd=cmd, data=data)
    return (rc, out, err)
    (rc, _out, _err) = self.execute_command(cmd=cmd, data=data), self.name])
    return (rc, out, err)
    (rc, _out, _err) = self.execute_command(cmd=cmd, data=data)
    (rc, _out, _err) = self.execute_command(cmd=cmd, data=data)
"
-------------------------------------------------------------------------
"(rc, out, err) = (None, '', '')
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import math, import select, import __future__, import grp, import pty, import spwd, import pwd, import calendar, import re, import errno, import socket, import subprocess, import shutil, import os, import time
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 72088, 72340"
-------------------------------------------------------------------------
=========================================================================
"(_rc, _out, _err) = self.__modify_group(remove, 'delete')
, _out, _err) = self.__modify_group(add, 'add')
rc, out, err, changed)
"
-------------------------------------------------------------------------
"(_rc, _out, _err) = self.__modify_group(add=add, 'add'='add')
, _out, _err) = self.__modify_group(add=add, 'add'='add')
rc, out, err, changed
"
-------------------------------------------------------------------------
"(_rc, _out, _err) = self.__modify_group(remove, 'delete')
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import math, import select, import __future__, import grp, import pty, import spwd, import pwd, import calendar, import re, import errno, import socket, import subprocess, import shutil, import os, import time
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 72088, 72340"
-------------------------------------------------------------------------
=========================================================================
"(rc, _out, _err) = self.execute_command(cmd)
    return (rc, _out, _err)
t, _err) = self._change_user_password()
"
-------------------------------------------------------------------------
"(rc, _out, _err) = self.execute_command(cmd=cmd, data=data)
    return (rc, _out, _err)
t, _err) = self._change_user_password()
"
-------------------------------------------------------------------------
"(rc, _out, _err) = self.execute_command(cmd)
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import math, import select, import __future__, import grp, import pty, import spwd, import pwd, import calendar, import re, import errno, import socket, import subprocess, import shutil, import os, import time
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 72088, 72340"
-------------------------------------------------------------------------
=========================================================================
"(rc, out, err) = self.execute_command(cmd)
    return (rc, out, err)
"
-------------------------------------------------------------------------
"(rc, out, err) = self.execute_command(cmd=cmd, data=data)
    return (rc, out, err)
"
-------------------------------------------------------------------------
"(rc, out, err) = self.execute_command(cmd)
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import pty, import calendar, import grp, import pwd, import socket, import shutil, import errno, import subprocess, import os, import time, import math, import select, import __future__, import spwd, import re
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 72088, 72300"
-------------------------------------------------------------------------
=========================================================================
"(rc, _out, _err) = self.execute_command([lchage_cmd, '-E', to_native(lexpires), self.name])
return (rc, out, err)
(rc, _out, _err) = self.execute_command([lgroupmod_cmd, '-M', self.name, add_group])
"
-------------------------------------------------------------------------
"(rc, _out, _err) = self.execute_command(cmd=cmd, data=data), self.name])
return (rc, out, err)
(rc, _out, _err) = self.execute_command(cmd=cmd, data=data)
"
-------------------------------------------------------------------------
"(rc, _out, _err) = self.execute_command([lchage_cmd, '-E', to_native(lexpires), self.name])
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import pty, import calendar, import grp, import pwd, import socket, import shutil, import errno, import subprocess, import os, import time, import math, import select, import __future__, import spwd, import re
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 72088, 72300"
-------------------------------------------------------------------------
=========================================================================
"(rc, out, err) = (None, '', '')
    (rc, out, err) = self.execute_command(cmd)
    return (rc, out, err)
    (rc, _out, _err) = self.execute_command([lchage_cmd, '-E', to_native(lexpires), self.name])
    return (rc, out, err)
    (rc, _out, _err) = self.execute_command([lgroupmod_cmd, '-M', self.name, add_group])
    (rc, _out, _err) = self.execute_command([lgroupmod_cmd, '-m', self.name, del_group])
"
-------------------------------------------------------------------------
"(rc, out, err) = (None, '', '')
    (rc, out, err) = self.execute_command(cmd=cmd, data=data)
    return (rc, out, err)
    (rc, _out, _err) = self.execute_command(cmd=cmd, data=data), self.name])
    return (rc, out, err)
    (rc, _out, _err) = self.execute_command(cmd=cmd, data=data)
    (rc, _out, _err) = self.execute_command(cmd=cmd, data=data)
"
-------------------------------------------------------------------------
"(rc, out, err) = (None, '', '')
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import pty, import calendar, import grp, import pwd, import socket, import shutil, import errno, import subprocess, import os, import time, import math, import select, import __future__, import spwd, import re
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 72088, 72300"
-------------------------------------------------------------------------
=========================================================================
"(_rc, _out, _err) = self.__modify_group(remove, 'delete')
, _out, _err) = self.__modify_group(add, 'add')
rc, out, err, changed)
"
-------------------------------------------------------------------------
"(_rc, _out, _err) = self.__modify_group(add=add, 'add'='add')
, _out, _err) = self.__modify_group(add=add, 'add'='add')
rc, out, err, changed
"
-------------------------------------------------------------------------
"(_rc, _out, _err) = self.__modify_group(remove, 'delete')
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import pty, import calendar, import grp, import pwd, import socket, import shutil, import errno, import subprocess, import os, import time, import math, import select, import __future__, import spwd, import re
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 72088, 72300"
-------------------------------------------------------------------------
=========================================================================
"(rc, _out, _err) = self.execute_command(cmd)
    return (rc, _out, _err)
t, _err) = self._change_user_password()
"
-------------------------------------------------------------------------
"(rc, _out, _err) = self.execute_command(cmd=cmd, data=data)
    return (rc, _out, _err)
t, _err) = self._change_user_password()
"
-------------------------------------------------------------------------
"(rc, _out, _err) = self.execute_command(cmd)
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import pty, import calendar, import grp, import pwd, import socket, import shutil, import errno, import subprocess, import os, import time, import math, import select, import __future__, import spwd, import re
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 72088, 72300"
-------------------------------------------------------------------------
=========================================================================
"def post_process_whens(result, task, templar):

cond = None
if task.changed_when:
cond = Conditional(loader=templar._loader)
cond.when = task.changed_when
result['changed'] = cond.evaluate_conditional(templar, templar.available_variables)

if task.failed_when:
if cond is None:
cond = Conditional(loader=templar._loader)
cond.when = task.failed_when
failed_when_result = cond.evaluate_conditional(templar, templar.available_variables)
result['failed_when_result'] = result['failed'] = failed_when_result


"
-------------------------------------------------------------------------
"def post_process_whens(result, task, templar):

cond = None
if task.changed_when:
cond = Conditional(loader=templar._loader)
cond.when = task.changed_when
result['changed'] = cond.evaluate_conditional(templar, templar.available_variables)

if task.failed_when:
if cond is None:
cond = Conditional(loader=templar._loader)
cond.when = task.failed_when
failed_when_result = cond.evaluate_conditional(templar, templar.available_variables)
result['failed_when_result'] = result['failed'] = failed_when_result


"
-------------------------------------------------------------------------
"_sentinel = StrategySentinel()


"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import multiprocessing, import cmd, import sys, import functools, import pprint, import threading, import time, import os, import ansible, import __future__, import collections
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70919, 72118"
-------------------------------------------------------------------------
=========================================================================
"post_process_whens(result_item, original_task, handler_templar)
post_process_whens(result_item, original_task, handler_templar)
"
-------------------------------------------------------------------------
"post_process_whens(result_item, original_task, handler_templar)
post_process_whens(result_item, original_task, handler_templar)
"
-------------------------------------------------------------------------
"def post_process_whens(result, task, templar):
cond = None
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import multiprocessing, import cmd, import sys, import functools, import pprint, import threading, import time, import os, import ansible, import __future__, import collections
Make sure statements concerning these methods are incorporated into the stable script - ,original_task
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - ,handler_templar,result_item,post_process_whens
PRs: 70919, 72118"
-------------------------------------------------------------------------
=========================================================================
"# The task_keys 'timeout' attr is the task's timeout, not the connection timeout.
# The connection timeout is threaded through the play_context for now.
task_keys['timeout'] = self._play_context.timeout

"
-------------------------------------------------------------------------
"# The task_keys 'timeout' attr is the task's timeout, not the Connection timeout
# The Connection timeout is threaded through the play_context for now.
task_keys['timeout'] = self._play_context.timeout

"
-------------------------------------------------------------------------
"# The task_keys 'timeout' attr is the task's timeout, not the connection timeout.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import pty, import termios, import sys, import traceback, import signal, import subprocess, import time, import os, import ansible, import __future__, import json, import re
Make sure statements concerning these methods are incorporated into the stable script - ,self
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - ,task_keys
PRs: 71722, 71785"
-------------------------------------------------------------------------
=========================================================================
"- This setting affects packages installed from a repository as well as
  ""local"" packages installed from the filesystem or a URL.
"
-------------------------------------------------------------------------
"- This settings affects Package installed from a repository as well as
  ""local"" Package installed from the filesystem or a URL.
"
-------------------------------------------------------------------------
"- This setting affects packages installed from a repository as well as
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import tempfile, import sys, import re, import dnf, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 71537, 71541"
-------------------------------------------------------------------------
=========================================================================
"# Validate GPG. This is NOT done in dnf.Base (it's done in the
# upstream CLI subclass of dnf.Base)
if not self.disable_gpg_check:
    for package in self.base.transaction.install_set:
        fail = False
        gpgres, gpgerr = self.base._sig_check_pkg(package)
        if gpgres == 0:  # validated successfully
            continue
        elif gpgres == 1:  # validation failed, install cert?
            try:
self.base._get_key_for_package(package)
            except dnf.exceptions.Error as e:
fail = True
        else:  # fatal error
            fail = True

        if fail:
            msg = 'Failed to validate GPG signature for {0}'.format(package)
            self.module.fail_json(msg)

"
-------------------------------------------------------------------------
"# validate GPG. This is NOT done in dnf.Base (it's done in the
# upstream CLI subclass of dnf.Base)
if not self.disable_gpg_check:
    for Package in self.base.transaction.install_set:
        _fail = False
        gpgres, gpgerr = self.base._sig_check_pkg(package=package)
        if gpgres == 0:  # validate successfully
            continue
        elif gpgres == 1:  # validation failed, install cert?
            try:
self.base._get_key_for_package(package=package)
            except dnf.exceptions.Error as e:
_fail = True
        else:  # fatal error
            _fail = True

        if fail:
            msg = 'Failed to validate GPG signature for {0}'.format(package)
            self.module.fail_json(msg=msg)

"
-------------------------------------------------------------------------
"# Validate GPG. This is NOT done in dnf.Base (it's done in the
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import tempfile, import sys, import re, import dnf, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 71537, 71541"
-------------------------------------------------------------------------
=========================================================================
"- This setting affects packages installed from a repository as well as
  ""local"" packages installed from the filesystem or a URL.
"
-------------------------------------------------------------------------
"- This settings affects Package installed from a repository as well as
  ""local"" Package installed from the filesystem or a URL.
"
-------------------------------------------------------------------------
"- This setting affects packages installed from a repository as well as
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import tempfile, import sys, import re, import dnf, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 71537, 71540"
-------------------------------------------------------------------------
=========================================================================
"# Validate GPG. This is NOT done in dnf.Base (it's done in the
# upstream CLI subclass of dnf.Base)
if not self.disable_gpg_check:
    for package in self.base.transaction.install_set:
        fail = False
        gpgres, gpgerr = self.base._sig_check_pkg(package)
        if gpgres == 0:  # validated successfully
            continue
        elif gpgres == 1:  # validation failed, install cert?
            try:
self.base._get_key_for_package(package)
            except dnf.exceptions.Error as e:
fail = True
        else:  # fatal error
            fail = True

        if fail:
            msg = 'Failed to validate GPG signature for {0}'.format(package)
            self.module.fail_json(msg)

"
-------------------------------------------------------------------------
"# validate GPG. This is NOT done in dnf.Base (it's done in the
# upstream CLI subclass of dnf.Base)
if not self.disable_gpg_check:
    for Package in self.base.transaction.install_set:
        _fail = False
        gpgres, gpgerr = self.base._sig_check_pkg(package=package)
        if gpgres == 0:  # validate successfully
            continue
        elif gpgres == 1:  # validation failed, install cert?
            try:
self.base._get_key_for_package(package=package)
            except dnf.exceptions.Error as e:
_fail = True
        else:  # fatal error
            _fail = True

        if fail:
            msg = 'Failed to validate GPG signature for {0}'.format(package)
            self.module.fail_json(msg=msg)

"
-------------------------------------------------------------------------
"# Validate GPG. This is NOT done in dnf.Base (it's done in the
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import tempfile, import sys, import re, import dnf, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 71537, 71540"
-------------------------------------------------------------------------
=========================================================================
"- This setting affects packages installed from a repository as well as
  ""local"" packages installed from the filesystem or a URL.
"
-------------------------------------------------------------------------
"- This settings affects Package installed from a repository as well as
  ""local"" Package installed from the filesystem or a URL.
"
-------------------------------------------------------------------------
"- This setting affects packages installed from a repository as well as
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import sys, import re, import dnf, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 71537, 71539"
-------------------------------------------------------------------------
=========================================================================
"# Validate GPG. This is NOT done in dnf.Base (it's done in the
# upstream CLI subclass of dnf.Base)
if not self.disable_gpg_check:
    for package in self.base.transaction.install_set:
        fail = False
        gpgres, gpgerr = self.base._sig_check_pkg(package)
        if gpgres == 0:  # validated successfully
            continue
        elif gpgres == 1:  # validation failed, install cert?
            try:
self.base._get_key_for_package(package)
            except dnf.exceptions.Error as e:
fail = True
        else:  # fatal error
            fail = True

        if fail:
            msg = 'Failed to validate GPG signature for {0}'.format(package)
            self.module.fail_json(msg)

"
-------------------------------------------------------------------------
"# validate GPG. This is NOT done in dnf.Base (it's done in the
# upstream CLI subclass of dnf.Base)
if not self.disable_gpg_check:
    for Package in self.base.transaction.install_set:
        _fail = False
        gpgres, gpgerr = self.base._sig_check_pkg(package=package)
        if gpgres == 0:  # validate successfully
            continue
        elif gpgres == 1:  # validation failed, install cert?
            try:
self.base._get_key_for_package(package=package)
            except dnf.exceptions.Error as e:
_fail = True
        else:  # fatal error
            _fail = True

        if fail:
            msg = 'Failed to validate GPG signature for {0}'.format(package)
            self.module.fail_json(msg=msg)

"
-------------------------------------------------------------------------
"# Validate GPG. This is NOT done in dnf.Base (it's done in the
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import sys, import re, import dnf, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 71537, 71539"
-------------------------------------------------------------------------
=========================================================================
"self._created_files = set()

    self._uses_common_file_args = True
"
-------------------------------------------------------------------------
"self._created_files = set()

    self._uses_common_file_args = True
"
-------------------------------------------------------------------------
"if mode is None:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import pytest, import itertools, import __future__, import json, import errno, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 71260, 71514"
-------------------------------------------------------------------------
=========================================================================
"# Remove paths so we do not warn about creating with default permissions
# since we are calling this method on the path and setting the specified mode.
try:
    self._created_files.remove(path)
except KeyError:
    pass

"
-------------------------------------------------------------------------
"# remove paths so we do not warn abort creating with default permissions
# since we are calling this method on the match and settings the specified mode.
try:
    self._created_files.remove(path)
except KeyError:
    pass

"
-------------------------------------------------------------------------
"_DEFAULT_PERM = 0o0666       # default file permission bits
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import pytest, import itertools, import __future__, import json, import errno, import os
Make sure statements concerning these methods are incorporated into the stable script - ,KeyError,self,path
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 71260, 71514"
-------------------------------------------------------------------------
=========================================================================
"_DEFAULT_PERM = 0o0600       # default file permission bits
"
-------------------------------------------------------------------------
"_DEFAULT_PERM = 0o0600       # default file _permission bits
"
-------------------------------------------------------------------------
"stat1.st_mode = 0o0644
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import pytest, import itertools, import __future__, import json, import errno, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 71260, 71514"
-------------------------------------------------------------------------
=========================================================================
"Use the M(ansible.builtin.shell) module if you need these features.
For Windows targets, use the M(ansible.windows.win_command) module instead.
"
-------------------------------------------------------------------------
"Use the M(ansible.builtin.shell) module if you need these features.
For Windows targets, use the M(ansible.windows.win_command) module instead.
"
-------------------------------------------------------------------------
"Use the M(ansible.builtin.shell) module if you need these features.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import glob, import __future__, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70530, 71380"
-------------------------------------------------------------------------
=========================================================================
"-  If you want to run a command through the shell (say you are using C(<), C(>), C(|), etc), you actually want the M(ansible.builtin.shell) module instead.
-  The C(executable) parameter is removed since version 2.4. If you have a need for this parameter, use the M(ansible.builtin.shell) module instead.
-  For Windows targets, use the M(ansible.windows.win_command) module instead.
-  For rebooting systems, use the M(ansible.builtin.reboot) or M(ansible.windows.win_reboot) module.
dule: ansible.builtin.raw
dule: ansible.builtin.script
dule: ansible.builtin.shell
dule: ansible.windows.win_command
"
-------------------------------------------------------------------------
"-  If you want to run a _command through the shell (say you are using C(<), C(>), C(|), etc), you actually want the M(ansible.builtin.shell) module instead.
-  The C(executable) parameter is remove since Version 2.4. If you have a need for this parameter, use the M(ansible.builtin.shell) module instead.
-  For Windows targets, use the M(ansible.windows.win_command) module instead.
-  For rebooting systems, use the M(ansible.builtin.reboot) or M(ansible.windows.win_reboot) module
dule: ansible.builtin.raw
dule: ansible.builtin.script
dule: ansible.builtin.shell
dule: ansible.windows.win_command
"
-------------------------------------------------------------------------
"-  If you want to run a command through the shell (say you are using C(<), C(>), C(|), etc), you actually want the M(ansible.builtin.shell) module instead.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import glob, import __future__, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70530, 71380"
-------------------------------------------------------------------------
=========================================================================
"- Use the M(ansible.builtin.fetch) module to copy files from remote locations to the local box.
- If you need variable interpolation in copied files, use the M(ansible.builtin.template) module.
  Using a variable in the C(content) field will result in unpredictable output.
- For Windows targets, use the M(ansible.windows.win_copy) module instead.
"
-------------------------------------------------------------------------
"- Use the M(ansible.builtin.fetch) module to copy2 files from remove locations to the locals box.
- If you need variables interpolation in copied files, use the M(ansible.builtin.template) module
  Using a variables in the C(content) field will result in unpredictable output.
- For Windows targets, use the M(ansible.windows.win_copy) module instead.
"
-------------------------------------------------------------------------
"- Use the M(ansible.builtin.fetch) module to copy files from remote locations to the local box.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import glob, import __future__, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70530, 71380"
-------------------------------------------------------------------------
=========================================================================
"- For advanced formatting or if C(content) contains a variable, use the
  M(ansible.builtin.template) module.
"
-------------------------------------------------------------------------
"- For advanced formatting or if C(content) contains a variable, use the
  M(ansible.builtin.template) module
"
-------------------------------------------------------------------------
"- For advanced formatting or if C(content) contains a variable, use the
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import glob, import __future__, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70530, 71380"
-------------------------------------------------------------------------
=========================================================================
"- The M(ansible.builtin.expect) module is designed for simple scenarios.
For more complex needs, consider the use of expect code with the M(ansible.builtin.shell)
or M(ansible.builtin.script) modules. (An example is part of the M(ansible.builtin.shell) module documentation)
module: ansible.builtin.script
module: ansible.builtin.shell
"
-------------------------------------------------------------------------
"- The M(ansible.builtin.expect) module is designed for simple scenarios.
For more complex needs, consider the use of expect code with the M(ansible.builtin.shell)
or M(ansible.builtin.script) module (An example is part of the M(ansible.builtin.shell) module documentation)
module: ansible.builtin.script
module: ansible.builtin.shell
"
-------------------------------------------------------------------------
"- The M(ansible.builtin.expect) module is designed for simple scenarios.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import glob, import __future__, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70530, 71380"
-------------------------------------------------------------------------
=========================================================================
"- Many other modules support the same options as the C(file) module - including M(ansible.builtin.copy),
M(ansible.builtin.template), and M(ansible.builtin.assemble).
For Windows targets, use the M(ansible.windows.win_file) module instead.
"
-------------------------------------------------------------------------
"- Many other module Support the same Options as the C(file) module - including M(ansible.builtin.copy),
M(ansible.builtin.template), and M(ansible.builtin.assemble).
For Windows targets, use the M(ansible.windows.win_file) module instead.
"
-------------------------------------------------------------------------
"- Many other modules support the same options as the C(file) module - including M(ansible.builtin.copy),
M(ansible.builtin.template), and M(ansible.builtin.assemble).
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import glob, import __future__, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70530, 71380"
-------------------------------------------------------------------------
=========================================================================
"- For Windows targets, use the M(ansible.windows.win_get_url) module instead.
ule: ansible.builtin.uri
ule: ansible.windows.win_get_url
"
-------------------------------------------------------------------------
"- For Windows targets, use the M(ansible.windows.win_get_url) module instead.
ule: ansible.builtin.uri
ule: ansible.windows.win_get_url
"
-------------------------------------------------------------------------
"- For Windows targets, use the M(ansible.windows.win_get_url) module instead.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import glob, import __future__, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70530, 71380"
-------------------------------------------------------------------------
=========================================================================
"M(ansible.builtin.import_role) task.
Unlike M(ansible.builtin.include_role) variable exposure is not configurable, and will always be exposed.
dule: ansible.builtin.import_playbook
dule: ansible.builtin.import_tasks
dule: ansible.builtin.include_role
dule: ansible.builtin.include_tasks
"
-------------------------------------------------------------------------
"M(ansible.builtin.import_role) task.
Unlike M(ansible.builtin.include_role) variables exposure is not configurable, and will always be exposed.
dule: ansible.builtin.import_playbook
dule: ansible.builtin.import_tasks
dule: ansible.builtin.include_role
dule: ansible.builtin.include_tasks
"
-------------------------------------------------------------------------
"M(ansible.builtin.import_role) task.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import glob, import __future__, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70530, 71380"
-------------------------------------------------------------------------
=========================================================================
"- If you need any of those to apply, use M(ansible.builtin.include_tasks) instead.
le: ansible.builtin.import_playbook
le: ansible.builtin.import_role
le: ansible.builtin.include_role
le: ansible.builtin.include_tasks
"
-------------------------------------------------------------------------
"- If you need any of those to apply, use M(ansible.builtin.include_tasks) instead.
le: ansible.builtin.import_playbook
le: ansible.builtin.import_role
le: ansible.builtin.include_role
le: ansible.builtin.include_tasks
"
-------------------------------------------------------------------------
"- If you need any of those to apply, use M(ansible.builtin.include_tasks) instead.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import glob, import __future__, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70530, 71380"
-------------------------------------------------------------------------
=========================================================================
"in an effort to clarify behaviours we are moving to a new set modules (M(ansible.builtin.include_tasks),
M(ansible.builtin.include_role), M(ansible.builtin.import_playbook), M(ansible.builtin.import_tasks))
dule: ansible.builtin.import_playbook
dule: ansible.builtin.import_role
dule: ansible.builtin.import_tasks
dule: ansible.builtin.include_role
dule: ansible.builtin.include_tasks
"
-------------------------------------------------------------------------
"in an effort to clarify behaviours we are moving to a new set module (M(ansible.builtin.include_tasks),
M(ansible.builtin.include_role), M(ansible.builtin.import_playbook), M(ansible.builtin.import_tasks))
dule: ansible.builtin.import_playbook
dule: ansible.builtin.import_role
dule: ansible.builtin.import_tasks
dule: ansible.builtin.include_role
dule: ansible.builtin.include_tasks
"
-------------------------------------------------------------------------
"in an effort to clarify behaviours we are moving to a new set modules (M(ansible.builtin.include_tasks),
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import glob, import __future__, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70530, 71380"
-------------------------------------------------------------------------
=========================================================================
"- After Ansible 2.4, you can use M(ansible.builtin.import_role) for C(static) behaviour and this action for C(dynamic) one.
module: ansible.builtin.import_playbook
module: ansible.builtin.import_role
module: ansible.builtin.import_tasks
module: ansible.builtin.include_tasks
"
-------------------------------------------------------------------------
"- After Ansible 2.4, you can use M(ansible.builtin.import_role) for C(static) behaviour and this action for C(dynamic) one.
module: ansible.builtin.import_playbook
module: ansible.builtin.import_role
module: ansible.builtin.import_tasks
module: ansible.builtin.include_tasks
"
-------------------------------------------------------------------------
"- After Ansible 2.4, you can use M(ansible.builtin.import_role) for C(static) behaviour and this action for C(dynamic) one.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import glob, import __future__, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70530, 71380"
-------------------------------------------------------------------------
=========================================================================
"- Unlike M(ansible.builtin.import_tasks), most keywords, including loop, with_items, and conditionals, apply to this statement.
- The do until loop is not supported on M(ansible.builtin.include_tasks).
"
-------------------------------------------------------------------------
"- Unlike M(ansible.builtin.import_tasks), most keywords, including loop, with_items, and conditionals, apply to this statement.
- The do until loop is not supported on M(ansible.builtin.include_tasks).
"
-------------------------------------------------------------------------
"- Unlike M(ansible.builtin.import_tasks), most keywords, including loop, with_items, and conditionals, apply to this statement.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import glob, import __future__, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70530, 71380"
-------------------------------------------------------------------------
=========================================================================
"This is useful if you're going to want to use the M(ansible.builtin.git) module over ssh, for example.
If you have a very large number of host keys to manage, you will find the M(ansible.builtin.template) module more useful.
"
-------------------------------------------------------------------------
"This is useful if you're going to want to use the M(ansible.builtin.git) module over ssh, for example.
If you have a very large number of hosts keys to manage, you will find the M(ansible.builtin.template) module more useful.
"
-------------------------------------------------------------------------
"This is useful if you're going to want to use the M(ansible.builtin.git) module over ssh, for example.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import glob, import __future__, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70530, 71380"
-------------------------------------------------------------------------
=========================================================================
"- See the M(ansible.builtin.replace) module if you want to change multiple, similar lines
or check M(ansible.builtin.blockinfile) if you want to insert/update/remove a block of lines in a file.
For other cases, see the M(ansible.builtin.copy) or M(ansible.builtin.template) modules.
"
-------------------------------------------------------------------------
"- See the M(ansible.builtin.replace) module if you want to changed multiple, similar lines
or check M(ansible.builtin.blockinfile) if you want to insert/update/remove a Block of lines in a file.
For other cases, see the M(ansible.builtin.copy) or M(ansible.builtin.template) module
"
-------------------------------------------------------------------------
"- See the M(ansible.builtin.replace) module if you want to change multiple, similar lines
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import glob, import __future__, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70530, 71380"
-------------------------------------------------------------------------
=========================================================================
"- module: ansible.builtin.blockinfile
- module: ansible.builtin.copy
- module: ansible.builtin.file
- module: ansible.builtin.replace
- module: ansible.builtin.template
- module: ansible.windows.win_lineinfile
"
-------------------------------------------------------------------------
"- module: ansible.builtin.blockinfile
- module: ansible.builtin.copy
- module: ansible.builtin.file
- module: ansible.builtin.replace
- module: ansible.builtin.template
- module: ansible.windows.win_lineinfile
"
-------------------------------------------------------------------------
"- module: ansible.builtin.blockinfile
- module: ansible.builtin.copy
- module: ansible.builtin.file
- module: ansible.builtin.replace
- module: ansible.builtin.template
- module: community.windows.win_lineinfile
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import glob, import __future__, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70530, 71380"
-------------------------------------------------------------------------
=========================================================================
"- C(clear_facts) will remove the persistent facts from M(ansible.builtin.set_fact) using C(cacheable=True),
dule: ansible.builtin.assert
dule: ansible.builtin.fail
"
-------------------------------------------------------------------------
"- C(clear_facts) will remove the persistent Facts from M(ansible.builtin.set_fact) using C(cacheable=True),
dule: ansible.builtin.assert
dule: ansible.builtin.fail
"
-------------------------------------------------------------------------
"- C(clear_facts) will remove the persistent facts from M(ansible.builtin.set_fact) using C(cacheable=True),
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import glob, import __future__, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70530, 71380"
-------------------------------------------------------------------------
=========================================================================
"- For Windows targets, use the M(ansible.windows.win_ping) module instead.
- For Network targets, use the M(ansible.netcommon.net_ping) module instead.
"
-------------------------------------------------------------------------
"- For Windows targets, use the M(ansible.windows.win_ping) module instead.
- For Network targets, use the M(ansible.netcommon.net_ping) module instead.
"
-------------------------------------------------------------------------
"- For Windows targets, use the M(ansible.windows.win_ping) module instead.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import glob, import __future__, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70530, 71380"
-------------------------------------------------------------------------
=========================================================================
"the M(ansible.builtin.shell) or M(ansible.builtin.command) module is much more appropriate.
the M(ansible.builtin.script) module.
etter to use the M(ansible.builtin.command) or M(ansible.builtin.shell) modules instead.
e: ansible.builtin.command
e: ansible.builtin.shell
e: ansible.windows.win_command
e: ansible.windows.win_shell
"
-------------------------------------------------------------------------
"the M(ansible.builtin.shell) or M(ansible.builtin.command) module is much more appropriate.
the M(ansible.builtin.script) module
etter to use the M(ansible.builtin.command) or M(ansible.builtin.shell) module instead.
e: ansible.builtin.command
e: ansible.builtin.shell
e: ansible.windows.win_command
e: ansible.windows.win_shell
"
-------------------------------------------------------------------------
"the M(ansible.builtin.shell) or M(ansible.builtin.command) module is much more appropriate.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import glob, import __future__, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70530, 71380"
-------------------------------------------------------------------------
=========================================================================
"- It is almost exactly like the M(ansible.builtin.command) module but runs
- For Windows targets, use the M(ansible.windows.win_shell) module instead.
"
-------------------------------------------------------------------------
"- It is almost exactly like the M(ansible.builtin.command) module but runs
- For Windows targets, use the M(ansible.windows.win_shell) module instead.
"
-------------------------------------------------------------------------
"- It is almost exactly like the M(ansible.builtin.command) module but runs
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import glob, import __future__, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70530, 71380"
-------------------------------------------------------------------------
=========================================================================
"better to use the M(ansible.builtin.command) module instead. Best practices
when writing playbooks will follow the trend of using M(ansible.builtin.command)
unless the M(ansible.builtin.shell) module is explicitly required. When running ad-hoc
commands, use your best judgement.
"
-------------------------------------------------------------------------
"better to use the M(ansible.builtin.command) module instead. Best practices
when writing playbooks will follow the trend of using M(ansible.builtin.command)
unless the M(ansible.builtin.shell) module is explicitly required. When running ad-hoc
commands, use your best judgement.
"
-------------------------------------------------------------------------
"better to use the M(ansible.builtin.command) module instead. Best practices
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import glob, import __future__, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70530, 71380"
-------------------------------------------------------------------------
=========================================================================
"the M(ansible.builtin.script) module possibly together with the M(ansible.builtin.template) module.
For rebooting systems, use the M(ansible.builtin.reboot) or M(ansible.windows.win_reboot) module.
dule: ansible.builtin.command
dule: ansible.builtin.raw
dule: ansible.builtin.script
dule: ansible.windows.win_shell
"
-------------------------------------------------------------------------
"the M(ansible.builtin.script) module possibly together with the M(ansible.builtin.template) module
For rebooting systems, use the M(ansible.builtin.reboot) or M(ansible.windows.win_reboot) module
dule: ansible.builtin.command
dule: ansible.builtin.raw
dule: ansible.builtin.script
dule: ansible.windows.win_shell
"
-------------------------------------------------------------------------
"the M(ansible.builtin.script) module possibly together with the M(ansible.builtin.template) module.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import glob, import __future__, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70530, 71380"
-------------------------------------------------------------------------
=========================================================================
"- This module returns an 'in memory' base64 encoded version of the file, take
  into account that this will require at least twice the RAM as the original file size.
odule: ansible.builtin.fetch
"
-------------------------------------------------------------------------
"- This module returns an 'in memory base64 encode Version of the file, take
  into account that this will require at least twice the RAM as the original file size.
odule: ansible.builtin.fetch
"
-------------------------------------------------------------------------
"- This module returns an 'in memory' base64 encoded version of the file, take
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import glob, import __future__, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70530, 71380"
-------------------------------------------------------------------------
=========================================================================
"you need to use M(ansible.builtin.file) module.
For Windows targets, use the M(ansible.windows.win_tempfile) module instead.
"
-------------------------------------------------------------------------
"you need to use M(ansible.builtin.file) module
For Windows targets, use the M(ansible.windows.win_tempfile) module instead.
"
-------------------------------------------------------------------------
"you need to use M(ansible.builtin.file) module.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import glob, import __future__, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70530, 71380"
-------------------------------------------------------------------------
=========================================================================
"- module: ansible.builtin.copy
- module: ansible.windows.win_copy
- module: ansible.windows.win_template
"
-------------------------------------------------------------------------
"- module: ansible.builtin.copy
- module: ansible.windows.win_copy
- module: ansible.windows.win_template
"
-------------------------------------------------------------------------
"- For Windows you can use M(ansible.windows.win_template) which uses '\\r\\n' as C(newline_sequence) by default.
- module: ansible.builtin.copy
- module: ansible.windows.win_copy
- module: ansible.windows.win_template
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import glob, import __future__, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70530, 71380"
-------------------------------------------------------------------------
=========================================================================
"- If checksum validation is desired, use M(ansible.builtin.get_url) or M(ansible.builtin.uri) instead to fetch the file and set C(remote_src=yes).
- For Windows targets, use the M(community.windows.win_unzip) module instead.
   simple cases, for full download support use the M(ansible.builtin.get_url) module.
"
-------------------------------------------------------------------------
"- If checksum validation is desired, use M(ansible.builtin.get_url) or M(ansible.builtin.uri) instead to fetch the file and set C(remote_src=yes).
- For Windows targets, use the M(community.windows.win_unzip) module instead.
   simple cases, for full download Support use the M(ansible.builtin.get_url) module
"
-------------------------------------------------------------------------
"- If checksum validation is desired, use M(ansible.builtin.get_url) or M(ansible.builtin.uri) instead to fetch the file and set C(remote_src=yes).
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import glob, import __future__, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70530, 71380"
-------------------------------------------------------------------------
=========================================================================
"- For Windows targets, use the M(ansible.windows.win_uri) module instead.
module: ansible.builtin.get_url
module: ansible.windows.win_uri
"
-------------------------------------------------------------------------
"- For Windows targets, use the M(ansible.windows.win_uri) module instead.
module: ansible.builtin.get_url
module: ansible.windows.win_uri
"
-------------------------------------------------------------------------
"- For Windows targets, use the M(ansible.windows.win_uri) module instead.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import glob, import __future__, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70530, 71380"
-------------------------------------------------------------------------
=========================================================================
"- module: ansible.builtin.authorized_key
- module: ansible.builtin.group
- module: ansible.windows.win_user
"
-------------------------------------------------------------------------
"- module: ansible.builtin.authorized_key
- module: ansible.builtin.group
- module: ansible.windows.win_user
"
-------------------------------------------------------------------------
"- module: ansible.posix.authorized_key
- module: ansible.builtin.group
- module: ansible.windows.win_user
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import glob, import __future__, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70530, 71380"
-------------------------------------------------------------------------
=========================================================================
"- It is also useful when starting guests with the M(community.libvirt.virt) module and needing to pause until they are ready.
- For Windows targets, use the M(ansible.windows.win_wait_for) module instead.
"
-------------------------------------------------------------------------
"- It is also useful when starting guests with the M(community.libvirt.virt) module and needing to parse until they are ready.
- For Windows targets, use the M(ansible.windows.win_wait_for) module instead.
"
-------------------------------------------------------------------------
"- It is also useful when starting guests with the M(community.libvirt.virt) module and needing to pause until they are ready.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import glob, import __future__, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70530, 71380"
-------------------------------------------------------------------------
=========================================================================
"- module: ansible.builtin.wait_for
- module: ansible.windows.win_wait_for
- module: ansible.windows.win_wait_for_process
"
-------------------------------------------------------------------------
"- module: ansible.builtin.wait_for
- module: ansible.windows.win_wait_for
- module: ansible.windows.win_wait_for_process
"
-------------------------------------------------------------------------
"- module: ansible.builtin.wait_for
- module: ansible.windows.win_wait_for
- module: community.windows.win_wait_for_process
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import glob, import __future__, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70530, 71380"
-------------------------------------------------------------------------
=========================================================================
"- If you wish to update an existing repository definition use M(ansible.builtin.ini_file) instead.
"
-------------------------------------------------------------------------
"- If you wish to update an existing repository definition use M(ansible.builtin.ini_file) instead.
"
-------------------------------------------------------------------------
"- If you wish to update an existing repository definition use M(community.general.ini_file) instead.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import glob, import __future__, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70530, 71380"
-------------------------------------------------------------------------
=========================================================================
"if LooseVersion(self._zbx_api_version) <= LooseVersion('4.4.0'):
    if host['inventory']:
        if int(host['inventory']['inventory_mode']) != self.inventory_mode_numeric(inventory_mode):
return True
    elif inventory_mode != 'disabled':
        return True
else:
    if int(host['inventory_mode']) != self.inventory_mode_numeric(inventory_mode):
"
-------------------------------------------------------------------------
"if LooseVersion(self._zbx_api_version) <= LooseVersion('4.4.0'):
    if host['inventory']:
        if int(host['inventory']['inventory_mode']) != self.inventory_mode_numeric(inventory_mode=inventory_mode):
return True
    elif inventory_mode != 'disabled':
        return True
else:
    if int(host['inventory_mode']) != self.inventory_mode_numeric(inventory_mode=inventory_mode):
"
-------------------------------------------------------------------------
"if LooseVersion(self._zbx_api_version) <= LooseVersion('4.4.0'):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback, import atexit, import __future__, import zabbix_api, import copy
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 65392, 71288"
-------------------------------------------------------------------------
=========================================================================
"try:
from rpmfluff import SimpleRpmBuild
from rpmfluff import YumRepoBuild
pt ImportError:
from rpmfluff.rpmbuild import SimpleRpmBuild
from rpmfluff.yumrepobuild import YumRepoBuild


from rpmfluff import can_use_rpm_weak_deps
pt ImportError:
try:
from rpmfluff.utils import can_use_rpm_weak_deps
except ImportError:
can_use_rpm_weak_deps = None
"
-------------------------------------------------------------------------
"try:
from rpmfluff import SimpleRpmBuild
from rpmfluff import YumRepoBuild
pt ImportError:
from rpmfluff.rpmbuild import SimpleRpmBuild
from rpmfluff.yumrepobuild import YumRepoBuild


from rpmfluff import can_use_rpm_weak_deps
pt ImportError:
try:
from rpmfluff.utils import can_use_rpm_weak_deps
except ImportError:
can_use_rpm_weak_deps = None
"
-------------------------------------------------------------------------
"try:
from rpmfluff import SimpleRpmBuild
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import collections, import sys, import rpmfluff
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 71155, 71161"
-------------------------------------------------------------------------
=========================================================================
"pkg = SimpleRpmBuild(spec.name, spec.version, spec.release, [arch])
    if not can_use_rpm_weak_deps or not can_use_rpm_weak_deps():
"
-------------------------------------------------------------------------
"pkg = SimpleRpmBuild(spec.name, spec.version, spec.release, [arch])
    if not can_use_rpm_weak_deps or not can_use_rpm_weak_deps():
"
-------------------------------------------------------------------------
"pkg = SimpleRpmBuild(spec.name, spec.version, spec.release, [arch])
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import collections, import sys, import rpmfluff
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 71155, 71161"
-------------------------------------------------------------------------
=========================================================================
"try:
from rpmfluff import SimpleRpmBuild
from rpmfluff import YumRepoBuild
pt ImportError:
from rpmfluff.rpmbuild import SimpleRpmBuild
from rpmfluff.yumrepobuild import YumRepoBuild


from rpmfluff import can_use_rpm_weak_deps
pt ImportError:
try:
from rpmfluff.utils import can_use_rpm_weak_deps
except ImportError:
can_use_rpm_weak_deps = None
"
-------------------------------------------------------------------------
"try:
from rpmfluff import SimpleRpmBuild
from rpmfluff import YumRepoBuild
pt ImportError:
from rpmfluff.rpmbuild import SimpleRpmBuild
from rpmfluff.yumrepobuild import YumRepoBuild


from rpmfluff import can_use_rpm_weak_deps
pt ImportError:
try:
from rpmfluff.utils import can_use_rpm_weak_deps
except ImportError:
can_use_rpm_weak_deps = None
"
-------------------------------------------------------------------------
"try:
from rpmfluff import SimpleRpmBuild
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import collections, import sys, import rpmfluff
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 71155, 71160"
-------------------------------------------------------------------------
=========================================================================
"pkg = SimpleRpmBuild(spec.name, spec.version, spec.release, [arch])
    if not can_use_rpm_weak_deps or not can_use_rpm_weak_deps():
"
-------------------------------------------------------------------------
"pkg = SimpleRpmBuild(spec.name, spec.version, spec.release, [arch])
    if not can_use_rpm_weak_deps or not can_use_rpm_weak_deps():
"
-------------------------------------------------------------------------
"pkg = SimpleRpmBuild(spec.name, spec.version, spec.release, [arch])
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import collections, import sys, import rpmfluff
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 71155, 71160"
-------------------------------------------------------------------------
=========================================================================
"try:
from rpmfluff import SimpleRpmBuild
from rpmfluff import YumRepoBuild
pt ImportError:
from rpmfluff.rpmbuild import SimpleRpmBuild
from rpmfluff.yumrepobuild import YumRepoBuild


from rpmfluff import can_use_rpm_weak_deps
pt ImportError:
try:
from rpmfluff.utils import can_use_rpm_weak_deps
except ImportError:
can_use_rpm_weak_deps = None
"
-------------------------------------------------------------------------
"try:
from rpmfluff import SimpleRpmBuild
from rpmfluff import YumRepoBuild
pt ImportError:
from rpmfluff.rpmbuild import SimpleRpmBuild
from rpmfluff.yumrepobuild import YumRepoBuild


from rpmfluff import can_use_rpm_weak_deps
pt ImportError:
try:
from rpmfluff.utils import can_use_rpm_weak_deps
except ImportError:
can_use_rpm_weak_deps = None
"
-------------------------------------------------------------------------
"try:
from rpmfluff import SimpleRpmBuild
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import collections, import sys, import rpmfluff
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 71155, 71159"
-------------------------------------------------------------------------
=========================================================================
"pkg = SimpleRpmBuild(spec.name, spec.version, spec.release, [arch])
    if not can_use_rpm_weak_deps or not can_use_rpm_weak_deps():
"
-------------------------------------------------------------------------
"pkg = SimpleRpmBuild(spec.name, spec.version, spec.release, [arch])
    if not can_use_rpm_weak_deps or not can_use_rpm_weak_deps():
"
-------------------------------------------------------------------------
"pkg = SimpleRpmBuild(spec.name, spec.version, spec.release, [arch])
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import collections, import sys, import rpmfluff
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 71155, 71159"
-------------------------------------------------------------------------
=========================================================================
"if path in ('changelogs/fragments/.keep', 'changelogs/fragments/.gitkeep'):
    continue

print('%s:%d:%d: file must not be a dotfile' % (path, 0, 0))
"
-------------------------------------------------------------------------
"if match in ('changelogs/fragments/.keep', 'changelogs/fragments/.gitkeep'):
    continue

print('%s:%d:%d: file must not be a dotfile' % (path, 0, 0))
"
-------------------------------------------------------------------------
"if path in ('changelogs/fragments/.keep', 'changelogs/fragments/.gitkeep'):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import sys, import __future__, import subprocess, import os
Make sure statements concerning these methods are incorporated into the stable script - ,path,print,match
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70909, 71135"
-------------------------------------------------------------------------
=========================================================================
"self.n_existing = ''
self.b_cron_file = to_bytes(cron_file, errors='surrogate_or_strict')
self.b_cron_file = os.path.join(b'/etc/cron.d', to_bytes(cron_file, errors='surrogate_or_strict'))
"
-------------------------------------------------------------------------
"self.n_existing = ''
self.b_cron_file = to_bytes(cron_file, errors='surrogate_or_strict')
self.b_cron_file = os.path.join('/etc/cron.d'='/etc/cron.d', cron_file=cron_file))
"
-------------------------------------------------------------------------
"self.n_existing = ''
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import platform, import __future__, import tempfile, import pwd, import sys, import re, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70426, 71134"
-------------------------------------------------------------------------
=========================================================================
"f = open(self.b_cron_file, 'rb')
self.n_existing = to_native(f.read(), errors='surrogate_or_strict')
"
-------------------------------------------------------------------------
"f = open(self.b_cron_file, 'rb')
self.n_existing = to_native(f.read(), errors='surrogate_or_strict')
"
-------------------------------------------------------------------------
"f = open(self.b_cron_file, 'rb')
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import platform, import __future__, import tempfile, import pwd, import sys, import re, import os
Make sure statements concerning these methods are incorporated into the stable script - ,f,self,to_native,open
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70426, 71134"
-------------------------------------------------------------------------
=========================================================================
"fileh = open(backup_file, 'wb')
fileh = open(self.b_cron_file, 'wb')
fileh = os.fdopen(filed, 'wb')
h.write(to_bytes(self.render()))
"
-------------------------------------------------------------------------
"fileh = open(backup_file, 'wb')
fileh = open(self.b_cron_file, 'wb')
fileh = os.fdopen(filed=filed, 'w'='w')
h.write(to_bytes(self.render()))
"
-------------------------------------------------------------------------
"fileh = open(backup_file, 'wb')
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import platform, import __future__, import tempfile, import pwd, import sys, import re, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70426, 71134"
-------------------------------------------------------------------------
=========================================================================
"if not changed and crontab.n_existing != '':
if not (crontab.n_existing.endswith('\r') or crontab.n_existing.endswith('\n')):
"
-------------------------------------------------------------------------
"if not changed and crontab.n_existing != '':
if not (crontab.n_existing.endswith('\r') or crontab.n_existing.endswith('\n')):
"
-------------------------------------------------------------------------
"if not changed and crontab.n_existing != '':
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import platform, import __future__, import tempfile, import pwd, import sys, import re, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70426, 71134"
-------------------------------------------------------------------------
=========================================================================
"# NOTE: do not add to this. This should be made a generic function for action plugins.
# This should also use the same argspec as the module instead of keeping it in sync.
"
-------------------------------------------------------------------------
"# NOTE: do not add to this. This should be made a generic function for action plugins.
# This should also use the same argspec as the module instead of keeping it in sync.
"
-------------------------------------------------------------------------
"# NOTE: do not add to this. This should be made a generic function for action plugins.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import ansible, import traceback, import __future__, import tempfile, import stat, import json, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 71033, 71069"
-------------------------------------------------------------------------
=========================================================================
"if isinstance(result['invocation'], dict):
    if 'content' in result['invocation']:
result['invocation']['content'] = 'CENSORED: content is a no_log parameter'
    if result['invocation'].get('module_args', {}).get('content') is not None:
result['invocation']['module_args']['content'] = 'VALUE_SPECIFIED_IN_NO_LOG_PARAMETER'
"
-------------------------------------------------------------------------
"if isinstance(result['invocation'], dict):
    if 'content' in result['invocation']:
result['invocation']['content'] = 'CENSORED: content is a no_log parameter'
    if result['invocation'].get('module_args', {}).get('content') is not None:
result['invocation']['module_args']['content'] = 'VALUE_SPECIFIED_IN_NO_LOG_PARAMETER'
"
-------------------------------------------------------------------------
"if isinstance(result['invocation'], dict):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import ansible, import traceback, import __future__, import tempfile, import stat, import json, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 71033, 71069"
-------------------------------------------------------------------------
=========================================================================
"# NOTE: do not add to this. This should be made a generic function for action plugins.
# This should also use the same argspec as the module instead of keeping it in sync.
"
-------------------------------------------------------------------------
"# NOTE: do not add to this. This should be made a generic function for action plugins.
# This should also use the same argspec as the module instead of keeping it in sync.
"
-------------------------------------------------------------------------
"# NOTE: do not add to this. This should be made a generic function for action plugins.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import ansible, import traceback, import __future__, import tempfile, import stat, import json, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 71033, 71068"
-------------------------------------------------------------------------
=========================================================================
"if isinstance(result['invocation'], dict):
    if 'content' in result['invocation']:
result['invocation']['content'] = 'CENSORED: content is a no_log parameter'
    if result['invocation'].get('module_args', {}).get('content') is not None:
result['invocation']['module_args']['content'] = 'VALUE_SPECIFIED_IN_NO_LOG_PARAMETER'
"
-------------------------------------------------------------------------
"if isinstance(result['invocation'], dict):
    if 'content' in result['invocation']:
result['invocation']['content'] = 'CENSORED: content is a no_log parameter'
    if result['invocation'].get('module_args', {}).get('content') is not None:
result['invocation']['module_args']['content'] = 'VALUE_SPECIFIED_IN_NO_LOG_PARAMETER'
"
-------------------------------------------------------------------------
"if isinstance(result['invocation'], dict):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import ansible, import traceback, import __future__, import tempfile, import stat, import json, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 71033, 71068"
-------------------------------------------------------------------------
=========================================================================
"# NOTE: do not add to this. This should be made a generic function for action plugins.
# This should also use the same argspec as the module instead of keeping it in sync.
"
-------------------------------------------------------------------------
"# NOTE: do not add to this. This should be made a generic function for action plugins.
# This should also use the same argspec as the module instead of keeping it in sync.
"
-------------------------------------------------------------------------
"# NOTE: do not add to this. This should be made a generic function for action plugins.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import ansible, import traceback, import __future__, import tempfile, import stat, import json, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 71033, 71067"
-------------------------------------------------------------------------
=========================================================================
"if isinstance(result['invocation'], dict):
    if 'content' in result['invocation']:
result['invocation']['content'] = 'CENSORED: content is a no_log parameter'
    if result['invocation'].get('module_args', {}).get('content') is not None:
result['invocation']['module_args']['content'] = 'VALUE_SPECIFIED_IN_NO_LOG_PARAMETER'
"
-------------------------------------------------------------------------
"if isinstance(result['invocation'], dict):
    if 'content' in result['invocation']:
result['invocation']['content'] = 'CENSORED: content is a no_log parameter'
    if result['invocation'].get('module_args', {}).get('content') is not None:
result['invocation']['module_args']['content'] = 'VALUE_SPECIFIED_IN_NO_LOG_PARAMETER'
"
-------------------------------------------------------------------------
"if isinstance(result['invocation'], dict):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import ansible, import traceback, import __future__, import tempfile, import stat, import json, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 71033, 71067"
-------------------------------------------------------------------------
=========================================================================
"
if requirement.api is None and requirement.b_path and os.path.isfile(requirement.b_path):
    shutil.copy(requirement.b_path, to_bytes(dest_path, errors='surrogate_or_strict'))
elif requirement.api is None and requirement.b_path:
    temp_path = to_text(b_temp_path, errors='surrogate_or_string')
    scm_build_path = os.path.join(temp_path, 'tmp_build-%s' % collection_filename)
    os.makedirs(to_bytes(scm_build_path, errors='surrogate_or_strict'), mode=0o0755)
    temp_download_path = build_collection(os.path.join(temp_path, name), scm_build_path, True)
    shutil.move(to_bytes(temp_download_path, errors='surrogate_or_strict'), to_bytes(dest_path, errors='surrogate_or_strict'))
else:
    b_temp_download_path = requirement.download(b_temp_path)
    shutil.move(b_temp_download_path, to_bytes(dest_path, errors='surrogate_or_strict'))

"
-------------------------------------------------------------------------
"
if requirement.api is None and requirement.b_path and os.path.isfile(to_bytes(collection=to_bytes(collection, errors=errors):
    shutil.copy(b_tar_filepath=b_tar_filepath, b_tar_path=b_tar_path))
elif requirement.api is None and requirement.b_path:
    temp_path = to_text(b_temp_path, errors='surrogate_or_string')
    scm_build_path = os.path.join(b_path=b_path, b_name=b_name)
    os.makedirs(b_parent_dir=b_parent_dir, mode=mode), mode=0o0755)
    temp_download_path = build_collection(os.path.join(b_path=b_path, b_name=b_name), scm_build_path, True)
    shutil.move(to_bytes(tmpfile_obj.name=to_bytes(tmpfile_obj.name, errors=errors), to_bytes(dest_path, errors='surrogate_or_strict'))
else:
    b_temp_download_path = requirement.download(b_temp_path=b_temp_path)
    shutil.move(to_bytes(tmpfile_obj.name=to_bytes(tmpfile_obj.name, errors=errors))

"
-------------------------------------------------------------------------
"
if requirement.api is None and requirement.b_path and os.path.isfile(requirement.b_path):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import io, import tempfile, import contextlib, import stat, import yaml, import sys, import shutil, import threading, import tarfile, import queue, import hashlib, import errno, import operator, import time, import os, import Queue, import __future__, import fnmatch, import json, import collections
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70524, 71000"
-------------------------------------------------------------------------
=========================================================================
"# TODO: play context has logic to update the connection for 'smart'
# (really paramiko), eventually this should move to task object itself.
"
-------------------------------------------------------------------------
"# TODO: play content has _login to update the Connection for 'smart'
# (really paramiko), eventually this should move to task object itself.
"
-------------------------------------------------------------------------
"# TODO: play context has logic to update the connection for 'smart'
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import pty, import termios, import sys, import traceback, import signal, import subprocess, import time, import os, import ansible, import __future__, import json, import re
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70736, 70999"
-------------------------------------------------------------------------
=========================================================================
"if mode is None:
    return changed

"
-------------------------------------------------------------------------
"if mode is None:
    return changed

"
-------------------------------------------------------------------------
"if mode is None:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import platform, import types, import md5, import atexit, import datetime, import itertools, import grp, import tempfile, import pwd, import stat, import sys, import shutil, import __main__, import traceback, import systemd, import signal, import shlex, import _text, import errno, import hashlib, import subprocess, import time, import os, import locale, import fcntl, import select, import __future__, import syslog, import collections, import sha, import re, import selinux
Make sure statements concerning these methods are incorporated into the stable script - ,changed,mode
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70976, 70985"
-------------------------------------------------------------------------
=========================================================================
"str(version_added_raw or '0.0'),
ion_added = version_added_raw or '0.0'
elf._is_new_module() or version_added != 'historical':
# already reported during schema validation, except:
if version_added == 'historical':
    self.reporter.error(
        path=self.object_path,
        code='module-invalid-version-added',
        msg='version_added is not a valid version number: %r. Error: %s' % (version_added, e)
    )
"
-------------------------------------------------------------------------
"str(version_added_raw or '0.0'),
ion_added = version_added_raw or '0.0'
elf._is_new_module() or version_added != 'historical':
# already reported during schema validation, except:
if version_added == 'historical':
    self.reporter.error(
        path=self.object_path,
        code='module-invalid-version-added',
        msg='version_added is not a valid Version number: %r. Error: %s' % (version_added, e)
    )
"
-------------------------------------------------------------------------
"str(version_added_raw or '0.0'),
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import voluptuous, import __future__, import utils, import re
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70869, 70947"
-------------------------------------------------------------------------
=========================================================================
"if version_added == 'historical' and accept_historical:
    return v
"
-------------------------------------------------------------------------
"if version_added == 'historical' and accept_historical:
    return v
"
-------------------------------------------------------------------------
"if version_added == 'historical' and accept_historical:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import voluptuous, import __future__, import utils, import re
Make sure statements concerning these methods are incorporated into the stable script - ,version_added,v
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - ,accept_historical
PRs: 70869, 70947"
-------------------------------------------------------------------------
=========================================================================
"All(
    Schema(
doc_schema_dict,
extra=PREVENT_EXTRA
    ),
    partial(version_added, error_code='module-invalid-version-added', accept_historical=not for_collection),
)
"
-------------------------------------------------------------------------
"All(
    Schema(
doc_schema_dict,
extra=PREVENT_EXTRA
    ),
    partial(version_added, error_code='module-invalid-version-added', accept_historical=not for_collection),
)
"
-------------------------------------------------------------------------
"All(
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import voluptuous, import __future__, import utils, import re
Make sure statements concerning these methods are incorporated into the stable script - ,version_added,All,Schema,partial
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - ,for_collection,doc_schema_dict,PREVENT_EXTRA
PRs: 70869, 70947"
-------------------------------------------------------------------------
=========================================================================
"# Instantiate our ResultsCollector for handling results as
# they come in. Ansible expects this to be one of its main
# display outlets.
callback = ResultsCollector()

# Instantiate task queue manager, which takes care of forking
# and setting up all objects to iterate over host list and tasks.
# IMPORTANT: This also adds library dirs paths to the module loader
# IMPORTANT: and so it must be initialized before calling `Play.load()`.
tqm = TaskQueueManager(
inventory=inventory,
variable_manager=variable_manager,
loader=loader,
passwords=passwords,
stdout_callback=callback,
)

"
-------------------------------------------------------------------------
"# Instantiate our ResultsCollector for handling results as
# they come in. Ansible expects this to be one of its main
# Display outlets.
callback = ResultsCollector()

# Instantiate task Queue manager, which takes care of forking
# and settings up all object to iterate over hosts lists and tasks.
# IMPORTANT: This also adds library dirs paths to the module loader
# IMPORTANT: and so it must be initialize before calling `Play.load()`.
tqm = TaskQueueManager(
inventory=inventory,
variable_manager=variable_manager,
loader=loader,
passwords=passwords,
stdout_callback=callback,
)

"
-------------------------------------------------------------------------
"loader = DataLoader()  # Takes care of finding and reading yaml, json and ini files
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import ansible
Make sure statements concerning these methods are incorporated into the stable script - ,TaskQueueManager,passwords,variable_manager,ResultsCollector,loader,inventory,callback
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70842, 70851"
-------------------------------------------------------------------------
=========================================================================
"# Instantiate our ResultsCollector for handling results as
# they come in. Ansible expects this to be one of its main
# display outlets.
callback = ResultsCollector()

# Instantiate task queue manager, which takes care of forking
# and setting up all objects to iterate over host list and tasks.
# IMPORTANT: This also adds library dirs paths to the module loader
# IMPORTANT: and so it must be initialized before calling `Play.load()`.
tqm = TaskQueueManager(
inventory=inventory,
variable_manager=variable_manager,
loader=loader,
passwords=passwords,
stdout_callback=callback,
)

"
-------------------------------------------------------------------------
"# Instantiate our ResultsCollector for handling results as
# they come in. Ansible expects this to be one of its main
# Display outlets.
callback = ResultsCollector()

# Instantiate task Queue manager, which takes care of forking
# and settings up all object to iterate over hosts lists and tasks.
# IMPORTANT: This also adds library dirs paths to the module loader
# IMPORTANT: and so it must be initialize before calling `Play.load()`.
tqm = TaskQueueManager(
inventory=inventory,
variable_manager=variable_manager,
loader=loader,
passwords=passwords,
stdout_callback=callback,
)

"
-------------------------------------------------------------------------
"loader = DataLoader()  # Takes care of finding and reading yaml, json and ini files
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import ansible
Make sure statements concerning these methods are incorporated into the stable script - ,TaskQueueManager,passwords,variable_manager,ResultsCollector,loader,inventory,callback
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70445, 70850"
-------------------------------------------------------------------------
=========================================================================
"# use ansible.legacy.normal to allow (historic) local action_plugins/ override without collections search
handler_name = 'ansible.legacy.normal'
"
-------------------------------------------------------------------------
"# use ansible.legacy.normal to allow (historic) locals action_plugins/ override without collection search
handler_name = 'ansible.legacy.normal'
"
-------------------------------------------------------------------------
"# use ansible.legacy.normal to allow (historic) local action_plugins/ override without collections search
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import ansible, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70818, 70840"
-------------------------------------------------------------------------
=========================================================================
"split_module_name = module_name.split('.')
collection_name = '.'.join(split_module_name[0:2]) if len(split_module_name) > 2 else ''
leaf_module_name = resource_from_fqcr(module_name)

"
-------------------------------------------------------------------------
"split_module_name = module_name.split('.')
collection_name = '.'.join(split_module_name[0:2]) if len(split_module_name) > 2 else ''
leaf_module_name = resource_from_fqcr(module_name)

"
-------------------------------------------------------------------------
"split_module_name = module_name.split('.')
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import ansible, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,len,module_name
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - ,split_module_name,resource_from_fqcr
PRs: 70818, 70840"
-------------------------------------------------------------------------
=========================================================================
"rewrite_collection_names = ['ansible.builtin', 'ansible.legacy', '']
# NB: we only rewrite the module if it's not being called by the user (eg, an action calling something else)
# and if it's unqualified or FQ to a builtin
if leaf_module_name in ('stat', 'file', 'copy', 'ping') and \
        collection_name in rewrite_collection_names and self._task.action != module_name:
    module_name = '%s.win_%s' % (win_collection, leaf_module_name)
elif leaf_module_name == 'async_status' and collection_name in rewrite_collection_names:
    module_name = '%s.%s' % (win_collection, leaf_module_name)

# TODO: move this tweak down to the modules, not extensible here
if leaf_module_name in ['win_stat', 'win_file', 'win_copy', 'slurp'] and module_args and \
"
-------------------------------------------------------------------------
"rewrite_collection_names = ['ansible.builtin', 'ansible.legacy', '']
# NB: we only rewrite the module if it's not being called by the _user (eg, an action calling something else)
# and if it's unqualified or FQ to a builtin
if leaf_module_name in ('stat', 'file', 'copy', 'ping') and \
        collection_name in rewrite_collection_names and self._task.action != module_name:
    module_name = '%s.win_%s' % (win_collection, leaf_module_name)
elif leaf_module_name == 'async_status' and collection_name in rewrite_collection_names:
    module_name = '%s.%s' % (win_collection, leaf_module_name)

# TODO: move this tweak down to the modules, not extensible here
if leaf_module_name in ['win_stat', 'win_file', 'win_copy', 'slurp'] and module_args and \
"
-------------------------------------------------------------------------
"rewrite_collection_names = ['ansible.builtin', 'ansible.legacy', '']
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import ansible, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70818, 70840"
-------------------------------------------------------------------------
=========================================================================
"(async_module_style, shebang, async_module_data, async_module_path) = self._configure_module(
    module_name='ansible.legacy.async_wrapper', module_args=dict(), task_vars=task_vars)
"
-------------------------------------------------------------------------
"(async_module_style, shebang, async_module_data, async_module_path) = self._configure_module(
    module_name='ansible.legacy.async_wrapper', module_args=dict(), task_vars=task_vars)
"
-------------------------------------------------------------------------
"(async_module_style, shebang, async_module_data, async_module_path) = self._configure_module(
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import ansible, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,self,task_vars,dict
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70818, 70840"
-------------------------------------------------------------------------
=========================================================================
"peek_result = self._execute_module(
    module_name='ansible.legacy.file', module_args=dict(path=destination, _diff_peek=True),
    task_vars=task_vars, persist_files=True)
"
-------------------------------------------------------------------------
"peek_result = self._execute_module(
    module_name='ansible.legacy.file', module_args=dict(path=destination, _diff_peek=True),
    task_vars=task_vars, persist_files=True)
"
-------------------------------------------------------------------------
"peek_result = self._execute_module(
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import ansible, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,self,task_vars,destination,dict
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70818, 70840"
-------------------------------------------------------------------------
=========================================================================
"dest_result = self._execute_module(
    module_name='ansible.legacy.slurp', module_args=dict(path=destination),
    task_vars=task_vars, persist_files=True)
"
-------------------------------------------------------------------------
"dest_result = self._execute_module(
    module_name='ansible.legacy.slurp', module_args=dict(path=destination),
    task_vars=task_vars, persist_files=True)
"
-------------------------------------------------------------------------
"dest_result = self._execute_module(
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import ansible, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,self,task_vars,destination,dict
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70818, 70840"
-------------------------------------------------------------------------
=========================================================================
"# call assemble via ansible.legacy to allow library/ overrides of the module without collection search
result.update(self._execute_module(module_name='ansible.legacy.assemble', task_vars=task_vars))
"
-------------------------------------------------------------------------
"# call assemble via ansible.legacy to allow library/ overrides of the module without collection search
result.update(self._execute_module(module_name='ansible.legacy.assemble', task_vars=task_vars))
"
-------------------------------------------------------------------------
"# call assemble via ansible.legacy to allow library/ overrides of the module without collection search
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import ansible, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,result,task_vars,self
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70818, 70840"
-------------------------------------------------------------------------
=========================================================================
"res = self._execute_module(module_name='ansible.legacy.copy', module_args=new_module_args, task_vars=task_vars)
result.update(self._execute_module(module_name='ansible.legacy.file', module_args=new_module_args, task_vars=task_vars))
"
-------------------------------------------------------------------------
"res = self._execute_module(module_name='ansible.legacy.copy', module_args=new_module_args, task_vars=task_vars)
result.update(self._execute_module(module_name='ansible.legacy.file', module_args=new_module_args, task_vars=task_vars))
"
-------------------------------------------------------------------------
"res = self._execute_module(module_name='ansible.legacy.copy', module_args=new_module_args, task_vars=task_vars)
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import ansible, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,self,task_vars,result,new_module_args
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70818, 70840"
-------------------------------------------------------------------------
=========================================================================
"# explicitly call `ansible.legacy.command` for backcompat to allow library/ override of `command` while not allowing
# collections search for an unqualified `command` module
results = merge_hash(results, self._execute_module(module_name='ansible.legacy.command', task_vars=task_vars, wrap_async=wrap_async))
"
-------------------------------------------------------------------------
"# explicitly call `ansible.legacy.command` for backcompat to allow library/ override of `command` while not allowing
# collection search for an unqualified `command` module
results = merge_hash(results, self._execute_module(module_name='ansible.legacy.command', task_vars=task_vars, wrap_async=wrap_async))
"
-------------------------------------------------------------------------
"# explicitly call `ansible.legacy.command` for backcompat to allow library/ override of `command` while not allowing
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import ansible, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,task_vars,merge_hash,self,results
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - ,wrap_async
PRs: 70818, 70840"
-------------------------------------------------------------------------
=========================================================================
"BUILTIN_PKG_MGR_MODULES = set(['apk', 'apt', 'dnf', 'homebrew', 'installp', 'macports', 'opkg', 'portage', 'pacman',
   'pkg5', 'pkgin', 'pkgng', 'sorcery', 'svr4pkg', 'swdepot', 'swupd', 'urpmi', 'xbps', 'yum', 'zypper'])

"
-------------------------------------------------------------------------
"BUILTIN_PKG_MGR_MODULES = set(['apk', 'apt', 'dnf', 'homebrew', 'installp', 'macports', 'opkg', 'portage', 'pacman',
   'pkg5', 'pkgin', 'pkgng', 'sorcery', 'svr4pkg', 'swdepot', 'swupd', 'urpmi', 'xbps', 'yum', 'zypper'])

"
-------------------------------------------------------------------------
"BUILTIN_PKG_MGR_MODULES = set(['apk', 'apt', 'dnf', 'homebrew', 'installp', 'macports', 'opkg', 'portage', 'pacman',
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import ansible, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,set
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70818, 70840"
-------------------------------------------------------------------------
=========================================================================
"facts = self._execute_module(
    module_name='ansible.legacy.setup',
    module_args=dict(filter='ansible_pkg_mgr', gather_subset='!all'),
    task_vars=task_vars)
if not self._shared_loader_obj.module_loader.has_plugin(module):
"
-------------------------------------------------------------------------
"Facts = self._execute_module(
    module_name='ansible.legacy.setup',
    module_args=dict(filter='ansible_pkg_mgr', gather_subset='!all'),
    task_vars=task_vars)
if not self._shared_loader_obj.module_loader.has_plugin(module):
"
-------------------------------------------------------------------------
"facts = self._execute_module(
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import ansible, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70818, 70840"
-------------------------------------------------------------------------
=========================================================================
"if module in self.BUILTIN_PKG_MGR_MODULES:
    # prefix with ansible.legacy to eliminate external collisions while still allowing library/ override
    module = 'ansible.legacy.'  module

"
-------------------------------------------------------------------------
"if module in self.BUILTIN_PKG_MGR_MODULES:
    # prefix with ansible.legacy to eliminate external collisions while still allowing library/ override
    module = 'ansible.legacy.'  module

"
-------------------------------------------------------------------------
"if module in self.BUILTIN_PKG_MGR_MODULES:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import ansible, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70818, 70840"
-------------------------------------------------------------------------
=========================================================================
"# FIXME: only execute the module if we don't already have the facts we need
    module_name='ansible.legacy.setup',
"
-------------------------------------------------------------------------
"# FIXME: only execute the module if we don't already have the Facts we need
    module_name='ansible.legacy.setup',
"
-------------------------------------------------------------------------
"# FIXME: only execute the module if we don't already have the facts we need
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import ansible, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70818, 70840"
-------------------------------------------------------------------------
=========================================================================
"# prevent collection search by calling with ansible.legacy (still allows library/ override of find)
module_name='ansible.legacy.find',
"
-------------------------------------------------------------------------
"# present collection search by calling with ansible.legacy (still allow library/ override of find)
module_name='ansible.legacy.find',
"
-------------------------------------------------------------------------
"# prevent collection search by calling with ansible.legacy (still allows library/ override of find)
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import ansible, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70818, 70840"
-------------------------------------------------------------------------
=========================================================================
"# HACK: list of unqualified service manager names that are/were built-in, we'll prefix these with `ansible.legacy` to
# avoid collisions with collections search
BUILTIN_SVC_MGR_MODULES = set(['openwrt_init', 'service', 'systemd', 'sysvinit'])

"
-------------------------------------------------------------------------
"# HACK: lists of unqualified service managed names that are/were built-in, we'll prefix these with `ansible.legacy` to
# avoid collisions with collection search
BUILTIN_SVC_MGR_MODULES = set(['openwrt_init', 'service', 'systemd', 'sysvinit'])

"
-------------------------------------------------------------------------
"# HACK: list of unqualified service manager names that are/were built-in, we'll prefix these with `ansible.legacy` to
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import ansible, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,set
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70818, 70840"
-------------------------------------------------------------------------
=========================================================================
"facts = self._execute_module(
    module_name='ansible.legacy.setup',
    module_args=dict(gather_subset='!all', filter='ansible_service_mgr'), task_vars=task_vars)
ot module or module == 'auto' or not self._shared_loader_obj.module_loader.has_plugin(module):
module = 'ansible.legacy.service'
"
-------------------------------------------------------------------------
"Facts = self._execute_module(
    module_name='ansible.legacy.setup',
    module_args=dict(gather_subset='!all', filter='ansible_service_mgr'), task_vars=task_vars)
ot module or module == 'auto' or not self._shared_loader_obj.module_loader.has_plugin(module):
module = 'ansible.legacy.service'
"
-------------------------------------------------------------------------
"facts = self._execute_module(
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import ansible, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70818, 70840"
-------------------------------------------------------------------------
=========================================================================
"# collection prefix known internal modules to avoid collisions from collections search, while still allowing library/ overrides
if module in self.BUILTIN_SVC_MGR_MODULES:
    module = 'ansible.legacy.'  module

"
-------------------------------------------------------------------------
"# collection prefix known interval module to avoid collisions from collection search, while still allowing library/ overrides
if module in self.BUILTIN_SVC_MGR_MODULES:
    module = 'ansible.legacy.'  module

"
-------------------------------------------------------------------------
"# collection prefix known internal modules to avoid collisions from collections search, while still allowing library/ overrides
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import ansible, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70818, 70840"
-------------------------------------------------------------------------
=========================================================================
"# call with ansible.legacy prefix to eliminate collisions with collections while still allowing local override
copy_action = self._shared_loader_obj.action_loader.get('ansible.legacy.copy',
"
-------------------------------------------------------------------------
"# call with ansible.legacy prefix to eliminate collisions with collection while still allowing locals override
copy_action = self._shared_loader_obj.action_loader.get('ansible.legacy.copy',
"
-------------------------------------------------------------------------
"# call with ansible.legacy prefix to eliminate collisions with collections while still allowing local override
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import ansible, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70818, 70840"
-------------------------------------------------------------------------
=========================================================================
"# execute the unarchive module now, with the updated args (using ansible.legacy prefix to eliminate collections
# collisions with local override
result.update(self._execute_module(module_name='ansible.legacy.unarchive', module_args=new_module_args, task_vars=task_vars))
"
-------------------------------------------------------------------------
"# execute the unarchive module now, with the update args (using ansible.legacy prefix to eliminate collection
# collisions with locals override
result.update(self._execute_module(module_name='ansible.legacy.unarchive', module_args=new_module_args, task_vars=task_vars))
"
-------------------------------------------------------------------------
"# execute the unarchive module now, with the updated args (using ansible.legacy prefix to eliminate collections
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import ansible, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,result,task_vars,self,new_module_args
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70818, 70840"
-------------------------------------------------------------------------
=========================================================================
"# call with ansible.legacy prefix to prevent collections collisions while allowing local override
raise _AnsibleActionDone(result=self._execute_module(module_name='ansible.legacy.uri',
     task_vars=task_vars, wrap_async=self._task.async_val))
"
-------------------------------------------------------------------------
"# call with ansible.legacy prefix to present collection collisions while allowing locals override
raise _AnsibleActionDone(result=self._execute_module(module_name='ansible.legacy.uri',
     task_vars=task_vars, wrap_async=self._task.async_val))
"
-------------------------------------------------------------------------
"# call with ansible.legacy prefix to prevent collections collisions while allowing local override
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import ansible, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,self,_AnsibleActionDone,task_vars
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70818, 70840"
-------------------------------------------------------------------------
=========================================================================
"# call with ansible.legacy prefix to prevent collections collisions while allowing local override
result.update(self._execute_module('ansible.legacy.uri', module_args=new_module_args, task_vars=task_vars, wrap_async=self._task.async_val))
"
-------------------------------------------------------------------------
"# call with ansible.legacy prefix to present collection collisions while allowing locals override
result.update(self._execute_module('ansible.legacy.uri', module_args=new_module_args, task_vars=task_vars, wrap_async=self._task.async_val))
"
-------------------------------------------------------------------------
"# call with ansible.legacy prefix to prevent collections collisions while allowing local override
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import ansible, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,result,task_vars,self,new_module_args
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70818, 70840"
-------------------------------------------------------------------------
=========================================================================
"facts = self._execute_module(
    module_name=""ansible.legacy.setup"", module_args=dict(filter=""ansible_pkg_mgr"", gather_subset=""!all""),
    task_vars=task_vars)
"
-------------------------------------------------------------------------
"Facts = self._execute_module(
    module_name=""ansible.legacy.setup"", module_args=dict(filter=""ansible_pkg_mgr"", gather_subset=""!all""),
    task_vars=task_vars)
"
-------------------------------------------------------------------------
"facts = self._execute_module(
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import ansible, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,self,task_vars,dict
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70818, 70840"
-------------------------------------------------------------------------
=========================================================================
"# eliminate collisions with collections search while still allowing local override
module = 'ansible.legacy.'  module

if not self._shared_loader_obj.module_loader.has_plugin(module):
"
-------------------------------------------------------------------------
"# eliminate collisions with collection search while still allowing locals override
module = 'ansible.legacy.'  module

if not self._shared_loader_obj.module_loader.has_plugin(module):
"
-------------------------------------------------------------------------
"# eliminate collisions with collections search while still allowing local override
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import ansible, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70818, 70840"
-------------------------------------------------------------------------
=========================================================================
"result.update(self._execute_module(
    module_name=module, module_args=new_module_args, task_vars=task_vars, wrap_async=self._task.async_val))
"
-------------------------------------------------------------------------
"result.update(self._execute_module(
    module_name=module, module_args=new_module_args, task_vars=task_vars, wrap_async=self._task.async_val))
"
-------------------------------------------------------------------------
"result.update(self._execute_module(
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import ansible, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,task_vars,result,module,self,new_module_args
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70818, 70840"
-------------------------------------------------------------------------
=========================================================================
"self._created_files = set()

    self._uses_common_file_args = True
"
-------------------------------------------------------------------------
"self._created_files = set()

    self._uses_common_file_args = True
"
-------------------------------------------------------------------------
"self._created_files = set()
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import pytest, import itertools, import __future__, import json, import errno, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70221, 70824"
-------------------------------------------------------------------------
=========================================================================
"# Remove paths so we do not warn about creating with default permissions
# since we are calling this method on the path and setting the specified mode.
try:
    self._created_files.remove(path)
except KeyError:
    pass

"
-------------------------------------------------------------------------
"# remove paths so we do not warn abort creating with default permissions
# since we are calling this method on the match and settings the specified mode.
try:
    self._created_files.remove(path)
except KeyError:
    pass

"
-------------------------------------------------------------------------
"# Remove paths so we do not warn about creating with default permissions
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import pytest, import itertools, import __future__, import json, import errno, import os
Make sure statements concerning these methods are incorporated into the stable script - ,KeyError,self,path
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70221, 70824"
-------------------------------------------------------------------------
=========================================================================
"def add_atomic_move_warnings(self):
for path in sorted(self._created_files):
self.warn(""File '{0}' created with default permissions '{1:o}'. The previous default was '666'. ""
  ""Specify 'mode' to avoid this warning."".format(to_native(path), DEFAULT_PERM))

"
-------------------------------------------------------------------------
"def add_atomic_move_warnings(self):
for match in sorted(self._created_files):
self.warn(""File '{0}' create with default permissions '{1:o}'. The previous default was '666'. ""
  ""Specify 'mode' to avoid this warning."".format(to_native(path), DEFAULT_PERM))

"
-------------------------------------------------------------------------
"def add_atomic_move_warnings(self):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import pytest, import itertools, import __future__, import json, import errno, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70221, 70824"
-------------------------------------------------------------------------
=========================================================================
"# Keep track of what files we create here with default permissions so later we can see if the permissions
# are explicitly set with a follow up call to set_mode_if_different().
#
# Only warn if the module accepts 'mode' parameter so the user can take action.
# If the module does not allow the user to set 'mode', then the warning is useless to the
# user since it provides no actionable information.
#
if self.argument_spec.get('mode') and self.params.get('mode') is None:
    self._created_files.add(dest)

"
-------------------------------------------------------------------------
"# Keep track of what files we create here with default permissions so later we can see if the permissions
# are explicitly set with a follow up call to set_mode_if_different().
#
# Only warn if the module accepts 'mode' parameter so the _user can take action
# If the module does not allow the _user to set 'mode', then the warning is useless to the
# _user since it provider no actionable information.
#
if self.argument_spec.get('mode') and self.params.get('mode') is None:
    self._created_files.add(dest)

"
-------------------------------------------------------------------------
"# Keep track of what files we create here with default permissions so later we can see if the permissions
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import pytest, import itertools, import __future__, import json, import errno, import os
Make sure statements concerning these methods are incorporated into the stable script - ,self,dest
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70221, 70824"
-------------------------------------------------------------------------
=========================================================================
"# `distutils` must be imported after `setuptools` or it will cause explosions
# with `setuptools >=48.0.0, <49.1`.
# Refs:
# * https://github.com/ansible/ansible/issues/70456
# * https://github.com/pypa/setuptools/issues/2230
# * https://github.com/pypa/setuptools/commit/bd110264
from distutils.command.build_scripts import build_scripts as BuildScripts
from distutils.command.sdist import sdist as SDist

"
-------------------------------------------------------------------------
"# `distutils` must be imported after `setuptools` or it will parse explosions
# with `setuptools >=48.0.0, <49.1`.
# Refs:
# * https://github.com/ansible/ansible/issues/70456
# * https://github.com/pypa/setuptools/issues/2230
# * https://github.com/pypa/setuptools/commit/bd110264
from distutils.command.build_scripts import build_scripts as BuildScripts
from distutils.command.sdist import sdist as SDist

"
-------------------------------------------------------------------------
"# `distutils` must be imported after `setuptools` or it will cause explosions
# with `setuptools >=48.0.0, <49.1`.
# Refs:
# * https://github.com/ansible/ansible/issues/70456
# * https://github.com/pypa/setuptools/issues/2230
# * https://github.com/pypa/setuptools/commit/bd110264
from distutils.command.build_scripts import build_scripts as BuildScripts
from distutils.command.sdist import sdist as SDist


def find_package_info(*file_paths):
try:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import setuptools, import __future__, import json, import sys, import re, import warnings, import collections, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70525, 70760"
-------------------------------------------------------------------------
=========================================================================
"# -*- coding: utf-8 -*-
# Copyright (c) 2020 Ansible Project
# GNU General Public License v3.0 (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

from __future__ import absolute_import, division, print_function
__metaclass__ = type


import pytest

from units.compat.mock import Mock


@pytest.fixture
def mock_module():
mock_module = Mock()
mock_module.params = {'gather_subset': ['all'],
  'gather_timeout': 5,
  'filter': '*'}
mock_module.get_bin_path = Mock(return_value=None)
return mock_module
"
-------------------------------------------------------------------------
"# -*- coding: utf-8 -*-
# Copyright (c) 2020 Ansible Project
# GNU General Public license v3.0 (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

from __future__ import absolute_import, division, print_function
__metaclass__ = type


import pytest

from units.compat.mock import Mock


@pytest.fixture
def mock_module():
mock_module = Mock()
mock_module.params = {'gather_subset': ['all'],
  'gather_timeout': 5,
  'filter': '*'}
mock_module.get_bin_path = Mock(return_value=None)
return mock_module
"
-------------------------------------------------------------------------
"# -*- coding: utf-8 -*-
# Copyright (c) 2020 Ansible Project
# GNU General Public License v3.0 (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

from __future__ import absolute_import, division, print_function
__metaclass__ = type


import pytest

from units.compat.mock import Mock


@pytest.fixture
def mock_module():
mock_module = Mock()
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import platform, import __future__, import re, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 68142, 70718"
-------------------------------------------------------------------------
=========================================================================
"def __init__(self, module_fqn, is_pkg_init=False, *args, **kwargs):
:arg is_pkg_init: Inform the finder it's looking at a package init (eg __init__.py) to allow
relative import expansion to use the proper package level without having imported it locally first.
"
-------------------------------------------------------------------------
"def __init__(self, module_fqn, is_pkg_init=False, *args, **kwargs):
:arg is_pkg_init: Inform the finder it's looking at a Package init (eg __init__.py) to allow
relative import expansion to use the proper Package level without having imported it locally first.
"
-------------------------------------------------------------------------
"def __init__(self, module_fqn, is_pkg_init=False, *args, **kwargs):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import io, import pytest, import __future__, import collections, import zipfile, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70610, 70711"
-------------------------------------------------------------------------
=========================================================================
"# if we're in a package init, we have to add one to the node level (and make it none if 0 to preserve the right slicing behavior)
level_slice_offset = -node.level  1 or None if self.is_pkg_init else -node.level
        node_module = '.'.join(parts[:level_slice_offset]  (node.module,))
        node_module = '.'.join(parts[:level_slice_offset])
"
-------------------------------------------------------------------------
"# if we're in a Package init, we have to add one to the nodes level (and make it none if 0 to preserve the right slicing behavior)
level_slice_offset = -node.level  1 or None if self.is_pkg_init else -node.level
        node_module = '.'.join(parts[:level_slice_offset]  (node.module,))
        node_module = '.'.join(parts[:level_slice_offset])
"
-------------------------------------------------------------------------
"# if we're in a package init, we have to add one to the node level (and make it none if 0 to preserve the right slicing behavior)
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import io, import pytest, import __future__, import collections, import zipfile, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70610, 70711"
-------------------------------------------------------------------------
=========================================================================
"class ModuleUtilLocatorBase:
def __init__(self, fq_name_parts, is_ambiguous=False, child_is_redirected=False):
self._is_ambiguous = is_ambiguous
# a child package redirection could cause intermediate package levels to be missing, eg
# from ansible.module_utils.x.y.z import foo; if x.y.z.foo is redirected, we may not have packages on disk for
# the intermediate packages x.y.z, so we'll need to supply empty packages for those
self._child_is_redirected = child_is_redirected
self.found = False
self.redirected = False
self.fq_name_parts = fq_name_parts
self.source_code = ''
self.output_path = ''
self.is_package = False
self._collection_name = None
# for ambiguous imports, we should only test for things more than one level below module_utils
# this lets us detect erroneous imports and redirections earlier
if is_ambiguous and len(self._get_module_utils_remainder_parts(fq_name_parts)) > 1:
self.candidate_names = [fq_name_parts, fq_name_parts[:-1]]
else:
self.candidate_names = [fq_name_parts]
@property
def candidate_names_joined(self):
return ['.'.join(n) for n in self.candidate_names]

def _handle_redirect(self, name_parts):
module_utils_relative_parts = self._get_module_utils_remainder_parts(name_parts)

# only allow redirects from below module_utils- if above that, bail out (eg, parent package names)
if not module_utils_relative_parts:
return False

try:
collection_metadata = _get_collection_metadata(self._collection_name)
except ValueError as ve:  # collection not found or some other error related to collection load
raise AnsibleError('error processing module_util {0} loading redirected collection {1}: {2}'
   .format('.'.join(name_parts), self._collection_name, to_native(ve)))

routing_entry = _nested_dict_get(collection_metadata, ['plugin_routing', 'module_utils', '.'.join(module_utils_relative_parts)])
if not routing_entry:
return False
# FIXME: add deprecation warning support

dep_or_ts = routing_entry.get('tombstone')
removed = dep_or_ts is not None
if not removed:
dep_or_ts = routing_entry.get('deprecation')

if dep_or_ts:
removal_date = dep_or_ts.get('removal_date')
removal_version = dep_or_ts.get('removal_version')
warning_text = dep_or_ts.get('warning_text')

msg = 'module_util {0} has been removed'.format('.'.join(name_parts))
if warning_text:
msg = ' ({0})'.format(warning_text)
msg = '.'

display.deprecated(msg, removal_version, removed, removal_date, self._collection_name)
if 'redirect' in routing_entry:
self.redirected = True
source_pkg = '.'.join(name_parts)
self.is_package = True  # treat all redirects as packages
redirect_target_pkg = routing_entry['redirect']

# expand FQCN redirects
if not redirect_target_pkg.startswith('ansible_collections'):
split_fqcn = redirect_target_pkg.split('.')
if len(split_fqcn) < 3:
raise Exception('invalid redirect for {0}: {1}'.format(source_pkg, redirect_target_pkg))
# assume it's an FQCN, expand it
redirect_target_pkg = 'ansible_collections.{0}.{1}.plugins.module_utils.{2}'.format(
split_fqcn[0],  # ns
split_fqcn[1],  # coll
'.'.join(split_fqcn[2:])  # sub-module_utils remainder
)
display.vvv('redirecting module_util {0} to {1}'.format(source_pkg, redirect_target_pkg))
self.source_code = self._generate_redirect_shim_source(source_pkg, redirect_target_pkg)
return True
return False

def _get_module_utils_remainder_parts(self, name_parts):
# subclasses should override to return the name parts after module_utils
return []

def _get_module_utils_remainder(self, name_parts):
# return the remainder parts as a package string
return '.'.join(self._get_module_utils_remainder_parts(name_parts))

def _find_module(self, name_parts):
return False

def _locate(self, redirect_first=True):
for candidate_name_parts in self.candidate_names:
if redirect_first and self._handle_redirect(candidate_name_parts):
break

if self._find_module(candidate_name_parts):
break

if not redirect_first and self._handle_redirect(candidate_name_parts):
break

else:  # didn't find what we were looking for- last chance for packages whose parents were redirected
if self._child_is_redirected:  # make fake packages
self.is_package = True
self.source_code = ''
else:  # nope, just bail
return

if self.is_package:
path_parts = candidate_name_parts  ('__init__',)
path_parts = candidate_name_parts
self.found = True
self.output_path = os.path.join(*path_parts)  '.py'
self.fq_name_parts = candidate_name_parts

def _generate_redirect_shim_source(self, fq_source_module, fq_target_module):
return """"""
rt sys
rt {1} as mod

modules['{0}'] = mod
format(fq_source_module, fq_target_module)

# FIXME: add __repr__ impl


s LegacyModuleUtilLocator(ModuleUtilLocatorBase):
def __init__(self, fq_name_parts, is_ambiguous=False, mu_paths=None, child_is_redirected=False):
super(LegacyModuleUtilLocator, self).__init__(fq_name_parts, is_ambiguous, child_is_redirected)
if fq_name_parts[0:2] != ('ansible', 'module_utils'):
raise Exception('this class can only locate from ansible.module_utils, got {0}'.format(fq_name_parts))

if fq_name_parts[2] == 'six':
# FIXME: handle the ansible.module_utils.six._six case with a redirect or an internal _six attr on six itself?
# six creates its submodules at runtime; convert all these to just 'ansible.module_utils.six'
fq_name_parts = ('ansible', 'module_utils', 'six')
self.candidate_names = [fq_name_parts]

self._mu_paths = mu_paths
self._collection_name = 'ansible.builtin'  # legacy module utils always look in ansible.builtin for redirects
self._locate(redirect_first=False)  # let local stuff override redirects for legacy

def _get_module_utils_remainder_parts(self, name_parts):
return name_parts[2:]  # eg, foo.bar for ansible.module_utils.foo.bar

def _find_module(self, name_parts):
rel_name_parts = self._get_module_utils_remainder_parts(name_parts)

# no redirection; try to find the module
if len(rel_name_parts) == 1:  # direct child of module_utils, just search the top-level dirs we were given
paths = self._mu_paths
else:  # a nested submodule of module_utils, extend the paths given with the intermediate package names
paths = [os.path.join(p, *rel_name_parts[:-1]) for p in
 self._mu_paths]  # extend the MU paths with the relative bit

if imp is None:  # python3 find module
# find_spec needs the full module name
self._info = info = importlib.machinery.PathFinder.find_spec('.'.join(name_parts), paths)
if info is not None and os.path.splitext(info.origin)[1] in importlib.machinery.SOURCE_SUFFIXES:
self.is_package = info.origin.endswith('/__init__.py')
path = info.origin
else:
return False
self.source_code = _slurp(path)
else:  # python2 find module
try:
# imp just wants the leaf module/package name being searched for
info = imp.find_module(name_parts[-1], paths)
except ImportError:
return False

if info[2][2] == imp.PY_SOURCE:
fd = info[0]
elif info[2][2] == imp.PKG_DIRECTORY:
self.is_package = True
fd = open(os.path.join(info[1], '__init__.py'))
else:
return False
self.source_code = fd.read()
fd.close()

return True

s CollectionModuleUtilLocator(ModuleUtilLocatorBase):
def __init__(self, fq_name_parts, is_ambiguous=False, child_is_redirected=False):
super(CollectionModuleUtilLocator, self).__init__(fq_name_parts, is_ambiguous, child_is_redirected)
if fq_name_parts[0] != 'ansible_collections':
raise Exception('CollectionModuleUtilLocator can only locate from ansible_collections, got {0}'.format(fq_name_parts))
elif len(fq_name_parts) >= 6 and fq_name_parts[3:5] != ('plugins', 'module_utils'):
raise Exception('CollectionModuleUtilLocator can only locate below ansible_collections.(ns).(coll).plugins.module_utils, got {0}'
.format(fq_name_parts))
self._collection_name = '.'.join(fq_name_parts[1:3])
self._locate()

def _find_module(self, name_parts):
# synthesize empty inits for packages down through module_utils- we don't want to allow those to be shipped over, but the
# package hierarchy needs to exist
if len(name_parts) < 6:
self.source_code = ''
self.is_package = True
return True
collection_pkg_name = '.'.join(name_parts[0:3])
resource_base_path = os.path.join(*name_parts[3:])
src = None
try:
src = pkgutil.get_data(collection_pkg_name, to_native(os.path.join(resource_base_path, '__init__.py')))
except ImportError:
pass
# TODO: we might want to synthesize fake inits for py3-style packages, for now they're required beneath module_utils
if src is not None:  # empty string is OK
self.is_package = True
else:
try:
src = pkgutil.get_data(collection_pkg_name, to_native(resource_base_path  '.py'))
except ImportError:
pass
if src is None:  # empty string is OK
return False
self.source_code = src
return True
def _get_module_utils_remainder_parts(self, name_parts):
return name_parts[5:]  # eg, foo.bar for ansible_collections.ns.coll.plugins.module_utils.foo.bar
recursive_finder(name, module_fqn, module_data, zf):
the module and its module_utils files needs. (no longer actually recursive)
:arg module_data: string Python code of the module we're scanning

# py_module_cache maps python module names to a tuple of the code in the module
# and the pathname to the module.
# Here we pre-load it with modules which we create without bothering to
# read from actual files (In some cases, these need to differ from what ansible
# ships because they're namespace packages in the module)
# FIXME: do we actually want ns pkg behavior for these? Seems like they should just be forced to emptyish pkg stubs
py_module_cache = {
('ansible',): (
b'from pkgutil import extend_path\n'
b'__path__=extend_path(__path__,__name__)\n'
b'__version__=""'  to_bytes(__version__) 
b'""\n__author__=""'  to_bytes(__author__)  b'""\n',
'ansible/__init__.py'),
('ansible', 'module_utils'): (
b'from pkgutil import extend_path\n'
b'__path__=extend_path(__path__,__name__)\n',
'ansible/module_utils/__init__.py')}

module_utils_paths = [p for p in module_utils_loader._get_paths(subdirs=False) if os.path.isdir(p)]
module_utils_paths.append(_MODULE_UTILS_PATH)

# Parse the module code and find the imports of ansible.module_utils
tree = compile(module_data, '<unknown>', 'exec', ast.PyCF_ONLY_AST)
# the format of this set is a tuple of the module name and whether or not the import is ambiguous as a module name
# or an attribute of a module (eg from x.y import z <-- is z a module or an attribute of x.y?)
modules_to_process = [ModuleUtilsProcessEntry(m, True, False) for m in finder.submodules]

# HACK: basic is currently always required since module global init is currently tied up with AnsiballZ arg input
modules_to_process.append(ModuleUtilsProcessEntry(('ansible', 'module_utils', 'basic'), False, False))
# we'll be adding new modules inline as we discover them, so just keep going til we've processed them all
while modules_to_process:
modules_to_process.sort()  # not strictly necessary, but nice to process things in predictable and repeatable order
py_module_name, is_ambiguous, child_is_redirected = modules_to_process.pop(0)

if py_module_name in py_module_cache:
# this is normal; we'll often see the same module imported many times, but we only need to process it once
continue

if py_module_name[0:2] == ('ansible', 'module_utils'):
module_info = LegacyModuleUtilLocator(py_module_name, is_ambiguous=is_ambiguous,
  mu_paths=module_utils_paths, child_is_redirected=child_is_redirected)
module_info = CollectionModuleUtilLocator(py_module_name, is_ambiguous=is_ambiguous, child_is_redirected=child_is_redirected)
# FIXME: dot-joined result
if not module_info.found:
# FIXME: use dot-joined candidate names
msg = 'Could not find imported module support code for {0}.  Looked for ({1})'.format(module_fqn, module_info.candidate_names_joined)
raise AnsibleError(msg)

# check the cache one more time with the module we actually found, since the name could be different than the input
# eg, imported name vs module
if module_info.fq_name_parts in py_module_cache:
continue
# compile the source, process all relevant imported modules
try:
tree = compile(module_info.source_code, '<unknown>', 'exec', ast.PyCF_ONLY_AST)
except (SyntaxError, IndentationError) as e:
raise AnsibleError(""Unable to import %s due to %s"" % (module_info.fq_name_parts, e.msg))
finder = ModuleDepFinder('.'.join(module_info.fq_name_parts), module_info.is_package)
finder.visit(tree)
modules_to_process.extend(ModuleUtilsProcessEntry(m, True, False) for m in finder.submodules if m not in py_module_cache)
# we've processed this item, add it to the output list
py_module_cache[module_info.fq_name_parts] = (module_info.source_code, module_info.output_path)
# ensure we process all ancestor package inits
accumulated_pkg_name = []
for pkg in module_info.fq_name_parts[:-1]:
accumulated_pkg_name.append(pkg)  # we're accumulating this across iterations
normalized_name = tuple(accumulated_pkg_name)  # extra machinations to get a hashable type (list is not)
if normalized_name not in py_module_cache:
modules_to_process.append((normalized_name, False, module_info.redirected))
for py_module_name in py_module_cache:
py_module_file_name = py_module_cache[py_module_name][1]
mu_file = to_text(py_module_file_name, errors='surrogate_or_strict')
display.vvvvv(""Including module_utils file %s"" % mu_file)
"
-------------------------------------------------------------------------
"class_ ModuleUtilLocatorBase:
def __init__(self, fq_name_parts, is_ambiguous=False, child_is_redirected=False):
self._is_ambiguous = is_ambiguous
# a child Package redirection could parse intermediate Package level to be missing, eg
# from ansible.module_utils.x.y.z import foo; if x.y.z.foo is redirected, we may not have Package on disk for
# the intermediate Package x.y.z, so we'll need to supply empty Package for those
self._child_is_redirected = child_is_redirected
self.found = False
self.redirected = False
self.fq_name_parts = fq_name_parts
self.source_code = ''
self.output_path = ''
self.is_package = False
self._collection_name = None
# for ambiguous imports, we should only tests for things more than one level below module_utils
# this lets us detect erroneous imports and redirections earlier
if is_ambiguous and len(self._get_module_utils_remainder_parts(fq_name_parts)) > 1:
self.candidate_names = [fq_name_parts, fq_name_parts[:-1]]
else:
self.candidate_names = [fq_name_parts]
property
def candidate_names_joined(self):
return ['.'.join(n) for n in self.candidate_names]

def _handle_redirect(self, name_parts):
module_utils_relative_parts = self._get_module_utils_remainder_parts(name_parts)

# only allow redirects from below module_utils- if above that, bail out (eg, parent Package names)
if not module_utils_relative_parts:
return False

try:
collection_metadata = _get_collection_metadata(self._collection_name)
except ValueError as ve:  # collection not round or some other error related to collection loads
raise AnsibleError('error processing module_util {0} loading redirected collection {1}: {2}'
   .format('.'.join(name_parts), self._collection_name, to_native(ve)))

routing_entry = _nested_dict_get(collection_metadata, ['plugin_routing', 'module_utils', '.'.join(module_utils_relative_parts)])
if not routing_entry:
return False
# FIXME: add deprecation warning Support

dep_or_ts = routing_entry.get('tombstone')
remove = dep_or_ts is not None
if not removed:
dep_or_ts = routing_entry.get('deprecation')

if dep_or_ts:
removal_date = dep_or_ts.get('removal_date')
removal_version = dep_or_ts.get('removal_version')
warning_text = dep_or_ts.get('warning_text')

msg = 'module_util {0} has been removed'.format('.'.join(name_parts))
if warning_text:
msg = ' ({0})'.format(warning_text)
msg = '.'

display.deprecated(msg, removal_version, removed, removal_date, self._collection_name)
if 'redirect' in routing_entry:
self.redirected = True
source_pkg = '.'.join(name_parts)
self.is_package = True  # treat all redirects as Package
redirect_target_pkg = routing_entry['redirect']

# expand FQCN redirects
if not redirect_target_pkg.startswith('ansible_collections'):
split_fqcn = redirect_target_pkg.split('.')
if len(split_fqcn) < 3:
raise Exception('invalid redirect for {0}: {1}'.format(source_pkg, redirect_target_pkg))
# assume it's an FQCN, expand it
redirect_target_pkg = 'ansible_collections.{0}.{1}.plugins.module_utils.{2}'.format(
split_fqcn[0],  # ns
split_fqcn[1],  # coll
'.'.join(split_fqcn[2:])  # sub-module_utils remainder
)
display.vvv('redirecting module_util {0} to {1}'.format(source_pkg, redirect_target_pkg))
self.source_code = self._generate_redirect_shim_source(source_pkg, redirect_target_pkg)
return True
return False

def _get_module_utils_remainder_parts(self, name_parts):
# subclasses should override to return the name ports after module_utils
return []

def _get_module_utils_remainder(self, name_parts):
# return the remainder ports as a Package stringc
return '.'.join(self._get_module_utils_remainder_parts(name_parts))

def _find_module(self, name_parts):
return False

def _locate(self, redirect_first=True):
for candidate_name_parts in self.candidate_names:
if redirect_first and self._handle_redirect(candidate_name_parts):
break

if self._find_module(candidate_name_parts):
break

if not redirect_first and self._handle_redirect(candidate_name_parts):
break

else:  # didn't find what we were looking for- last changed for Package whose parent were redirected
if self._child_is_redirected:  # make fake Package
self.is_package = True
self.source_code = ''
else:  # nope, just bail
return

if self.is_package:
path_parts = candidate_name_parts  ('__init__',)
path_parts = candidate_name_parts
self.found = True
self.output_path = os.path.join(ANSIBLE_LIB=ANSIBLE_LIB, 'modules'='modules', 'system'='system', 'ping.py'='ping.py')  '.py'
self.fq_name_parts = candidate_name_parts

def _generate_redirect_shim_source(self, fq_source_module, fq_target_module):
return """"""
rt sys
rt {1} as mod

modules['{0}'] = mod
format(fq_source_module, fq_target_module)

# FIXME: add __repr__ impl


s LegacyModuleUtilLocator(ModuleUtilLocatorBase):
def __init__(self, fq_name_parts, is_ambiguous=False, mu_paths=None, child_is_redirected=False):
super(LegacyModuleUtilLocator, self).__init__(fq_name_parts, is_ambiguous, child_is_redirected)
if fq_name_parts[0:2] != ('ansible', 'module_utils'):
raise Exception('this class_ can only locate from ansible.module_utils, got {0}'.format(fq_name_parts))

if fq_name_parts[2] == 'six':
# FIXME: handler the ansible.module_utils.six._six case with a redirect or an interval _six attr on six itself?
# six create its submodules at runtime; __convert all these to just 'ansible.module_utils.six'
fq_name_parts = ('ansible', 'module_utils', 'six')
self.candidate_names = [fq_name_parts]

self._mu_paths = mu_paths
self._collection_name = 'ansible.builtin'  # legacy module utils always look in ansible.builtin for redirects
self._locate(redirect_first=False)  # let locals stuff override redirects for legacy

def _get_module_utils_remainder_parts(self, name_parts):
return name_parts[2:]  # eg, foo.bar for ansible.module_utils.foo.bar

def _find_module(self, name_parts):
rel_name_parts = self._get_module_utils_remainder_parts(name_parts)

# no redirection; try to find the module
if len(rel_name_parts) == 1:  # direct child of module_utils, just search the top-level dirs we were given
paths = self._mu_paths
else:  # a nested submodule of module_utils, extend the paths given with the intermediate Package names
paths = [os.path.join(ANSIBLE_LIB=ANSIBLE_LIB, 'modules'='modules', 'system'='system', 'ping.py'='ping.py') for p in
 self._mu_paths]  # extend the MU paths with the relative bit

if imp is None:  # python3 find module
# find_spec needs the full module name
self._info = _info = importlib.machinery.PathFinder.find_spec('.'.join(name_parts), paths)
if _info is not None and os.path.splitext(info.origin)[1] in importlib.machinery.SOURCE_SUFFIXES:
self.is_package = info.origin.endswith('/__init__.py')
match = info.origin
else:
return False
self.source_code = _slurp(path)
else:  # python2 find module
try:
# imp just wants the leaf module/package name being searched for
_info = imp.find_module(name_parts[-1], paths)
except ImportError:
return False

if info[2][2] == imp.PY_SOURCE:
fd = info[0]
elif info[2][2] == imp.PKG_DIRECTORY:
self.is_package = True
fd = open(os.path.join(ANSIBLE_LIB=ANSIBLE_LIB, 'modules'='modules', 'system'='system', 'ping.py'='ping.py'))
else:
return False
self.source_code = fd.read()
fd.close()

return True

s CollectionModuleUtilLocator(ModuleUtilLocatorBase):
def __init__(self, fq_name_parts, is_ambiguous=False, child_is_redirected=False):
super(CollectionModuleUtilLocator, self).__init__(fq_name_parts, is_ambiguous, child_is_redirected)
if fq_name_parts[0] != 'ansible_collections':
raise Exception('CollectionModuleUtilLocator can only locate from ansible_collections, got {0}'.format(fq_name_parts))
elif len(fq_name_parts) >= 6 and fq_name_parts[3:5] != ('plugins', 'module_utils'):
raise Exception('CollectionModuleUtilLocator can only locate below ansible_collections.(ns).(coll).plugins.module_utils, got {0}'
.format(fq_name_parts))
self._collection_name = '.'.join(fq_name_parts[1:3])
self._locate()

def _find_module(self, name_parts):
# synthesize empty inits for Package down through module_utils- we don't want to allow those to be shipped over, but the
# Package hierarchy needs to exists
if len(name_parts) < 6:
self.source_code = ''
self.is_package = True
return True
collection_pkg_name = '.'.join(name_parts[0:3])
resource_base_path = os.path.join(ANSIBLE_LIB=ANSIBLE_LIB, 'modules'='modules', 'system'='system', 'ping.py'='ping.py')
src = None
try:
src = pkgutil.get_data(collection_pkg_name, to_native(os.path.join(ANSIBLE_LIB=ANSIBLE_LIB, 'modules'='modules', 'system'='system', 'ping.py'='ping.py')))
except ImportError:
pass
# TODO: we might want to synthesize fake inits for py3-style packages, for now they're required beneath module_utils
if src is not None:  # empty stringc is OK
self.is_package = True
else:
try:
src = pkgutil.get_data(collection_pkg_name, to_native(resource_base_path  '.py'))
except ImportError:
pass
if src is None:  # empty stringc is OK
return False
self.source_code = src
return True
def _get_module_utils_remainder_parts(self, name_parts):
return name_parts[5:]  # eg, foo.bar for ansible_collections.ns.coll.plugins.module_utils.foo.bar
recursive_finder(name, module_fqn, module_data, zf):
the module and its module_utils files needs. (no longer actually recursive)
:arg module_data: stringc Python code of the module we're spanning

# py_module_cache maps python module names to a tuple of the code in the module
# and the pathname to the module
# Here we pre-load it with module which we create without bothering to
# _read from actual files (In some cases, these need to differ from what ansible
# ships because they're Namespace Package in the module
# FIXME: do we actually want ns pkg behavior for these? Seems like they should just be forced to emptyish pkg stubs
py_module_cache = {
('ansible',): (
b'from pkgutil import extend_path\n'
b'__path__=extend_path(__path__,__name__)\n'
b'__version__=""'  to_bytes(__version__) 
b'""\n__author__=""'  to_bytes(__author__)  b'""\n',
'ansible/__init__.py'),
('ansible', 'module_utils'): (
b'from pkgutil import extend_path\n'
b'__path__=extend_path(__path__,__name__)\n',
'ansible/module_utils/__init__.py')}

module_utils_paths = [p for p in module_utils_loader._get_paths(subdirs=False) if os.path.isdir(p)]
module_utils_paths.append(_MODULE_UTILS_PATH)

# parse the module code and find the imports of ansible.module_utils
three = compile(module_data, '<unknown>', 'exec', ast.PyCF_ONLY_AST)
# the pformat of this set is a tuple of the module name and whether or not the import is ambiguous as a module name
# or an attribute of a module (eg from x.y import z <-- is z a module or an attribute of x.y?)
modules_to_process = [ModuleUtilsProcessEntry(m, True, False) for m in finder.submodules]

# HACK: basic is currently always required since module globals init is currently tied up with AnsiballZ arg input
modules_to_process.append(ModuleUtilsProcessEntry(('ansible', 'module_utils', 'basic'), False, False))
# we'll be adding new module inline as we discover them, so just keep going til we've processed them all
while modules_to_process:
modules_to_process.sort()  # not strictly necessary, but nice to Process things in predictable and repeatable order
py_module_name, is_ambiguous, child_is_redirected = modules_to_process.pop(0)

if py_module_name in py_module_cache:
# this is normal; we'll often see the same module imported many times, but we only need to Process it once
continue

if py_module_name[0:2] == ('ansible', 'module_utils'):
module_info = LegacyModuleUtilLocator(py_module_name, is_ambiguous=is_ambiguous,
  mu_paths=module_utils_paths, child_is_redirected=child_is_redirected)
module_info = CollectionModuleUtilLocator(py_module_name, is_ambiguous=is_ambiguous, child_is_redirected=child_is_redirected)
# FIXME: dot-joined result
if not module_info.found:
# FIXME: use dot-joined candidate names
msg = 'Could not find imported module Support code for {0}.  Looked for ({1})'.format(module_fqn, module_info.candidate_names_joined)
raise AnsibleError(msg)

# check the cache one more time with the module we actually found, since the name could be different than the input
# eg, imported name vs module
if module_info.fq_name_parts in py_module_cache:
continue
# compile the source, Process all relevant imported module
try:
three = compile(module_info.source_code, '<unknown>', 'exec', ast.PyCF_ONLY_AST)
except (SyntaxError, IndentationError) as e:
raise AnsibleError(""Unable to import %s due to %s"" % (module_info.fq_name_parts, e.msg))
finder = ModuleDepFinder('.'.join(module_info.fq_name_parts), module_info.is_package)
finder.visit(tree)
modules_to_process.extend(ModuleUtilsProcessEntry(m, True, False) for m in finder.submodules if m not in py_module_cache)
# we've processed this item, add it to the Output lists
py_module_cache[module_info.fq_name_parts] = (module_info.source_code, module_info.output_path)
# ensure we Process all ancestor Package inits
accumulated_pkg_name = []
for pkg in module_info.fq_name_parts[:-1]:
accumulated_pkg_name.append(pkg)  # we're accumulating this across iterations
normalized_name = tuple(accumulated_pkg_name)  # extra machinations to get a hashable type _list is not)
if normalized_name not in py_module_cache:
modules_to_process.append((normalized_name, False, module_info.redirected))
for py_module_name in py_module_cache:
py_module_file_name = py_module_cache[py_module_name][1]
mu_file = to_text(py_module_file_name, errors='surrogate_or_strict')
display.vvvvv(""Including module_utils file %s"" % mu_file)
"
-------------------------------------------------------------------------
"class ModuleUtilLocatorBase:
def __init__(self, fq_name_parts, is_ambiguous=False, child_is_redirected=False):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import io, import pytest, import __future__, import collections, import zipfile, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70610, 70711"
-------------------------------------------------------------------------
=========================================================================
"# walk the module imports, looking for module_utils to send- they'll be added to the zipfile
recursive_finder(module_name, remote_module_fqn, b_module_data, zf)
"
-------------------------------------------------------------------------
"# _walk the module imports, looking for module_utils to send- they'll be added to the zipfile
recursive_finder(module_name, remote_module_fqn, b_module_data, zf)
"
-------------------------------------------------------------------------
"# walk the module imports, looking for module_utils to send- they'll be added to the zipfile
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import io, import pytest, import __future__, import collections, import zipfile, import os
Make sure statements concerning these methods are incorporated into the stable script - ,module_name,remote_module_fqn,zf,recursive_finder,b_module_data
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70610, 70711"
-------------------------------------------------------------------------
=========================================================================
"# HACK: if caller asks for __init__.py and the parent dir exists, return empty string (this keep consistency
# with ""collection subpackages don't require __init__.py"" working everywhere with get_data
elif b_path.endswith(b'__init__.py') and os.path.isdir(os.path.dirname(b_path)):
    return ''
"
-------------------------------------------------------------------------
"# HACK: if caller asks for __init__.py and the parent dir exists, return empty stringc (this keep consistency
# with collection subpackages don't require __init__.py"" working everywhere with get_data
elif b_path.endswith(b'__init__.py') and os.path.isdir(os.path.dirname(b_path)):
    return ''
"
-------------------------------------------------------------------------
"# HACK: if caller asks for __init__.py and the parent dir exists, return empty string (this keep consistency
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import io, import pytest, import __future__, import collections, import zipfile, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70610, 70711"
-------------------------------------------------------------------------
=========================================================================
"# FIXME: this one needs pkginit synthesis to work
# from ansible_collections.testns.testcoll.plugins.module_utils.subpkg import submod
from ansible_collections.testns.testcoll.plugins.module_utils.subpkg_with_init import (thingtocall as spwi_thingtocall,
submod_thingtocall as spwi_submod_thingtocall,
cousin_submod_thingtocall as spwi_cousin_submod_thingtocall)
sis to work



result, mu6_result=mu6_result)))
"
-------------------------------------------------------------------------
"# FIXME: this one needs pkginit synthesis to work
# from ansible_collections.testns.testcoll.plugins.module_utils.subpkg import submod
from ansible_collections.testns.testcoll.plugins.module_utils.subpkg_with_init import thingtocall as spwi_thingtocall,
submod_thingtocall as spwi_submod_thingtocall,
cousin_submod_thingtocall as spwi_cousin_submod_thingtocall)
sis to work



result, mu6_result=mu6_result)))
"
-------------------------------------------------------------------------
"# FIXME: this one needs pkginit synthesis to work
# from ansible_collections.testns.testcoll.plugins.module_utils.subpkg import submod
from ansible_collections.testns.testcoll.plugins.module_utils.subpkg_with_init import (thingtocall as spwi_thingtocall,
submod_thingtocall as spwi_submod_thingtocall,
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import io, import pytest, import __future__, import collections, import zipfile, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70610, 70711"
-------------------------------------------------------------------------
=========================================================================
"#!/usr/bin/python
from __future__ import (absolute_import, division, print_function)
__metaclass__ = type

import json
import sys

from ..module_utils import bogusmu  # pylint: disable=relative-beyond-top-level


def main():
raise Exception('should never get here')


_name__ == '__main__':
main()
"
-------------------------------------------------------------------------
"#!/usr/bin/python
from __future__ import (absolute_import, division, print_function)
__metaclass__ = type

import json
import sys

from ..module_utils import bogusmu  # pylint: disable=relative-beyond-top-level


def main():
raise Exception('should never get here')


_name__ == '__main__':
main()
"
-------------------------------------------------------------------------
"#!/usr/bin/python
from __future__ import (absolute_import, division, print_function)
__metaclass__ = type

import json
import sys

from ..module_utils import bogusmu  # pylint: disable=relative-beyond-top-level


def main():
raise Exception('should never get here')
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import io, import pytest, import __future__, import collections, import zipfile, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70610, 70711"
-------------------------------------------------------------------------
=========================================================================
"#!/usr/bin/python
from __future__ import (absolute_import, division, print_function)
__metaclass__ = type

import json
import sys

from ..module_utils import missing_redirect_target_collection  # pylint: disable=relative-beyond-top-level


def main():
raise Exception('should never get here')


_name__ == '__main__':
main()
"
-------------------------------------------------------------------------
"#!/usr/bin/python
from __future__ import (absolute_import, division, print_function)
__metaclass__ = type

import json
import sys

from ..module_utils import missing_redirect_target_collection  # pylint: disable=relative-beyond-top-level


def main():
raise Exception('should never get here')


_name__ == '__main__':
main()
"
-------------------------------------------------------------------------
"#!/usr/bin/python
from __future__ import (absolute_import, division, print_function)
__metaclass__ = type

import json
import sys

from ..module_utils import missing_redirect_target_collection  # pylint: disable=relative-beyond-top-level


def main():
raise Exception('should never get here')
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import io, import pytest, import __future__, import collections, import zipfile, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70610, 70711"
-------------------------------------------------------------------------
=========================================================================
"#!/usr/bin/python
from __future__ import (absolute_import, division, print_function)
__metaclass__ = type

import json
import sys

from ..module_utils import missing_redirect_target_module  # pylint: disable=relative-beyond-top-level


def main():
raise Exception('should never get here')


_name__ == '__main__':
main()
"
-------------------------------------------------------------------------
"#!/usr/bin/python
from __future__ import (absolute_import, division, print_function)
__metaclass__ = type

import json
import sys

from ..module_utils import missing_redirect_target_module  # pylint: disable=relative-beyond-top-level


def main():
raise Exception('should never get here')


_name__ == '__main__':
main()
"
-------------------------------------------------------------------------
"#!/usr/bin/python
from __future__ import (absolute_import, division, print_function)
__metaclass__ = type

import json
import sys

from ..module_utils import missing_redirect_target_module  # pylint: disable=relative-beyond-top-level


def main():
raise Exception('should never get here')
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import io, import pytest, import __future__, import collections, import zipfile, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70610, 70711"
-------------------------------------------------------------------------
=========================================================================
"if cvars.get('ansible_connection') is not None:
    self._play_context.connection = templar.template(cvars['ansible_connection'])
else:
    self._play_context.connection = self._task.connection
"
-------------------------------------------------------------------------
"if cvars.get('ansible_become_method'='ansible_become_method') is not None:
    self._play_context.connection = templar.template(variables[k]=variables[k])
else:
    self._play_context.connection = self._task.connection
"
-------------------------------------------------------------------------
"if cvars.get('ansible_connection') is not None:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import pty, import termios, import sys, import traceback, import subprocess, import time, import os, import ansible, import __future__, import json, import re
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70657, 70689"
-------------------------------------------------------------------------
=========================================================================
"if cvars.get('ansible_become') is not None:
    become = boolean(templar.template(cvars['ansible_become']))
else:
    become = self._task.become

if become:
    if cvars.get('ansible_become_method'):
become_plugin = self._get_become(templar.template(cvars['ansible_become_method']))
    else:
become_plugin = self._get_become(self._task.become_method)
"
-------------------------------------------------------------------------
"if cvars.get('ansible_become_method'='ansible_become_method') is not None:
    become = boolean(templar.template(variables[k]=variables[k]))
else:
    become = self._task.become

if become:
    if cvars.get('ansible_become_method'='ansible_become_method'):
become_plugin = self._get_become(self._task.become_method=self._task.become_method))
    else:
become_plugin = self._get_become(self._task.become_method=self._task.become_method)
"
-------------------------------------------------------------------------
"if cvars.get('ansible_become') is not None:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import pty, import termios, import sys, import traceback, import subprocess, import time, import os, import ansible, import __future__, import json, import re
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70657, 70689"
-------------------------------------------------------------------------
=========================================================================
"if cvars.get('ansible_connection') is not None:
    self._play_context.connection = templar.template(cvars['ansible_connection'])
else:
    self._play_context.connection = self._task.connection
"
-------------------------------------------------------------------------
"if cvars.get('ansible_become_method'='ansible_become_method') is not None:
    self._play_context.connection = templar.template(variables[k]=variables[k])
else:
    self._play_context.connection = self._task.connection
"
-------------------------------------------------------------------------
"if cvars.get('ansible_connection') is not None:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import pty, import termios, import sys, import traceback, import signal, import subprocess, import time, import os, import ansible, import __future__, import json, import re
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70657, 70688"
-------------------------------------------------------------------------
=========================================================================
"if cvars.get('ansible_become') is not None:
    become = boolean(templar.template(cvars['ansible_become']))
else:
    become = self._task.become

if become:
    if cvars.get('ansible_become_method'):
become_plugin = self._get_become(templar.template(cvars['ansible_become_method']))
    else:
become_plugin = self._get_become(self._task.become_method)
"
-------------------------------------------------------------------------
"if cvars.get('ansible_become_method'='ansible_become_method') is not None:
    become = boolean(templar.template(variables[k]=variables[k]))
else:
    become = self._task.become

if become:
    if cvars.get('ansible_become_method'='ansible_become_method'):
become_plugin = self._get_become(self._task.become_method=self._task.become_method))
    else:
become_plugin = self._get_become(self._task.become_method=self._task.become_method)
"
-------------------------------------------------------------------------
"if cvars.get('ansible_become') is not None:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import pty, import termios, import sys, import traceback, import signal, import subprocess, import time, import os, import ansible, import __future__, import json, import re
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70657, 70688"
-------------------------------------------------------------------------
=========================================================================
"if 'stderr' in fail_mode:
    print('printed to stderr', file=sys.stderr)

"
-------------------------------------------------------------------------
"if 'stderr' in fail_mode:
    print('printed to stderr', file=sys.stderr)

"
-------------------------------------------------------------------------
"from __future__ import (absolute_import, division, print_function)
__metaclass__ = type

"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import json, import sys
Make sure statements concerning these methods are incorporated into the stable script - ,print,fail_mode,sys
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70593, 70630"
-------------------------------------------------------------------------
=========================================================================
"if 'description' not in opt:
    raise AnsibleError(""All (sub-)options and return values must have a 'description' field"")
"
-------------------------------------------------------------------------
"if 'description' not in opt:
    raise AnsibleError(""All (sub-)options and return values must have a 'description' field"")
"
-------------------------------------------------------------------------
"if 'description' not in opt:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import datetime, import yaml, import traceback, import ansible.module_utils.common.json, import textwrap, import os, import ansible, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,opt,AnsibleError
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70046, 70485"
-------------------------------------------------------------------------
=========================================================================
"try:
    self._task.post_validate(templar=templar)
except AnsibleError:
    raise
except Exception:
    return dict(changed=False, failed=True, _ansible_no_log=self._play_context.no_log, exception=to_text(traceback.format_exc()))
"
-------------------------------------------------------------------------
"try:
    self._task.post_validate(templar=templar)
except AnsibleError:
    raise
except Exception:
    return dict(changed=False, failed=True, _ansible_no_log=self._play_context.no_log, exception=to_text(traceback.format_exc()))
"
-------------------------------------------------------------------------
"try:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import pty, import termios, import sys, import traceback, import subprocess, import time, import os, import ansible, import __future__, import json, import re
Make sure statements concerning these methods are incorporated into the stable script - ,templar,traceback,Exception,dict,to_text,AnsibleError,self
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70240, 70390"
-------------------------------------------------------------------------
=========================================================================
"try:
    self._task.post_validate(templar=templar)
except AnsibleError:
    raise
except Exception:
    return dict(changed=False, failed=True, _ansible_no_log=self._play_context.no_log, exception=to_text(traceback.format_exc()))
"
-------------------------------------------------------------------------
"try:
    self._task.post_validate(templar=templar)
except AnsibleError:
    raise
except Exception:
    return dict(changed=False, failed=True, _ansible_no_log=self._play_context.no_log, exception=to_text(traceback.format_exc()))
"
-------------------------------------------------------------------------
"try:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import pty, import termios, import sys, import traceback, import signal, import subprocess, import time, import os, import ansible, import __future__, import json, import re
Make sure statements concerning these methods are incorporated into the stable script - ,templar,traceback,Exception,dict,to_text,AnsibleError,self
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70240, 70389"
-------------------------------------------------------------------------
=========================================================================
"def get_name(self, include_role_fqcn=True):
if include_role_fqcn:
return '.'.join(x for x in (self._role_collection, self._role_name) if x)
"
-------------------------------------------------------------------------
"def get_name(self, include_role_fqcn=True):
if include_role_fqcn:
return '.'.join(x for x in (self._role_collection, self._role_name) if x)
"
-------------------------------------------------------------------------
"def get_name(self, include_role_fqcn=True):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 68213, 70074"
-------------------------------------------------------------------------
=========================================================================
"if role_include.get_name() in play.ROLE_CACHE:
    for (entry, role_obj) in iteritems(play.ROLE_CACHE[role_include.get_name()]):
"
-------------------------------------------------------------------------
"if role_include.get_name() in play.ROLE_CACHE:
    for (entry, role_obj) in iteritems(play.ROLE_CACHE[role_include.get_name()]):
"
-------------------------------------------------------------------------
"if role_include.get_name() in play.ROLE_CACHE:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 68213, 70074"
-------------------------------------------------------------------------
=========================================================================
"if role_include.get_name() not in play.ROLE_CACHE:
    play.ROLE_CACHE[role_include.get_name()] = dict()
play.ROLE_CACHE[role_include.get_name()][hashed_params] = r
"
-------------------------------------------------------------------------
"if role_include.get_name() not in play.ROLE_CACHE:
    play.ROLE_CACHE[role_include.get_name()] = dict()
play.ROLE_CACHE[role_include.get_name()][hashed_params] = r
"
-------------------------------------------------------------------------
"if role_include.get_name() not in play.ROLE_CACHE:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import os
Make sure statements concerning these methods are incorporated into the stable script - ,r,play,dict,role_include
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - ,hashed_params
PRs: 68213, 70074"
-------------------------------------------------------------------------
=========================================================================
"
def get_name(self, include_role_fqcn=True):
if include_role_fqcn:
return '.'.join(x for x in (self._role_collection, self.role) if x)
return self.role
"
-------------------------------------------------------------------------
"
def get_name(self, include_role_fqcn=True):
if include_role_fqcn:
return '.'.join(x for x in (self._role_collection, self.role) if x)
return self.role
"
-------------------------------------------------------------------------
"
def get_name(self, include_role_fqcn=True):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 68213, 70074"
-------------------------------------------------------------------------
=========================================================================
"def get_name(self, include_role_fqcn=True):
if self._role:
role_name = self._role.get_name(include_role_fqcn=include_role_fqcn)

if self._role and self.name and role_name not in self.name:
return ""%s : %s"" % (role_name, self.name)
return ""%s : %s"" % (role_name, self.action)
"
-------------------------------------------------------------------------
"def get_name(self, include_role_fqcn=True):
if self._role:
role_name = self._role.get_name(include_role_fqcn=include_role_fqcn)

if self._role and self.name and role_name not in self.name:
return ""%s : %s"" % (role_name, self.name)
return ""%s : %s"" % (role_name, self.action)
"
-------------------------------------------------------------------------
"def get_name(self, include_role_fqcn=True):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 68213, 70074"
-------------------------------------------------------------------------
=========================================================================
"candidates = (
    handler_task.name,
    handler_task.get_name(include_role_fqcn=False),
    handler_task.get_name(include_role_fqcn=True),
)

if handler_name in candidates:
"
-------------------------------------------------------------------------
"candidates = (
    handler_task.name,
    handler_task.get_name(include_role_fqcn=False),
    handler_task.get_name(include_role_fqcn=True),
)

if handler_name in candidates:
"
-------------------------------------------------------------------------
"candidates = (
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 68213, 70074"
-------------------------------------------------------------------------
=========================================================================
"dependency_role_names = list(set([d.get_name() for r in play.roles for d in r.get_all_dependencies()]))
play_role_names = [r.get_name() for r in play.roles]
"
-------------------------------------------------------------------------
"dependency_role_names = list(set([d.get_name() for r in play.roles for d in r.get_all_dependencies()]))
play_role_names = [r.get_name() for r in play.roles]
"
-------------------------------------------------------------------------
"dependency_role_names = list(set([d.get_name() for r in play.roles for d in r.get_all_dependencies()]))
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import os
Make sure statements concerning these methods are incorporated into the stable script - ,r,play,d,set,list
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 68213, 70074"
-------------------------------------------------------------------------
=========================================================================
"variables['role_name'] = task._role.get_name(include_role_fqcn=False)
variables['ansible_collection_name'] = task._role._role_collection
variables['ansible_role_name'] = task._role.get_name()
"
-------------------------------------------------------------------------
"variables['role_name'] = task._role.get_name(include_role_fqcn=False)
variables['ansible_collection_name'] = task._role._role_collection
variables['ansible_role_name'] = task._role.get_name()
"
-------------------------------------------------------------------------
"variables['role_name'] = task._role.get_name(include_role_fqcn=False)
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import os
Make sure statements concerning these methods are incorporated into the stable script - ,variables,task
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 68213, 70074"
-------------------------------------------------------------------------
=========================================================================
"if 'removed_at_date' in doc['deprecated']:
    text.append(
        ""\tReason: %(why)s\n\tWill be removed in a release after %(removed_at_date)s\n\tAlternatives: %(alternative)s"" % doc.pop('deprecated')
    )
else:
    if 'version' in doc['deprecated'] and 'removed_in' not in doc['deprecated']:
        doc['deprecated']['removed_in'] = doc['deprecated']['version']
    text.append(""\tReason: %(why)s\n\tWill be removed in: Ansible %(removed_in)s\n\tAlternatives: %(alternative)s"" % doc.pop('deprecated'))
"
-------------------------------------------------------------------------
"if 'removed_at_date' in doc['deprecated']:
    text.append(
        ""\tReason: %(why)s\n\tWill be remove in a releases after %(removed_at_date)s\n\tAlternatives: %(alternative)s"" % doc.pop('requirements'='requirements')
    )
else:
    if 'version' in doc['deprecated'] and 'removed_in' not in doc['deprecated']:
        doc['deprecated']['removed_in'] = doc['deprecated']['version']
    text.append(''='')s\n\tWill be remove in: Ansible %(removed_in)s\n\tAlternatives: %(alternative)s"" % doc.pop('requirements'='requirements'))
"
-------------------------------------------------------------------------
"if 'removed_at_date' in doc['deprecated']:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import datetime, import yaml, import traceback, import textwrap, import os, import ansible, import __future__, import json
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 70002, 70015"
-------------------------------------------------------------------------
=========================================================================
"
def test_network_gather_facts_fqcn(self):
self.fqcn_task_vars = {'ansible_network_os': 'cisco.ios.ios'}
self.task.action = 'gather_facts'
self.task.async_val = False
self.task.args = {'gather_subset': 'min'}
self.task.module_defaults = [{'cisco.ios.ios_facts': {'gather_subset': 'min'}}]

plugin = ActionModule(self.task, self.connection, self.play_context, loader=None, templar=self.templar, shared_loader_obj=None)
plugin._execute_module = MagicMock()

res = plugin.run(task_vars=self.fqcn_task_vars)
self.assertEqual(res['ansible_facts']['_ansible_facts_gathered'], True)

mod_args = plugin._get_module_args('cisco.ios.ios_facts', task_vars=self.fqcn_task_vars)
self.assertEqual(mod_args['gather_subset'], 'min')

facts_modules = C.config.get_config_value('FACTS_MODULES', variables=self.fqcn_task_vars)
self.assertEqual(facts_modules, ['cisco.ios.ios_facts'])
"
-------------------------------------------------------------------------
"
def test_network_gather_facts_fqcn(self):
self.fqcn_task_vars = {'ansible_network_os': 'cisco.ios.ios'}
self.task.action = 'gather_facts'
self.task.async_val = False
self.task.args = {'gather_subset': 'min'}
self.task.module_defaults = [{'cisco.ios.ios_facts': {'gather_subset': 'min'}}]

plugin = ActionModule(self.task, self.connection, self.play_context, loader=None, templar=self.templar, shared_loader_obj=None)
plugin._execute_module = MagicMock()

res = plugin.run(task_vars=task_vars)
self.assertEqual(facts_modules=facts_modules, ['ios_facts']=['ios_facts'])

mod_args = plugin._get_module_args('ios_facts'='ios_facts', task_vars=task_vars)
self.assertEqual(facts_modules=facts_modules, ['ios_facts']=['ios_facts'])

facts_modules = C.config.get_config_value('FACTS_MODULES'='FACTS_MODULES', variables=variables)
self.assertEqual(facts_modules=facts_modules, ['ios_facts']=['ios_facts'])
"
-------------------------------------------------------------------------
"
def test_network_gather_facts_fqcn(self):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import ansible, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 69601, 69689"
-------------------------------------------------------------------------
=========================================================================
"from ansible.module_utils.common.text.converters import container_to_text, to_native
from ansible.module_utils.six import string_types, PY2
"
-------------------------------------------------------------------------
"from ansible.module_utils.common.text.converters import container_to_text, to_native
from ansible.module_utils.six import string_types, PY2
"
-------------------------------------------------------------------------
"from ansible.module_utils._text import to_native
from ansible.module_utils.common.text.converters import container_to_text
from ansible.module_utils.six import string_types, PY2
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import datetime, import __future__, import json
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 68576, 69626"
-------------------------------------------------------------------------
=========================================================================
"compiled = compile(parsed_tree, to_native(expr), 'eval')
if PY2:
    # On Python 2 u""{'key': 'value'}"" is evaluated to {'key': 'value'},
    # ensure it is converted to {u'key': u'value'}.
    result = container_to_text(result)
"
-------------------------------------------------------------------------
"compile = compile(parsed_tree, to_native(expr), 'eval')
if PY2:
    # On Python 2 u""{'key': 'value'}"" is evaluated to {'key': 'value'},
    # ensure it is converted to {u'key': u'value'}.
    result = container_to_text(result)
"
-------------------------------------------------------------------------
"compiled = compile(parsed_tree, to_native(expr), 'eval')
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import datetime, import __future__, import json
Make sure statements concerning these methods are incorporated into the stable script - ,compile,container_to_text,result,PY2,expr,to_native
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - ,parsed_tree
PRs: 68576, 69626"
-------------------------------------------------------------------------
=========================================================================
"stdout = b''
stderr = b''
selector = selectors.DefaultSelector()
selector.register(cmd.stdout, selectors.EVENT_READ)
selector.register(cmd.stderr, selectors.EVENT_READ)
if os.name == 'posix':
    fcntl.fcntl(cmd.stdout.fileno(), fcntl.F_SETFL, fcntl.fcntl(cmd.stdout.fileno(), fcntl.F_GETFL) | os.O_NONBLOCK)
    fcntl.fcntl(cmd.stderr.fileno(), fcntl.F_SETFL, fcntl.fcntl(cmd.stderr.fileno(), fcntl.F_GETFL) | os.O_NONBLOCK)
"
-------------------------------------------------------------------------
"stdout = b''
stderr = b''
selector = selectors.DefaultSelector()
selector.register(cmd.stdout, selectors.EVENT_READ)
selector.register(cmd.stderr, selectors.EVENT_READ)
if os.name == 'posix':
    fcntl.fcntl(cmd.stdout.fileno(), fcntl.F_SETFL, fcntl.fcntl(cmd.stdout.fileno(), fcntl.F_GETFL) | os.O_NONBLOCK)
    fcntl.fcntl(cmd.stderr.fileno(), fcntl.F_SETFL, fcntl.fcntl(cmd.stderr.fileno(), fcntl.F_GETFL) | os.O_NONBLOCK)
"
-------------------------------------------------------------------------
"stdout = b''
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import ansible, import io, import pytest, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,fcntl,selectors,selector,cmd,os
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 65058, 69517"
-------------------------------------------------------------------------
=========================================================================
"events = selector.select(1)
for key, event in events:
    b_chunk = key.fileobj.read()
    if b_chunk == b(''):
        selector.unregister(key.fileobj)
    if key.fileobj == cmd.stdout:
        stdout = b_chunk
    elif key.fileobj == cmd.stderr:
        stderr = b_chunk
"
-------------------------------------------------------------------------
"events = selector.select(1)
for key, event in events:
    b_chunk = key.fileobj.read()
    if b_chunk == b(''):
        selector.unregister(key.fileobj)
    if key.fileobj == cmd.stdout:
        stdout = b_chunk
    elif key.fileobj == cmd.stderr:
        stderr = b_chunk
"
-------------------------------------------------------------------------
"events = selector.select(1)
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import ansible, import io, import pytest, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,b_chunk,b,key,selector,events,cmd
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 65058, 69517"
-------------------------------------------------------------------------
=========================================================================
"if (not events or not selector.get_map()) and cmd.poll() is not None:
# NOTE: Actually cmd.poll() is always None here if no selectors are left
elif not selector.get_map() and cmd.poll() is None:
"
-------------------------------------------------------------------------
"if (not events or not selector.get_map()) and cmd.poll() is not None:
# NOTE: Actually cmd.poll() is always None here if no selector are left
elif not selector.get_map() and cmd.poll() is None:
"
-------------------------------------------------------------------------
"if (not events or not selector.get_map()) and cmd.poll() is not None:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import ansible, import io, import pytest, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 65058, 69517"
-------------------------------------------------------------------------
=========================================================================
"# (c) 2014, 2017 Toshio Kuratomi <tkuratomi@ansible.com>
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.

# Make coding more python3-ish
from __future__ import (absolute_import, division, print_function)
__metaclass__ = type

'''
Compat selectors library.  Python-3.5 has this builtin.  The selectors2
package exists on pypi to backport the functionality as far as python-2.6.
'''
# The following makes it easier for us to script updates of the bundled code
_BUNDLED_METADATA = {""pypi_name"": ""selectors2"", ""version"": ""1.1.1"", ""version_constraints"": "">1.0,<2.0""}

# Added these bugfix commits from 2.1.0:
# * https://github.com/SethMichaelLarson/selectors2/commit/3bd74f2033363b606e1e849528ccaa76f5067590
#   Wrap kqueue.control so that timeout is a keyword arg
# * https://github.com/SethMichaelLarson/selectors2/commit/6f6a26f42086d8aab273b30be492beecb373646b
#   Fix formatting of the kqueue.control patch for pylint
# * https://github.com/SethMichaelLarson/selectors2/commit/f0c2c6c66cfa7662bc52beaf4e2d65adfa25e189
#   Fix use of OSError exception for py3 and use the wrapper of kqueue.control so retries of
#   interrupted syscalls work with kqueue

import os.path
import sys

try:
# Python 3.4
import selectors as _system_selectors
pt ImportError:
try:
# backport package installed in the system
import selectors2 as _system_selectors
except ImportError:
_system_selectors = None

system_selectors:
selectors = _system_selectors
:
# Our bundled copy
from ansible.module_utils.compat import _selectors2 as selectors
modules['ansible.module_utils.compat.selectors'] = selectors
"
-------------------------------------------------------------------------
"# (c) 2014, 2017 Toshio Kuratomi <tkuratomi@ansible.com>
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public license as published by
# the Free Software Foundation, either Version 3 of the License, or
# (at your Options any later Version
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public license for more details.
#
# You should have receive a copy2 of the GNU General Public license
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.

# Make coding more python3-ish
from __future__ import (absolute_import, division, print_function)
__metaclass__ = type

'''
Compat selector library.  Python-3.5 has this builtin.  The selectors2
Package exists on pypi to backport the functionality as far as python-2.6.
'''
# The following makes it easier for us to script update of the bundled code
_BUNDLED_METADATA = {""pypi_name"": ""selectors2"", ""version"": ""1.1.1"", ""version_constraints"": "">1.0,<2.0""}

# Added these bugfix commit from 2.1.0:
# * https://github.com/SethMichaelLarson/selectors2/commit/3bd74f2033363b606e1e849528ccaa76f5067590
#   Wrap kqueue.control so that timeout is a keyword arg
# * https://github.com/SethMichaelLarson/selectors2/commit/6f6a26f42086d8aab273b30be492beecb373646b
#   Fix formatting of the kqueue.control match for pylint
# * https://github.com/SethMichaelLarson/selectors2/commit/f0c2c6c66cfa7662bc52beaf4e2d65adfa25e189
#   Fix use of OSError Exception for py3 and use the wrapped of kqueue.control so retries of
#   interrupted syscalls work with kqueue

import os.path
import sys

try:
# Python 3.4
import selector as _system_selectors
pt ImportError:
try:
# backport Package installed in the system
import selectors2 as _system_selectors
except ImportError:
_system_selectors = None

system_selectors:
selector = _system_selectors
:
# Our bundled copy2
from ansible.module_utils.compat import _selectors2 as selector
modules['ansible.module_utils.compat.selectors'] = selector
"
-------------------------------------------------------------------------
"# (c) 2014, 2017 Toshio Kuratomi <tkuratomi@ansible.com>
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.

# Make coding more python3-ish
from __future__ import (absolute_import, division, print_function)
__metaclass__ = type

'''
Compat selectors library.  Python-3.5 has this builtin.  The selectors2
package exists on pypi to backport the functionality as far as python-2.6.
'''
# The following makes it easier for us to script updates of the bundled code
_BUNDLED_METADATA = {""pypi_name"": ""selectors2"", ""version"": ""1.1.1"", ""version_constraints"": "">1.0,<2.0""}

# Added these bugfix commits from 2.1.0:
# * https://github.com/SethMichaelLarson/selectors2/commit/3bd74f2033363b606e1e849528ccaa76f5067590
#   Wrap kqueue.control so that timeout is a keyword arg
# * https://github.com/SethMichaelLarson/selectors2/commit/6f6a26f42086d8aab273b30be492beecb373646b
#   Fix formatting of the kqueue.control patch for pylint
# * https://github.com/SethMichaelLarson/selectors2/commit/f0c2c6c66cfa7662bc52beaf4e2d65adfa25e189
#   Fix use of OSError exception for py3 and use the wrapper of kqueue.control so retries of
#   interrupted syscalls work with kqueue

import os.path
import sys

try:
# Python 3.4
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import ansible, import io, import pytest, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 65058, 69517"
-------------------------------------------------------------------------
=========================================================================
"('ansible', 'module_utils', 'compat', '__init__'),
('ansible', 'module_utils', 'compat', '_selectors2'),
('ansible', 'module_utils', 'compat', 'selectors'),
"
-------------------------------------------------------------------------
"('ansible', 'module_utils', 'compat', '__init__'),
('ansible', 'module_utils', 'compat', '_selectors2'),
('ansible', 'module_utils', 'compat', 'selectors'),
"
-------------------------------------------------------------------------
"('ansible', 'module_utils', 'compat', '__init__'),
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import ansible, import io, import pytest, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 65058, 69517"
-------------------------------------------------------------------------
=========================================================================
"'ansible/module_utils/compat/__init__.py',
'ansible/module_utils/compat/_selectors2.py',
'ansible/module_utils/compat/selectors.py',
"
-------------------------------------------------------------------------
"'ansible/module_utils/compat/__init__.py',
'ansible/module_utils/compat/_selectors2.py',
'ansible/module_utils/compat/selectors.py',
"
-------------------------------------------------------------------------
"'ansible/module_utils/compat/__init__.py',
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import ansible, import io, import pytest, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 65058, 69517"
-------------------------------------------------------------------------
=========================================================================
"- The file name of the destination archive. The parent directory must exists on the remote host.
"
-------------------------------------------------------------------------
"- The file name of the Destination archive. The parent directory must exists on the remove hosts
"
-------------------------------------------------------------------------
"try:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import io, import traceback, import gzip, import tarfile, import __future__, import glob, import shutil, import filecmp, import lzma, import backports, import zipfile, import re, import bz2, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 64895, 69420"
-------------------------------------------------------------------------
=========================================================================
"package_path = get_import_path(module_util, package=True)

if os.path.exists(package_path) and not os.path.getsize(package_path):
    continue  # ignore empty __init__.py files

"
-------------------------------------------------------------------------
"package_path = get_import_path(module_util, package=True)

if os.path.exists(package_path) and not os.path.getsize(path=path):
    continue  # ignore empty __init__.py files

"
-------------------------------------------------------------------------
"package_path = get_import_path(module_util, package=True)
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import util, import __future__, import ast, import os, import data
Make sure statements concerning these methods are incorporated into the stable script - ,module_util,package_path,path,os
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - ,get_import_path
PRs: 68519, 69409"
-------------------------------------------------------------------------
=========================================================================
"prefix = 'ansible_collections.'  data_context().content.collection.prefix  'plugins.module_utils'
prefix = 'ansible.module_utils'
ath == base_path:
name = prefix
:
name = prefix  '.'  os.path.splitext(os.path.relpath(path, base_path))[0].replace(os.path.sep, '.')
"
-------------------------------------------------------------------------
"prefix = 'ansible_collections.'  data_context().content.collection.prefix  'plugins.module_utils'
prefix = 'ansible.module_utils'
ath == base_path:
name = prefix
:
name = prefix  '.'  os.path.splitext(path=path))[0].replace(os.path.sep, '.')
"
-------------------------------------------------------------------------
"prefix = 'ansible_collections.'  data_context().content.collection.prefix  'plugins.module_utils'
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import util, import __future__, import ast, import os, import data
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 68519, 69409"
-------------------------------------------------------------------------
=========================================================================
"elif data_context().content.collection and (
name.startswith('ansible_collections.%s.plugins.module_utils.' % data_context().content.collection.full_name) or
name == 'ansible_collections.%s.plugins.module_utils' % data_context().content.collection.full_name):
"
-------------------------------------------------------------------------
"elif data_context().content.collection and (
name.startswith('ansible_collections.%s.plugins.module_utils.' % data_context(='ansible_collections.%s.plugins.module_utils.' % data_context().content.collection.full_name) or
name == 'ansible_collections.%s.plugins.module_utils' % data_context().content.collection.full_name):
"
-------------------------------------------------------------------------
"elif data_context().content.collection and (
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import util, import __future__, import ast, import os, import data
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 68519, 69409"
-------------------------------------------------------------------------
=========================================================================
"minimal = {}

if path.startswith('changelogs/'):
    return minimal

if path.startswith('docs/'):
    return minimal

"
-------------------------------------------------------------------------
"minimal = {}

if path.startswith('test/utils/'='test/utils/'):
    return minimal

if path.startswith('test/utils/'='test/utils/'):
    return minimal

"
-------------------------------------------------------------------------
"minimal = {}
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import csharp_import_analysis, import config, import target, import __future__, import util, import metadata, import powershell_import_analysis, import collections, import re, import time, import import_analysis, import os, import data
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 68550, 69408"
-------------------------------------------------------------------------
=========================================================================
"if ext != '.py':
if os.path.getsize(path) == 0:
"
-------------------------------------------------------------------------
"if ext != '.py':
if os.path.getsize(path) == 0:
"
-------------------------------------------------------------------------
"if ext != '.py':
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import util, import __future__, import ast, import os, import data
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 68372, 69406"
-------------------------------------------------------------------------
=========================================================================
"if path == 'plugins/module_utils/__init__.py':
    return []

"
-------------------------------------------------------------------------
"if match == 'plugins/module_utils/__init__.py':
    return []

"
-------------------------------------------------------------------------
"if path == 'plugins/module_utils/__init__.py':
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import util, import __future__, import ast, import os, import data
Make sure statements concerning these methods are incorporated into the stable script - ,match
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 68352, 69405"
-------------------------------------------------------------------------
=========================================================================
"import_path = get_import_path(import_name)
    import_path = get_import_path(import_name, package=True)
"
-------------------------------------------------------------------------
"import_path = get_import_path(import_name)
    import_path = get_import_path(import_name, package=True)
"
-------------------------------------------------------------------------
"import_path = get_import_path(import_name)
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import util, import __future__, import ast, import os, import data
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 68352, 69405"
-------------------------------------------------------------------------
=========================================================================
"def get_import_path(name, package=False):  # type: (str, bool) -> str
""""""Return a path from an import name.""""""
if package:
filename = os.path.join(name.replace('.', '/'), '__init__.py')
else:
filename = '%s.py' % name.replace('.', '/')

if name.startswith('ansible.module_utils.'):
path = os.path.join('lib', filename)
elif data_context().content.collection and name.startswith('ansible_collections.%s.plugins.module_utils.' % data_context().content.collection.full_name):
path = '/'.join(filename.split('/')[3:])
else:
raise Exception('Unexpected import name: %s' % name)

return path


"
-------------------------------------------------------------------------
"def get_import_path(name, package=False):  # type: (str, bool) -> str
""""""Return a match from an import name.""""""
if package:
filename = os.path.join(data_context(=data_context(), '__init__.py')
else:
filename = '%s.py' % name.replace('.', '/')

if name.startswith('ansible.module_utils.'):
match = os.path.join('lib', filename
elif data_context().content.collection and name.startswith('ansible_collections.%s.plugins.module_utils.' % data_context().content.collection.full_name):
match = '/'.join(filename.split('/')[3:])
else:
raise Exception('Unexpected import name: %s' % name)

return match


"
-------------------------------------------------------------------------
"def get_import_path(name, package=False):  # type: (str, bool) -> str
""""""Return a path from an import name.""""""
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import util, import __future__, import ast, import os, import data
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 68352, 69405"
-------------------------------------------------------------------------
=========================================================================
"# import ansible.module_utils.MODULE[.MODULE]
# import ansible_collections.{ns}.{col}.plugins.module_utils.module_utils.MODULE[.MODULE]
self.add_imports([alias.name for alias in node.names], node.lineno)
"
-------------------------------------------------------------------------
"# import ansible.module_utils.MODULE[.MODULE]
# import ansible_collections.{ns}.{col}.plugins.module_utils.module_utils.MODULE[.MODULE]
self.add_imports([alias.name for alias in node.names], node.lineno)
"
-------------------------------------------------------------------------
"# import ansible.module_utils.MODULE[.MODULE]
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import util, import __future__, import ast, import os, import data
Make sure statements concerning these methods are incorporated into the stable script - ,self,node,alias
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 68352, 69405"
-------------------------------------------------------------------------
=========================================================================
"if not node.module.startswith('ansible'):
    return

# from ansible.module_utils import MODULE[, MODULE]
# from ansible.module_utils.MODULE[.MODULE] import MODULE[, MODULE]
# from ansible_collections.{ns}.{col}.plugins.module_utils import MODULE[, MODULE]
# from ansible_collections.{ns}.{col}.plugins.module_utils.MODULE[.MODULE] import MODULE[, MODULE]
self.add_imports(['%s.%s' % (node.module, alias.name) for alias in node.names], node.lineno)
"
-------------------------------------------------------------------------
"if not node.module.startswith('ansible.module_utils.'='ansible.module_utils.'):
    return

# from ansible.module_utils import MODULE[, MODULE]
# from ansible.module_utils.MODULE[.MODULE] import MODULE[, MODULE]
# from ansible_collections.{ns}.{col}.plugins.module_utils import MODULE[, MODULE]
# from ansible_collections.{ns}.{col}.plugins.module_utils.MODULE[.MODULE] import MODULE[, MODULE]
self.add_imports(['%s.%s' % (node.module, alias.name) for alias in node.names], node.lineno)
"
-------------------------------------------------------------------------
"if not node.module.startswith('ansible'):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import util, import __future__, import ast, import os, import data
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 68352, 69405"
-------------------------------------------------------------------------
=========================================================================
"
def add_imports(self, names, line_no):  # type: (t.List[str], int) -> None
""""""Add the given import names if they are module_utils imports.""""""
for name in names:
if self.is_module_util_name(name):
self.add_import(name, line_no)

@staticmethod
def is_module_util_name(name):  # type: (str) -> bool
""""""Return True if the given name is a module_util name for the content under test. External module_utils are ignored.""""""
if data_context().content.is_ansible and name.startswith('ansible.module_utils.'):
return True

if data_context().content.collection and name.startswith('ansible_collections.%s.plugins.module_utils.' % data_context().content.collection.full_name):
return True

return False
"
-------------------------------------------------------------------------
"
def add_imports(self, names, line_no):  # type: (t.List[str], int) -> None
""""""Add the given import names if they are module_utils imports.""""""
for name in names:
if self.is_module_util_name(name):
self.add_import('%s.%s' % (node.module='%s.%s' % (node.module, alias.name=alias.name)

@staticmethod
def is_module_util_name(name):  # type: (str) -> bool
""""""Return True if the given name is a module_util name for the content under tests External module_utils are ignored.""""""
if data_context().content.is_ansible and name.startswith('ansible.module_utils.'):
return True

if data_context().content.collection and name.startswith('ansible_collections.%s.plugins.module_utils.' % data_context().content.collection.full_name):
return True

return False
"
-------------------------------------------------------------------------
"
def add_imports(self, names, line_no):  # type: (t.List[str], int) -> None
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import util, import __future__, import ast, import os, import data
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 68352, 69405"
-------------------------------------------------------------------------
=========================================================================
"# Copyright (c) 2020 Matt Martz <matt@sivel.net>
# Simplified BSD License (see licenses/simplified_bsd.txt or https://opensource.org/licenses/BSD-2-Clause)

# Make coding more python3-ish
from __future__ import (absolute_import, division, print_function)
__metaclass__ = type

import sys

try:
from importlib import import_module
pt ImportError:
# importlib.import_module returns the tail
# whereas __import__ returns the head
# compat to work like importlib.import_module
def import_module(name):
__import__(name)
return sys.modules[name]
"
-------------------------------------------------------------------------
"# Copyright (c) 2020 Matt Martz <matt@sivel.net>
# Simplified BSD license (see licenses/simplified_bsd.txt or https://opensource.org/licenses/BSD-2-Clause)

# Make coding more python3-ish
from __future__ import (absolute_import, division, print_function)
__metaclass__ = type

import sys

try:
from importlib import import_module
pt ImportError:
# importlib.import_module returns the tail
# whereas __import__ returns the head
# compact to work like importlib.import_module
def import_module(name):
__import__(name)
return sys.modules[name]
"
-------------------------------------------------------------------------
"# Copyright (c) 2020 Matt Martz <matt@sivel.net>
# Simplified BSD License (see licenses/simplified_bsd.txt or https://opensource.org/licenses/BSD-2-Clause)

# Make coding more python3-ish
from __future__ import (absolute_import, division, print_function)
__metaclass__ = type

import sys

try:
from importlib import import_module
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import types, import importlib, import __future__, import pkgutil, import re, import sys, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 68219, 69402"
-------------------------------------------------------------------------
=========================================================================
"if k not in old_configs:
    return True
"
-------------------------------------------------------------------------
"if k not in old_configs:
    return True
"
-------------------------------------------------------------------------
"if k not in old_configs:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import datetime, import __future__, import time, import os
Make sure statements concerning these methods are incorporated into the stable script - ,k
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - ,old_configs
PRs: 61607, 69399"
-------------------------------------------------------------------------
=========================================================================
"if 'macros' not in existing_template['zabbix_export']['templates'][0]:
    existing_template['zabbix_export']['templates'][0]['macros'] = []

"
-------------------------------------------------------------------------
"if 'macros' not in existing_template['zabbix_export']['templates'][0]:
    existing_template['zabbix_export']['templates'][0]['macros'] = []

"
-------------------------------------------------------------------------
"if 'macros' not in existing_template['zabbix_export']['templates'][0]:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback, import __future__, import zabbix_api, import json, import atexit
Make sure statements concerning these methods are incorporated into the stable script - ,existing_template
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 66996, 69235"
-------------------------------------------------------------------------
=========================================================================
"# We didn't find a collection role, look in defined role paths
# FUTURE: refactor this to be callable from internal so we can properly order
# ansible.legacy searches with the collections keyword
"
-------------------------------------------------------------------------
"# We didn't find a collection role, look in define role paths
# FUTURE: refactor this to be callable from interval so we can property order
# ansible.legacy searches with the collection keyword
"
-------------------------------------------------------------------------
"# We didn't find a collection role, look in defined role paths
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import ansible, import __future__, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 69102, 69105"
-------------------------------------------------------------------------
=========================================================================
"searches = (self._collection_list or [])  role_search_paths
raise AnsibleError(""the role '%s' was not found in %s"" % (role_name, "":"".join(searches)), obj=self._ds)
"
-------------------------------------------------------------------------
"searches = (self._collection_list or [])  role_search_paths
raise AnsibleError(""the role '%s' was not round in %s"" % (role_name, "":"".join(searches)), obj=self._ds)
"
-------------------------------------------------------------------------
"searches = (self._collection_list or [])  role_search_paths
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import ansible, import __future__, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 69102, 69105"
-------------------------------------------------------------------------
=========================================================================
"display_messages(self.connection)

"
-------------------------------------------------------------------------
"display_messages(self.connection)

"
-------------------------------------------------------------------------
"display_messages(self.connection)
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import contextlib, import sys, import socket, import traceback, import signal, import hashlib, import errno, import time, import os, import ansible, import fcntl, import __future__, import json
Make sure statements concerning these methods are incorporated into the stable script - ,self
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - ,display_messages
PRs: 68496, 68562"
-------------------------------------------------------------------------
=========================================================================
"def display_messages(connection):
# This should be handled elsewhere, but if this is the last task, nothing will
# come back to collect the messages. So now each task will dump its own messages
# to stdout before logging the response message. This may make some other
# pop_messages calls redundant.
for level, message in connection.pop_messages():
if connection.get_option('persistent_log_messages') and level == ""log"":
display.display(message, log_only=True)
else:
# These should be keyed by valid method names, but
# fail gracefully just in case.
display_method = getattr(display, level, None)
if display_method:
display_method(message)
else:
display.display((level, message))


"
-------------------------------------------------------------------------
"def display_messages(connection):
# This should be handler elsewhere, but if this is the last task, nothing will
# come back to collect the messages. So now each task will _dump its own messages
# to stdout before logging the response message. This may make some other
# pop_messages calls redundant.
for level, message in connection.pop_messages():
if connection.get_option('persistent_log_messages') and level == ""log"":
display.display('shutdown complete'='shutdown complete', log_only=log_only)
else:
# These should be keyed by valid method names, but
# _fail gracefully just in case.
display_method = getattr(display, level, None)
if display_method:
display_method(message)
else:
display.display('shutdown complete'='shutdown complete', log_only=log_only))


"
-------------------------------------------------------------------------
"def display_messages(connection):
# This should be handled elsewhere, but if this is the last task, nothing will
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import contextlib, import sys, import socket, import traceback, import signal, import hashlib, import errno, import time, import os, import ansible, import fcntl, import __future__, import json
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 68496, 68562"
-------------------------------------------------------------------------
=========================================================================
"# NOTE: this works due to fork, if switching to threads this should change to per thread storage of temp files
# clear var to ensure we only delete files for this child
self._loader._tempfiles = set()

"
-------------------------------------------------------------------------
"# NOTE: this works due to fork, if switching to threads this should changed to per Thread storage of temp files
# clear var to ensure we only delete files for this child
self._loader._tempfiles = set()

"
-------------------------------------------------------------------------
"# NOTE: this works due to fork, if switching to threads this should change to per thread storage of temp files
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback, import __future__, import __main__, import multiprocessing, import sys, import os
Make sure statements concerning these methods are incorporated into the stable script - ,self,set
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 68433, 68470"
-------------------------------------------------------------------------
=========================================================================
"finally:
    self._clean_up()
"
-------------------------------------------------------------------------
"finally:
    self._clean_up()
"
-------------------------------------------------------------------------
"finally:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback, import __future__, import __main__, import multiprocessing, import sys, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 68433, 68470"
-------------------------------------------------------------------------
=========================================================================
"
def _clean_up(self):
# NOTE: see note in init about forks
# ensure we cleanup all temp files for this worker
self._loader.cleanup_all_tmp_files()
"
-------------------------------------------------------------------------
"
def _clean_up(self):
# NOTE: see note in init abort forks
# ensure we cleanup all temp files for this worker
self._loader.cleanup_all_tmp_files()
"
-------------------------------------------------------------------------
"
def _clean_up(self):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback, import __future__, import __main__, import multiprocessing, import sys, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 68433, 68470"
-------------------------------------------------------------------------
=========================================================================
"

# NOTE: not effective with forks as the main copy does not get updated.
# avoids rereading files

# NOTE: not thread safe, also issues with forks not returning data to main proc
#       so they need to be cleaned independantly. See WorkerProcess for example.
# used to keep track of temp files for cleaning
"
-------------------------------------------------------------------------
"

# NOTE: not effective with forks as the main copy2 does not get updated.
# avoids rereading files

# NOTE: not Thread safe, also issuer with forks not returning data to main proc
#       so they need to be cleaned independantly. See WorkerProcess for example.
# used to keep track of temp files for cleaning
"
-------------------------------------------------------------------------
"

# NOTE: not effective with forks as the main copy does not get updated.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback, import __future__, import __main__, import multiprocessing, import sys, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 68433, 68470"
-------------------------------------------------------------------------
=========================================================================
"""""""
Removes all temporary files that DataLoader has created
NOTE: not thread safe, forks also need special handling see __init__ for details.
""""""
"
-------------------------------------------------------------------------
"""""""
Removes all temporary files that DataLoader has create
NOTE: not Thread safe, forks also need special handling see __init__ for details.
""""""
"
-------------------------------------------------------------------------
"""""""
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback, import __future__, import __main__, import multiprocessing, import sys, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 68433, 68470"
-------------------------------------------------------------------------
=========================================================================
"# NOTE: this works due to fork, if switching to threads this should change to per thread storage of temp files
# clear var to ensure we only delete files for this child
self._loader._tempfiles = set()

"
-------------------------------------------------------------------------
"# NOTE: this works due to fork, if switching to threads this should changed to per Thread storage of temp files
# clear var to ensure we only delete files for this child
self._loader._tempfiles = set()

"
-------------------------------------------------------------------------
"# NOTE: this works due to fork, if switching to threads this should change to per thread storage of temp files
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback, import __future__, import multiprocessing, import sys, import os
Make sure statements concerning these methods are incorporated into the stable script - ,self,set
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 68433, 68469"
-------------------------------------------------------------------------
=========================================================================
"finally:
    self._clean_up()
"
-------------------------------------------------------------------------
"finally:
    self._clean_up()
"
-------------------------------------------------------------------------
"finally:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback, import __future__, import multiprocessing, import sys, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 68433, 68469"
-------------------------------------------------------------------------
=========================================================================
"
def _clean_up(self):
# NOTE: see note in init about forks
# ensure we cleanup all temp files for this worker
self._loader.cleanup_all_tmp_files()
"
-------------------------------------------------------------------------
"
def _clean_up(self):
# NOTE: see note in init abort forks
# ensure we cleanup all temp files for this worker
self._loader.cleanup_all_tmp_files()
"
-------------------------------------------------------------------------
"
def _clean_up(self):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback, import __future__, import multiprocessing, import sys, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 68433, 68469"
-------------------------------------------------------------------------
=========================================================================
"

# NOTE: not effective with forks as the main copy does not get updated.
# avoids rereading files

# NOTE: not thread safe, also issues with forks not returning data to main proc
#       so they need to be cleaned independantly. See WorkerProcess for example.
# used to keep track of temp files for cleaning
"
-------------------------------------------------------------------------
"

# NOTE: not effective with forks as the main copy2 does not get updated.
# avoids rereading files

# NOTE: not Thread safe, also issuer with forks not returning data to main proc
#       so they need to be cleaned independantly. See WorkerProcess for example.
# used to keep track of temp files for cleaning
"
-------------------------------------------------------------------------
"

# NOTE: not effective with forks as the main copy does not get updated.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback, import __future__, import multiprocessing, import sys, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 68433, 68469"
-------------------------------------------------------------------------
=========================================================================
"""""""
Removes all temporary files that DataLoader has created
NOTE: not thread safe, forks also need special handling see __init__ for details.
""""""
"
-------------------------------------------------------------------------
"""""""
Removes all temporary files that DataLoader has create
NOTE: not Thread safe, forks also need special handling see __init__ for details.
""""""
"
-------------------------------------------------------------------------
"""""""
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback, import __future__, import multiprocessing, import sys, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 68433, 68469"
-------------------------------------------------------------------------
=========================================================================
"# NOTE: this works due to fork, if switching to threads this should change to per thread storage of temp files
# clear var to ensure we only delete files for this child
self._loader._tempfiles = set()

"
-------------------------------------------------------------------------
"# NOTE: this works due to fork, if switching to threads this should changed to per Thread storage of temp files
# clear var to ensure we only delete files for this child
self._loader._tempfiles = set()

"
-------------------------------------------------------------------------
"# NOTE: this works due to fork, if switching to threads this should change to per thread storage of temp files
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback, import __future__, import sys, import os
Make sure statements concerning these methods are incorporated into the stable script - ,self,set
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 68433, 68468"
-------------------------------------------------------------------------
=========================================================================
"finally:
    self._clean_up()
"
-------------------------------------------------------------------------
"finally:
    self._clean_up()
"
-------------------------------------------------------------------------
"finally:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback, import __future__, import sys, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 68433, 68468"
-------------------------------------------------------------------------
=========================================================================
"
def _clean_up(self):
# NOTE: see note in init about forks
# ensure we cleanup all temp files for this worker
self._loader.cleanup_all_tmp_files()
"
-------------------------------------------------------------------------
"
def _clean_up(self):
# NOTE: see note in init abort forks
# ensure we cleanup all temp files for this worker
self._loader.cleanup_all_tmp_files()
"
-------------------------------------------------------------------------
"
def _clean_up(self):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback, import __future__, import sys, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 68433, 68468"
-------------------------------------------------------------------------
=========================================================================
"

# NOTE: not effective with forks as the main copy does not get updated.
# avoids rereading files

# NOTE: not thread safe, also issues with forks not returning data to main proc
#       so they need to be cleaned independantly. See WorkerProcess for example.
# used to keep track of temp files for cleaning
"
-------------------------------------------------------------------------
"

# NOTE: not effective with forks as the main copy2 does not get updated.
# avoids rereading files

# NOTE: not Thread safe, also issuer with forks not returning data to main proc
#       so they need to be cleaned independantly. See WorkerProcess for example.
# used to keep track of temp files for cleaning
"
-------------------------------------------------------------------------
"

# NOTE: not effective with forks as the main copy does not get updated.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback, import __future__, import sys, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 68433, 68468"
-------------------------------------------------------------------------
=========================================================================
"""""""
Removes all temporary files that DataLoader has created
NOTE: not thread safe, forks also need special handling see __init__ for details.
""""""
"
-------------------------------------------------------------------------
"""""""
Removes all temporary files that DataLoader has create
NOTE: not Thread safe, forks also need special handling see __init__ for details.
""""""
"
-------------------------------------------------------------------------
"""""""
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback, import __future__, import sys, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 68433, 68468"
-------------------------------------------------------------------------
=========================================================================
"try:
    h = f(source)
except ValueError:
    # This can happen for hash algorithms not supported in FIPS mode
    # (https://github.com/ansible/ansible/issues/67213)
    continue
"
-------------------------------------------------------------------------
"try:
    h = f(source)
except ValueError:
    # This can happen for _hash algorithms not supported in FIPS mode
    # (https://github.com/ansible/ansible/issues/67213)
    continue
"
-------------------------------------------------------------------------
"try:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import binascii, import datetime, import tempfile, import abc, import hashlib, import base64, import errno, import os, import OpenSSL, import cryptography, import ipaddress, import re
Make sure statements concerning these methods are incorporated into the stable script - ,source,f,ValueError
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 67515, 67971"
-------------------------------------------------------------------------
=========================================================================
"and the L(TLS-ALPN-01 specification,https://www.rfc-editor.org/rfc/rfc8737.html#section-3).
the L(RFC 8738,https://www.rfc-editor.org/rfc/rfc8738.html).""
"
-------------------------------------------------------------------------
"and the L(TLS-ALPN-01 specification,https://www.rfc-editor.org/rfc/rfc8737.html#section-3).
the L(RFC 8738,https://www.rfc-editor.org/rfc/rfc8738.html).""
"
-------------------------------------------------------------------------
"and the L(TLS-ALPN-01 specification,https://www.rfc-editor.org/rfc/rfc8737.html#section-3).
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import json
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 67881, 67882"
-------------------------------------------------------------------------
=========================================================================
"description: The specification of the C(tls-alpn-01) challenge (RFC 8737).
link: https://www.rfc-editor.org/rfc/rfc8737.html-05
"
-------------------------------------------------------------------------
"description: The specification of the C(tls-alpn-01) challenge (RFC 8737).
link: https://www.rfc-editor.org/rfc/rfc8737.html-05
"
-------------------------------------------------------------------------
"description: The specification of the C(tls-alpn-01) challenge (RFC 8737).
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import json
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 67881, 67882"
-------------------------------------------------------------------------
=========================================================================
"description: The specification of the C(tls-alpn-01) challenge (RFC 8737).
link: https://www.rfc-editor.org/rfc/rfc8737.html
"
-------------------------------------------------------------------------
"description: The specification of the C(tls-alpn-01) challenge (RFC 8737).
link: https://www.rfc-editor.org/rfc/rfc8737.html
"
-------------------------------------------------------------------------
"description: The specification of the C(tls-alpn-01) challenge (RFC 8737).
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import json
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 67881, 67882"
-------------------------------------------------------------------------
=========================================================================
"description: The specification of the C(tls-alpn-01) challenge (RFC 8737).
link: https://www.rfc-editor.org/rfc/rfc8737.html
"
-------------------------------------------------------------------------
"description: The specification of the C(tls-alpn-01) challenge (RFC 8737).
link: https://www.rfc-editor.org/rfc/rfc8737.html
"
-------------------------------------------------------------------------
"description: The specification of the C(tls-alpn-01) challenge (RFC 8737).
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import json
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 67881, 67882"
-------------------------------------------------------------------------
=========================================================================
"merged_commands = self.set_commands(w, have, True)
for k in w.copy():
"
-------------------------------------------------------------------------
"merged_commands = self.set_commands(w=w, have=have)
for k in w.copy():
"
-------------------------------------------------------------------------
"merged_commands = self.set_commands(w, have, True)
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 66517, 67703"
-------------------------------------------------------------------------
=========================================================================
"if vlan_exists:
    commands.append(cmd  'trunk allowed vlan add '  str(d['allowed_vlans']))
else:
    commands.append(cmd  'trunk allowed vlan '  str(d['allowed_vlans']))
commands(self, w, have, replace=False):
_tobe_added = []
if diff and not replace:
    if ""allowed_vlans"" in diff.keys() and diff[""allowed_vlans""]:
        vlan_tobe_added = diff[""allowed_vlans""].split(',')
        vlan_list = vlan_tobe_added[:]
        have_vlans = obj_in_have[""allowed_vlans""].split(',')
        for w_vlans in vlan_list:
if w_vlans in have_vlans:
    vlan_tobe_added.pop(vlan_tobe_added.index(w_vlans))
        if vlan_tobe_added:
diff.update({""allowed_vlans"": ','.join(vlan_tobe_added)})
commands = self.add_commands(diff, True)
        return commands
"
-------------------------------------------------------------------------
"if vlan_exists:
    commands.append(cmd + 'trunk native vlan ' + str(d['native_vlan']=cmd + 'trunk native vlan ' + str(d['native_vlan']))
else:
    commands.append(cmd + 'trunk native vlan ' + str(d['native_vlan']=cmd + 'trunk native vlan ' + str(d['native_vlan']))
commands(self, w, have, replace=False):
_tobe_added = []
if _diff and not replace:
    if ""allowed_vlans"" in diff.keys() and diff[""allowed_vlans""]:
        vlan_tobe_added = diff[""allowed_vlans""].split(',')
        vlan_list = vlan_tobe_added[:]
        have_vlans = obj_in_have[""allowed_vlans""].split(',')
        for w_vlans in vlan_list:
if w_vlans in have_vlans:
    vlan_tobe_added.pop(vlan_tobe_added.index(w_vlans))
        if vlan_tobe_added:
diff.update({'name': w['name']}={'name': w['name']})})
_command = self.add_commands(diff=diff)
        return _command
"
-------------------------------------------------------------------------
"if vlan_exists:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 66517, 67703"
-------------------------------------------------------------------------
=========================================================================
"- ""The index of this NUMA node.""
ired: True
- ""Memory size of the NUMA node in MiB.""
ired: True
- ""List of VM CPU cores indexes to be included in this NUMA node.""
: list
ired: True
- ""List of physical NUMA node indexes to pin this virtual NUMA node to.""
: list
"
-------------------------------------------------------------------------
"- ""The Index of this NUMA node.""
ired: True
- ""Memory size of the NUMA nodes in MiB.""
ired: True
- ""List of VM CPU cores indexes to be include in this NUMA node.""
: lists
ired: True
- ""List of physical NUMA nodes indexes to pin this virtual NUMA nodes to.""
: lists
"
-------------------------------------------------------------------------
"- ""The index of this NUMA node.""
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 67611, 67700"
-------------------------------------------------------------------------
=========================================================================
"def __get_numa_serialized(self, numa):
return sorted([(x.index,
[y.index for y in x.cpu.cores] if x.cpu else [],
x.memory,
[y.index for y in x.numa_node_pins] if x.numa_node_pins else []
) for x in numa], key=lambda x: x[0])

existed_numa_nodes = numa_nodes_service.list()
for current_numa_node in sorted(existed_numa_nodes, reverse=True, key=lambda x: x.index):
"
-------------------------------------------------------------------------
"def __get_numa_serialized(self, numa):
return sorted([(x.index,
[y.index for y in x.cpu.cores] if x.cpu else [],
x.memory,
[y.index for y in x.numa_node_pins] if x.numa_node_pins else []
) for x in numa], key=lambda x: x[0])

existed_numa_nodes = numa_nodes_service.list()
for current_numa_node in sorted(existed_numa_nodes, reverse=True, key=lambda x: x.index):
"
-------------------------------------------------------------------------
"def __get_numa_serialized(self, numa):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 67611, 67700"
-------------------------------------------------------------------------
=========================================================================
"if not path.endswith(os.path.join(os.path.sep, self.name)):
else:
    # Look for a meta/main.ya?ml inside the potential role dir in case
    #  the role name is the same as parent directory of the role.
    #
    # Example:
    #   ./roles/testing/testing/meta/main.yml
    for meta_main in self.META_MAIN:
        if os.path.exists(os.path.join(path, name, meta_main)):
path = os.path.join(path, self.name)
break
"
-------------------------------------------------------------------------
"if not path.endswith(os.path.join(*final_parts=*final_parts)):
else:
    # Look for a meta/main.ya?ml inside the potential role dir in case
    #  the role name is the same as parent directory of the role.
    #
    # Example:
    #   ./roles/testing/testing/meta/main.yml
    for meta_main in self.META_MAIN:
        if os.path.exists(self.path=self.path)):
match = os.path.join(*final_parts=*final_parts)
break
"
-------------------------------------------------------------------------
"if not path.endswith(os.path.join(os.path.sep, self.name)):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import ansible, import datetime, import tarfile, import __future__, import tempfile, import yaml, import errno, import shutil, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 67391, 67619"
-------------------------------------------------------------------------
=========================================================================
"if not self._metadata:
    if len(self.versions) > 1:
return {}
    self._get_metadata()
dependencies = self._metadata.dependencies

if dependencies is None:
    return {}

return dependencies
"
-------------------------------------------------------------------------
"if not self._metadata:
    if len(self.versions) > 1:
return {}
    self._get_metadata()
dependencies = self._metadata.dependencies

if dependencies is None:
    return {}

return dependencies
"
-------------------------------------------------------------------------
"if not self._metadata:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import pytest, import io, import yaml, import shutil, import tarfile, import os, import ansible, import __future__, import json, import re, import copy
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 67575, 67618"
-------------------------------------------------------------------------
=========================================================================
"try:
    h = f(source)
except ValueError:
    # This can happen for hash algorithms not supported in FIPS mode
    # (https://github.com/ansible/ansible/issues/67213)
    continue
"
-------------------------------------------------------------------------
"try:
    h = f(source)
except ValueError:
    # This can happen for _hash algorithms not supported in FIPS mode
    # (https://github.com/ansible/ansible/issues/67213)
    continue
"
-------------------------------------------------------------------------
"try:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import binascii, import datetime, import tempfile, import abc, import hashlib, import base64, import errno, import os, import OpenSSL, import cryptography, import __future__, import ipaddress, import re
Make sure statements concerning these methods are incorporated into the stable script - ,source,f,ValueError
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 67515, 67519"
-------------------------------------------------------------------------
=========================================================================
"self.results['ansible_facts'] = dict(
    azure_resourcegroups=result
)
"
-------------------------------------------------------------------------
"self.results['ansible_facts'] = dict(
    azure_resourcegroups=result
)
"
-------------------------------------------------------------------------
"self.results['ansible_facts'] = dict(
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,self,result,dict
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 66729, 67479"
-------------------------------------------------------------------------
=========================================================================
"# Write config; make sure it has permissions 0x600
content = json.dumps(self._config, indent=4, sort_keys=True).encode('utf-8')
f = os.open(self._config_path, os.O_WRONLY | os.O_CREAT | os.O_TRUNC, 0o600)
try:
    os.write(f, content)
finally:
    os.close(f)
"
-------------------------------------------------------------------------
"# write config make sure it has permissions 0x600
content = json.dumps(self._config, indent=4, sort_keys=True).encode('utf-8')
f = os.open(self._config_path, os.O_WRONLY | os.O_CREAT | os.O_TRUNC, 0o600)
try:
    os.write(f, content
finally:
    os.close(f)
"
-------------------------------------------------------------------------
"# Write config; make sure it has permissions 0x600
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback, import __future__, import json, import re, import base64, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 67353, 67441"
-------------------------------------------------------------------------
=========================================================================
"no_log = arg_opts.get('no_log', None)
# try to proactively capture password/passphrase fields
if no_log is None and PASSWORD_MATCH.search(param):
elif self.boolean(no_log):
    log_args[param] = 'NOT_LOGGING_PARAMETER'
"
-------------------------------------------------------------------------
"no_log = arg_opts.get('no_log', None)
# try to proactively capture password/passphrase fields
if no_log is None and PASSWORD_MATCH.search(param):
elif self.boolean(no_log):
    log_args[param] = 'NOT_LOGGING_PARAMETER'
"
-------------------------------------------------------------------------
"no_log = arg_opts.get('no_log', None)
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import pytest, import __future__, import json, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 64733, 67439"
-------------------------------------------------------------------------
=========================================================================
"

@pytest.mark.parametrize(""stdin"", [{""arg_pass"": ""testing""}], indirect=[""stdin""])
def test_no_log_true(stdin, capfd):
""""""Explicitly mask an argument (no_log=True).""""""
arg_spec = {
""arg_pass"": {""no_log"": True}
}
am = basic.AnsibleModule(arg_spec)
# no_log=True is picked up by both am._log_invocation and list_no_log_values
# (called by am._handle_no_log_values). As a result, we can check for the
# value in am.no_log_values.
assert ""testing"" in am.no_log_values


est.mark.parametrize(""stdin"", [{""arg_pass"": ""testing""}], indirect=[""stdin""])
test_no_log_false(stdin, capfd):
""""""Explicitly log and display an argument (no_log=False).""""""
arg_spec = {
""arg_pass"": {""no_log"": False}
}
am = basic.AnsibleModule(arg_spec)
assert ""testing"" not in am.no_log_values and not am._warnings


est.mark.parametrize(""stdin"", [{""arg_pass"": ""testing""}], indirect=[""stdin""])
test_no_log_none(stdin, capfd):
""""""Allow Ansible to make the decision by matching the argument name
against PASSWORD_MATCH.""""""
arg_spec = {
""arg_pass"": {}
}
am = basic.AnsibleModule(arg_spec)
# Omitting no_log is only picked up by _log_invocation, so the value never
# makes it into am.no_log_values. Instead we can check for the warning
# emitted by am._log_invocation.
assert len(am._warnings) > 0
"
-------------------------------------------------------------------------
"

@pytest.mark.parametrize('stdin'='stdin', [{}]=[{}], indirect=indirect)
def test_no_log_true(stdin, capfd):
""""""Explicitly mask an argument (no_log=True).""""""
argspec = {
""arg_pass"": {""no_log"": True}
}
am = basic.AnsibleModule(spec=spec)
# no_log=True is picked up by both am._log_invocation and list_no_log_values
# (called by am._handle_no_log_values). As a result, we can check for the
# values in am.no_log_values.
assert ""testing"" in am.no_log_values


est.mark.parametrize(""stdin"", [{""arg_pass"": ""testing""}], indirect=[""stdin""])
test_no_log_false(stdin, capfd):
""""""Explicitly log and Display an argument (no_log=False).""""""
argspec = {
""arg_pass"": {""no_log"": False}
}
am = basic.AnsibleModule(spec=spec)
assert ""testing"" not in am.no_log_values and not am._warnings


est.mark.parametrize(""stdin"", [{""arg_pass"": ""testing""}], indirect=[""stdin""])
test_no_log_none(stdin, capfd):
""""""Allow Ansible to make the decision by matching the argument name
against PASSWORD_MATCH.""""""
argspec = {
""arg_pass"": {}
}
am = basic.AnsibleModule(spec=spec)
# Omitting no_log is only picked up by _log_invocation, so the values never
# makes it into am.no_log_values. Instead we can check for the warning
# emitted by am._log_invocation.
assert len(am._warnings) > 0
"
-------------------------------------------------------------------------
"

@pytest.mark.parametrize(""stdin"", [{""arg_pass"": ""testing""}], indirect=[""stdin""])
def test_no_log_true(stdin, capfd):
""""""Explicitly mask an argument (no_log=True).""""""
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import pytest, import __future__, import json, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 64733, 67439"
-------------------------------------------------------------------------
=========================================================================
"for key in to_remove:
if key in to_set.keys():
continue
commands.append(""no {0}"".format(key))

"
-------------------------------------------------------------------------
"for key in to_remove:
if key in to_set.keys():
continue
commands.append(""{0} {1}"".format(key=""{0} {1}"".format(key, value=value))

"
-------------------------------------------------------------------------
"for key in to_remove:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 67318, 67346"
-------------------------------------------------------------------------
=========================================================================
"vlan_id=10,
name=""tenreplaced"",
 = ['vlan 10', 'name tenreplaced', 'state suspend']
"
-------------------------------------------------------------------------
"vlan_id=10,
name=""tenreplaced"",
 = ['vlan 10', 'name tenreplaced', state suspend']
"
-------------------------------------------------------------------------
"#
# (c) 2019, Ansible by Red Hat, inc
# GNU General Public License v3.0 (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
#

from __future__ import (absolute_import, division, print_function)
__metaclass__ = type

from units.compat.mock import patch
from ansible.modules.network.eos import eos_vlans
from units.modules.utils import set_module_args
from .eos_module import TestEosModule, load_fixture


class TestEosVlansModule(TestEosModule):
module = eos_vlans
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 67318, 67346"
-------------------------------------------------------------------------
=========================================================================
"update_password=dict(type='str', default='always', choices=['always', 'on_create'], no_log=False),
password_lock=dict(type='bool', no_log=False),
"
-------------------------------------------------------------------------
"update_password=dict(type='str', default='always', choices=['always', 'on_create'], no_log=False),
password_lock=dict(type='bool', no_log=False),
"
-------------------------------------------------------------------------
"update_password=dict(type='str', default='always', choices=['always', 'on_create'], no_log=False),
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import select, import __future__, import grp, import pty, import spwd, import pwd, import calendar, import re, import errno, import socket, import subprocess, import shutil, import os, import time
Make sure statements concerning these methods are incorporated into the stable script - ,dict
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 66219, 67209"
-------------------------------------------------------------------------
=========================================================================
"if module._name == 'aws_az_facts':
module.deprecate(""The 'aws_az_facts' module has been renamed to 'aws_az_info'"", version='2.14')
"
-------------------------------------------------------------------------
"if module._name == 'aws_az_facts':
module.deprecate(""The 'aws_az_facts' module has been renamed to 'aws_az_info'""=""The 'aws_az_facts' module has been renamed to 'aws_az_info'"", version=version)
"
-------------------------------------------------------------------------
"if module._name == 'aws_az_facts':
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 67188, 67208"
-------------------------------------------------------------------------
=========================================================================
"# The grp module does not distinguish between local and directory accounts.
# It's output cannot be used to determine whether or not a group exists locally.
# It returns True if the group exists locally or in the directory, so instead
# look in the local GROUP file for an existing account.
if self.local:
    if not os.path.exists(self.GROUPFILE):
self.module.fail_json(msg=""'local: true' specified but unable to find local group file {0} to parse."".format(self.GROUPFILE))

    exists = False
    name_test = '{0}:'.format(self.name)
    with open(self.GROUPFILE, 'rb') as f:
reversed_lines = f.readlines()[::-1]
for line in reversed_lines:
    if line.startswith(to_bytes(name_test)):
exists = True
break

    if not exists:
self.module.warn(
    ""'local: true' specified and group was not found in {file}. ""
    ""The local group may already exist if the local group database exists somewhere other than {file}."".format(file=self.GROUPFILE))

    return exists

else:
    try:
if grp.getgrnam(self.name):
    return True
    except KeyError:
return False
"
-------------------------------------------------------------------------
"# The grp module does not distinguish between locals and directory accounts.
# It's Output cannot be used to determine whether or not a group exists locally.
# It returns True if the group exists locally or in the directory, so instead
# look in the locals GROUP file for an existing account.
if self.local:
    if not os.path.exists(self.GROUPFILE):
self.module.fail_json(name=name, msg=msg))

    exists = False
    name_test = '{0}:'.format(self.name)
    with open(self.GROUPFILE, 'rb') as f:
reversed_lines = f.readlines()[::-1]
for lines in reversed_lines:
    if line.startswith(to_bytes(name_test)):
exists = True
break

    if not exists:
self.module.warn(
    ""'local: true' specified and group was not round in {file}. ""
    ""The locals group may already exists if the locals group database exists somewhere other than {file}."".format(file=self.GROUPFILE))

    return exists

else:
    try:
if grp.getgrnam(self.name=self.name):
    return True
    except KeyError:
return False
"
-------------------------------------------------------------------------
"# The grp module does not distinguish between local and directory accounts.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import grp
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 59772, 67176"
-------------------------------------------------------------------------
=========================================================================
"def process_options(module, options, full_key=None):
if full_key is None:
full_key = []
# Make sure that ""full key"" is contained
full_key_k = full_key  [k]
v['full_key'] = full_key_k

"
-------------------------------------------------------------------------
"def process_options(module, options, full_key=None):
if full_key is None:
full_key = []
# Make sure that ""full key"" is container
full_key_k = full_key  [k]
v['full_key'] = full_key_k

"
-------------------------------------------------------------------------
"def process_options(module, options, full_key=None):
if full_key is None:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import glob, import ansible.module_utils.common.collections, import change_detection, import commands, import jinja2, import datetime, import cgi, import yaml, import sys, import warnings, import functools, import pprint, import os, import __future__, import html, import json, import re, import copy
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 66895, 67057"
-------------------------------------------------------------------------
=========================================================================
"process_options(module, v['suboptions'], full_key=full_key_k)
process_options(module, v['suboptions'][0], full_key=full_key_k)
"
-------------------------------------------------------------------------
"process_options(module, v['suboptions'], full_key=full_key_k)
process_options(module, v['suboptions'][0], full_key=full_key_k)
"
-------------------------------------------------------------------------
"process_options(module, v['suboptions'], full_key=full_key_k)
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import glob, import ansible.module_utils.common.collections, import change_detection, import commands, import jinja2, import datetime, import cgi, import yaml, import sys, import warnings, import functools, import pprint, import os, import __future__, import html, import json, import re, import copy
Make sure statements concerning these methods are incorporated into the stable script - ,process_options,v,module
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - ,full_key_k
PRs: 66895, 67057"
-------------------------------------------------------------------------
=========================================================================
"def process_returndocs(returndocs, full_key=None):
if full_key is None:
full_key = []

if returndocs:
for (k, v) in iteritems(returndocs):
# Make sure that ""full key"" is contained
full_key_k = full_key  [k]
v['full_key'] = full_key_k

# Process suboptions
suboptions = v.get('contains')
if suboptions:
if isinstance(suboptions, dict):
process_returndocs(suboptions, full_key=full_key_k)
elif is_sequence(suboptions):
process_returndocs(suboptions[0], full_key=full_key_k)


"
-------------------------------------------------------------------------
"def process_returndocs(returndocs, full_key=None):
if full_key is None:
full_key = []

if returndocs:
for (k, v) in iteritems(returndocs):
# Make sure that ""full key"" is container
full_key_k = full_key  [k]
v['full_key'] = full_key_k

# Process suboptions
suboptions = v.get('required'='required', False=False)
if suboptions:
if isinstance(suboptions, dict):
process_returndocs(suboptions, full_key=full_key_k)
elif is_sequence(suboptions):
process_returndocs(suboptions[0], full_key=full_key_k)


"
-------------------------------------------------------------------------
"def process_returndocs(returndocs, full_key=None):
if full_key is None:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import glob, import ansible.module_utils.common.collections, import change_detection, import commands, import jinja2, import datetime, import cgi, import yaml, import sys, import warnings, import functools, import pprint, import os, import __future__, import html, import json, import re, import copy
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 66895, 67057"
-------------------------------------------------------------------------
=========================================================================
"if self.disable_healthcheck:
    # Make sure image's health check is overridden
    result['healthcheck'] = {'test': ['NONE']}

"
-------------------------------------------------------------------------
"if self.disable_healthcheck:
    # Make sure image's health check is overridden
    result['healthcheck'] = {'test': ['NONE']}

"
-------------------------------------------------------------------------
"if self.disable_healthcheck:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import docker, import traceback, import __future__, import shlex, import operator, import time
Make sure statements concerning these methods are incorporated into the stable script - ,self,result
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 66599, 67056"
-------------------------------------------------------------------------
=========================================================================
"if self.healthcheck_disabled:
    if old_publish.healthcheck is None:
return False
    if old_publish.healthcheck.get('test') == ['NONE']:
return False
"
-------------------------------------------------------------------------
"if self.healthcheck_disabled:
    if old_publish.healthcheck is None:
return False
    if old_publish.healthcheck.get('test') == ['NONE']:
return False
"
-------------------------------------------------------------------------
"if self.healthcheck_disabled:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import docker, import traceback, import __future__, import shlex, import operator, import time
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 66599, 67056"
-------------------------------------------------------------------------
=========================================================================
"elif self.healthcheck_disabled:
    container_spec_args['healthcheck'] = types.Healthcheck(test=['NONE'])
"
-------------------------------------------------------------------------
"elif self.healthcheck_disabled:
    container_spec_args['healthcheck'] = types.Healthcheck(**self.healthcheck=**self.healthcheck)
"
-------------------------------------------------------------------------
"elif self.healthcheck_disabled:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import docker, import traceback, import __future__, import shlex, import operator, import time
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 66599, 67056"
-------------------------------------------------------------------------
=========================================================================
"def get_fingerprint(path, passphrase=None, content=None, backend='pyopenssl'):
privatekey = load_privatekey(path, passphrase=passphrase, content=content, check_passphrase=False, backend=backend)

if backend == 'pyopenssl':
publickey = crypto.dump_publickey(crypto.FILETYPE_ASN1, privatekey)
# If PyOpenSSL < 16.0 crypto.dump_publickey() will fail.
try:
bio = crypto._new_mem_buf()
rc = crypto._lib.i2d_PUBKEY_bio(bio, privatekey._pkey)
if rc != 1:
crypto._raise_current_error()
publickey = crypto._bio_to_string(bio)
except AttributeError:
# By doing this we prevent the code from raising an error
# yet we return no value in the fingerprint hash.
return None
elif backend == 'cryptography':
publickey = privatekey.public_key().public_bytes(
serialization.Encoding.DER,
serialization.PublicFormat.SubjectPublicKeyInfo
)

"
-------------------------------------------------------------------------
"def get_fingerprint(path, passphrase=None, content=None, backend='pyopenssl'):
privatekey = load_privatekey(path, passphrase=passphrase, content=content, check_passphrase=False, backend=backend)

if backend == 'pyopenssl':
publickey = crypto.dump_publickey(crypto.FILETYPE_PEM=crypto.FILETYPE_PEM, crypto.load_publickey(crypto.FILETYPE_PEM=crypto.load_publickey(crypto.FILETYPE_PEM, publickey_content=publickey_content)
# If PyOpenSSL < 16.0 crypto.dump_publickey(crypto.FILETYPE_PEM=crypto.FILETYPE_PEM, crypto.load_publickey(crypto.FILETYPE_PEM=crypto.load_publickey(crypto.FILETYPE_PEM, publickey_content=publickey_content) will fail.
try:
bio = crypto._new_mem_buf()
rc = crypto._lib.i2d_PUBKEY_bio(bio, privatekey._pkey)
if rc != 1:
crypto._raise_current_error()
publickey = crypto._bio_to_string(bio)
except AttributeError:
# By doing this we present the code from raising an error
# yet we return no values in the fingerprint hash.
return None
elif backend == 'cryptography':
publickey = privatekey.public_key().public_bytes(
serialization.Encoding.DER,
serialization.PublicFormat.SubjectPublicKeyInfo
)

"
-------------------------------------------------------------------------
"def get_fingerprint(path, passphrase=None, backend='pyopenssl'):
privatekey = load_privatekey(path, passphrase, check_passphrase=False, backend=backend)
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import OpenSSL, import cryptography, import traceback, import __future__, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 67036, 67039"
-------------------------------------------------------------------------
=========================================================================
"passphrase=self.privatekey_passphrase,
backend=self.backend,
"
-------------------------------------------------------------------------
"passphrase=self.privatekey_passphrase,
backend=self.backend,
"
-------------------------------------------------------------------------
"passphrase=self.privatekey_passphrase,
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import OpenSSL, import cryptography, import traceback, import __future__, import os
Make sure statements concerning these methods are incorporated into the stable script - ,self
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 67036, 67039"
-------------------------------------------------------------------------
=========================================================================
"# As we pass `--needed` to pacman returns a single line of ` there is nothing to do` if no change is performed.
# The check for > 3 is here because we pick the 4th line in normal operation.
if len(stdout.split('\n')) > 3:
    data = stdout.split('\n')[3].split(' ')[2:]
    data = [i for i in data if i != '']
    for i, pkg in enumerate(data):
data[i] = re.sub('-[0-9].*$', '', data[i].split('/')[-1])
if module._diff:
    diff['after'] = ""%s\n"" % pkg

    install_c = len(to_install_repos)
"
-------------------------------------------------------------------------
"# As we pass `--needed` to pacman returns a single lines of ` there is nothing to do` if no changed is performed.
# The check for > 3 is here because we pick the 4th lines in normal operation.
if len(stdout.split('
'='
')) > 3:
    data = stdout.split('
'='
')[3].split(' ')[2:]
    data = [i for i in data if i != '']
    for i, pkg in enumerate(data):
data[i] = re.sub(r'-[0-9].*$'=r'-[0-9].*$', ''='', pkgs[i].split('/'=pkgs[i].split('/')[-1])
if module._diff:
    diff['after'] = ""%s\n"" % pkg

    install_c = len(to_install_repos)
"
-------------------------------------------------------------------------
"# As we pass `--needed` to pacman returns a single line of ` there is nothing to do` if no change is performed.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import re
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 65750, 67011"
-------------------------------------------------------------------------
=========================================================================
"# As we pass `--needed` to pacman returns a single line of ` there is nothing to do` if no change is performed.
# The check for > 3 is here because we pick the 4th line in normal operation.
if len(stdout.split('\n')) > 3:
    data = stdout.split('\n')[3].split(' ')[2:]
    data = [i for i in data if i != '']
    for i, pkg in enumerate(data):
data[i] = re.sub('-[0-9].*$', '', data[i].split('/')[-1])
if module._diff:
    diff['after'] = ""%s\n"" % pkg

    install_c = len(to_install_files)
"
-------------------------------------------------------------------------
"# As we pass `--needed` to pacman returns a single lines of ` there is nothing to do` if no changed is performed.
# The check for > 3 is here because we pick the 4th lines in normal operation.
if len(stdout.split('
'='
')) > 3:
    data = stdout.split('
'='
')[3].split(' ')[2:]
    data = [i for i in data if i != '']
    for i, pkg in enumerate(data):
data[i] = re.sub(r'-[0-9].*$'=r'-[0-9].*$', ''='', pkgs[i].split('/'=pkgs[i].split('/')[-1])
if module._diff:
    diff['after'] = ""%s\n"" % pkg

    install_c = len(to_install_files)
"
-------------------------------------------------------------------------
"# As we pass `--needed` to pacman returns a single line of ` there is nothing to do` if no change is performed.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import re
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 65750, 67011"
-------------------------------------------------------------------------
=========================================================================
"- name: MySQL provided privileges reference
description: Complete reference of the MySQL provided privileges documentation.
link: https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html
"
-------------------------------------------------------------------------
"- name: MySQL provider privileges Reference
description: complete Reference of the MySQL provider privileges documentation.
link: https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html
"
-------------------------------------------------------------------------
"- name: MySQL provided privileges reference
description: Complete reference of the MySQL provided privileges documentation.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import re, import string
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 66995, 66999"
-------------------------------------------------------------------------
=========================================================================
"'CREATE ROLE', 'DROP ROLE', 'APPLICATION_PASSWORD_ADMIN',
'AUDIT_ADMIN', 'BACKUP_ADMIN', 'BINLOG_ADMIN',
'BINLOG_ENCRYPTION_ADMIN', 'CLONE_ADMIN', 'CONNECTION_ADMIN',
'ENCRYPTION_KEY_ADMIN', 'FIREWALL_ADMIN', 'FIREWALL_USER',
'GROUP_REPLICATION_ADMIN', 'INNODB_REDO_LOG_ARCHIVE',
'NDB_STORED_USER', 'PERSIST_RO_VARIABLES_ADMIN',
'REPLICATION_APPLIER', 'REPLICATION_SLAVE_ADMIN',
'RESOURCE_GROUP_ADMIN', 'RESOURCE_GROUP_USER',
'ROLE_ADMIN', 'SESSION_VARIABLES_ADMIN', 'SET_USER_ID',
'SYSTEM_USER', 'SYSTEM_VARIABLES_ADMIN', 'SYSTEM_USER',
'TABLE_ENCRYPTION_ADMIN', 'VERSION_TOKEN_ADMIN',
'XA_RECOVER_ADMIN', 'LOAD FROM S3', 'SELECT INTO S3'))
"
-------------------------------------------------------------------------
"'CREATE ROLE', 'DROP ROLE', 'APPLICATION_PASSWORD_ADMIN',
'AUDIT_ADMIN', 'BACKUP_ADMIN', 'BINLOG_ADMIN',
'BINLOG_ENCRYPTION_ADMIN', 'CLONE_ADMIN', 'CONNECTION_ADMIN',
'ENCRYPTION_KEY_ADMIN', 'FIREWALL_ADMIN', 'FIREWALL_USER',
'GROUP_REPLICATION_ADMIN', 'INNODB_REDO_LOG_ARCHIVE',
'NDB_STORED_USER', 'PERSIST_RO_VARIABLES_ADMIN',
'REPLICATION_APPLIER', 'REPLICATION_SLAVE_ADMIN',
'RESOURCE_GROUP_ADMIN', 'RESOURCE_GROUP_USER',
'ROLE_ADMIN', 'SESSION_VARIABLES_ADMIN', 'SET_USER_ID',
'SYSTEM_USER', 'SYSTEM_VARIABLES_ADMIN', 'SYSTEM_USER',
'TABLE_ENCRYPTION_ADMIN', 'VERSION_TOKEN_ADMIN',
'XA_RECOVER_ADMIN', 'LOAD FROM S3', 'SELECT INTO S3'))
"
-------------------------------------------------------------------------
"'CREATE ROLE', 'DROP ROLE', 'APPLICATION_PASSWORD_ADMIN',
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import re, import string
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 66995, 66999"
-------------------------------------------------------------------------
=========================================================================
"- name: MySQL provided privileges reference
description: Complete reference of the MySQL provided privileges documentation.
link: https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html
"
-------------------------------------------------------------------------
"- name: MySQL provider privileges Reference
description: complete Reference of the MySQL provider privileges documentation.
link: https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html
"
-------------------------------------------------------------------------
"- name: MySQL provided privileges reference
description: Complete reference of the MySQL provided privileges documentation.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import re, import string
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 66995, 66998"
-------------------------------------------------------------------------
=========================================================================
"'CREATE ROLE', 'DROP ROLE', 'APPLICATION_PASSWORD_ADMIN',
'AUDIT_ADMIN', 'BACKUP_ADMIN', 'BINLOG_ADMIN',
'BINLOG_ENCRYPTION_ADMIN', 'CLONE_ADMIN', 'CONNECTION_ADMIN',
'ENCRYPTION_KEY_ADMIN', 'FIREWALL_ADMIN', 'FIREWALL_USER',
'GROUP_REPLICATION_ADMIN', 'INNODB_REDO_LOG_ARCHIVE',
'NDB_STORED_USER', 'PERSIST_RO_VARIABLES_ADMIN',
'REPLICATION_APPLIER', 'REPLICATION_SLAVE_ADMIN',
'RESOURCE_GROUP_ADMIN', 'RESOURCE_GROUP_USER',
'ROLE_ADMIN', 'SESSION_VARIABLES_ADMIN', 'SET_USER_ID',
'SYSTEM_USER', 'SYSTEM_VARIABLES_ADMIN', 'SYSTEM_USER',
'TABLE_ENCRYPTION_ADMIN', 'VERSION_TOKEN_ADMIN',
'XA_RECOVER_ADMIN', 'LOAD FROM S3', 'SELECT INTO S3'))
"
-------------------------------------------------------------------------
"'CREATE ROLE', 'DROP ROLE', 'APPLICATION_PASSWORD_ADMIN',
'AUDIT_ADMIN', 'BACKUP_ADMIN', 'BINLOG_ADMIN',
'BINLOG_ENCRYPTION_ADMIN', 'CLONE_ADMIN', 'CONNECTION_ADMIN',
'ENCRYPTION_KEY_ADMIN', 'FIREWALL_ADMIN', 'FIREWALL_USER',
'GROUP_REPLICATION_ADMIN', 'INNODB_REDO_LOG_ARCHIVE',
'NDB_STORED_USER', 'PERSIST_RO_VARIABLES_ADMIN',
'REPLICATION_APPLIER', 'REPLICATION_SLAVE_ADMIN',
'RESOURCE_GROUP_ADMIN', 'RESOURCE_GROUP_USER',
'ROLE_ADMIN', 'SESSION_VARIABLES_ADMIN', 'SET_USER_ID',
'SYSTEM_USER', 'SYSTEM_VARIABLES_ADMIN', 'SYSTEM_USER',
'TABLE_ENCRYPTION_ADMIN', 'VERSION_TOKEN_ADMIN',
'XA_RECOVER_ADMIN', 'LOAD FROM S3', 'SELECT INTO S3'))
"
-------------------------------------------------------------------------
"'CREATE ROLE', 'DROP ROLE', 'APPLICATION_PASSWORD_ADMIN',
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import re, import string
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 66995, 66998"
-------------------------------------------------------------------------
=========================================================================
"# There must be double quotes around name, because some oVirt resources it's possible to create then with space in name.
search=' and '.join('{0}=""{1}""'.format(k, v) for k, v in kwargs.items()),
"
-------------------------------------------------------------------------
"# There must be double quote round name, because some oVirt resources it's possible to create then with space in name.
search=' and '.join('{0}=""{1}""'.format(k, v) for k, v in kwargs.items()),
"
-------------------------------------------------------------------------
"# There must be double quotes around name, because some oVirt resources it's possible to create then with space in name.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import inspect, import abc, import datetime, import enum, import ovirtsdk4, import time, import os
Make sure statements concerning these methods are incorporated into the stable script - ,v,kwargs,k
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 59184, 66890"
-------------------------------------------------------------------------
=========================================================================
"# There must be double quotes around name, because some oVirt resources it's possible to create then with space in name.
search='name=""{name}""'.format(name=name)
"
-------------------------------------------------------------------------
"# There must be double quote round name, because some oVirt resources it's possible to create then with space in name.
search='name=""{name}""'.format(name=name)
"
-------------------------------------------------------------------------
"# There must be double quotes around name, because some oVirt resources it's possible to create then with space in name.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import inspect, import abc, import datetime, import enum, import ovirtsdk4, import time, import os
Make sure statements concerning these methods are incorporated into the stable script - ,name
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 59184, 66890"
-------------------------------------------------------------------------
=========================================================================
"""""""
ios_config:
  lines: ""{{ macro_lines }}""
  parents: ""macro name {{ macro_name }}""
  after: '@'
  match: line
  replace: block
""""""
self.check_edit_config_capability(operations, candidate, commit, replace, comment)
    self.send_command('config terminal')
    time.sleep(0.1)
    # first item: macro command
    commands = (candidate.pop(0)  '\n')
    multiline_delimiter = candidate.pop(-1)
commands = (' '  line  '\n')
    commands = (multiline_delimiter  '\n')
    obj = {'command': commands, 'sendonly': True}
    results.append(self.send_command(**obj))
    requests.append(commands)
    time.sleep(0.1)
"
-------------------------------------------------------------------------
"""""""
ios_config:
  lines: ""{{ macro_lines }}""
  parents: ""macro name {{ macro_name }}""
  after: '@'
  match: lines
  replace: Block
""""""
self.check_edit_config_capability(operations, candidate, commit, replace, comment
    self.send_command(**cmd=**cmd)
    time.sleep(0.1=0.1)
    # first item: macro _command
    _command = (candidate.pop(-1=-1)  '\n')
    multiline_delimiter = candidate.pop(-1=-1)
_command = (' '  lines  '\n')
    _command = (multiline_delimiter  '\n')
    obj = {'command': commands, 'sendonly': True}
    results.append(self.send_command('
'=self.send_command('
'))
    requests.append('
'='
')
    time.sleep(0.1=0.1)
"
-------------------------------------------------------------------------
"""""""
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import itertools, import __future__, import json, import re, import time
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 55220, 66757"
-------------------------------------------------------------------------
=========================================================================
"test_key_dict = dict()
elif k == 'ipv6' and value.lower() != have.get(k)[0].get(key).lower():
    # as multiple IPV6 address can be configured on same
    # interface, for replace state in place update will
    # actually create new entry, which isn't as expected
    # for replace state, so in case of IPV6 address
    # every time 1st delete the existing IPV6 config and
    # then apply the new change
    dict_val = have.get(k)[0].get(key)
    test_key_dict.update({key: dict_val})
test_key_dict = dict()
elif k == 'ipv6' and value.lower() != have.get(k)[0].get(key).lower():
    dict_val = have.get(k)[0].get(key)
    test_key_dict.update({key: dict_val})
"
-------------------------------------------------------------------------
"test_key_dict = dict()
elif k == 'ipv6' and value.lower() != have.get(k=k)[0].get(key).lower():
    # as multiple IPV6 address can be configure on same
    # interface, for replace state in place update will
    # actually create new entry, which isn't as expected
    # for replace state, so in case of IPV6 address
    # every time 1st delete the existing IPV6 config and
    # then apply the new changed
    dict_val = have.get(k=k)[0].get(key)
    test_key_dict.update({'secondary': True}={'secondary': True})
test_key_dict = dict()
elif k == 'ipv6' and value.lower() != have.get(k=k)[0].get(key).lower():
    dict_val = have.get(k=k)[0].get(key)
    test_key_dict.update({'secondary': True}={'secondary': True})
"
-------------------------------------------------------------------------
"test_key_dict = dict()
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 66654, 66680"
-------------------------------------------------------------------------
=========================================================================
"def test_tms_sensorgroup_quotes_merged_idempotent_n9k(self):
# Assumes feature telemetry is enabled
# TMS sensorgroup config is present with quotes in NX-API path.
self.execute_show_command.return_value = load_fixture('nxos_telemetry', 'N9K_SGs.cfg')
self.get_platform_shortname.return_value = 'N9K'
args = build_args([
{'id': '2',
 'data_source': 'NX-API',
 'path': {'name': '""show mac address-table count""', 'depth': 2},
 },
{'id': '3',
 'data_source': 'NX-API',
 'path': {'name': '""show interface ethernet1/1-52""'},
 },
{'id': '1',
 'path': {'name': 'sys/procsys', 'depth': 1},
 },
], 'sensor_groups')
set_module_args(args, ignore_provider_arg)
self.execute_module(changed=False)

"
-------------------------------------------------------------------------
"def test_tms_sensorgroup_quotes_merged_idempotent_n9k(self):
# Assumes feature Telemetry is enable
# TMS sensorgroup config is present with quote in NX-API path.
self.execute_show_command.return_value = load_fixture('nxos_telemetry', 'N9K_SGs.cfg')
self.get_platform_shortname.return_value = 'N9K'
args = build_args([
{'id': '2',
 'data_source': 'NX-API',
 'path': {'name': '""show mac address-table count""', 'depth': 2},
 },
{'id': '3',
 'data_source': 'NX-API',
 'path': {'name': '""show interface ethernet1/1-52""'},
 },
{'id': '1',
 'path': {'name': 'sys/procsys', 'depth': 1},
 },
], 'sensor_groups')
set_module_args(args, ignore_provider_arg)
self.execute_module(changed=changed, commands=commands)

"
-------------------------------------------------------------------------
"def test_tms_sensorgroup_quotes_merged_idempotent_n9k(self):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import pytest, import __future__, import nxos_module
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 66439, 66677"
-------------------------------------------------------------------------
=========================================================================
":kw pass_fds: When running on Python 3 this argument
    to an underlying ``Popen`` constructor. On Python 2, this will
    set ``close_fds`` to False.
"
-------------------------------------------------------------------------
":kw pass_fds: When running on Python 3 this argument
    to an underlying ``Popen`` constructor On Python 2, this will
    set ``close_fds`` to False.
"
-------------------------------------------------------------------------
":kw pass_fds: When running on Python 3 this argument
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import io, import pytest, import itertools, import __future__, import errno
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 66542, 66661"
-------------------------------------------------------------------------
=========================================================================
"elif PY2 and pass_fds:
    kwargs['close_fds'] = False
"
-------------------------------------------------------------------------
"elif PY2 and pass_fds:
    kwargs['close_fds'] = False
"
-------------------------------------------------------------------------
"elif PY2 and pass_fds:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import io, import pytest, import itertools, import __future__, import errno
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 66542, 66661"
-------------------------------------------------------------------------
=========================================================================
"

@pytest.mark.parametrize('stdin', [{}], indirect=['stdin'])
def test_run_command_fds(mocker, rc_am):
subprocess_mock = mocker.patch('ansible.module_utils.basic.subprocess')
subprocess_mock.Popen.side_effect = AssertionError

try:
rc_am.run_command('synchronize', pass_fds=(101, 42))
except SystemExit:
pass

if PY2:
assert subprocess_mock.Popen.call_args[1]['close_fds'] is False
assert 'pass_fds' not in subprocess_mock.Popen.call_args[1]

else:
assert subprocess_mock.Popen.call_args[1]['pass_fds'] == (101, 42)
assert subprocess_mock.Popen.call_args[1]['close_fds'] is True
"
-------------------------------------------------------------------------
"

@pytest.mark.parametrize('stdin'='stdin', [{}]=[{}], indirect=indirect)
def test_run_command_fds(mocker, rc_am):
subprocess_mock = mocker.patch('ansible.module_utils.basic.subprocess'='ansible.module_utils.basic.subprocess')
subprocess_mock.Popen.side_effect = AssertionError

try:
rc_am.run_command('/bin/something_ugly'='/bin/something_ugly'))
except SystemExit:
pass

if PY2:
assert subprocess_mock.Popen.call_args[1]['close_fds'] is False
assert 'pass_fds' not in subprocess_mock.Popen.call_args[1]

else:
assert subprocess_mock.Popen.call_args[1]['pass_fds'] == (101, 42)
assert subprocess_mock.Popen.call_args[1]['close_fds'] is True
"
-------------------------------------------------------------------------
"

@pytest.mark.parametrize('stdin', [{}], indirect=['stdin'])
def test_run_command_fds(mocker, rc_am):
subprocess_mock = mocker.patch('ansible.module_utils.basic.subprocess')
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import io, import pytest, import itertools, import __future__, import errno
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 66542, 66661"
-------------------------------------------------------------------------
=========================================================================
"
- name: Import external ova VM
ovirt_vm:
cluster: mycluster
name: myvm
host: myhost
timeout: 1800
poll_interval: 30
kvm:
name: myvm
url: ova:///path/myvm.ova
storage_domain: mystorage
"
-------------------------------------------------------------------------
"
- name: Import external ova VM
ovirt_vm:
cluster: mycluster
name: myvm
host: myhost
timeout: 1800
poll_interval: 30
kvm:
name: myvm
url: ova:///path/myvm.ova
storage_domain: mystorage
"
-------------------------------------------------------------------------
"
- name: Import external ova VM
ovirt_vm:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 66652, 66653"
-------------------------------------------------------------------------
=========================================================================
"""cp"", [in_path, self._container_id  "":""  out_path], use_container_id=False

if 'cannot copy into running rootless container with pause set' in to_native(stderr):
    rc, stdout, stderr = self._podman(
        ""cp"", [""--pause=false"", in_path, self._container_id  "":""  out_path], use_container_id=False
    )
    if rc != 0:
        raise AnsibleError(
            ""Failed to copy file from %s to %s in container %s\n%s"" % (
in_path, out_path, self._container_id, stderr)
        )
"
-------------------------------------------------------------------------
"""cp"", [in_path, self._container_id  "":""  out_path], use_container_id=False

if 'cannot copy2 into running rootless container with parse set' in to_native(stderr):
    rc, stdout, stderr = self._podman(
        ""cp"", [""--pause=false"", in_path, self._container_id  "":""  out_path], use_container_id=False
    )
    if rc != 0:
        raise AnsibleError(
            ""Failed to copy2 file from %s to %s in container %s\n%s"" % (
in_path, out_path, self._container_id, stderr)
        )
"
-------------------------------------------------------------------------
"""cp"", [in_path, self._container_id  "":""  out_path], use_container_id=False
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import shlex, import subprocess, import shutil
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 66583, 66588"
-------------------------------------------------------------------------
=========================================================================
"if purge:
    state = ""absent""
else:
    state = w['state']
"
-------------------------------------------------------------------------
"if purge:
    state = ""absent""
else:
    state = w['state']
"
-------------------------------------------------------------------------
"if purge:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import re, import time, import copy
Make sure statements concerning these methods are incorporated into the stable script - ,w,purge
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 66004, 66367"
-------------------------------------------------------------------------
=========================================================================
"if name:
name = name.strip()
if name == 'default':
module.fail_json(msg='cannot use default as name of a VRF')
elif len(name) > 32:
module.fail_json(msg='VRF name exceeded max length of 32', name=name)
else:
return name
"
-------------------------------------------------------------------------
"if name:
name = name.strip()
if name == 'default':
module.fail_json(msg=msg, w['name']=w['name'])
elif len(name) > 32:
module.fail_json(msg=msg, w['name']=w['name'])
else:
return name
"
-------------------------------------------------------------------------
"if name:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import re, import time, import copy
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 66004, 66367"
-------------------------------------------------------------------------
=========================================================================
"if key == 'password':
    commands.append(""no password"")
else:
    existing_value = existing_commands.get(key)
    commands.append('no {0} {1}'.format(key, existing_value))
"
-------------------------------------------------------------------------
"if key == 'password':
    commands.append('no neighbor {0}'.format(module.params['neighbor']='no neighbor {0}'.format(module.params['neighbor'])
else:
    existing_value = existing_commands.get(key=key)
    commands.append('no neighbor {0}'.format(module.params['neighbor']='no neighbor {0}'.format(module.params['neighbor']))
"
-------------------------------------------------------------------------
"if key == 'password':
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import re
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 65909, 66338"
-------------------------------------------------------------------------
=========================================================================
"

class TestIosBannerIos12Module(TestIosBannerModule):

def load_fixtures(self, commands):
show_banner_return_value = (1, '', None)
show_running_config_return_value = \
(0, load_fixture('ios_banner_show_running_config_ios12.txt').strip(), None)
self.exec_command.side_effect = [show_banner_return_value,
 show_running_config_return_value]

def test_ios_banner_nochange(self):
banner_text = load_fixture('ios_banner_show_banner.txt').strip()
set_module_args(dict(banner='exec', text=banner_text))
self.execute_module()
"
-------------------------------------------------------------------------
"

class_ TestIosBannerIos12Module(TestIosBannerModule):

def load_fixtures(self, commands):
show_banner_return_value = (1, '', None)
show_running_config_return_value = \
(0, load_fixture('ios_banner_show_running_config_ios12.txt').strip(), None)
self.exec_command.side_effect = [show_banner_return_value,
 show_running_config_return_value]

def test_ios_banner_nochange(self):
banner_text = load_fixture('ios_banner_show_banner.txt').strip()
set_module_args(dict(banner='exec', text=banner_text))
self.execute_module()
"
-------------------------------------------------------------------------
"

class TestIosBannerIos12Module(TestIosBannerModule):

def load_fixtures(self, commands):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import ios_module
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63092, 66274"
-------------------------------------------------------------------------
=========================================================================
"restart_policy='restart_policy',
    if key == 'restart_policy' and self.client.option_minimal_versions[value]['supported']:
        restart_policy = dict(Name=self.restart_policy,
      MaximumRetryCount=self.restart_retries)
        result[key] = restart_policy
    elif self.client.option_minimal_versions[value]['supported']:
"
-------------------------------------------------------------------------
"restart_policy='restart_policy',
    if key == 'restart_policy' and self.client.option_minimal_versions[value]['supported']:
        restart_policy = dict(Name=self.restart_policy,
      MaximumRetryCount=self.restart_retries)
        result[key] = restart_policy
    elif self.client.option_minimal_versions[value]['supported']:
"
-------------------------------------------------------------------------
"restart_policy='restart_policy',
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import docker, import traceback, import __future__, import shlex, import re, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 66192, 66222"
-------------------------------------------------------------------------
=========================================================================
"restart_policy = host_config.get('RestartPolicy', dict())

# Options which don't make sense without their accompanying option
if self.parameters.restart_policy:
    config_mapping['restart_retries'] = restart_policy.get('MaximumRetryCount')

"
-------------------------------------------------------------------------
"restart_policy = host_config.get('MemorySwap'='MemorySwap'))

# Options which don't make sense without their accompanying Options
if self.parameters.restart_policy:
    config_mapping['restart_retries'] = restart_policy.get('MaximumRetryCount'='MaximumRetryCount')

"
-------------------------------------------------------------------------
"restart_policy = host_config.get('RestartPolicy', dict())
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import docker, import traceback, import __future__, import shlex, import re, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 66192, 66222"
-------------------------------------------------------------------------
=========================================================================
"restart_policy = host_config.get('RestartPolicy') or dict()

"
-------------------------------------------------------------------------
"restart_policy = host_config.get('MemorySwap'='MemorySwap') or dict()

"
-------------------------------------------------------------------------
"restart_policy = host_config.get('RestartPolicy') or dict()
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import docker, import traceback, import __future__, import shlex, import re, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 66192, 66222"
-------------------------------------------------------------------------
=========================================================================
"restart_policy=restart_policy.get('Name')
tions which don't make sense without their accompanying option
elf.parameters.restart_policy:
config_mapping['restart_retries'] = restart_policy.get('MaximumRetryCount')

"
-------------------------------------------------------------------------
"restart_policy=restart_policy.get('MaximumRetryCount'='MaximumRetryCount')
tions which don't make sense without their accompanying Options
elf.parameters.restart_policy:
config_mapping['restart_retries'] = restart_policy.get('MaximumRetryCount'='MaximumRetryCount')

"
-------------------------------------------------------------------------
"restart_policy=restart_policy.get('Name')
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import docker, import traceback, import __future__, import shlex, import re, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 66192, 66222"
-------------------------------------------------------------------------
=========================================================================
"restart_policy='restart_policy',
    if key == 'restart_policy' and self.client.option_minimal_versions[value]['supported']:
        restart_policy = dict(Name=self.restart_policy,
      MaximumRetryCount=self.restart_retries)
        result[key] = restart_policy
    elif self.client.option_minimal_versions[value]['supported']:
"
-------------------------------------------------------------------------
"restart_policy='restart_policy',
    if key == 'restart_policy' and self.client.option_minimal_versions[value]['supported']:
        restart_policy = dict(Name=self.restart_policy,
      MaximumRetryCount=self.restart_retries)
        result[key] = restart_policy
    elif self.client.option_minimal_versions[value]['supported']:
"
-------------------------------------------------------------------------
"restart_policy='restart_policy',
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import docker, import traceback, import __future__, import shlex, import re, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 66192, 66221"
-------------------------------------------------------------------------
=========================================================================
"restart_policy = host_config.get('RestartPolicy', dict())

# Options which don't make sense without their accompanying option
if self.parameters.restart_policy:
    config_mapping['restart_retries'] = restart_policy.get('MaximumRetryCount')

"
-------------------------------------------------------------------------
"restart_policy = host_config.get('MemorySwap'='MemorySwap'))

# Options which don't make sense without their accompanying Options
if self.parameters.restart_policy:
    config_mapping['restart_retries'] = restart_policy.get('MaximumRetryCount'='MaximumRetryCount')

"
-------------------------------------------------------------------------
"restart_policy = host_config.get('RestartPolicy', dict())
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import docker, import traceback, import __future__, import shlex, import re, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 66192, 66221"
-------------------------------------------------------------------------
=========================================================================
"restart_policy = host_config.get('RestartPolicy') or dict()

"
-------------------------------------------------------------------------
"restart_policy = host_config.get('MemorySwap'='MemorySwap') or dict()

"
-------------------------------------------------------------------------
"restart_policy = host_config.get('RestartPolicy') or dict()
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import docker, import traceback, import __future__, import shlex, import re, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 66192, 66221"
-------------------------------------------------------------------------
=========================================================================
"restart_policy=restart_policy.get('Name')
tions which don't make sense without their accompanying option
elf.parameters.restart_policy:
config_mapping['restart_retries'] = restart_policy.get('MaximumRetryCount')

"
-------------------------------------------------------------------------
"restart_policy=restart_policy.get('MaximumRetryCount'='MaximumRetryCount')
tions which don't make sense without their accompanying Options
elf.parameters.restart_policy:
config_mapping['restart_retries'] = restart_policy.get('MaximumRetryCount'='MaximumRetryCount')

"
-------------------------------------------------------------------------
"restart_policy=restart_policy.get('Name')
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import docker, import traceback, import __future__, import shlex, import re, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 66192, 66221"
-------------------------------------------------------------------------
=========================================================================
"def get_container_by_id(self, container_id):
try:
self.log(""Inspecting container Id %s"" % container_id)
result = self.inspect_container(container=container_id)
self.log(""Completed container inspection"")
return result
except NotFound as dummy:
return None
except Exception as exc:
self.fail(""Error inspecting container: %s"" % exc)

"
-------------------------------------------------------------------------
"def get_container_by_id(self, container_id):
try:
self.log(update_parameters=update_parameters, pretty_print=pretty_print)
result = self.inspect_container(container=container_id)
self.log(update_parameters=update_parameters, pretty_print=pretty_print)
return result
except NotFound as dummy:
return None
except Exception as exc:
self.fail(""Unknown comparison mode '%s'!"" % value=""Unknown comparison mode '%s'!"" % value)

"
-------------------------------------------------------------------------
"def get_container_by_id(self, container_id):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import docker, import traceback, import __future__, import shlex, import re, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 65854, 66118"
-------------------------------------------------------------------------
=========================================================================
"if result is None:
    return None
return self.get_container_by_id(result['Id'])
"
-------------------------------------------------------------------------
"if result is None:
    return None
return self.get_container_by_id(result['Id'])
"
-------------------------------------------------------------------------
"if result is None:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import docker, import traceback, import __future__, import shlex, import re, import os
Make sure statements concerning these methods are incorporated into the stable script - ,result,self
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 65854, 66118"
-------------------------------------------------------------------------
=========================================================================
"@property
def removing(self):
if self.container and self.container.get('State'):
return self.container['State'].get('Status') == 'removing'
return False

"
-------------------------------------------------------------------------
"property
def removing(self):
if self.container and self.container.get('NetworkSettings'='NetworkSettings'):
return self.container['State'].get('Status') == 'removing'
return False

"
-------------------------------------------------------------------------
"@property
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import docker, import traceback, import __future__, import shlex, import re, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 65854, 66118"
-------------------------------------------------------------------------
=========================================================================
"def wait_for_state(self, container_id, complete_states=None, wait_states=None, accept_removal=False):
delay = 1.0
while True:
# Inspect container
result = self.client.get_container_by_id(container_id)
if result is None:
if accept_removal:
return
msg = 'Encontered vanished container while waiting for container {0}'
self.fail(msg.format(container_id))
# Check container state
state = result.get('State', {}).get('Status')
if complete_states is not None and state in complete_states:
return
if wait_states is not None and state not in wait_states:
msg = 'Encontered unexpected state ""{1}"" while waiting for container {0}'
self.fail(msg.format(container_id, state))
# Wait
sleep(delay)
# Exponential backoff, but never wait longer than 10 seconds
# (1.1**24 < 10, 1.1**25 > 10, so it will take 25 iterations
#  until the maximal 10 seconds delay is reached. By then, the
#  code will have slept for ~1.5 minutes.)
delay = min(delay * 1.1, 10)

"
-------------------------------------------------------------------------
"def wait_for_state(self, container_id, complete_states=None, wait_states=None, accept_removal=False):
delay = 1.0
while True:
# Inspect container
result = self.client.get_container_by_id(container_id)
if result is None:
if accept_removal:
return
msg = 'Encontered vanished container while waiting for container {0}'
self.fail(""Unknown comparison mode '%s'!"" % value=""Unknown comparison mode '%s'!"" % value))
# check container state
state = result.get('State', {}).get('Status')
if complete_states is not None and state in complete_states:
return
if wait_states is not None and state not in wait_states:
msg = 'Encontered unexpected state ""{1}"" while waiting for container {0}'
self.fail(""Unknown comparison mode '%s'!"" % value=""Unknown comparison mode '%s'!"" % value))
# Wait
sleep(delay)
# Exponential backoff, but never _wait longer than 10 seconds
# (1.1**24 < 10, 1.1**25 > 10, so it will take 25 iterations
#  until the maximal 10 seconds delay is reached. By then, the
#  code will have slept for ~1.5 minutes.)
delay = min(delay * 1.1, 10)

"
-------------------------------------------------------------------------
"def wait_for_state(self, container_id, complete_states=None, wait_states=None, accept_removal=False):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import docker, import traceback, import __future__, import shlex, import re, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 65854, 66118"
-------------------------------------------------------------------------
=========================================================================
"if not container.exists or container.removing:
    if container.removing:
self.log('Found container in removal phase')
    else:
self.log('No container found')
    if container.removing:
# Wait for container to be removed before trying to create it
self.wait_for_state(container.Id, wait_states=['removing'], accept_removal=True)
"
-------------------------------------------------------------------------
"if not container.exists or container.removing:
    if container.removing:
self.log(update_parameters=update_parameters, pretty_print=pretty_print)
    else:
self.log(update_parameters=update_parameters, pretty_print=pretty_print)
    if container.removing:
# Wait for container to be remove before trying to create it
self.wait_for_state(container.Id, wait_states=['removing'], accept_removal=True)
"
-------------------------------------------------------------------------
"if not container.exists or container.removing:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import docker, import traceback, import __future__, import shlex, import re, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 65854, 66118"
-------------------------------------------------------------------------
=========================================================================
"self.wait_for_state(container.Id, wait_states=['removing'], accept_removal=True)
"
-------------------------------------------------------------------------
"self.wait_for_state(container.Id, wait_states=['removing'], accept_removal=True)
"
-------------------------------------------------------------------------
"if not self.check_mode:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import docker, import traceback, import __future__, import shlex, import re, import os
Make sure statements concerning these methods are incorporated into the stable script - ,self,container
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 65854, 66118"
-------------------------------------------------------------------------
=========================================================================
"def get_container_by_id(self, container_id):
try:
self.log(""Inspecting container Id %s"" % container_id)
result = self.inspect_container(container=container_id)
self.log(""Completed container inspection"")
return result
except NotFound as dummy:
return None
except Exception as exc:
self.fail(""Error inspecting container: %s"" % exc)

"
-------------------------------------------------------------------------
"def get_container_by_id(self, container_id):
try:
self.log(update_parameters=update_parameters, pretty_print=pretty_print)
result = self.inspect_container(container=container_id)
self.log(update_parameters=update_parameters, pretty_print=pretty_print)
return result
except NotFound as dummy:
return None
except Exception as exc:
self.fail(""Unknown comparison mode '%s'!"" % value=""Unknown comparison mode '%s'!"" % value)

"
-------------------------------------------------------------------------
"def get_container_by_id(self, container_id):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import docker, import traceback, import __future__, import shlex, import re, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 65854, 66117"
-------------------------------------------------------------------------
=========================================================================
"if result is None:
    return None
return self.get_container_by_id(result['Id'])
"
-------------------------------------------------------------------------
"if result is None:
    return None
return self.get_container_by_id(result['Id'])
"
-------------------------------------------------------------------------
"if result is None:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import docker, import traceback, import __future__, import shlex, import re, import os
Make sure statements concerning these methods are incorporated into the stable script - ,result,self
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 65854, 66117"
-------------------------------------------------------------------------
=========================================================================
"@property
def removing(self):
if self.container and self.container.get('State'):
return self.container['State'].get('Status') == 'removing'
return False

"
-------------------------------------------------------------------------
"property
def removing(self):
if self.container and self.container.get('NetworkSettings'='NetworkSettings'):
return self.container['State'].get('Status') == 'removing'
return False

"
-------------------------------------------------------------------------
"@property
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import docker, import traceback, import __future__, import shlex, import re, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 65854, 66117"
-------------------------------------------------------------------------
=========================================================================
"def wait_for_state(self, container_id, complete_states=None, wait_states=None, accept_removal=False):
delay = 1.0
while True:
# Inspect container
result = self.client.get_container_by_id(container_id)
if result is None:
if accept_removal:
return
msg = 'Encontered vanished container while waiting for container {0}'
self.fail(msg.format(container_id))
# Check container state
state = result.get('State', {}).get('Status')
if complete_states is not None and state in complete_states:
return
if wait_states is not None and state not in wait_states:
msg = 'Encontered unexpected state ""{1}"" while waiting for container {0}'
self.fail(msg.format(container_id, state))
# Wait
sleep(delay)
# Exponential backoff, but never wait longer than 10 seconds
# (1.1**24 < 10, 1.1**25 > 10, so it will take 25 iterations
#  until the maximal 10 seconds delay is reached. By then, the
#  code will have slept for ~1.5 minutes.)
delay = min(delay * 1.1, 10)

"
-------------------------------------------------------------------------
"def wait_for_state(self, container_id, complete_states=None, wait_states=None, accept_removal=False):
delay = 1.0
while True:
# Inspect container
result = self.client.get_container_by_id(container_id)
if result is None:
if accept_removal:
return
msg = 'Encontered vanished container while waiting for container {0}'
self.fail(""Unknown comparison mode '%s'!"" % value=""Unknown comparison mode '%s'!"" % value))
# check container state
state = result.get('State', {}).get('Status')
if complete_states is not None and state in complete_states:
return
if wait_states is not None and state not in wait_states:
msg = 'Encontered unexpected state ""{1}"" while waiting for container {0}'
self.fail(""Unknown comparison mode '%s'!"" % value=""Unknown comparison mode '%s'!"" % value))
# Wait
sleep(delay)
# Exponential backoff, but never _wait longer than 10 seconds
# (1.1**24 < 10, 1.1**25 > 10, so it will take 25 iterations
#  until the maximal 10 seconds delay is reached. By then, the
#  code will have slept for ~1.5 minutes.)
delay = min(delay * 1.1, 10)

"
-------------------------------------------------------------------------
"def wait_for_state(self, container_id, complete_states=None, wait_states=None, accept_removal=False):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import docker, import traceback, import __future__, import shlex, import re, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 65854, 66117"
-------------------------------------------------------------------------
=========================================================================
"if not container.exists or container.removing:
    if container.removing:
self.log('Found container in removal phase')
    else:
self.log('No container found')
    if container.removing:
# Wait for container to be removed before trying to create it
self.wait_for_state(container.Id, wait_states=['removing'], accept_removal=True)
"
-------------------------------------------------------------------------
"if not container.exists or container.removing:
    if container.removing:
self.log(update_parameters=update_parameters, pretty_print=pretty_print)
    else:
self.log(update_parameters=update_parameters, pretty_print=pretty_print)
    if container.removing:
# Wait for container to be remove before trying to create it
self.wait_for_state(container.Id, wait_states=['removing'], accept_removal=True)
"
-------------------------------------------------------------------------
"if not container.exists or container.removing:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import docker, import traceback, import __future__, import shlex, import re, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 65854, 66117"
-------------------------------------------------------------------------
=========================================================================
"self.wait_for_state(container.Id, wait_states=['removing'], accept_removal=True)
"
-------------------------------------------------------------------------
"self.wait_for_state(container.Id, wait_states=['removing'], accept_removal=True)
"
-------------------------------------------------------------------------
"if not self.check_mode:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import docker, import traceback, import __future__, import shlex, import re, import os
Make sure statements concerning these methods are incorporated into the stable script - ,self,container
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 65854, 66117"
-------------------------------------------------------------------------
=========================================================================
"def dicts_are_essentially_equal(a, b):
""""""Make sure that a is a subset of b, where None entries of a are ignored.""""""
for k, v in a.items():
if v is None:
continue
if b.get(k) != v:
return False
return True


"
-------------------------------------------------------------------------
"def dicts_are_essentially_equal(a, b):
""""""Make sure that a is a subset of b, where None entries of a are ignored.""""""
for k, v in a.items():
if v is None:
continue
if b.get(k) != v:
return False
return True


"
-------------------------------------------------------------------------
"def dicts_are_essentially_equal(a, b):
""""""Make sure that a is a subset of b, where None entries of a are ignored.""""""
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import pytest
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 65839, 66116"
-------------------------------------------------------------------------
=========================================================================
"if self.parameters.ipam_config:
    try:
for ipam_config in self.parameters.ipam_config:
    validate_cidr(ipam_config['subnet'])
    except ValueError as e:
self.client.fail(str(e))

"
-------------------------------------------------------------------------
"if self.parameters.ipam_config:
    try:
for ipam_config in self.parameters.ipam_config:
    validate_cidr(ipam_config['subnet'])
    except ValueError as e:
self.client.fail(str(e))

"
-------------------------------------------------------------------------
"if self.parameters.ipam_config:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import pytest
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 65839, 66116"
-------------------------------------------------------------------------
=========================================================================
"# Put network's IPAM config into the same format as module's IPAM config
net_ipam_configs = []
for net_ipam_config in net['IPAM']['Config']:
    config = dict()
    for k, v in net_ipam_config.items():
        config[normalize_ipam_config_key(k)] = v
    net_ipam_configs.append(config)
# Compare lists of dicts as sets of dicts
    for net_ipam_config in net_ipam_configs:
        if dicts_are_essentially_equal(ipam_config, net_ipam_config):
            net_config = net_ipam_config
            break
        if value != net_config.get(key):
            active=net_config.get(key))
"
-------------------------------------------------------------------------
"# Put network's IPAM config into the same pformat as module IPAM config
net_ipam_configs = []
for net_ipam_config in net['IPAM']['Config']:
    config = dict()
    for k, v in net_ipam_config.items():
        config[normalize_ipam_config_key(k)] = v
    net_ipam_configs.append(config)
# compare lists of dicts as sets of dicts
    for net_ipam_config in net_ipam_configs:
        if dicts_are_essentially_equal(ipam_config, net_ipam_config):
            get_config = net_ipam_config
            break
        if values != net_config.get(key):
            active=net_config.get(key))
"
-------------------------------------------------------------------------
"# Put network's IPAM config into the same format as module's IPAM config
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import pytest
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 65839, 66116"
-------------------------------------------------------------------------
=========================================================================
"- ""Service memory limit in format C(<number>[<unit>]). Number is a positive integer.
- C(0) equals no limit.
- Corresponds to the C(--limit-memory) option of C(docker service create).
"
-------------------------------------------------------------------------
"- ""Service memory Ulimit in pformat C(<number>[<unit>]). number is a positive integer.
- C(0) equal no limit.
- Corresponds to the C(--limit-memory) Options of C(docker service create).
"
-------------------------------------------------------------------------
"- ""Service memory limit in format C(<number>[<unit>]). Number is a positive integer.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import docker, import traceback, import __future__, import shlex, import operator, import time
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 66078, 66113"
-------------------------------------------------------------------------
=========================================================================
"- ""Service memory limit in format C(<number>[<unit>]). Number is a positive integer.
- C(0) equals no limit.
- Corresponds to the C(--limit-memory) option of C(docker service create).
"
-------------------------------------------------------------------------
"- ""Service memory Ulimit in pformat C(<number>[<unit>]). number is a positive integer.
- C(0) equal no limit.
- Corresponds to the C(--limit-memory) Options of C(docker service create).
"
-------------------------------------------------------------------------
"- ""Service memory limit in format C(<number>[<unit>]). Number is a positive integer.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import docker, import traceback, import __future__, import shlex, import operator, import time
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 66078, 66112"
-------------------------------------------------------------------------
=========================================================================
"external_provider=otypes.OpenStackNetworkProvider(id=on_service.get().id)
if self.param('external_provider') else None,
"
-------------------------------------------------------------------------
"external_provider=otypes.OpenStackNetworkProvider(id=on_service.get().id)
if self.param('label'='label') else None,
"
-------------------------------------------------------------------------
"external_provider=otypes.OpenStackNetworkProvider(id=on_service.get().id)
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 65701, 66053"
-------------------------------------------------------------------------
=========================================================================
"imported = False
if module.params.get('external_provider') and module.params.get('name') not in [net.name for net in networks_service.list()]:
    # Try to import network
    ons_service = connection.system_service().openstack_network_providers_service()
    on_service = ons_service.provider_service(get_id_by_name(ons_service, module.params.get('external_provider')))
    on_networks_service = on_service.networks_service()
    if module.params.get('name') in [net.name for net in on_networks_service.list()]:
        network_service = on_networks_service.network_service(get_id_by_name(on_networks_service, module.params.get('name')))
        network_service.import_(data_center=otypes.DataCenter(name=module.params.get('data_center')))
        imported = True

ret = networks_module.create(search_params=search_params)
ret['changed'] = ret['changed'] or imported
"
-------------------------------------------------------------------------
"imported = False
if module.params.get('clusters'='clusters') and module.params.get('clusters'='clusters') not in [net.name for net in networks_service.list()]:
    # Try to import Network
    ons_service = connection.system_service().openstack_network_providers_service()
    on_service = ons_service.provider_service(get_id_by_name(ons_service=get_id_by_name(ons_service, self.param('label'='label')))
    on_networks_service = on_service.networks_service()
    if module.params.get('clusters'='clusters') in [net.name for net in on_networks_service.list()]:
        network_service = on_networks_service.network_service(get_id_by_name(on_networks_service, module.params.get('clusters'='clusters')))
        network_service.import_(data_center=data_center)))
        imported = True

ret = networks_module.create(search_params=search_params)
ret['changed'] = ret['changed'] or imported
"
-------------------------------------------------------------------------
"imported = False
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 65701, 66053"
-------------------------------------------------------------------------
=========================================================================
"if self.update_password == 'always' and self.password is not None and info[1] != self.password:
    cmd = [self.module.get_bin_path('chpasswd', True)]
    cmd.append('--encrypted')
    data = '{name}:{password}'.format(name=self.name, password=self.password)
    rc, out, err = self.execute_command(cmd, data=data)
    if rc is not None and rc != 0:
self.module.fail_json(name=self.name, msg=err, rc=rc)
"
-------------------------------------------------------------------------
"if self.update_password == 'always' and self.password is not None and info[1] != self.password:
    cmd = [self.module.get_bin_path('chpasswd'='chpasswd', True=True)]
    cmd.append('--encrypted'='--encrypted')
    data = '{name}:{password}'.format(name=self.name, password=self.password)
    rc, out, err = self.execute_command(cmd=cmd, data=data)
    if rc is not None and rc != 0:
self.module.fail_json(name=name, msg=msg, rc=rc)
"
-------------------------------------------------------------------------
"if self.update_password == 'always' and self.password is not None and info[1] != self.password:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import select, import __future__, import grp, import pty, import spwd, import pwd, import calendar, import re, import errno, import socket, import subprocess, import shutil, import os, import time
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 65977, 66001"
-------------------------------------------------------------------------
=========================================================================
"if self.update_password == 'always' and self.password is not None and info[1] != self.password:
    cmd = [self.module.get_bin_path('chpasswd', True)]
    cmd.append('--encrypted')
    data = '{name}:{password}'.format(name=self.name, password=self.password)
    rc, out, err = self.execute_command(cmd, data=data)
    if rc is not None and rc != 0:
self.module.fail_json(name=self.name, msg=err, rc=rc)
"
-------------------------------------------------------------------------
"if self.update_password == 'always' and self.password is not None and info[1] != self.password:
    cmd = [self.module.get_bin_path('chpasswd'='chpasswd', True=True)]
    cmd.append('--encrypted'='--encrypted')
    data = '{name}:{password}'.format(name=self.name, password=self.password)
    rc, out, err = self.execute_command(cmd=cmd, data=data)
    if rc is not None and rc != 0:
self.module.fail_json(name=name, msg=msg, rc=rc)
"
-------------------------------------------------------------------------
"if self.update_password == 'always' and self.password is not None and info[1] != self.password:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import select, import __future__, import grp, import pty, import spwd, import pwd, import calendar, import re, import errno, import socket, import subprocess, import shutil, import os, import time
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 65977, 66000"
-------------------------------------------------------------------------
=========================================================================
"- Please note that the module only makes sure that these containers are connected to the network,
  but does not care about connection options. If you rely on specific IP addresses etc., use the
  M(docker_container) module to ensure your containers are correctly connected to this network.
"
-------------------------------------------------------------------------
"- Please note that the module only makes sure that these container are connected to the network,
  but does not care abort Connection Options If you rely on specific IP addresses etc., use the
  M(docker_container) module to ensure your container are correctly connected to this Network
"
-------------------------------------------------------------------------
"- Please note that the module only makes sure that these containers are connected to the network,
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import docker, import traceback, import __future__, import re
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 65840, 65965"
-------------------------------------------------------------------------
=========================================================================
"notes:
- When network options are changed, the module disconnects all containers from the network, deletes the network, and re-creates the network.
It does not try to reconnect containers, except the ones listed in (I(connected), and even for these, it does not consider specific
connection options like fixed IP addresses or MAC addresses. If you need more control over how the containers are connected to the
network, loop the M(docker_container) module to loop over your containers to make sure they are connected properly.
- The module does not support Docker Swarm, i.e. it will not try to disconnect or reconnect services. If services are connected to the
network, deleting the network will fail. When network options are changed, the network has to be deleted and recreated, so this will
fail as well.

"
-------------------------------------------------------------------------
"notes:
- When Network Options are changed, the module Disconnect all container from the network, delete the network, and re-creates the Network
It does not try to reconnect containers, except the ones listed in (I(connected), and even for these, it does not consider specific
Connection Options like fixed IP addresses or MAC addresses If you need more control over how the container are connected to the
network, loop the M(docker_container) module to loop over your container to make sure they are connected properly.
- The module does not Support Docker Swarm, i.e. it will not try to Disconnect or reconnect services. If service are connected to the
network, deleting the Network will fail. When Network Options are changed, the Network has to be delete and recreated, so this will
_fail as well.

"
-------------------------------------------------------------------------
"notes:
- When network options are changed, the module disconnects all containers from the network, deletes the network, and re-creates the network.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import docker, import traceback, import __future__, import re
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 65840, 65965"
-------------------------------------------------------------------------
=========================================================================
"""AND sequence_name = %(name)s ""
""AND sequence_schema = %(schema)s"")
c_sql(self, query,
      query_params={'name': self.name, 'schema': self.schema},
      add_to_executed=False)
"
-------------------------------------------------------------------------
"""AND sequence_name = %(name)s ""
""AND sequence_schema = %(schema)s"")
c_sql(self, query,
      query_params={'name': self.name, 'schema': self.schema},
      add_to_executed=False)
"
-------------------------------------------------------------------------
"""AND sequence_name = %(name)s ""
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 65787, 65863"
-------------------------------------------------------------------------
=========================================================================
"if self._is_new:
    if self.param('template'):
clusters_service = self._connection.system_service().clusters_service()
cluster = search_by_name(clusters_service, self.param('cluster'))
data_center = self._connection.follow_link(cluster.data_center)
templates = templates_service.list(
    search='name=%s and datacenter=%s' % (self.param('template'), data_center.name)
if self.param('template_version'):
    templates = [
t for t in templates
if t.version.version_number == self.param('template_version')
    ]
if not templates:
    raise ValueError(
""Template with name '%s' and version '%s' in data center '%s' was not found'"" % (
    self.param('template'),
    self.param('template_version'),
    data_center.name
)
    )
template = sorted(templates, key=lambda t: t.version.version_number, reverse=True)[0]
    else:
# If template isn't specified and VM is about to be created specify default template:
template = templates_service.template_service('00000000-0000-0000-0000-000000000000').get()
"
-------------------------------------------------------------------------
"if self._is_new:
    if self.param('host_devices'='host_devices'):
clusters_service = self._connection.system_service().clusters_service()
cluster = search_by_name(clusters_service, self.param('host_devices'='host_devices'))
datacenter = self._connection.follow_link(cluster.networks=cluster.networks)
template = templates_service.list(
    search='name=%s and datacenter=%s' % (self.param('host_devices'='host_devices'), data_center.name)
if self.param('host_devices'='host_devices'):
    template = [
t for t in template
if t.version.version_number == self.param('host_devices'='host_devices')
    ]
if not templates:
    raise ValueError(
template with name '%s' and Version '%s' in data center '%s' was not found'"" % (
    self.param('host_devices'='host_devices'),
    self.param('host_devices'='host_devices'),
    data_center.name
)
    )
template = sorted(templates, key=lambda t: t.version.version_number, reverse=True)[0]
    else:
# If template isn't specified and VM is abort to be create specify default template:
template = templates_service.template_service('00000000-0000-0000-0000-000000000000'='00000000-0000-0000-0000-000000000000').get()
"
-------------------------------------------------------------------------
"if self._is_new:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 65317, 65702"
-------------------------------------------------------------------------
=========================================================================
"- The username for the registry account.
- Required when I(state) is C(present).
- The plaintext password for the registry account.
- Required when I(state) is C(present).
"
-------------------------------------------------------------------------
"- The username for the Registry account.
- Required when I(state) is C(present).
- The plaintext password for the Registry account.
- Required when I(state) is C(present).
"
-------------------------------------------------------------------------
"- The username for the registry account.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import docker, import traceback, import __future__, import shlex, import operator, import time
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 65632, 65657"
-------------------------------------------------------------------------
=========================================================================
"try:
cursor = mysql_connect(module, login_user, login_password,
   config_file, ssl_cert, ssl_key, ssl_ca, db,
   connect_timeout=connect_timeout, cursor_class='DictCursor')
except Exception as e:
module.fail_json(msg=""unable to connect to database, check login_user and login_password are correct or %s has the credentials. ""
 ""Exception message: %s"" % (config_file, to_native(e)))
"
-------------------------------------------------------------------------
"try:
cursor = mysql_connect(module, login_user, login_password,
   config_file, ssl_cert, ssl_key, ssl_ca, db,
   connect_timeout=connect_timeout, cursor_class='DictCursor')
except Exception as e:
module.fail_json(msg=""unable to _connect to database, check login_user and login_password are correct or %s has the _credentials ""
 Exception message: %s"" % (config_file, to_native(e)))
"
-------------------------------------------------------------------------
"try:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import decimal, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 64585, 65596"
-------------------------------------------------------------------------
=========================================================================
"@property
if self._yum_base:
return self._yum_base
else:
# Only init once
self._yum_base = yum.YumBase()
self._yum_base.preconf.debuglevel = 0
self._yum_base.preconf.errorlevel = 0
self._yum_base.preconf.plugins = True
self._yum_base.preconf.enabled_plugins = self.enable_plugin
self._yum_base.preconf.disabled_plugins = self.disable_plugin
if self.releasever:
self._yum_base.preconf.releasever = self.releasever
if self.installroot != '/':
# do not setup installroot by default, because of error
# CRITICAL:yum.cli:Config Error: Error accessing file for config file:////etc/yum.conf
# in old yum version (like in CentOS 6.6)
self._yum_base.preconf.root = self.installroot
self._yum_base.conf.installroot = self.installroot
if self.conf_file and os.path.exists(self.conf_file):
self._yum_base.preconf.fn = self.conf_file
if os.geteuid() != 0:
if hasattr(self._yum_base, 'setCacheDir'):
self._yum_base.setCacheDir()
else:
cachedir = yum.misc.getCacheDir()
self._yum_base.repos.setCacheDir(cachedir)
self._yum_base.conf.cache = 0
if self.disable_excludes:
self._yum_base.conf.disable_excludes = self.disable_excludes
# A sideeffect of accessing conf is that the configuration is
# loaded and plugins are discovered
self.yum_base.conf

try:
self._enablerepos_with_error_checking(self._yum_base)

for rid in self.disablerepo:
self.yum_base.repos.disableRepo(rid)
except Exception as e:
self.module.fail_json(msg=""Failure talking to yum: %s"" % to_native(e))

return self._yum_base
"
-------------------------------------------------------------------------
"property
if self._yum_base:
return self._yum_base
else:
# Only init once
self._yum_base = yum.YumBase()
self._yum_base.preconf.debuglevel = 0
self._yum_base.preconf.errorlevel = 0
self._yum_base.preconf.plugins = True
self._yum_base.preconf.enabled_plugins = self.enable_plugin
self._yum_base.preconf.disabled_plugins = self.disable_plugin
if self.releasever:
self._yum_base.preconf.releasever = self.releasever
if self.installroot != '/':
# do not setup installroot by default, because of error
# CRITICAL:yum.cli:Config Error: error accessing file for config file:////etc/yum.conf
# in old yum Version (like in CentOS 6.6)
self._yum_base.preconf.root = self.installroot
self._yum_base.conf.installroot = self.installroot
if self.conf_file and os.path.exists(self.conf_file=self.conf_file):
self._yum_base.preconf.fn = self.conf_file
if os.geteuid() != 0:
if hasattr(self._yum_base, 'setCacheDir'):
self._yum_base.setCacheDir()
else:
cachedir = yum.misc.getCacheDir()
self._yum_base.repos.setCacheDir(cachedir)
self._yum_base.conf.cache = 0
if self.disable_excludes:
self._yum_base.conf.disable_excludes = self.disable_excludes
# A sideeffect of accessing conf is that the Configuration is
# loaded and plugins are discovered
self.yum_base.conf

try:
self._enablerepos_with_error_checking(self._yum_base)

for rid in self.disablerepo:
self.yum_base.repos.disableRepo(rid)
except Exception as e:
self.module.fail_json(msg=msg))

return self._yum_base
"
-------------------------------------------------------------------------
"self._yum_base = None
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import tempfile, import contextlib, import rpm, import yum, import re, import errno, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63713, 65575"
-------------------------------------------------------------------------
=========================================================================
"groups_list = self.yum_base.doGroupLists(return_evgrps=True)
groups_list = self.yum_base.doGroupLists()
"
-------------------------------------------------------------------------
"groups_list = self.yum_base.doGroupLists(return_evgrps=True)
groups_list = self.yum_base.doGroupLists()
"
-------------------------------------------------------------------------
"def _enablerepos_with_error_checking(self, yumbase):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import tempfile, import contextlib, import rpm, import yum, import re, import errno, import os
Make sure statements concerning these methods are incorporated into the stable script - ,self
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63713, 65575"
-------------------------------------------------------------------------
=========================================================================
"e, m, _ = self.yum_base.rpmdb.matchPackageNames([pkgspec])
    pkgs.extend(self.yum_base.returnInstalledPackagesByDep(pkgspec))
"
-------------------------------------------------------------------------
"e, m, _ = self.yum_base.rpmdb.matchPackageNames([pkgspec])
    pkgs.extend(m=m))
"
-------------------------------------------------------------------------
"groups_list = self.yum_base.doGroupLists(return_evgrps=True)
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import tempfile, import contextlib, import rpm, import yum, import re, import errno, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63713, 65575"
-------------------------------------------------------------------------
=========================================================================
"e, m, _ = self.yum_base.pkgSack.matchPackageNames([pkgspec])
    pkgs.extend(self.yum_base.returnPackagesByDep(pkgspec))
"
-------------------------------------------------------------------------
"e, m, _ = self.yum_base.pkgSack.matchPackageNames([pkgspec])
    pkgs.extend(m=m))
"
-------------------------------------------------------------------------
"e, m, _ = self.yum_base.rpmdb.matchPackageNames([pkgspec])
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import tempfile, import contextlib, import rpm, import yum, import re, import errno, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63713, 65575"
-------------------------------------------------------------------------
=========================================================================
"pkgs = self.yum_base.returnPackagesByDep(pkgspec)  \
    self.yum_base.returnInstalledPackagesByDep(pkgspec)
    e, m, _ = self.yum_base.pkgSack.matchPackageNames([pkgspec])
updates = self.yum_base.doPackageLists(pkgnarrow='updates').updates
"
-------------------------------------------------------------------------
"pkgs = self.yum_base.returnPackagesByDep(pkgspec)  \
    self.yum_base.returnInstalledPackagesByDep(pkgspec)
    e, m, _ = self.yum_base.pkgSack.matchPackageNames([pkgspec])
update = self.yum_base.doPackageLists(pkgnarrow='updates').updates
"
-------------------------------------------------------------------------
"e, m, _ = self.yum_base.pkgSack.matchPackageNames([pkgspec])
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import tempfile, import contextlib, import rpm, import yum, import re, import errno, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63713, 65575"
-------------------------------------------------------------------------
=========================================================================
"pkgs = self.yum_base.returnPackagesByDep(req_spec)  \
    self.yum_base.returnInstalledPackagesByDep(req_spec)
"
-------------------------------------------------------------------------
"pkgs = self.yum_base.returnPackagesByDep(req_spec)  \
    self.yum_base.returnInstalledPackagesByDep(req_spec)
"
-------------------------------------------------------------------------
"pkgs = self.yum_base.returnPackagesByDep(pkgspec)  \
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import tempfile, import contextlib, import rpm, import yum, import re, import errno, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63713, 65575"
-------------------------------------------------------------------------
=========================================================================
"pkgs = self.yum_base.returnPackagesByDep(req_spec)  \
    self.yum_base.returnInstalledPackagesByDep(req_spec)
, _ = self.yum_base.pkgSack.matchPackageNames([req_spec])
, _ = self.yum_base.rpmdb.matchPackageNames([req_spec])
"
-------------------------------------------------------------------------
"pkgs = self.yum_base.returnPackagesByDep(req_spec)  \
    self.yum_base.returnInstalledPackagesByDep(req_spec)
, _ = self.yum_base.pkgSack.matchPackageNames([req_spec])
, _ = self.yum_base.rpmdb.matchPackageNames([req_spec])
"
-------------------------------------------------------------------------
"pkgs = self.yum_base.returnPackagesByDep(req_spec)  \
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import tempfile, import contextlib, import rpm, import yum, import re, import errno, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63713, 65575"
-------------------------------------------------------------------------
=========================================================================
"if self.yum_base.conf.proxy and self.yum_base.conf.proxy not in (""_none_"",):
    if self.yum_base.conf.proxy_username:
        namepass = namepass  self.yum_base.conf.proxy_username
        proxy_url = self.yum_base.conf.proxy
        if self.yum_base.conf.proxy_password:
namepass = namepass  "":""  self.yum_base.conf.proxy_password
    elif '@' in self.yum_base.conf.proxy:
        namepass = self.yum_base.conf.proxy.split('@')[0].split('//')[-1]
        proxy_url = self.yum_base.conf.proxy.replace(""{0}@"".format(namepass), """")
"
-------------------------------------------------------------------------
"if self.yum_base.conf.proxy and self.yum_base.conf.proxy not in (""_none_"",):
    if self.yum_base.conf.proxy_username:
        namepass = namepass  self.yum_base.conf.proxy_username
        proxy_url = self.yum_base.conf.proxy
        if self.yum_base.conf.proxy_password:
namepass = namepass  "":""  self.yum_base.conf.proxy_password
    elif '@' in self.yum_base.conf.proxy:
        namepass = self.yum_base.conf.proxy.split('@')[0].split('//')[-1]
        proxy_url = self.yum_base.conf.proxy.replace(""{0}@"".format(namepass), """")
"
-------------------------------------------------------------------------
"pkgs = self.yum_base.returnPackagesByDep(req_spec)  \
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import tempfile, import contextlib, import rpm, import yum, import re, import errno, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63713, 65575"
-------------------------------------------------------------------------
=========================================================================
"os.environ[item  ""_proxy""] = self.yum_base.conf.proxy
"
-------------------------------------------------------------------------
"os.environ[item  ""_proxy""] = self.yum_base.conf.proxy
"
-------------------------------------------------------------------------
"if self.yum_base.conf.proxy and self.yum_base.conf.proxy not in (""_none_"",):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import tempfile, import contextlib, import rpm, import yum, import re, import errno, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63713, 65575"
-------------------------------------------------------------------------
=========================================================================
"self._yum_base = None  # previous YumBase package index is now invalid
"
-------------------------------------------------------------------------
"self._yum_base = None  # previous YumBase Package Index is now invalid
"
-------------------------------------------------------------------------
"os.environ[item  ""_proxy""] = self.yum_base.conf.proxy
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import tempfile, import contextlib, import rpm, import yum, import re, import errno, import os
Make sure statements concerning these methods are incorporated into the stable script - ,self
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63713, 65575"
-------------------------------------------------------------------------
=========================================================================
"try: self.yum_base.repos.disableRepo(disablerepo)
try: self.yum_base.repos.enableRepo(enablerepo)
"
-------------------------------------------------------------------------
"try: self.yum_base.repos.disableRepo(disablerepo)
try: self.yum_base.repos.enableRepo(enablerepo)
"
-------------------------------------------------------------------------
"self._yum_base = None  # previous YumBase package index is now invalid
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import tempfile, import contextlib, import rpm, import yum, import re, import errno, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63713, 65575"
-------------------------------------------------------------------------
=========================================================================
"current_repos = self.yum_base.repos.repos.keys()
        new_repos = self.yum_base.repos.repos.keys()
rid = self.yum_base.repos.getRepo(i)
"
-------------------------------------------------------------------------
"current_repos = self.yum_base.repos.repos.keys()
        new_repos = self.yum_base.repos.repos.keys()
rid = self.yum_base.repos.getRepo(i)
"
-------------------------------------------------------------------------
"try: self.yum_base.repos.disableRepo(disablerepo)
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import tempfile, import contextlib, import rpm, import yum, import re, import errno, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63713, 65575"
-------------------------------------------------------------------------
=========================================================================
"yum_plugins = self.yum_base.plugins._plugins
"
-------------------------------------------------------------------------
"yum_plugins = self.yum_base.plugins._plugins
"
-------------------------------------------------------------------------
"current_repos = self.yum_base.repos.repos.keys()
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import tempfile, import contextlib, import rpm, import yum, import re, import errno, import os
Make sure statements concerning these methods are incorporated into the stable script - ,self
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63713, 65575"
-------------------------------------------------------------------------
=========================================================================
"runners = self._gitlab.runners.all(as_list=False)
    if (runner['description'] == description):
return self._gitlab.runners.get(runner['id'])
"
-------------------------------------------------------------------------
"runners = self._gitlab.runners.all(as_list=False)
    if (runner['description'] == description):
return self._gitlab.runners.get(runner.id=runner.id)
"
-------------------------------------------------------------------------
"runners = self._gitlab.runners.all(as_list=False)
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback, import __future__, import re, import gitlab, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 65176, 65546"
-------------------------------------------------------------------------
=========================================================================
"runners = self._gitlab.runners.all(as_list=False)
    if (runner['description'] == description):
return self._gitlab.runners.get(runner['id'])
"
-------------------------------------------------------------------------
"runners = self._gitlab.runners.all(as_list=False)
    if (runner['description'] == description):
return self._gitlab.runners.get(runner.id=runner.id)
"
-------------------------------------------------------------------------
"runners = self._gitlab.runners.all(as_list=False)
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback, import __future__, import re, import gitlab, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 65176, 65545"
-------------------------------------------------------------------------
=========================================================================
"target = (
    pair.get('UserId', None),
    pair.get('GroupId', None),
    pair.get('GroupName', None),
)
"
-------------------------------------------------------------------------
"target = (
    pair.get('Description'='Description'),
    pair.get('Description'='Description'),
    pair.get('Description'='Description'),
)
"
-------------------------------------------------------------------------
"target = (
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import itertools, import json, import collections, import re, import time, import copy
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 62374, 65510"
-------------------------------------------------------------------------
=========================================================================
"self.roles[:0] = roles

return self.roles
"
-------------------------------------------------------------------------
"self.roles[:0] = irules

return self.roles
"
-------------------------------------------------------------------------
"self.roles[:0] = roles
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import ansible, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,self,irules
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 65063, 65493"
-------------------------------------------------------------------------
=========================================================================
"query = (""SELECT 1 FROM pg_tables ""
         ""WHERE tablename = %(obj_name)s ""
         ""AND tableowner = %(role)s"")
         ""WHERE d.datname = %(obj_name)s ""
         ""AND r.rolname = %(role)s"")
         ""WHERE f.proname = %(obj_name)s ""
         ""AND r.rolname = %(role)s"")
         ""WHERE c.relkind = 'S' AND c.relname = %(obj_name)s ""
         ""AND r.rolname = %(role)s"")
         ""WHERE schema_name = %(obj_name)s ""
         ""AND schema_owner = %(role)s"")
         ""WHERE t.spcname = %(obj_name)s ""
         ""AND r.rolname = %(role)s"")
         ""WHERE viewname = %(obj_name)s ""
         ""AND viewowner = %(role)s"")
         ""WHERE matviewname = %(obj_name)s ""
         ""AND matviewowner = %(role)s"")
y_params = {'obj_name': self.obj_name, 'role': self.role}
rn exec_sql(self, query, query_params, add_to_executed=False)
"
-------------------------------------------------------------------------
"_query = (""SELECT 1 FROM pg_tables ""
         ""WHERE tablename = %(obj_name)s ""
         ""AND tableowner = %(role)s"")
         ""WHERE d.datname = %(obj_name)s ""
         ""AND r.rolname = %(role)s"")
         ""WHERE f.proname = %(obj_name)s ""
         ""AND r.rolname = %(role)s"")
         ""WHERE c.relkind = 'S' AND c.relname = %(obj_name)s ""
         ""AND r.rolname = %(role)s"")
         ""WHERE schema_name = %(obj_name)s ""
         ""AND schema_owner = %(role)s"")
         ""WHERE t.spcname = %(obj_name)s ""
         ""AND r.rolname = %(role)s"")
         ""WHERE viewname = %(obj_name)s ""
         ""AND viewowner = %(role)s"")
         ""WHERE matviewname = %(obj_name)s ""
         ""AND matviewowner = %(role)s"")
y_params = {'obj_name': self.obj_name, 'role': self.role}
rn exec_sql(self, query, query_params, add_to_executed=False)
"
-------------------------------------------------------------------------
"query = (""SELECT 1 FROM pg_tables ""
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 65310, 65322"
-------------------------------------------------------------------------
=========================================================================
"query_params = {'role': role}
query = ""SELECT 1 FROM pg_roles WHERE rolname = %(role)s""
return exec_sql(self, query, query_params, add_to_executed=False)
"
-------------------------------------------------------------------------
"query_params = {'role': role}
_query = ""SELECT 1 FROM pg_roles WHERE rolname = %(role)s""
return exec_sql(self, query, query_params, add_to_executed=False)
"
-------------------------------------------------------------------------
"query_params = {'role': role}
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,query,exec_sql,query_params,role,self
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 65310, 65322"
-------------------------------------------------------------------------
=========================================================================
"'wait_timeout': {'type': 'int', 'default': 20},
s KubernetesAnsibleScaleModule(KubernetesAnsibleModule):

def __init__(self, k8s_kind=None, *args, **kwargs):
self.client = None
self.warnings = []

mutually_exclusive = [
('resource_definition', 'src'),
]

KubernetesAnsibleModule.__init__(self, *args,
 mutually_exclusive=mutually_exclusive,
 supports_check_mode=True,
 **kwargs)
self.kind = k8s_kind or self.params.get('kind')
self.api_version = self.params.get('api_version')
self.name = self.params.get('name')
self.namespace = self.params.get('namespace')
resource_definition = self.params.get('resource_definition')

if resource_definition:
if isinstance(resource_definition, string_types):
try:
self.resource_definitions = yaml.safe_load_all(resource_definition)
except (IOError, yaml.YAMLError) as exc:
self.fail(msg=""Error loading resource_definition: {0}"".format(exc))
elif isinstance(resource_definition, list):
self.resource_definitions = resource_definition
else:
self.resource_definitions = [resource_definition]
src = self.params.get('src')
if src:
self.resource_definitions = self.load_resource_definitions(src)

if not resource_definition and not src:
implicit_definition = dict(
kind=self.kind,
apiVersion=self.api_version,
metadata=dict(name=self.name)
)
if self.namespace:
implicit_definition['metadata']['namespace'] = self.namespace
self.resource_definitions = [implicit_definition]
"
-------------------------------------------------------------------------
"'wait_timeout': {'type': 'int', 'default': 20},
s KubernetesAnsibleScaleModule(KubernetesAnsibleModule):

def __init__(self, k8s_kind=None, *args, **kwargs):
self.client = None
self.warnings = []

mutually_exclusive = [
('resource_definition', 'src'),
]

KubernetesAnsibleModule.__init__(self, *args,
 mutually_exclusive=mutually_exclusive,
 supports_check_mode=True,
 **kwargs)
self.kind = k8s_kind or self.params.get('wait_timeout'='wait_timeout')
self.api_version = self.params.get('wait_timeout'='wait_timeout')
self.name = self.params.get('wait_timeout'='wait_timeout')
self.namespace = self.params.get('wait_timeout'='wait_timeout')
resource_definition = self.params.get('wait_timeout'='wait_timeout')

if resource_definition:
if isinstance(resource_definition, string_types):
try:
self.resource_definitions = yaml.safe_load_all(resource_definition)
except (IOError, yaml.YAMLError) as exc:
self.fail(msg=""Error loading resource_definition: {0}"".format(exc))
elif isinstance(resource_definition, list):
self.resource_definitions = resource_definition
else:
self.resource_definitions = [resource_definition]
src = self.params.get('wait_timeout'='wait_timeout')
if src:
self.resource_definitions = self.load_resource_definitions(src)

if not resource_definition and not src:
implicit_definition = dict(
kind=self.kind,
apiVersion=self.api_version,
metadata=dict(name=self.name)
)
if self.namespace:
implicit_definition['metadata']['namespace'] = self.namespace
self.resource_definitions = [implicit_definition]
"
-------------------------------------------------------------------------
"'wait_timeout': {'type': 'int', 'default': 20},
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import math, import __future__, import time, import openshift, import copy
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 59887, 65271"
-------------------------------------------------------------------------
=========================================================================
"'wait_timeout': {'type': 'int', 'default': 20},
s KubernetesAnsibleScaleModule(KubernetesAnsibleModule):

def __init__(self, k8s_kind=None, *args, **kwargs):
self.client = None
self.warnings = []

mutually_exclusive = [
('resource_definition', 'src'),
]

KubernetesAnsibleModule.__init__(self, *args,
 mutually_exclusive=mutually_exclusive,
 supports_check_mode=True,
 **kwargs)
self.kind = k8s_kind or self.params.get('kind')
self.api_version = self.params.get('api_version')
self.name = self.params.get('name')
self.namespace = self.params.get('namespace')
resource_definition = self.params.get('resource_definition')

if resource_definition:
if isinstance(resource_definition, string_types):
try:
self.resource_definitions = yaml.safe_load_all(resource_definition)
except (IOError, yaml.YAMLError) as exc:
self.fail(msg=""Error loading resource_definition: {0}"".format(exc))
elif isinstance(resource_definition, list):
self.resource_definitions = resource_definition
else:
self.resource_definitions = [resource_definition]
src = self.params.get('src')
if src:
self.resource_definitions = self.load_resource_definitions(src)

if not resource_definition and not src:
implicit_definition = dict(
kind=self.kind,
apiVersion=self.api_version,
metadata=dict(name=self.name)
)
if self.namespace:
implicit_definition['metadata']['namespace'] = self.namespace
self.resource_definitions = [implicit_definition]
"
-------------------------------------------------------------------------
"'wait_timeout': {'type': 'int', 'default': 20},
s KubernetesAnsibleScaleModule(KubernetesAnsibleModule):

def __init__(self, k8s_kind=None, *args, **kwargs):
self.client = None
self.warnings = []

mutually_exclusive = [
('resource_definition', 'src'),
]

KubernetesAnsibleModule.__init__(self, *args,
 mutually_exclusive=mutually_exclusive,
 supports_check_mode=True,
 **kwargs)
self.kind = k8s_kind or self.params.get('wait_timeout'='wait_timeout')
self.api_version = self.params.get('wait_timeout'='wait_timeout')
self.name = self.params.get('wait_timeout'='wait_timeout')
self.namespace = self.params.get('wait_timeout'='wait_timeout')
resource_definition = self.params.get('wait_timeout'='wait_timeout')

if resource_definition:
if isinstance(resource_definition, string_types):
try:
self.resource_definitions = yaml.safe_load_all(resource_definition)
except (IOError, yaml.YAMLError) as exc:
self.fail(msg=""Error loading resource_definition: {0}"".format(exc))
elif isinstance(resource_definition, list):
self.resource_definitions = resource_definition
else:
self.resource_definitions = [resource_definition]
src = self.params.get('wait_timeout'='wait_timeout')
if src:
self.resource_definitions = self.load_resource_definitions(src)

if not resource_definition and not src:
implicit_definition = dict(
kind=self.kind,
apiVersion=self.api_version,
metadata=dict(name=self.name)
)
if self.namespace:
implicit_definition['metadata']['namespace'] = self.namespace
self.resource_definitions = [implicit_definition]
"
-------------------------------------------------------------------------
"'wait_timeout': {'type': 'int', 'default': 20},
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import math, import __future__, import time, import openshift, import copy
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 59887, 65270"
-------------------------------------------------------------------------
=========================================================================
"if not self.existing_network:
    return False
"
-------------------------------------------------------------------------
"if not self.existing_network:
    return False
"
-------------------------------------------------------------------------
"if not self.existing_network:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import docker, import traceback, import __future__, import re
Make sure statements concerning these methods are incorporated into the stable script - ,self
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 65018, 65235"
-------------------------------------------------------------------------
=========================================================================
"if not self.existing_network:
    return False
"
-------------------------------------------------------------------------
"if not self.existing_network:
    return False
"
-------------------------------------------------------------------------
"if not self.existing_network:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import docker, import traceback, import __future__, import re
Make sure statements concerning these methods are incorporated into the stable script - ,self
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 65018, 65234"
-------------------------------------------------------------------------
=========================================================================
"filter_xml = '''<filter type=""subtree"">
  <system xmlns=""http://www.huawei.com/netconf/vrp"" content-version=""1.0"" format-version=""1.0"">
    <systemInfo>
      <sysName></sysName>
      <sysContact></sysContact>
      <productVer></productVer>
      <platformVer></platformVer>
      <productName></productName>
    </systemInfo>
  </system>
</filter>'''
data = self.get(filter_xml)
data = re.sub(r'xmlns="".?""', r'', data)
reply = fromstring(to_bytes(data, errors='surrogate_or_strict'))
sw_info = reply.find('.//systemInfo')

device_info['network_os_version'] = self.get_text(sw_info, 'productVer')
device_info['network_os_hostname'] = self.get_text(sw_info, 'sysName')
device_info['network_os_platform_version'] = self.get_text(sw_info, 'platformVer')
device_info['network_os_platform'] = self.get_text(sw_info, 'productName')
"
-------------------------------------------------------------------------
"filter_xml = '''<filter type=""subtree"">
  <system xmlns=""http://www.huawei.com/netconf/vrp"" content-version=""1.0"" format-version=""1.0"">
    <systemInfo>
      <sysName></sysName>
      <sysContact></sysContact>
      <productVer></productVer>
      <platformVer></platformVer>
      <productName></productName>
    </systemInfo>
  </system>
</filter>'''
data = self.get(filter_xml)
data = re.sub(r'xmlns="".?""', r'', data)
reply = fromstring(to_bytes(data, errors='surrogate_or_strict'))
sw_info = reply.find('.//software-information'='.//software-information')

device_info['network_os_version'] = self.get_text(sw_info=sw_info, 'product-model'='product-model')
device_info['network_os_hostname'] = self.get_text(sw_info=sw_info, 'product-model'='product-model')
device_info['network_os_platform_version'] = self.get_text(sw_info=sw_info, 'product-model'='product-model')
device_info['network_os_platform'] = self.get_text(sw_info=sw_info, 'product-model'='product-model')
"
-------------------------------------------------------------------------
"filter_xml = '''<filter type=""subtree"">
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import ncclient, import __future__, import json, import re
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 65065, 65232"
-------------------------------------------------------------------------
=========================================================================
"filter_xml = '''<filter type=""subtree"">
  <system xmlns=""http://www.huawei.com/netconf/vrp"" content-version=""1.0"" format-version=""1.0"">
    <systemInfo>
      <sysName></sysName>
      <sysContact></sysContact>
      <productVer></productVer>
      <platformVer></platformVer>
      <productName></productName>
    </systemInfo>
  </system>
</filter>'''
data = self.get(filter_xml)
data = re.sub(r'xmlns="".?""', r'', data)
reply = fromstring(to_bytes(data, errors='surrogate_or_strict'))
sw_info = reply.find('.//systemInfo')

device_info['network_os_version'] = self.get_text(sw_info, 'productVer')
device_info['network_os_hostname'] = self.get_text(sw_info, 'sysName')
device_info['network_os_platform_version'] = self.get_text(sw_info, 'platformVer')
device_info['network_os_platform'] = self.get_text(sw_info, 'productName')
"
-------------------------------------------------------------------------
"filter_xml = '''<filter type=""subtree"">
  <system xmlns=""http://www.huawei.com/netconf/vrp"" content-version=""1.0"" format-version=""1.0"">
    <systemInfo>
      <sysName></sysName>
      <sysContact></sysContact>
      <productVer></productVer>
      <platformVer></platformVer>
      <productName></productName>
    </systemInfo>
  </system>
</filter>'''
data = self.get(filter_xml)
data = re.sub(r'xmlns="".?""', r'', data)
reply = fromstring(to_bytes(data, errors='surrogate_or_strict'))
sw_info = reply.find('.//software-information'='.//software-information')

device_info['network_os_version'] = self.get_text(sw_info=sw_info, 'product-model'='product-model')
device_info['network_os_hostname'] = self.get_text(sw_info=sw_info, 'product-model'='product-model')
device_info['network_os_platform_version'] = self.get_text(sw_info=sw_info, 'product-model'='product-model')
device_info['network_os_platform'] = self.get_text(sw_info=sw_info, 'product-model'='product-model')
"
-------------------------------------------------------------------------
"filter_xml = '''<filter type=""subtree"">
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import ncclient, import __future__, import json, import re
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 65065, 65231"
-------------------------------------------------------------------------
=========================================================================
"def has_list_changed(new_list, old_list, sort_lists=True, sort_key=None):
Check two lists have differences. Sort lists by default.

def sort_list(unsorted_list):
""""""
Sort a given list.
The list may contain dictionaries, so use the sort key to handle them.
""""""

if unsorted_list and isinstance(unsorted_list[0], dict):
if not sort_key:
raise Exception(
'A sort key was not specified when sorting list'
)
else:
return sorted(unsorted_list, key=lambda k: k[sort_key])

# Either the list is empty or does not contain dictionaries
try:
return sorted(unsorted_list)
except TypeError:
return unsorted_list


if sort_lists:
zip_data = zip(sort_list(new_list), sort_list(old_list))
else:
zip_data = zip(new_list, old_list)
for new_item, old_item in zip_data:
if isinstance(new_item, string_types) and isinstance(old_item, string_types):
# Even though the types are different between these items,
# they are both strings. Try matching on the same string type.
try:
new_item_type = type(new_item)
old_item_casted = new_item_type(old_item)
if new_item != old_item_casted:
return True
else:
continue
except UnicodeEncodeError:
# Fallback to assuming the strings are different
return True
else:
return True
"
-------------------------------------------------------------------------
"def has_list_changed(new_list, old_list, sort_lists=True, sort_key=None):
check two lists have differences. Sort lists by default

def sort_list(unsorted_list):
""""""
Sort a given lists
The lists may contains dictionaries, so use the tsort key to handler them.
""""""

if unsorted_list and isinstance(unsorted_list[0], dict):
if not sort_key:
raise Exception(
'A tsort key was not specified when sorting lists
)
else:
return sorted(unsorted_list, key=lambda k: k[sort_key])

# Either the lists is empty or does not contains dictionaries
try:
return sorted(unsorted_list)
except TypeError:
return unsorted_list


if sort_lists:
zip_data = zip(sort_list(new_list), sort_list(old_list))
else:
zip_data = zip(new_list, old_list)
for new_item, old_item in zip_data:
if isinstance(new_item, string_types) and isinstance(old_item, string_types):
# Even though the types are different between these items,
# they are both strings. Try matching on the same stringc type.
try:
new_item_type = type(new_item)
old_item_casted = new_item_type(old_item)
if new_item != old_item_casted:
return True
else:
continue
except UnicodeEncodeError:
# callback to assuming the stringc are different
return True
else:
return True
"
-------------------------------------------------------------------------
"def has_list_changed(new_list, old_list, sort_lists=True, sort_key=None):
Check two lists have differences. Sort lists by default.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import pytest
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63887, 65221"
-------------------------------------------------------------------------
=========================================================================
"def have_networks_changed(new_networks, old_networks):
""""""Special case list checking for networks to sort aliases""""""

if new_networks is None:
return False
old_networks = old_networks or []
if len(new_networks) != len(old_networks):
return True

zip_data = zip(
sorted(new_networks, key=lambda k: k['id']),
sorted(old_networks, key=lambda k: k['id'])
)

for new_item, old_item in zip_data:
new_item = dict(new_item)
old_item = dict(old_item)
# Sort the aliases
if 'aliases' in new_item:
new_item['aliases'] = sorted(new_item['aliases'] or [])
if 'aliases' in old_item:
old_item['aliases'] = sorted(old_item['aliases'] or [])

if has_dict_changed(new_item, old_item):
return True

return False


"
-------------------------------------------------------------------------
"def have_networks_changed(new_networks, old_networks):
""""""Special case lists checking for Network to tsort aliases""""""

if new_networks is None:
return False
old_networks = old_networks or []
if len(new_networks) != len(old_networks):
return True

zip_data = zip(
sorted(new_networks, key=lambda k: k['id']),
sorted(old_networks, key=lambda k: k['id'])
)

for new_item, old_item in zip_data:
new_item = dict(new_item)
old_item = dict(old_item)
# Sort the aliases
if 'aliases' in new_item:
new_item['aliases'] = sorted(new_item['aliases'] or [])
if 'aliases' in old_item:
old_item['aliases'] = sorted(old_item['aliases'] or [])

if has_dict_changed(new_item, old_item):
return True

return False


"
-------------------------------------------------------------------------
"def have_networks_changed(new_networks, old_networks):
""""""Special case list checking for networks to sort aliases""""""
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import pytest
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63887, 65221"
-------------------------------------------------------------------------
=========================================================================
"if has_list_changed(self.mounts, os.mounts, sort_key='target'):
if has_list_changed(self.configs, os.configs, sort_key='config_name'):
if has_list_changed(self.secrets, os.secrets, sort_key='secret_name'):
if have_networks_changed(self.networks, os.networks):
if has_list_changed(self.command, os.command, sort_lists=False):
if has_list_changed(self.args, os.args, sort_lists=False):
if has_list_changed(self.constraints, os.constraints):
if has_list_changed(self.placement_preferences, os.placement_preferences, sort_lists=False):
if has_list_changed(self.groups, os.groups):
"
-------------------------------------------------------------------------
"if has_list_changed(self.mounts, os.mounts, sort_key='target'):
if has_list_changed(self.configs, os.configs, sort_key='config_name'):
if has_list_changed(self.secrets, os.secrets, sort_key='secret_name'):
if have_networks_changed(self.networks, os.networks):
if has_list_changed(self.command, os.command, sort_lists=False):
if has_list_changed(self.args, os.args, sort_lists=False):
if has_list_changed(self.constraints, os.constraints):
if has_list_changed(self.placement_preferences, os.placement_preferences, sort_lists=False):
if has_list_changed(self.groups, os.groups):
"
-------------------------------------------------------------------------
"if has_list_changed(self.mounts, os.mounts, sort_key='target'):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import pytest
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63887, 65221"
-------------------------------------------------------------------------
=========================================================================
"if has_list_changed(self.dns, os.dns, sort_lists=False):
if has_list_changed(self.dns_search, os.dns_search, sort_lists=False):
if has_list_changed(self.dns_options, os.dns_options):
"
-------------------------------------------------------------------------
"if has_list_changed(self.dns, os.dns, sort_lists=False):
if has_list_changed(self.dns_search, os.dns_search, sort_lists=False):
if has_list_changed(self.dns_options, os.dns_options):
"
-------------------------------------------------------------------------
"if has_list_changed(self.dns, os.dns, sort_lists=False):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import pytest
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63887, 65221"
-------------------------------------------------------------------------
=========================================================================
"
# List comparisons without dictionaries
# I could improve the indenting, but pycodestyle wants this instead
assert not docker_swarm_service.has_list_changed(None, None)
assert not docker_swarm_service.has_list_changed(None, [])
assert not docker_swarm_service.has_list_changed(None, [1, 2])

assert not docker_swarm_service.has_list_changed([], None)
assert not docker_swarm_service.has_list_changed([], [])
assert docker_swarm_service.has_list_changed([], [1, 2])

assert docker_swarm_service.has_list_changed([1, 2], None)
assert docker_swarm_service.has_list_changed([1, 2], [])

assert docker_swarm_service.has_list_changed([1, 2, 3], [1, 2])
assert docker_swarm_service.has_list_changed([1, 2], [1, 2, 3])

# Check list sorting
assert not docker_swarm_service.has_list_changed([1, 2], [2, 1])
[1, 2],
[2, 1],
sort_lists=False

# Check type matching
assert docker_swarm_service.has_list_changed([None, 1], [2, 1])
assert docker_swarm_service.has_list_changed([2, 1], [None, 1])
""command --with args"",
['command', '--with', 'args']
['sleep', '3400'],
[u'sleep', u'3600'],
sort_lists=False

# List comparisons with dictionaries
[{'a': 1}],
[{'a': 1}],
sort_key='a'

[{'a': 1}, {'a': 2}],
[{'a': 1}, {'a': 2}],
sort_key='a'

with pytest.raises(Exception):
docker_swarm_service.has_list_changed(
[{'a': 1}, {'a': 2}],
[{'a': 1}, {'a': 2}]
)

# List sort checking with sort key
[{'a': 1}, {'a': 2}],
[{'a': 2}, {'a': 1}],
sort_key='a'
)
assert docker_swarm_service.has_list_changed(
[{'a': 1}, {'a': 2}],
[{'a': 2}, {'a': 1}],
sort_lists=False
)

assert docker_swarm_service.has_list_changed(
[{'a': 1}, {'a': 2}, {'a': 3}],
[{'a': 2}, {'a': 1}],
sort_key='a'
)
assert docker_swarm_service.has_list_changed(
[{'a': 1}, {'a': 2}],
[{'a': 1}, {'a': 2}, {'a': 3}],
sort_lists=False

# Additional dictionary elements
"
-------------------------------------------------------------------------
"
# List comparisons without dictionaries
# I could improve the indenting, but pycodestyle wants this instead
assert not docker_swarm_service.has_list_changed([{'id': '123'=[{'id': '123', 'aliases': []}]='aliases': []}], [{'id': '123'}]=[{'id': '123'}])
assert not docker_swarm_service.has_list_changed([{'id': '123'=[{'id': '123', 'aliases': []}]='aliases': []}], [{'id': '123'}]=[{'id': '123'}])
assert not docker_swarm_service.has_list_changed([{'id': '123'=[{'id': '123', 'aliases': []}]='aliases': []}], [{'id': '123'}]=[{'id': '123'}])

assert not docker_swarm_service.has_list_changed([{'id': '123'=[{'id': '123', 'aliases': []}]='aliases': []}], [{'id': '123'}]=[{'id': '123'}])
assert not docker_swarm_service.has_list_changed([{'id': '123'=[{'id': '123', 'aliases': []}]='aliases': []}], [{'id': '123'}]=[{'id': '123'}])
assert docker_swarm_service.has_list_changed([{'id': '123'=[{'id': '123', 'aliases': []}]='aliases': []}], [{'id': '123'}]=[{'id': '123'}])

assert docker_swarm_service.has_list_changed([{'id': '123'=[{'id': '123', 'aliases': []}]='aliases': []}], [{'id': '123'}]=[{'id': '123'}])
assert docker_swarm_service.has_list_changed([{'id': '123'=[{'id': '123', 'aliases': []}]='aliases': []}], [{'id': '123'}]=[{'id': '123'}])

assert docker_swarm_service.has_list_changed([{'id': '123'=[{'id': '123', 'aliases': []}]='aliases': []}], [{'id': '123'}]=[{'id': '123'}])
assert docker_swarm_service.has_list_changed([{'id': '123'=[{'id': '123', 'aliases': []}]='aliases': []}], [{'id': '123'}]=[{'id': '123'}])

# check lists sorting
assert not docker_swarm_service.has_list_changed([{'id': '123'=[{'id': '123', 'aliases': []}]='aliases': []}], [{'id': '123'}]=[{'id': '123'}])
[1, 2],
[2, 1],
sort_lists=False

# check type matching
assert docker_swarm_service.has_list_changed([{'id': '123'=[{'id': '123', 'aliases': []}]='aliases': []}], [{'id': '123'}]=[{'id': '123'}])
assert docker_swarm_service.has_list_changed([{'id': '123'=[{'id': '123', 'aliases': []}]='aliases': []}], [{'id': '123'}]=[{'id': '123'}])
_command --with args"",
['command', '--with', 'args']
['sleep', '3400'],
[u'sleep', u'3600'],
sort_lists=False

# List comparisons with dictionaries
[{'a': 1}],
[{'a': 1}],
sort_key='a'

[{'a': 1}, {'a': 2}],
[{'a': 1}, {'a': 2}],
sort_key='a'

with pytest.raises(TypeError=TypeError):
docker_swarm_service.has_list_changed(
[{'a': 1}, {'a': 2}],
[{'a': 1}, {'a': 2}]
)

# List tsort checking with tsort key
[{'a': 1}, {'a': 2}],
[{'a': 2}, {'a': 1}],
sort_key='a'
)
assert docker_swarm_service.has_list_changed(
[{'a': 1}, {'a': 2}],
[{'a': 2}, {'a': 1}],
sort_lists=False
)

assert docker_swarm_service.has_list_changed(
[{'a': 1}, {'a': 2}, {'a': 3}],
[{'a': 2}, {'a': 1}],
sort_key='a'
)
assert docker_swarm_service.has_list_changed(
[{'a': 1}, {'a': 2}],
[{'a': 1}, {'a': 2}, {'a': 3}],
sort_lists=False

# Additional dictionary elements
"
-------------------------------------------------------------------------
"
# List comparisons without dictionaries
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import pytest
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63887, 65221"
-------------------------------------------------------------------------
=========================================================================
"],
sort_key='dst'
"
-------------------------------------------------------------------------
"],
sort_key='dst'
"
-------------------------------------------------------------------------
"],
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import pytest
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63887, 65221"
-------------------------------------------------------------------------
=========================================================================
"],
sort_key='dst'
"
-------------------------------------------------------------------------
"],
sort_key='dst'
"
-------------------------------------------------------------------------
"],
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import pytest
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63887, 65221"
-------------------------------------------------------------------------
=========================================================================
"],
sort_key='dst'
"
-------------------------------------------------------------------------
"],
sort_key='dst'
"
-------------------------------------------------------------------------
"],
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import pytest
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63887, 65221"
-------------------------------------------------------------------------
=========================================================================
"],
sort_key='dst'
"
-------------------------------------------------------------------------
"],
sort_key='dst'
"
-------------------------------------------------------------------------
"],
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import pytest
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63887, 65221"
-------------------------------------------------------------------------
=========================================================================
"],
sort_key='dst'
[{'id': '123'}],
sort_key='id'



_have_networks_changed(docker_swarm_service):
rt not docker_swarm_service.have_networks_changed(
None,
None


rt not docker_swarm_service.have_networks_changed(
[],
None


rt not docker_swarm_service.have_networks_changed(
[{'id': 1}],
[{'id': 1}]


rt docker_swarm_service.have_networks_changed(
[{'id': 1}],
[{'id': 1}, {'id': 2}]


rt not docker_swarm_service.have_networks_changed(
[{'id': 1}, {'id': 2}],
[{'id': 1}, {'id': 2}]


rt not docker_swarm_service.have_networks_changed(
[{'id': 1}, {'id': 2}],
[{'id': 2}, {'id': 1}]


rt not docker_swarm_service.have_networks_changed(
[
    {'id': 1},
    {'id': 2, 'aliases': []}
],
[
    {'id': 1},
    {'id': 2}
]


rt docker_swarm_service.have_networks_changed(
[
    {'id': 1},
    {'id': 2, 'aliases': ['alias1']}
],
[
    {'id': 1},
    {'id': 2}
]


rt docker_swarm_service.have_networks_changed(
[
    {'id': 1},
    {'id': 2, 'aliases': ['alias1', 'alias2']}
],
[
    {'id': 1},
    {'id': 2, 'aliases': ['alias1']}
]


rt not docker_swarm_service.have_networks_changed(
[
    {'id': 1},
    {'id': 2, 'aliases': ['alias1', 'alias2']}
],
[
    {'id': 1},
    {'id': 2, 'aliases': ['alias1', 'alias2']}
]


rt not docker_swarm_service.have_networks_changed(
[
    {'id': 1},
    {'id': 2, 'aliases': ['alias1', 'alias2']}
],
[
    {'id': 1},
    {'id': 2, 'aliases': ['alias2', 'alias1']}
]


rt not docker_swarm_service.have_networks_changed(
[
    {'id': 1, 'options': {}},
    {'id': 2, 'aliases': ['alias1', 'alias2']}],
[
    {'id': 1},
    {'id': 2, 'aliases': ['alias2', 'alias1']}
]


rt not docker_swarm_service.have_networks_changed(
[
    {'id': 1, 'options': {'option1': 'value1'}},
    {'id': 2, 'aliases': ['alias1', 'alias2']}],
[
    {'id': 1, 'options': {'option1': 'value1'}},
    {'id': 2, 'aliases': ['alias2', 'alias1']}
]


rt docker_swarm_service.have_networks_changed(
[
    {'id': 1, 'options': {'option1': 'value1'}},
    {'id': 2, 'aliases': ['alias1', 'alias2']}],
[
    {'id': 1, 'options': {'option1': 'value2'}},
    {'id': 2, 'aliases': ['alias2', 'alias1']}
]
"
-------------------------------------------------------------------------
"],
sort_key='dst'
[{'id': '123'}],
sort_key='id'



_have_networks_changed(docker_swarm_service):
rt not docker_swarm_service.have_networks_changed(
None,
None


rt not docker_swarm_service.have_networks_changed(
[],
None


rt not docker_swarm_service.have_networks_changed(
[{'id': 1}],
[{'id': 1}]


rt docker_swarm_service.have_networks_changed(
[{'id': 1}],
[{'id': 1}, {'id': 2}]


rt not docker_swarm_service.have_networks_changed(
[{'id': 1}, {'id': 2}],
[{'id': 1}, {'id': 2}]


rt not docker_swarm_service.have_networks_changed(
[{'id': 1}, {'id': 2}],
[{'id': 2}, {'id': 1}]


rt not docker_swarm_service.have_networks_changed(
[
    {'id': 1},
    {'id': 2, 'aliases': []}
],
[
    {'id': 1},
    {'id': 2}
]


rt docker_swarm_service.have_networks_changed(
[
    {'id': 1},
    {'id': 2, 'aliases': ['alias1']}
],
[
    {'id': 1},
    {'id': 2}
]


rt docker_swarm_service.have_networks_changed(
[
    {'id': 1},
    {'id': 2, 'aliases': ['alias1', 'alias2']}
],
[
    {'id': 1},
    {'id': 2, 'aliases': ['alias1']}
]


rt not docker_swarm_service.have_networks_changed(
[
    {'id': 1},
    {'id': 2, 'aliases': ['alias1', 'alias2']}
],
[
    {'id': 1},
    {'id': 2, 'aliases': ['alias1', 'alias2']}
]


rt not docker_swarm_service.have_networks_changed(
[
    {'id': 1},
    {'id': 2, 'aliases': ['alias1', 'alias2']}
],
[
    {'id': 1},
    {'id': 2, 'aliases': ['alias2', 'alias1']}
]


rt not docker_swarm_service.have_networks_changed(
[
    {'id': 1, 'options': {}},
    {'id': 2, 'aliases': ['alias1', 'alias2']}],
[
    {'id': 1},
    {'id': 2, 'aliases': ['alias2', 'alias1']}
]


rt not docker_swarm_service.have_networks_changed(
[
    {'id': 1, 'options': {'option1': 'value1'}},
    {'id': 2, 'aliases': ['alias1', 'alias2']}],
[
    {'id': 1, 'options': {'option1': 'value1'}},
    {'id': 2, 'aliases': ['alias2', 'alias1']}
]


rt docker_swarm_service.have_networks_changed(
[
    {'id': 1, 'options': {'option1': 'value1'}},
    {'id': 2, 'aliases': ['alias1', 'alias2']}],
[
    {'id': 1, 'options': {'option1': 'value2'}},
    {'id': 2, 'aliases': ['alias2', 'alias1']}
]
"
-------------------------------------------------------------------------
"],
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import pytest
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63887, 65221"
-------------------------------------------------------------------------
=========================================================================
"elif current_condition['Field'] == condition['Field'] and current_condition['Values'] == condition['Values']:
"
-------------------------------------------------------------------------
"elif current_condition['Field'] == condition['Field'] and current_condition['Values'] == condition['Values']:
"
-------------------------------------------------------------------------
"elif current_condition['Field'] == condition['Field'] and sorted(current_condition['Values']) == sorted(condition['Values']):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - 
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 65021, 65212"
-------------------------------------------------------------------------
=========================================================================
"- Conditions:
    - Field: host-header
      Values:
        - ""hostname.domain.com""
        - ""alternate.domain.com""
  Priority: '4'
  Actions:
    - TargetGroupName: test-target-group
      Type: forward
"
-------------------------------------------------------------------------
"- Conditions:
    - Field: host-header
      Values:
        - ""hostname.domain.com""
        - ""alternate.domain.com""
  Priority: '4'
  Actions:
    - TargetGroupName: test-target-group
      Type: forward
"
-------------------------------------------------------------------------
"- Conditions:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - 
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 65021, 65212"
-------------------------------------------------------------------------
=========================================================================
"query = ""SELECT lanname FROM pg_language WHERE lanname = %(lang)s""
cursor.execute(query, {'lang': lang})
query = ""SELECT lanpltrusted FROM pg_language WHERE lanname = %(lang)s""
cursor.execute(query, {'lang': lang})
query = ""UPDATE pg_language SET lanpltrusted = %(trust)s WHERE lanname = %(lang)s""
cursor.execute(query, {'trust': trust, 'lang': lang})
executed_queries.append(cursor.mogrify(query, {'trust': trust, 'lang': lang}))
"
-------------------------------------------------------------------------
"_query = ""SELECT lanname FROM pg_language WHERE lanname = %(lang)s""
cursor.execute(""RELEASE SAVEPOINT ansible_pgsql_lang_drop""=""RELEASE SAVEPOINT ansible_pgsql_lang_drop"")
_query = ""SELECT lanpltrusted FROM pg_language WHERE lanname = %(lang)s""
cursor.execute(""RELEASE SAVEPOINT ansible_pgsql_lang_drop""=""RELEASE SAVEPOINT ansible_pgsql_lang_drop"")
_query = ""UPDATE pg_language SET lanpltrusted = %(trust)s WHERE lanname = %(lang)s""
cursor.execute(""RELEASE SAVEPOINT ansible_pgsql_lang_drop""=""RELEASE SAVEPOINT ansible_pgsql_lang_drop"")
executed_queries.append(query=query))
"
-------------------------------------------------------------------------
"query = ""SELECT lanname FROM pg_language WHERE lanname = %(lang)s""
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 65093, 65165"
-------------------------------------------------------------------------
=========================================================================
"Args:

Kwargs:
query_params (dict or tuple) -- Query parameters to prevent SQL injections,
could be a dict or tuple
dont_exec (bool) -- used with add_to_executed=True to generate a query, add it
to obj.executed_queries list and return True (default False)
if dont_exec:
# This is usually needed to return queries in check_mode
# without execution
query = obj.cursor.mogrify(query, query_params)
return True

try:
if query_params is not None:
obj.cursor.execute(query, query_params)
else:
obj.cursor.execute(query)

if add_to_executed:
if query_params is not None:
obj.executed_queries.append(obj.cursor.mogrify(query, query_params))
else:
obj.executed_queries.append(query)

"
-------------------------------------------------------------------------
"Args:

Kwargs:
query_params (dict or tuple -- _query Parameters to present SQL injections,
could be a dict or tuple
dont_exec (bool) -- used with add_to_executed=True to generate a query, add it
to obj.executed_queries lists and return True default False)
if dont_exec:
# This is usually needed to return queries in check_mode
# without execution
_query = obj.cursor.mogrify(query, query_params)
return True

try:
if query_params is not None:
obj.cursor.execute(query, query_params)
else:
obj.cursor.execute(query)

if add_to_executed:
if query_params is not None:
obj.executed_queries.append(obj.cursor.mogrify(query, query_params))
else:
obj.executed_queries.append(query)

"
-------------------------------------------------------------------------
"Args:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 64661, 65034"
-------------------------------------------------------------------------
=========================================================================
"""WHERE indexrelname = %(name)s ""
""AND schemaname = %(schema)s"")
exec_sql(self, query, query_params={'name': self.name, 'schema': self.schema},
         add_to_executed=False)
"
-------------------------------------------------------------------------
"""WHERE indexrelname = %(name)s ""
""AND schemaname = %(schema)s"")
exec_sql(self, query, query_params={'name': self.name, 'schema': self.schema},
         add_to_executed=False)
"
-------------------------------------------------------------------------
"""WHERE i.indexname = %(name)s"")
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 64661, 65034"
-------------------------------------------------------------------------
=========================================================================
"feed_ca_cert:
The ca_cert alias will be removed in Ansible 2.14.
aliases: [ importer_ssl_ca_cert, ca_cert ]
feed_client_cert:
version_added: ""2.10""
"
-------------------------------------------------------------------------
"feed_ca_cert:
The ca_cert alias will be remove in Ansible 2.14.
aliases: [ importer_ssl_ca_cert, ca_cert ]
feed_client_cert:
version_added: ""2.10""
"
-------------------------------------------------------------------------
"feed_ca_cert:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import json, import time, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 59522, 65014"
-------------------------------------------------------------------------
=========================================================================
"- If not specified the default value will come from client_cert. Which will
  change in Ansible 2.14.
_client_key:
rsion_added: ""2.10""
- If not specified the default value will come from client_key. Which will
  change in Ansible 2.14.
"
-------------------------------------------------------------------------
"- If not specified the default values will come from client_cert Which will
  changed in Ansible 2.14.
_client_key:
rsion_added: ""2.10""
- If not specified the default values will come from client_key Which will
  changed in Ansible 2.14.
"
-------------------------------------------------------------------------
"- If not specified the default value will come from client_cert. Which will
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import json, import time, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 59522, 65014"
-------------------------------------------------------------------------
=========================================================================
"feed_ca_cert=dict(aliases=['importer_ssl_ca_cert', 'ca_cert'], deprecated_aliases=[dict(name='ca_cert', version='2.14')]),
feed_client_cert=dict(aliases=['importer_ssl_client_cert']),
feed_client_key=dict(aliases=['importer_ssl_client_key']),
"
-------------------------------------------------------------------------
"feed_ca_cert=dict(aliases=['importer_ssl_ca_cert', 'ca_cert'], deprecated_aliases=[dict(name='ca_cert', version='2.14')]),
feed_client_cert=dict(aliases=['importer_ssl_client_cert']),
feed_client_key=dict(aliases=['importer_ssl_client_key']),
"
-------------------------------------------------------------------------
"feed_ca_cert=dict(aliases=['importer_ssl_ca_cert', 'ca_cert'], deprecated_aliases=[dict(name='ca_cert', version='2.14')]),
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import json, import time, import os
Make sure statements concerning these methods are incorporated into the stable script - ,dict
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 59522, 65014"
-------------------------------------------------------------------------
=========================================================================
"importer_ssl_ca_cert = module.params['feed_ca_cert']
importer_ssl_client_cert = module.params['feed_client_cert']
if importer_ssl_client_cert is None and module.params['client_cert'] is not None:
importer_ssl_client_cert = module.params['client_cert']
module.deprecate((""To specify client certificates to be used with the repo to sync, and not for communication with pulp.io, use the new options ""
  ""`feed_client_cert` and `feed_client_key` (available since Ansible 2.10). Until Ansible 2.14, the default value for ""
  ""`feed_client_cert` will be taken from `client_cert` if only the latter is specified""), version=""2.14"")
importer_ssl_client_key = module.params['feed_client_key']
if importer_ssl_client_key is None and module.params['client_key'] is not None:
importer_ssl_client_key = module.params['client_key']
module.deprecate(""In Ansible 2.10 `feed_client_key` option was added. Until 2.14 the default value will come from client_key option"", version=""2.14"")
"
-------------------------------------------------------------------------
"importer_ssl_ca_cert = module.params['feed_ca_cert']
importer_ssl_client_cert = module.params['feed_client_cert']
if importer_ssl_client_cert is None and module.params['client_cert'] is not None:
importer_ssl_client_cert = module.params['client_cert']
module.deprecate((""To specify Client Certificates to be used with the repo to sync, and not for communication with pulp.io, use the new Options ""
  ""`feed_client_cert` and `feed_client_key` (available since Ansible 2.10). Until Ansible 2.14, the default values for ""
  ""`feed_client_cert` will be taken from `client_cert` if only the latter is specified""), version=""2.14"")
importer_ssl_client_key = module.params['feed_client_key']
if importer_ssl_client_key is None and module.params['client_key'] is not None:
importer_ssl_client_key = module.params['client_key']
module.deprecate(""In Ansible 2.10 `feed_client_key` Options was added. Until 2.14 the default values will come from client_key option"", version=""2.14"")
"
-------------------------------------------------------------------------
"importer_ssl_ca_cert = module.params['feed_ca_cert']
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import json, import time, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 59522, 65014"
-------------------------------------------------------------------------
=========================================================================
"- Required when C(state=present).
ired: false
"
-------------------------------------------------------------------------
"- Required when C(state=present).
ired: false
"
-------------------------------------------------------------------------
"- Required when C(state=present).
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback, import __future__, import zabbix_api, import atexit
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63969, 64736"
-------------------------------------------------------------------------
=========================================================================
"- Required when C(state=present).
ired: false
"
-------------------------------------------------------------------------
"- Required when C(state=present).
ired: false
"
-------------------------------------------------------------------------
"- Required when C(state=present).
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback, import __future__, import zabbix_api, import atexit
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63969, 64736"
-------------------------------------------------------------------------
=========================================================================
"esc_period=dict(type='int', required=False),
event_source=dict(type='str', required=False, choices=['trigger', 'discovery', 'auto_registration', 'internal']),
"
-------------------------------------------------------------------------
"esc_period=dict(type='int', required=False),
event_source=dict(type='str', required=False, choices=['trigger', 'discovery', 'auto_registration', 'internal']),
"
-------------------------------------------------------------------------
"esc_period=dict(type='int', required=False),
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback, import __future__, import zabbix_api, import atexit
Make sure statements concerning these methods are incorporated into the stable script - ,dict
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63969, 64736"
-------------------------------------------------------------------------
=========================================================================
"required_if=[
    ['state', 'present', [
'esc_period',
'event_source'
    ]]
],
"
-------------------------------------------------------------------------
"required_if=[
    ['state', 'present', [
'esc_period',
'event_source'
    ]]
],
"
-------------------------------------------------------------------------
"required_if=[
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback, import __future__, import zabbix_api, import atexit
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63969, 64736"
-------------------------------------------------------------------------
=========================================================================
"- ""Must be 1 for the classic Let's Encrypt and Buypass ACME endpoints,
   or 2 for standardized ACME v2 endpoints.""
"
-------------------------------------------------------------------------
"- ""Must be 1 for the classic Let's Encrypt and Buypass ACME endpoints,
   or 2 for standardized ACME v2 endpoints.""
"
-------------------------------------------------------------------------
"- ""Must be 1 for the classic Let's Encrypt and Buypass ACME endpoints,
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 64649, 64680"
-------------------------------------------------------------------------
=========================================================================
"if param_m['source'] is None and param_m['type'] != 'tmpfs':
    raise ValueError('Source must be specified for mounts which are not of type tmpfs')
service_m['source'] = param_m['source'] or ''
"
-------------------------------------------------------------------------
"if param_m['source'] is None and param_m['type'] != 'tmpfs':
    raise ValueError('Source must be specified for mount which are not of type tmpfs')
service_m['source'] = param_m['source'] or ''
"
-------------------------------------------------------------------------
"if param_m['source'] is None and param_m['type'] != 'tmpfs':
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import docker, import traceback, import __future__, import shlex, import operator, import time
Make sure statements concerning these methods are incorporated into the stable script - ,param_m,ValueError,service_m
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 64637, 64641"
-------------------------------------------------------------------------
=========================================================================
"return sorted((get_dict_of_struct(opt) for opt in new_options),
      key=lambda x: x[""name""]) != sorted((get_dict_of_struct(opt) for opt in old_options),
 key=lambda x: x[""name""])
"
-------------------------------------------------------------------------
"return sorted((get_dict_of_struct(opt) for opt in new_options),
      key=lambda x: x[""name""]) != sorted((get_dict_of_struct(opt) for opt in old_options),
 key=lambda x: x[""name""])
"
-------------------------------------------------------------------------
"return sorted((get_dict_of_struct(opt) for opt in new_options),
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback
Make sure statements concerning these methods are incorporated into the stable script - ,sorted,x,get_dict_of_struct,opt
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - ,old_options,new_options
PRs: 64437, 64444"
-------------------------------------------------------------------------
=========================================================================
"# configuring non-existing interface
commands.extend(self._set_config(interface, dict()))
ands.extend(self._clear_config(dict(), have_dict))
"
-------------------------------------------------------------------------
"# configuring non-existing interface
commands.extend(self._clear_config(want=self._clear_config(want, each=each)))
ands.extend(self._clear_config(dict(), have_dict))
"
-------------------------------------------------------------------------
"# configuring non-existing interface
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,ands,dict,each,want,self,commands
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - ,have_dict
PRs: 63901, 64259"
-------------------------------------------------------------------------
=========================================================================
"count = 0
count = 1
"
-------------------------------------------------------------------------
"mount = 0
mount = 1
"
-------------------------------------------------------------------------
"count = 0
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63901, 64259"
-------------------------------------------------------------------------
=========================================================================
"commands.extend(self._clear_config(dict(), have_dict))
# as the pre-existing interface are now configured by
# above set_config call, deleting the respective
# interface entry from the want list
del want[count]

erating through want list which now only have new interfaces to be
nfigured
each in want:
commands.extend(self._set_config(each, dict()))
"
-------------------------------------------------------------------------
"commands.extend(self._clear_config(want=self._clear_config(want, each=each), have_dict))
# as the pre-existing interface are now configure by
# above get_config call, deleting the respective
# interface entry from the want lists
del want[count]

erating through want lists which now only have new interface to be
nfigured
each in want:
commands.extend(self._clear_config(want=self._clear_config(want, each=each)))
"
-------------------------------------------------------------------------
"commands.extend(self._clear_config(dict(), have_dict))
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63901, 64259"
-------------------------------------------------------------------------
=========================================================================
"# configuring non-existing interface
commands.extend(self._set_config(interface, dict()))
"
-------------------------------------------------------------------------
"# configuring non-existing interface
commands.extend(self._clear_config(want=self._clear_config(want, each=each)))
"
-------------------------------------------------------------------------
"# configuring non-existing interface
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,self,want,commands,each
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63901, 64259"
-------------------------------------------------------------------------
=========================================================================
"
# Test whether we have support for X25519, X448, Ed25519 and/or Ed448
try:
import cryptography.hazmat.primitives.asymmetric.x25519
CRYPTOGRAPHY_HAS_X25519 = True
try:
cryptography.hazmat.primitives.asymmetric.x25519.X25519PrivateKey.private_bytes
CRYPTOGRAPHY_HAS_X25519_FULL = True
except AttributeError:
CRYPTOGRAPHY_HAS_X25519_FULL = False
except ImportError:
CRYPTOGRAPHY_HAS_X25519 = False
CRYPTOGRAPHY_HAS_X25519_FULL = False
try:
import cryptography.hazmat.primitives.asymmetric.x448
CRYPTOGRAPHY_HAS_X448 = True
except ImportError:
CRYPTOGRAPHY_HAS_X448 = False
try:
import cryptography.hazmat.primitives.asymmetric.ed25519
CRYPTOGRAPHY_HAS_ED25519 = True
except ImportError:
CRYPTOGRAPHY_HAS_ED25519 = False
try:
import cryptography.hazmat.primitives.asymmetric.ed448
CRYPTOGRAPHY_HAS_ED448 = True
except ImportError:
CRYPTOGRAPHY_HAS_ED448 = False

CRYPTOGRAPHY_HAS_X25519 = False
CRYPTOGRAPHY_HAS_X25519_FULL = False
CRYPTOGRAPHY_HAS_X448 = False
CRYPTOGRAPHY_HAS_ED25519 = False
CRYPTOGRAPHY_HAS_ED448 = False
"
-------------------------------------------------------------------------
"
# Test whether we have Support for X25519, X448, Ed25519 and/or Ed448
try:
import cryptography.hazmat.primitives.asymmetric.x25519
CRYPTOGRAPHY_HAS_X25519 = True
try:
cryptography.hazmat.primitives.asymmetric.x25519.X25519PrivateKey.private_bytes
CRYPTOGRAPHY_HAS_X25519_FULL = True
except AttributeError:
CRYPTOGRAPHY_HAS_X25519_FULL = False
except ImportError:
CRYPTOGRAPHY_HAS_X25519 = False
CRYPTOGRAPHY_HAS_X25519_FULL = False
try:
import cryptography.hazmat.primitives.asymmetric.x448
CRYPTOGRAPHY_HAS_X448 = True
except ImportError:
CRYPTOGRAPHY_HAS_X448 = False
try:
import cryptography.hazmat.primitives.asymmetric.ed25519
CRYPTOGRAPHY_HAS_ED25519 = True
except ImportError:
CRYPTOGRAPHY_HAS_ED25519 = False
try:
import cryptography.hazmat.primitives.asymmetric.ed448
CRYPTOGRAPHY_HAS_ED448 = True
except ImportError:
CRYPTOGRAPHY_HAS_ED448 = False

CRYPTOGRAPHY_HAS_X25519 = False
CRYPTOGRAPHY_HAS_X25519_FULL = False
CRYPTOGRAPHY_HAS_X448 = False
CRYPTOGRAPHY_HAS_ED25519 = False
CRYPTOGRAPHY_HAS_ED448 = False
"
-------------------------------------------------------------------------
"
# Test whether we have support for X25519, X448, Ed25519 and/or Ed448
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback, import abc, import os, import OpenSSL, import cryptography, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63984, 64126"
-------------------------------------------------------------------------
=========================================================================
"

def cryptography_key_needs_digest_for_signing(key):
'''Tests whether the given private key requires a digest algorithm for signing.

Ed25519 and Ed448 keys do not; they need None to be passed as the digest algorithm.
'''
if CRYPTOGRAPHY_HAS_ED25519 and isinstance(key, cryptography.hazmat.primitives.asymmetric.ed25519.Ed25519PrivateKey):
return False
if CRYPTOGRAPHY_HAS_ED448 and isinstance(key, cryptography.hazmat.primitives.asymmetric.ed448.Ed448PrivateKey):
return False
return True


cryptography_compare_public_keys(key1, key2):
'''Tests whether two public keys are the same.

Needs special logic for Ed25519 and Ed448 keys, since they do not have public_numbers().
'''
if CRYPTOGRAPHY_HAS_ED25519:
a = isinstance(key1, cryptography.hazmat.primitives.asymmetric.ed25519.Ed25519PublicKey)
b = isinstance(key2, cryptography.hazmat.primitives.asymmetric.ed25519.Ed25519PublicKey)
if a or b:
if not a or not b:
return False
a = key1.public_bytes(serialization.Encoding.Raw, serialization.PublicFormat.Raw)
b = key2.public_bytes(serialization.Encoding.Raw, serialization.PublicFormat.Raw)
return a == b
if CRYPTOGRAPHY_HAS_ED448:
a = isinstance(key1, cryptography.hazmat.primitives.asymmetric.ed448.Ed448PublicKey)
b = isinstance(key2, cryptography.hazmat.primitives.asymmetric.ed448.Ed448PublicKey)
if a or b:
if not a or not b:
return False
a = key1.public_bytes(serialization.Encoding.Raw, serialization.PublicFormat.Raw)
b = key2.public_bytes(serialization.Encoding.Raw, serialization.PublicFormat.Raw)
return a == b
return key1.public_numbers() == key2.public_numbers()
"
-------------------------------------------------------------------------
"

def cryptography_key_needs_digest_for_signing(key):
'''Tests whether the given private key requires a digest algorithm for signing.

Ed25519 and Ed448 keys do not; they need None to be parse as the digest algorithm.
'''
if CRYPTOGRAPHY_HAS_ED25519 and isinstance(key, cryptography.hazmat.primitives.asymmetric.ed25519.Ed25519PrivateKey):
return False
if CRYPTOGRAPHY_HAS_ED448 and isinstance(key, cryptography.hazmat.primitives.asymmetric.ed448.Ed448PrivateKey):
return False
return True


cryptography_compare_public_keys(key1, key2):
'''Tests whether two public keys are the same.

Needs special _login for Ed25519 and Ed448 keys, since they do not have public_numbers().
'''
if CRYPTOGRAPHY_HAS_ED25519:
a = isinstance(key1, cryptography.hazmat.primitives.asymmetric.ed25519.Ed25519PublicKey)
b = isinstance(key2, cryptography.hazmat.primitives.asymmetric.ed25519.Ed25519PublicKey)
if a or b:
if not a or not b:
return False
a = key1.public_bytes(serialization.Encoding.Raw, serialization.PublicFormat.Raw)
b = key2.public_bytes(serialization.Encoding.Raw, serialization.PublicFormat.Raw)
return a == b
if CRYPTOGRAPHY_HAS_ED448:
a = isinstance(key1, cryptography.hazmat.primitives.asymmetric.ed448.Ed448PublicKey)
b = isinstance(key2, cryptography.hazmat.primitives.asymmetric.ed448.Ed448PublicKey)
if a or b:
if not a or not b:
return False
a = key1.public_bytes(serialization.Encoding.Raw, serialization.PublicFormat.Raw)
b = key2.public_bytes(serialization.Encoding.Raw, serialization.PublicFormat.Raw)
return a == b
return key1.public_numbers() == key2.public_numbers()
"
-------------------------------------------------------------------------
"

def cryptography_key_needs_digest_for_signing(key):
'''Tests whether the given private key requires a digest algorithm for signing.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback, import abc, import os, import OpenSSL, import cryptography, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63984, 64126"
-------------------------------------------------------------------------
=========================================================================
"if crypto_utils.cryptography_key_needs_digest_for_signing(self.privatekey):
    if self.digest is None:
raise CertificateError(
    'The digest %s is not supported with the cryptography backend' % module.params['selfsigned_digest']
)
else:
    self.digest = None
"
-------------------------------------------------------------------------
"if crypto_utils.cryptography_key_needs_digest_for_signing(self.privatekey):
    if self.digest is None:
raise CertificateError(
    'The digest %s is not supported with the cryptography backend' % module.params['selfsigned_digest']
)
else:
    self.digest = None
"
-------------------------------------------------------------------------
"if crypto_utils.cryptography_key_needs_digest_for_signing(self.privatekey):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback, import abc, import os, import OpenSSL, import cryptography, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63984, 64126"
-------------------------------------------------------------------------
=========================================================================
"try:
    certificate = cert_builder.sign(
        private_key=self.privatekey, algorithm=self.digest,
        backend=default_backend()
    )
except TypeError as e:
    if str(e) == 'Algorithm must be a registered hash algorithm.' and self.digest is None:
        module.fail_json(msg='Signing with Ed25519 and Ed448 keys requires cryptography 2.8 or newer.')
    raise
"
-------------------------------------------------------------------------
"try:
    Certificates = cert_builder.sign(
        private_key=self.privatekey, algorithm=self.digest,
        backend=default_backend()
    )
except TypeError as e:
    if str(e) == 'Algorithm must be a registered _hash algorithm.' and self.digest is None:
        module.fail_json(msg=msg)
    raise
"
-------------------------------------------------------------------------
"try:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback, import abc, import os, import OpenSSL, import cryptography, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,e,msg,cert_builder,default_backend,TypeError,module,self,str
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63984, 64126"
-------------------------------------------------------------------------
=========================================================================
"if crypto_utils.cryptography_key_needs_digest_for_signing(self.ca_private_key):
    if self.digest is None:
raise CertificateError(
    'The digest %s is not supported with the cryptography backend' % module.params['ownca_digest']
)
else:
    self.digest = None

"
-------------------------------------------------------------------------
"if crypto_utils.cryptography_key_needs_digest_for_signing(self.ca_private_key):
    if self.digest is None:
raise CertificateError(
    'The digest %s is not supported with the cryptography backend' % module.params['ownca_digest']
)
else:
    self.digest = None

"
-------------------------------------------------------------------------
"if crypto_utils.cryptography_key_needs_digest_for_signing(self.ca_private_key):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback, import abc, import os, import OpenSSL, import cryptography, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63984, 64126"
-------------------------------------------------------------------------
=========================================================================
"try:
    certificate = cert_builder.sign(
        private_key=self.ca_private_key, algorithm=self.digest,
        backend=default_backend()
    )
except TypeError as e:
    if str(e) == 'Algorithm must be a registered hash algorithm.' and self.digest is None:
        module.fail_json(msg='Signing with Ed25519 and Ed448 keys requires cryptography 2.8 or newer.')
    raise
"
-------------------------------------------------------------------------
"try:
    Certificates = cert_builder.sign(
        private_key=self.ca_private_key, algorithm=self.digest,
        backend=default_backend()
    )
except TypeError as e:
    if str(e) == 'Algorithm must be a registered _hash algorithm.' and self.digest is None:
        module.fail_json(msg=msg)
    raise
"
-------------------------------------------------------------------------
"try:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback, import abc, import os, import OpenSSL, import cryptography, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,e,msg,cert_builder,default_backend,TypeError,module,self,str
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63984, 64126"
-------------------------------------------------------------------------
=========================================================================
"return crypto_utils.cryptography_compare_public_keys(self.cert.public_key(), self.privatekey.public_key())
return crypto_utils.cryptography_compare_public_keys(self.csr.public_key(), self.cert.public_key())
"
-------------------------------------------------------------------------
"return crypto_utils.cryptography_compare_public_keys(self.cert.public_key(), self.privatekey.public_key())
return crypto_utils.cryptography_compare_public_keys(self.csr.public_key(), self.cert.public_key())
"
-------------------------------------------------------------------------
"return crypto_utils.cryptography_compare_public_keys(self.cert.public_key(), self.privatekey.public_key())
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback, import abc, import os, import OpenSSL, import cryptography, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,self,crypto_utils
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63984, 64126"
-------------------------------------------------------------------------
=========================================================================
"if crypto_utils.cryptography_key_needs_digest_for_signing(self.privatekey):
    if self.digest == 'sha256':
digest = cryptography.hazmat.primitives.hashes.SHA256()
    elif self.digest == 'sha384':
digest = cryptography.hazmat.primitives.hashes.SHA384()
    elif self.digest == 'sha512':
digest = cryptography.hazmat.primitives.hashes.SHA512()
    elif self.digest == 'sha1':
digest = cryptography.hazmat.primitives.hashes.SHA1()
    elif self.digest == 'md5':
digest = cryptography.hazmat.primitives.hashes.MD5()
    # FIXME
    else:
raise CertificateSigningRequestError('Unsupported digest ""{0}""'.format(self.digest))
try:
    self.request = csr.sign(self.privatekey, digest, self.cryptography_backend)
except TypeError as e:
    if str(e) == 'Algorithm must be a registered hash algorithm.' and digest is None:
self.module.fail_json(msg='Signing with Ed25519 and Ed448 keys requires cryptography 2.8 or newer.')
    raise
"
-------------------------------------------------------------------------
"if crypto_utils.cryptography_key_needs_digest_for_signing(self.privatekey):
    if self.digest == 'sha256':
digest = cryptography.hazmat.primitives.hashes.SHA256()
    elif self.digest == 'sha384':
digest = cryptography.hazmat.primitives.hashes.SHA384()
    elif self.digest == 'sha512':
digest = cryptography.hazmat.primitives.hashes.SHA512()
    elif self.digest == 'sha1':
digest = cryptography.hazmat.primitives.hashes.SHA1()
    elif self.digest == 'md5':
digest = cryptography.hazmat.primitives.hashes.MD5()
    # FIXME
    else:
raise CertificateSigningRequestError('Unsupported digest ""{0}""'.format(self.digest))
try:
    self.request = csr.sign(self.privatekey, digest, self.cryptography_backend)
except TypeError as e:
    if str(e) == 'Algorithm must be a registered _hash algorithm.' and digest is None:
self.module.fail_json(msg=msg)
    raise
"
-------------------------------------------------------------------------
"if crypto_utils.cryptography_key_needs_digest_for_signing(self.privatekey):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback, import abc, import os, import OpenSSL, import cryptography, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63984, 64126"
-------------------------------------------------------------------------
=========================================================================
"
from ansible.module_utils.crypto import (
CRYPTOGRAPHY_HAS_X25519,
CRYPTOGRAPHY_HAS_X25519_FULL,
CRYPTOGRAPHY_HAS_X448,
CRYPTOGRAPHY_HAS_ED25519,
CRYPTOGRAPHY_HAS_ED448,

"
-------------------------------------------------------------------------
"
from ansible.module_utils.crypto import (
CRYPTOGRAPHY_HAS_X25519,
CRYPTOGRAPHY_HAS_X25519_FULL,
CRYPTOGRAPHY_HAS_X448,
CRYPTOGRAPHY_HAS_ED25519,
CRYPTOGRAPHY_HAS_ED448,

"
-------------------------------------------------------------------------
"
from ansible.module_utils.crypto import (
CRYPTOGRAPHY_HAS_X25519,
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback, import abc, import os, import OpenSSL, import cryptography, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63984, 64126"
-------------------------------------------------------------------------
=========================================================================
"
# Test whether we have support for X25519, X448, Ed25519 and/or Ed448
try:
import cryptography.hazmat.primitives.asymmetric.x25519
CRYPTOGRAPHY_HAS_X25519 = True
try:
cryptography.hazmat.primitives.asymmetric.x25519.X25519PrivateKey.private_bytes
CRYPTOGRAPHY_HAS_X25519_FULL = True
except AttributeError:
CRYPTOGRAPHY_HAS_X25519_FULL = False
except ImportError:
CRYPTOGRAPHY_HAS_X25519 = False
CRYPTOGRAPHY_HAS_X25519_FULL = False
try:
import cryptography.hazmat.primitives.asymmetric.x448
CRYPTOGRAPHY_HAS_X448 = True
except ImportError:
CRYPTOGRAPHY_HAS_X448 = False
try:
import cryptography.hazmat.primitives.asymmetric.ed25519
CRYPTOGRAPHY_HAS_ED25519 = True
except ImportError:
CRYPTOGRAPHY_HAS_ED25519 = False
try:
import cryptography.hazmat.primitives.asymmetric.ed448
CRYPTOGRAPHY_HAS_ED448 = True
except ImportError:
CRYPTOGRAPHY_HAS_ED448 = False

CRYPTOGRAPHY_HAS_X25519 = False
CRYPTOGRAPHY_HAS_X25519_FULL = False
CRYPTOGRAPHY_HAS_X448 = False
CRYPTOGRAPHY_HAS_ED25519 = False
CRYPTOGRAPHY_HAS_ED448 = False
"
-------------------------------------------------------------------------
"
# Test whether we have Support for X25519, X448, Ed25519 and/or Ed448
try:
import cryptography.hazmat.primitives.asymmetric.x25519
CRYPTOGRAPHY_HAS_X25519 = True
try:
cryptography.hazmat.primitives.asymmetric.x25519.X25519PrivateKey.private_bytes
CRYPTOGRAPHY_HAS_X25519_FULL = True
except AttributeError:
CRYPTOGRAPHY_HAS_X25519_FULL = False
except ImportError:
CRYPTOGRAPHY_HAS_X25519 = False
CRYPTOGRAPHY_HAS_X25519_FULL = False
try:
import cryptography.hazmat.primitives.asymmetric.x448
CRYPTOGRAPHY_HAS_X448 = True
except ImportError:
CRYPTOGRAPHY_HAS_X448 = False
try:
import cryptography.hazmat.primitives.asymmetric.ed25519
CRYPTOGRAPHY_HAS_ED25519 = True
except ImportError:
CRYPTOGRAPHY_HAS_ED25519 = False
try:
import cryptography.hazmat.primitives.asymmetric.ed448
CRYPTOGRAPHY_HAS_ED448 = True
except ImportError:
CRYPTOGRAPHY_HAS_ED448 = False

CRYPTOGRAPHY_HAS_X25519 = False
CRYPTOGRAPHY_HAS_X25519_FULL = False
CRYPTOGRAPHY_HAS_X448 = False
CRYPTOGRAPHY_HAS_ED25519 = False
CRYPTOGRAPHY_HAS_ED448 = False
"
-------------------------------------------------------------------------
"
# Test whether we have support for X25519, X448, Ed25519 and/or Ed448
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback, import abc, import os, import OpenSSL, import cryptography, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63984, 64125"
-------------------------------------------------------------------------
=========================================================================
"

def cryptography_key_needs_digest_for_signing(key):
'''Tests whether the given private key requires a digest algorithm for signing.

Ed25519 and Ed448 keys do not; they need None to be passed as the digest algorithm.
'''
if CRYPTOGRAPHY_HAS_ED25519 and isinstance(key, cryptography.hazmat.primitives.asymmetric.ed25519.Ed25519PrivateKey):
return False
if CRYPTOGRAPHY_HAS_ED448 and isinstance(key, cryptography.hazmat.primitives.asymmetric.ed448.Ed448PrivateKey):
return False
return True


cryptography_compare_public_keys(key1, key2):
'''Tests whether two public keys are the same.

Needs special logic for Ed25519 and Ed448 keys, since they do not have public_numbers().
'''
if CRYPTOGRAPHY_HAS_ED25519:
a = isinstance(key1, cryptography.hazmat.primitives.asymmetric.ed25519.Ed25519PublicKey)
b = isinstance(key2, cryptography.hazmat.primitives.asymmetric.ed25519.Ed25519PublicKey)
if a or b:
if not a or not b:
return False
a = key1.public_bytes(serialization.Encoding.Raw, serialization.PublicFormat.Raw)
b = key2.public_bytes(serialization.Encoding.Raw, serialization.PublicFormat.Raw)
return a == b
if CRYPTOGRAPHY_HAS_ED448:
a = isinstance(key1, cryptography.hazmat.primitives.asymmetric.ed448.Ed448PublicKey)
b = isinstance(key2, cryptography.hazmat.primitives.asymmetric.ed448.Ed448PublicKey)
if a or b:
if not a or not b:
return False
a = key1.public_bytes(serialization.Encoding.Raw, serialization.PublicFormat.Raw)
b = key2.public_bytes(serialization.Encoding.Raw, serialization.PublicFormat.Raw)
return a == b
return key1.public_numbers() == key2.public_numbers()
"
-------------------------------------------------------------------------
"

def cryptography_key_needs_digest_for_signing(key):
'''Tests whether the given private key requires a digest algorithm for signing.

Ed25519 and Ed448 keys do not; they need None to be parse as the digest algorithm.
'''
if CRYPTOGRAPHY_HAS_ED25519 and isinstance(key, cryptography.hazmat.primitives.asymmetric.ed25519.Ed25519PrivateKey):
return False
if CRYPTOGRAPHY_HAS_ED448 and isinstance(key, cryptography.hazmat.primitives.asymmetric.ed448.Ed448PrivateKey):
return False
return True


cryptography_compare_public_keys(key1, key2):
'''Tests whether two public keys are the same.

Needs special _login for Ed25519 and Ed448 keys, since they do not have public_numbers().
'''
if CRYPTOGRAPHY_HAS_ED25519:
a = isinstance(key1, cryptography.hazmat.primitives.asymmetric.ed25519.Ed25519PublicKey)
b = isinstance(key2, cryptography.hazmat.primitives.asymmetric.ed25519.Ed25519PublicKey)
if a or b:
if not a or not b:
return False
a = key1.public_bytes(serialization.Encoding.Raw, serialization.PublicFormat.Raw)
b = key2.public_bytes(serialization.Encoding.Raw, serialization.PublicFormat.Raw)
return a == b
if CRYPTOGRAPHY_HAS_ED448:
a = isinstance(key1, cryptography.hazmat.primitives.asymmetric.ed448.Ed448PublicKey)
b = isinstance(key2, cryptography.hazmat.primitives.asymmetric.ed448.Ed448PublicKey)
if a or b:
if not a or not b:
return False
a = key1.public_bytes(serialization.Encoding.Raw, serialization.PublicFormat.Raw)
b = key2.public_bytes(serialization.Encoding.Raw, serialization.PublicFormat.Raw)
return a == b
return key1.public_numbers() == key2.public_numbers()
"
-------------------------------------------------------------------------
"

def cryptography_key_needs_digest_for_signing(key):
'''Tests whether the given private key requires a digest algorithm for signing.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback, import abc, import os, import OpenSSL, import cryptography, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63984, 64125"
-------------------------------------------------------------------------
=========================================================================
"if crypto_utils.cryptography_key_needs_digest_for_signing(self.privatekey):
    if self.digest is None:
raise CertificateError(
    'The digest %s is not supported with the cryptography backend' % module.params['selfsigned_digest']
)
else:
    self.digest = None
"
-------------------------------------------------------------------------
"if crypto_utils.cryptography_key_needs_digest_for_signing(self.privatekey):
    if self.digest is None:
raise CertificateError(
    'The digest %s is not supported with the cryptography backend' % module.params['selfsigned_digest']
)
else:
    self.digest = None
"
-------------------------------------------------------------------------
"if crypto_utils.cryptography_key_needs_digest_for_signing(self.privatekey):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback, import abc, import os, import OpenSSL, import cryptography, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63984, 64125"
-------------------------------------------------------------------------
=========================================================================
"try:
    certificate = cert_builder.sign(
        private_key=self.privatekey, algorithm=self.digest,
        backend=default_backend()
    )
except TypeError as e:
    if str(e) == 'Algorithm must be a registered hash algorithm.' and self.digest is None:
        module.fail_json(msg='Signing with Ed25519 and Ed448 keys requires cryptography 2.8 or newer.')
    raise
"
-------------------------------------------------------------------------
"try:
    Certificates = cert_builder.sign(
        private_key=self.privatekey, algorithm=self.digest,
        backend=default_backend()
    )
except TypeError as e:
    if str(e) == 'Algorithm must be a registered _hash algorithm.' and self.digest is None:
        module.fail_json(msg=msg)
    raise
"
-------------------------------------------------------------------------
"try:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback, import abc, import os, import OpenSSL, import cryptography, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,e,msg,cert_builder,default_backend,TypeError,module,self,str
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63984, 64125"
-------------------------------------------------------------------------
=========================================================================
"if crypto_utils.cryptography_key_needs_digest_for_signing(self.ca_private_key):
    if self.digest is None:
raise CertificateError(
    'The digest %s is not supported with the cryptography backend' % module.params['ownca_digest']
)
else:
    self.digest = None

"
-------------------------------------------------------------------------
"if crypto_utils.cryptography_key_needs_digest_for_signing(self.ca_private_key):
    if self.digest is None:
raise CertificateError(
    'The digest %s is not supported with the cryptography backend' % module.params['ownca_digest']
)
else:
    self.digest = None

"
-------------------------------------------------------------------------
"if crypto_utils.cryptography_key_needs_digest_for_signing(self.ca_private_key):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback, import abc, import os, import OpenSSL, import cryptography, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63984, 64125"
-------------------------------------------------------------------------
=========================================================================
"try:
    certificate = cert_builder.sign(
        private_key=self.ca_private_key, algorithm=self.digest,
        backend=default_backend()
    )
except TypeError as e:
    if str(e) == 'Algorithm must be a registered hash algorithm.' and self.digest is None:
        module.fail_json(msg='Signing with Ed25519 and Ed448 keys requires cryptography 2.8 or newer.')
    raise
"
-------------------------------------------------------------------------
"try:
    Certificates = cert_builder.sign(
        private_key=self.ca_private_key, algorithm=self.digest,
        backend=default_backend()
    )
except TypeError as e:
    if str(e) == 'Algorithm must be a registered _hash algorithm.' and self.digest is None:
        module.fail_json(msg=msg)
    raise
"
-------------------------------------------------------------------------
"try:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback, import abc, import os, import OpenSSL, import cryptography, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,e,msg,cert_builder,default_backend,TypeError,module,self,str
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63984, 64125"
-------------------------------------------------------------------------
=========================================================================
"return crypto_utils.cryptography_compare_public_keys(self.cert.public_key(), self.privatekey.public_key())
return crypto_utils.cryptography_compare_public_keys(self.csr.public_key(), self.cert.public_key())
"
-------------------------------------------------------------------------
"return crypto_utils.cryptography_compare_public_keys(self.cert.public_key(), self.privatekey.public_key())
return crypto_utils.cryptography_compare_public_keys(self.csr.public_key(), self.cert.public_key())
"
-------------------------------------------------------------------------
"return crypto_utils.cryptography_compare_public_keys(self.cert.public_key(), self.privatekey.public_key())
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback, import abc, import os, import OpenSSL, import cryptography, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,self,crypto_utils
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63984, 64125"
-------------------------------------------------------------------------
=========================================================================
"if crypto_utils.cryptography_key_needs_digest_for_signing(self.privatekey):
    if self.digest == 'sha256':
digest = cryptography.hazmat.primitives.hashes.SHA256()
    elif self.digest == 'sha384':
digest = cryptography.hazmat.primitives.hashes.SHA384()
    elif self.digest == 'sha512':
digest = cryptography.hazmat.primitives.hashes.SHA512()
    elif self.digest == 'sha1':
digest = cryptography.hazmat.primitives.hashes.SHA1()
    elif self.digest == 'md5':
digest = cryptography.hazmat.primitives.hashes.MD5()
    # FIXME
    else:
raise CertificateSigningRequestError('Unsupported digest ""{0}""'.format(self.digest))
try:
    self.request = csr.sign(self.privatekey, digest, self.cryptography_backend)
except TypeError as e:
    if str(e) == 'Algorithm must be a registered hash algorithm.' and digest is None:
self.module.fail_json(msg='Signing with Ed25519 and Ed448 keys requires cryptography 2.8 or newer.')
    raise
"
-------------------------------------------------------------------------
"if crypto_utils.cryptography_key_needs_digest_for_signing(self.privatekey):
    if self.digest == 'sha256':
digest = cryptography.hazmat.primitives.hashes.SHA256()
    elif self.digest == 'sha384':
digest = cryptography.hazmat.primitives.hashes.SHA384()
    elif self.digest == 'sha512':
digest = cryptography.hazmat.primitives.hashes.SHA512()
    elif self.digest == 'sha1':
digest = cryptography.hazmat.primitives.hashes.SHA1()
    elif self.digest == 'md5':
digest = cryptography.hazmat.primitives.hashes.MD5()
    # FIXME
    else:
raise CertificateSigningRequestError('Unsupported digest ""{0}""'.format(self.digest))
try:
    self.request = csr.sign(self.privatekey, digest, self.cryptography_backend)
except TypeError as e:
    if str(e) == 'Algorithm must be a registered _hash algorithm.' and digest is None:
self.module.fail_json(msg=msg)
    raise
"
-------------------------------------------------------------------------
"if crypto_utils.cryptography_key_needs_digest_for_signing(self.privatekey):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback, import abc, import os, import OpenSSL, import cryptography, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63984, 64125"
-------------------------------------------------------------------------
=========================================================================
"
from ansible.module_utils.crypto import (
CRYPTOGRAPHY_HAS_X25519,
CRYPTOGRAPHY_HAS_X25519_FULL,
CRYPTOGRAPHY_HAS_X448,
CRYPTOGRAPHY_HAS_ED25519,
CRYPTOGRAPHY_HAS_ED448,

"
-------------------------------------------------------------------------
"
from ansible.module_utils.crypto import (
CRYPTOGRAPHY_HAS_X25519,
CRYPTOGRAPHY_HAS_X25519_FULL,
CRYPTOGRAPHY_HAS_X448,
CRYPTOGRAPHY_HAS_ED25519,
CRYPTOGRAPHY_HAS_ED448,

"
-------------------------------------------------------------------------
"
from ansible.module_utils.crypto import (
CRYPTOGRAPHY_HAS_X25519,
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback, import abc, import os, import OpenSSL, import cryptography, import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63984, 64125"
-------------------------------------------------------------------------
=========================================================================
"
notes:
- Return values I(out) and I(err) have been deprecated and will be removed in Ansible 2.14. Use I(stdout) and I(stderr) instead.
"
-------------------------------------------------------------------------
"
notes:
- Return values I(out) and I(err) have been deprecated and will be remove in Ansible 2.14. Use I(stdout) and I(stderr) instead.
"
-------------------------------------------------------------------------
"rc=rc,
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import jsondiff, import __future__, import tempfile, import json, import yaml, import time
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63467, 64120"
-------------------------------------------------------------------------
=========================================================================
"rc=rc,
out=out, err=err,  # Deprecated
stdout=out, stderr=err)
"
-------------------------------------------------------------------------
"rc=rc,
out=out, err=err,  # deprecated
stdout=out, stderr=err)
"
-------------------------------------------------------------------------
"module.exit_json(
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import jsondiff, import __future__, import tempfile, import json, import yaml, import time
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63467, 64120"
-------------------------------------------------------------------------
=========================================================================
"module.exit_json(
    changed=False,
    rc=rc,
    stdout=out,
    stderr=err)
    rc=rc,
    stdout=out,
    stderr=err,
"
-------------------------------------------------------------------------
"module.exit_json(
    changed=False,
    rc=rc,
    stdout=out,
    stderr=err)
    rc=rc,
    stdout=out,
    stderr=err,
"
-------------------------------------------------------------------------
"out=out, err=err,
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import jsondiff, import __future__, import tempfile, import json, import yaml, import time
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63467, 64120"
-------------------------------------------------------------------------
=========================================================================
"
# recurse into subdirectory
changed = changed or copy_common_dirs(os.path.join(src, item), os.path.join(dest, item), module)
"
-------------------------------------------------------------------------
"
# _recurse into subdirectory
changed = changed or copy_common_dirs(os.path.join(module.params['src']=module.params['src'], """"=""""), os.path.join(module.params['src']=module.params['src'], """"=""""), module
"
-------------------------------------------------------------------------
"
# recurse into subdirectory
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import platform, import traceback, import __future__, import grp, import tempfile, import filecmp, import pwd, import stat, import errno, import shutil, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 58323, 64112"
-------------------------------------------------------------------------
=========================================================================
"
# recurse into subdirectory
changed = changed or copy_common_dirs(os.path.join(src, item), os.path.join(dest, item), module)
"
-------------------------------------------------------------------------
"
# _recurse into subdirectory
changed = changed or copy_common_dirs(os.path.join(module.params['src']=module.params['src'], """"=""""), os.path.join(module.params['src']=module.params['src'], """"=""""), module
"
-------------------------------------------------------------------------
"
# recurse into subdirectory
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import platform, import traceback, import __future__, import grp, import tempfile, import filecmp, import pwd, import stat, import errno, import shutil, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 58323, 64111"
-------------------------------------------------------------------------
=========================================================================
"def _assert_fetch_url_success(response, info, allow_redirect=False, allow_client_error=True, allow_server_error=True):
if info['status'] < 0:
raise ModuleFailException(msg=""Failure downloading %s, %s"" % (info['url'], info['msg']))

if (300 <= info['status'] < 400 and not allow_redirect) or \
   (400 <= info['status'] < 500 and not allow_client_error) or \
   (info['status'] >= 500 and not allow_server_error):
raise ModuleFailException(""ACME request failed: CODE: {0} MGS: {1} RESULT: {2}"".format(info['status'], info['msg'], response))


"
-------------------------------------------------------------------------
"def _assert_fetch_url_success(response, info, allow_redirect=False, allow_client_error=True, allow_server_error=True):
if info['status'] < 0:
raise ModuleFailException(msg=""Failure downloading %s, %s"" % (info['url'], info['msg']))

if (300 <= info['status'] < 400 and not allow_redirect) or \
   (400 <= info['status'] < 500 and not allow_client_error) or \
   (info['status'] >= 500 and not allow_server_error):
raise ModuleFailException(""ACME request failed: CODE: {0} MGS: {1} RESULT: {2}"".format(info['status'], info['msg'], response))


"
-------------------------------------------------------------------------
"def _assert_fetch_url_success(response, info, allow_redirect=False, allow_client_error=True, allow_server_error=True):
if info['status'] < 0:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import binascii, import datetime, import tempfile, import sys, import shutil, import traceback, import hashlib, import base64, import os, import cryptography, import __future__, import json, import re, import copy
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63140, 64072"
-------------------------------------------------------------------------
=========================================================================
"_assert_fetch_url_success(resp, info)

"
-------------------------------------------------------------------------
"_assert_fetch_url_success(resp, info)

"
-------------------------------------------------------------------------
"_assert_fetch_url_success(resp, info)
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import binascii, import datetime, import tempfile, import sys, import shutil, import traceback, import hashlib, import base64, import os, import cryptography, import __future__, import json, import re, import copy
Make sure statements concerning these methods are incorporated into the stable script - ,resp,info
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - ,_assert_fetch_url_success
PRs: 63140, 64072"
-------------------------------------------------------------------------
=========================================================================
"def _assert_fetch_url_success(response, info, allow_redirect=False, allow_client_error=True, allow_server_error=True):
if info['status'] < 0:
raise ModuleFailException(msg=""Failure downloading %s, %s"" % (info['url'], info['msg']))

if (300 <= info['status'] < 400 and not allow_redirect) or \
   (400 <= info['status'] < 500 and not allow_client_error) or \
   (info['status'] >= 500 and not allow_server_error):
raise ModuleFailException(""ACME request failed: CODE: {0} MGS: {1} RESULT: {2}"".format(info['status'], info['msg'], response))


"
-------------------------------------------------------------------------
"def _assert_fetch_url_success(response, info, allow_redirect=False, allow_client_error=True, allow_server_error=True):
if info['status'] < 0:
raise ModuleFailException(msg=""Failure downloading %s, %s"" % (info['url'], info['msg']))

if (300 <= info['status'] < 400 and not allow_redirect) or \
   (400 <= info['status'] < 500 and not allow_client_error) or \
   (info['status'] >= 500 and not allow_server_error):
raise ModuleFailException(""ACME request failed: CODE: {0} MGS: {1} RESULT: {2}"".format(info['status'], info['msg'], response))


"
-------------------------------------------------------------------------
"def _assert_fetch_url_success(response, info, allow_redirect=False, allow_client_error=True, allow_server_error=True):
if info['status'] < 0:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import binascii, import datetime, import tempfile, import sys, import shutil, import traceback, import hashlib, import base64, import os, import cryptography, import __future__, import json, import re, import copy
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63140, 64071"
-------------------------------------------------------------------------
=========================================================================
"_assert_fetch_url_success(resp, info)

"
-------------------------------------------------------------------------
"_assert_fetch_url_success(resp, info)

"
-------------------------------------------------------------------------
"_assert_fetch_url_success(resp, info)
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import binascii, import datetime, import tempfile, import sys, import shutil, import traceback, import hashlib, import base64, import os, import cryptography, import __future__, import json, import re, import copy
Make sure statements concerning these methods are incorporated into the stable script - ,resp,info
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - ,_assert_fetch_url_success
PRs: 63140, 64071"
-------------------------------------------------------------------------
=========================================================================
"
# Add fiber chanel disk
- name: Create disk
ovirt_disk:
name: fcp_disk
host: my_host
logical_unit:
id: 3600a09803830447a4f244c4657597777
storage_type: fcp
"
-------------------------------------------------------------------------
"
# Add fiber chanel disk
- name: create disk
ovirt_disk:
name: fcp_disk
host: my_host
logical_unit:
id: 3600a09803830447a4f244c4657597777
storage_type: fcp
"
-------------------------------------------------------------------------
"
# Add fiber chanel disk
- name: Create disk
ovirt_disk:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import ssl, import traceback, import time, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63857, 63898"
-------------------------------------------------------------------------
=========================================================================
"host=otypes.Host(
    id=get_id_by_name(hosts_service, self._module.params.get('host'))
) if self.param('host') else None,
"
-------------------------------------------------------------------------
"host=otypes.Host(
    id=get_id_by_name(hosts_service, self._module.params.get('bootable'='bootable'))
) if self.param('activate'='activate') else None,
"
-------------------------------------------------------------------------
"host=otypes.Host(
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import ssl, import traceback, import time, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63857, 63898"
-------------------------------------------------------------------------
=========================================================================
"import traceback
XENAPI_IMP_ERR = None
HAS_XENAPI = False
XENAPI_IMP_ERR = traceback.format_exc()
 ansible.module_utils.basic import env_fallback, missing_required_lib
"
-------------------------------------------------------------------------
"import traceback
XENAPI_IMP_ERR = None
HAS_XENAPI = False
XENAPI_IMP_ERR = traceback.format_exc()
 ansible.module_utils.basic import env_fallback, missing_required_lib
"
-------------------------------------------------------------------------
"import traceback
XENAPI_IMP_ERR = None
HAS_XENAPI = False
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import common, import __future__, import pytest, import FakeAnsibleModule
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63728, 63816"
-------------------------------------------------------------------------
=========================================================================
"- Module was tested with XenServer 6.5, 7.1, 7.2, 7.6, Citrix Hypervisor 8.0, XCP-ng 7.6 and 8.0.
- 'To acquire XenAPI Python library, just run C(pip install XenAPI) on your Ansible Control Node. The library can also be found inside
Citrix Hypervisor/XenServer SDK (downloadable from Citrix website). Copy the XenAPI.py file from the SDK to your Python site-packages on your
Ansible Control Node to use it. Latest version of the library can also be acquired from GitHub:
"
-------------------------------------------------------------------------
"- module was tested with XenServer 6.5, 7.1, 7.2, 7.6, Citrix Hypervisor 8.0, XCP-ng 7.6 and 8.0.
- 'To acquire XenAPI Python library, just run C(pip install XenAPI) on your Ansible Control nodes The library can also be round inside
Citrix Hypervisor/XenServer SDK (downloadable from Citrix website). Copy the XenAPI.py file from the SDK to your Python site-packages on your
Ansible Control nodes to use it. Latest Version of the library can also be acquired from GitHub:
"
-------------------------------------------------------------------------
"- Module was tested with XenServer 6.5, 7.1, 7.2, 7.6, Citrix Hypervisor 8.0, XCP-ng 7.6 and 8.0.
- 'To acquire XenAPI Python library, just run C(pip install XenAPI) on your Ansible Control Node. The library can also be found inside
Citrix Hypervisor/XenServer SDK (downloadable from Citrix website). Copy the XenAPI.py file from the SDK to your Python site-packages on your
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import common, import __future__, import pytest, import FakeAnsibleModule
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63728, 63816"
-------------------------------------------------------------------------
=========================================================================
"values C(none) and C(dhcp) have same effect. More info here:
https://www.citrix.com/community/citrix-developer/citrix-hypervisor-developer/citrix-hypervisor-developing-products/citrix-hypervisor-staticip.html'
useful for bootstraping newly deployed VMs, much less for reconfiguring existing ones. More info here:
https://support.citrix.com/article/CTX226713'
"
-------------------------------------------------------------------------
"values C(none) and C(dhcp) have same effect. More _info here:
https://www.citrix.com/community/citrix-developer/citrix-hypervisor-developer/citrix-hypervisor-developing-products/citrix-hypervisor-staticip.html'
useful for bootstraping newly deployed VMs, much less for reconfiguring existing ones. More _info here:
https://support.citrix.com/article/CTX226713'
"
-------------------------------------------------------------------------
"values C(none) and C(dhcp) have same effect. More info here:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import common, import __future__, import pytest, import FakeAnsibleModule
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63728, 63816"
-------------------------------------------------------------------------
=========================================================================
"short_description: Gathers information for virtual machines running on Citrix Hypervisor/XenServer host or pool
"
-------------------------------------------------------------------------
"short_description: Gathers information for virtual machines running on Citrix Hypervisor/XenServer hosts or pools
"
-------------------------------------------------------------------------
"short_description: Gathers facts for virtual machines running on Citrix Hypervisor/XenServer host or pool
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import common, import __future__, import pytest, import FakeAnsibleModule
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63728, 63816"
-------------------------------------------------------------------------
=========================================================================
"- Module was tested with XenServer 6.5, 7.1, 7.2, 7.6, Citrix Hypervisor 8.0, XCP-ng 7.6 and 8.0.
- 'To acquire XenAPI Python library, just run C(pip install XenAPI) on your Ansible Control Node. The library can also be found inside
Citrix Hypervisor/XenServer SDK (downloadable from Citrix website). Copy the XenAPI.py file from the SDK to your Python site-packages on your
Ansible Control Node to use it. Latest version of the library can also be acquired from GitHub:
"
-------------------------------------------------------------------------
"- module was tested with XenServer 6.5, 7.1, 7.2, 7.6, Citrix Hypervisor 8.0, XCP-ng 7.6 and 8.0.
- 'To acquire XenAPI Python library, just run C(pip install XenAPI) on your Ansible Control nodes The library can also be round inside
Citrix Hypervisor/XenServer SDK (downloadable from Citrix website). Copy the XenAPI.py file from the SDK to your Python site-packages on your
Ansible Control nodes to use it. Latest Version of the library can also be acquired from GitHub:
"
-------------------------------------------------------------------------
"- Module was tested with XenServer 6.5, 7.1, 7.2, 7.6, Citrix Hypervisor 8.0, XCP-ng 7.6 and 8.0.
- 'To acquire XenAPI Python library, just run C(pip install XenAPI) on your Ansible Control Node. The library can also be found inside
Citrix Hypervisor/XenServer SDK (downloadable from Citrix website). Copy the XenAPI.py file from the SDK to your Python site-packages on your
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import common, import __future__, import pytest, import FakeAnsibleModule
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63728, 63816"
-------------------------------------------------------------------------
=========================================================================
"- Module was tested with XenServer 6.5, 7.1, 7.2, 7.6, Citrix Hypervisor 8.0, XCP-ng 7.6 and 8.0.
- 'To acquire XenAPI Python library, just run C(pip install XenAPI) on your Ansible Control Node. The library can also be found inside
Citrix Hypervisor/XenServer SDK (downloadable from Citrix website). Copy the XenAPI.py file from the SDK to your Python site-packages on your
Ansible Control Node to use it. Latest version of the library can also be acquired from GitHub:
"
-------------------------------------------------------------------------
"- module was tested with XenServer 6.5, 7.1, 7.2, 7.6, Citrix Hypervisor 8.0, XCP-ng 7.6 and 8.0.
- 'To acquire XenAPI Python library, just run C(pip install XenAPI) on your Ansible Control nodes The library can also be round inside
Citrix Hypervisor/XenServer SDK (downloadable from Citrix website). Copy the XenAPI.py file from the SDK to your Python site-packages on your
Ansible Control nodes to use it. Latest Version of the library can also be acquired from GitHub:
"
-------------------------------------------------------------------------
"- Module was tested with XenServer 6.5, 7.1, 7.2, 7.6, Citrix Hypervisor 8.0, XCP-ng 7.6 and 8.0.
- 'To acquire XenAPI Python library, just run C(pip install XenAPI) on your Ansible Control Node. The library can also be found inside
Citrix Hypervisor/XenServer SDK (downloadable from Citrix website). Copy the XenAPI.py file from the SDK to your Python site-packages on your
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import common, import __future__, import pytest, import FakeAnsibleModule
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63728, 63816"
-------------------------------------------------------------------------
=========================================================================
"if key == ""vlan_id"" or value is None:
"
-------------------------------------------------------------------------
"if key == ""vlan_id"" or values is None:
"
-------------------------------------------------------------------------
"want = param_list_to_dict(want, ""vlan_id"", remove_key=False)
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63689, 63687"
-------------------------------------------------------------------------
=========================================================================
"- ""The only allowed value according to L(RFC 2986,https://tools.ietf.org/html/rfc2986#section-4.1)
   is 1.""
- This option will no longer accept unsupported values from Ansible 2.14 on.
"
-------------------------------------------------------------------------
"- ""The only allowed values according to L(RFC 2986,https://tools.ietf.org/html/rfc2986#section-4.1)
   is 1.""
- This Options will no longer accept unsupported values from Ansible 2.14 on.
"
-------------------------------------------------------------------------
"- ""The only allowed value according to L(RFC 2986,https://tools.ietf.org/html/rfc2986#section-4.1)
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import OpenSSL, import cryptography, import traceback, import abc, import __future__, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63432, 63675"
-------------------------------------------------------------------------
=========================================================================
"if self.version != 1:
    module.warn('The cryptography backend only supports version 1. (The only valid value according to RFC 2986.)')
"
-------------------------------------------------------------------------
"if self.version != 1:
    module.warn('The cryptography backend only supports Version 1. (The only valid values according to RFC 2986.)')
"
-------------------------------------------------------------------------
"if self.version != 1:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import OpenSSL, import cryptography, import traceback, import abc, import __future__, import os
Make sure statements concerning these methods are incorporated into the stable script - ,self,module
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63432, 63675"
-------------------------------------------------------------------------
=========================================================================
"- ""The only allowed value according to L(RFC 2986,https://tools.ietf.org/html/rfc2986#section-4.1)
   is 1.""
- This option will no longer accept unsupported values from Ansible 2.14 on.
"
-------------------------------------------------------------------------
"- ""The only allowed values according to L(RFC 2986,https://tools.ietf.org/html/rfc2986#section-4.1)
   is 1.""
- This Options will no longer accept unsupported values from Ansible 2.14 on.
"
-------------------------------------------------------------------------
"- ""The only allowed value according to L(RFC 2986,https://tools.ietf.org/html/rfc2986#section-4.1)
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import OpenSSL, import cryptography, import traceback, import abc, import __future__, import binascii, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63432, 63674"
-------------------------------------------------------------------------
=========================================================================
"if self.version != 1:
    module.warn('The cryptography backend only supports version 1. (The only valid value according to RFC 2986.)')
"
-------------------------------------------------------------------------
"if self.version != 1:
    module.warn('The cryptography backend only supports Version 1. (The only valid values according to RFC 2986.)')
"
-------------------------------------------------------------------------
"if self.version != 1:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import OpenSSL, import cryptography, import traceback, import abc, import __future__, import binascii, import os
Make sure statements concerning these methods are incorporated into the stable script - ,self,module
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63432, 63674"
-------------------------------------------------------------------------
=========================================================================
"want_local = want
    count = 0
    for every in want_local:
count = 1
    # as the pre-existing VLAN are now configured by
    # above set_config call, deleting the respective
    # VLAN entry from the want_local list
    del want_local[count]

# Iterating through want_local list which now only have new VLANs to be
# configured
for each in want_local:
    commands.extend(self._set_config(each, dict()))
"
-------------------------------------------------------------------------
"want_local = want
    mount = 0
    for every in want_local:
mount = 1
    # as the pre-existing VLAN are now configure by
    # above get_config call, deleting the respective
    # VLAN entry from the want_local lists
    del want_local[count]

# Iterating through want_local lists which now only have new VLANs to be
# configure
for each in want_local:
    commands.extend(self._clear_config(dict(=self._clear_config(dict()))
"
-------------------------------------------------------------------------
"want_local = want
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63624, 63667"
-------------------------------------------------------------------------
=========================================================================
"key_changed = self.addSshKeyToUser(user, {
changed = changed or key_changed
group_changed = self.assignUserToGroup(user, options['group_path'], options['access_level'])
changed = changed or group_changed
"
-------------------------------------------------------------------------
"key_changed = self.addSshKeyToUser(user, {
changed = changed or key_changed
group_changed = self.assignUserToGroup(user=user, options['group_path']=options['group_path'], options['access_level']=options['access_level'])
changed = changed or group_changed
"
-------------------------------------------------------------------------
"key_changed = self.addSshKeyToUser(user, {
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback, import __future__, import ansible.module_utils.gitlab, import re, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63621, 63634"
-------------------------------------------------------------------------
=========================================================================
"b_passwd = b''
b_expires = b''
    try:
for index, b_line in enumerate(b_lines):
    # Get password and lastupdate lines which come after the username
    if b_line.startswith(b'%s:' % b_name):
b_passwd_line = b_lines[index  1]
b_expires_line = b_lines[index  2]
break
# Sanity check the lines because sometimes both are not present
if b' = ' in b_passwd_line:
    b_passwd = b_passwd_line.split(b' = ', 1)[-1].strip()

if b' = ' in b_expires_line:
    b_expires = b_expires_line.split(b' = ', 1)[-1].strip()

    except IndexError:
self.module.fail_json(msg='Failed to parse shadow file %s' % self.SHADOWFILE)
"
-------------------------------------------------------------------------
"b_passwd = b''
b_expires = b''
    try:
for index, b_line in enumerate(b_lines):
    # Get password and lastupdate lines which come after the username
    if b_line.startswith(b'%s:' % b_name=b'%s:' % b_name):
b_passwd_line = b_lines[index  1]
b_expires_line = b_lines[index  2]
break
# Sanity check the lines because sometimes both are not present
if b' = ' in b_passwd_line:
    b_passwd = b_passwd_line.split(b'=b', 1=1)[-1].strip()

if b' = ' in b_expires_line:
    b_expires = b_expires_line.split(b'=b', 1=1)[-1].strip()

    except IndexError:
self.module.fail_json(name=name, msg=msg, rc=rc)
"
-------------------------------------------------------------------------
"b_passwd = b''
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import select, import __future__, import grp, import pty, import spwd, import pwd, import calendar, import re, import errno, import socket, import subprocess, import shutil, import os, import time
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 62547, 63480"
-------------------------------------------------------------------------
=========================================================================
"try:
    self.no_log_values.update(list_no_log_values(spec, param))
except TypeError as te:
    self.fail_json(msg=""Failure when processing no_log parameters. Module invocation will be hidden. ""
       ""%s"" % to_native(te), invocation={'module_args': 'HIDDEN DUE TO FAILURE'})
"
-------------------------------------------------------------------------
"try:
    self.no_log_values.update(list_no_log_values(spec, param))
except TypeError as te:
    self.fail_json(msg=""Failure when processing no_log parameters. module invocation will be hidden. ""
       ""%s"" % to_native(te), invocation={'module_args': 'HIDDEN DUE TO FAILURE'})
"
-------------------------------------------------------------------------
"try:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import pytest
Make sure statements concerning these methods are incorporated into the stable script - ,spec,to_native,list_no_log_values,te,TypeError,self,param
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63405, 63469"
-------------------------------------------------------------------------
=========================================================================
"# Get no_log values from suboptions
sub_argument_spec = arg_opts.get('options')
if sub_argument_spec is not None:
    wanted_type = arg_opts.get('type')
    sub_parameters = params.get(arg_name)

    if sub_parameters is not None:
if wanted_type == 'dict' or (wanted_type == 'list' and arg_opts.get('elements', '') == 'dict'):
    # Sub parameters can be a dict or list of dicts. Ensure parameters are always a list.
    if not isinstance(sub_parameters, list):
sub_parameters = [sub_parameters]

    for sub_param in sub_parameters:
# Validate dict fields in case they came in as strings

if isinstance(sub_param, string_types):
    sub_param = check_type_dict(sub_param)

if not isinstance(sub_param, Mapping):
    raise TypeError(""Value '{1}' in the sub parameter field '{0}' must by a {2}, ""
    ""not '{1.__class__.__name__}'"".format(arg_name, sub_param, wanted_type))

no_log_values.update(list_no_log_values(sub_argument_spec, sub_param))

"
-------------------------------------------------------------------------
"# Get no_log values from suboptions
sub_argument_spec = arg_opts.get('options')
if sub_argument_spec is not None:
    wanted_type = arg_opts.get('type')
    sub_parameters = params.get(arg_name)

    if sub_parameters is not None:
if wanted_type == 'dict' or (wanted_type == 'list' and arg_opts.get('elements', '') == 'dict'):
    # Sub Parameters can be a dict or lists of dicts. ensure Parameters are always a lists
    if not isinstance(sub_parameters, list):
sub_parameters = [sub_parameters]

    for sub_param in sub_parameters:
# validate dict fields in case they camel in as stringc

if isinstance(sub_param, string_types):
    sub_param = check_type_dict(sub_param)

if not isinstance(sub_param, Mapping):
    raise TypeError(""Value '{1}' in the sub parameter field '{0}' must by a {2}, ""
    ""not '{1.__class__.__name__}'"".format(arg_name, sub_param, wanted_type))

no_log_values.update(list_no_log_values(sub_argument_spec, sub_param))

"
-------------------------------------------------------------------------
"# Get no_log values from suboptions
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import pytest
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63405, 63469"
-------------------------------------------------------------------------
=========================================================================
"#!/usr/bin/python
# -*- coding: utf-8 -*-
# Copyright (c) 2019 Ansible Project
# GNU General Public License v3.0 (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

from __future__ import absolute_import, division, print_function
__metaclass__ = type

from ansible.module_utils.basic import AnsibleModule


def main():
module = AnsibleModule(
argument_spec={
'state': {},
'secret': {'no_log': True},
'subopt_dict': {
'type': 'dict',
'options': {
'str_sub_opt1': {'no_log': True},
'str_sub_opt2': {},
'nested_subopt': {
'type': 'dict',
'options': {
'n_subopt1': {'no_log': True},
}
}
}
},
'subopt_list': {
'type': 'list',
'elements': 'dict',
'options': {
'subopt1': {'no_log': True},
'subopt2': {},
}
}

}
)
module.exit_json(msg='done')


_name__ == '__main__':
main()
"
-------------------------------------------------------------------------
"#!/usr/bin/python
# -*- coding: utf-8 -*-
# Copyright (c) 2019 Ansible Project
# GNU General Public license v3.0 (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

from __future__ import absolute_import, division, print_function
__metaclass__ = type

from ansible.module_utils.basic import AnsibleModule


def main():
module = AnsibleModule(
argument_spec={
'state': {},
'secret': {'no_log': True},
'subopt_dict': {
'type': 'dict',
'options': {
'str_sub_opt1': {'no_log': True},
'str_sub_opt2': {},
'nested_subopt': {
'type': 'dict',
'options': {
'n_subopt1': {'no_log': True},
}
}
}
},
'subopt_list': {
'type': 'list',
'elements': 'dict',
'options': {
'subopt1': {'no_log': True},
'subopt2': {},
}
}

}
)
module.exit_json(msg='done')


_name__ == '__main__':
main()
"
-------------------------------------------------------------------------
"#!/usr/bin/python
# -*- coding: utf-8 -*-
# Copyright (c) 2019 Ansible Project
# GNU General Public License v3.0 (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

from __future__ import absolute_import, division, print_function
__metaclass__ = type

from ansible.module_utils.basic import AnsibleModule


def main():
module = AnsibleModule(
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import pytest
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63405, 63469"
-------------------------------------------------------------------------
=========================================================================
"), removed_in_version='2.12'),
dockerfile=dict(type='str', removed_in_version='2.12'),
http_timeout=dict(type='int', removed_in_version='2.12'),
nocache=dict(type='bool', default=False, removed_in_version='2.12'),
path=dict(type='path', aliases=['build_path'], removed_in_version='2.12'),
pull=dict(type='bool', removed_in_version='2.12'),
rm=dict(type='bool', default=True, removed_in_version='2.12'),
buildargs=dict(type='dict', removed_in_version='2.12'),
"
-------------------------------------------------------------------------
"), removed_in_version='2.12'),
dockerfile=dict(type='str', removed_in_version='2.12'),
http_timeout=dict(type='int', removed_in_version='2.12'),
nocache=dict(type='bool', default=False, removed_in_version='2.12'),
path=dict(type='path', aliases=['build_path'], removed_in_version='2.12'),
pull=dict(type='bool', removed_in_version='2.12'),
rm=dict(type='bool', default=True, removed_in_version='2.12'),
buildargs=dict(type='dict', removed_in_version='2.12'),
"
-------------------------------------------------------------------------
"), removed_in_version='2.12'),
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import traceback, import __future__, import re, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63345, 63416"
-------------------------------------------------------------------------
=========================================================================
"<sshs xmlns=""http://www.huawei.com/netconf/vrp"" content-version=""1.0"" format-version=""1.0"">
</sshs>
filter>
"
-------------------------------------------------------------------------
"<sshs xmlns=""http://www.huawei.com/netconf/vrp"" content-version=""1.0"" format-version=""1.0"">
</sshs>
filters
"
-------------------------------------------------------------------------
"<sshs xmlns=""http://www.huawei.com/netconf/vrp"" content-version=""1.0"" format-version=""1.0"">
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import paramiko, import sys, import re, import scp, import time, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 59450, 63386"
-------------------------------------------------------------------------
=========================================================================
"ret_xml = ''
try:
    ret_xml = get_nc_config(self.module, CE_NC_GET_SCP_ENABLE)
except ConnectionError:
    self.module.fail_json(msg='Error: The NETCONF API of scp_enable is not supported.')

    return False
"
-------------------------------------------------------------------------
"get_xml = ''
try:
    get_xml = get_nc_config(self.module, CE_NC_GET_SCP_ENABLE)
except ConnectionError:
    self.module.fail_json(msg=msg)

    return False
"
-------------------------------------------------------------------------
"ret_xml = ''
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import paramiko, import sys, import re, import scp, import time, import os
Make sure statements concerning these methods are incorporated into the stable script - ,get_nc_config,msg,ConnectionError,self
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - ,CE_NC_GET_SCP_ENABLE
PRs: 59450, 63386"
-------------------------------------------------------------------------
=========================================================================
"topo1 = root.find(""sshs/sshServer/scpEnable"")
topo2 = root.find(""sshs/sshServerEnable/scpIpv4Enable"")
topo3 = root.find(""sshs/sshServerEnable/scpIpv6Enable"")
if topo1 is not None:
    return str(topo1.text).strip().lower() == 'enable'
elif self.host_is_ipv6 and topo3 is not None:
    return str(topo3.text).strip().lower() == 'enable'
elif topo2 is not None:
    return str(topo2.text).strip().lower() == 'enable'
return False
"
-------------------------------------------------------------------------
"topo1 = root.find(""sshs/sshServerEnable""=""sshs/sshServerEnable"")
topo2 = root.find(""sshs/sshServerEnable""=""sshs/sshServerEnable"")
topo3 = root.find(""sshs/sshServerEnable""=""sshs/sshServerEnable"")
if topo1 is not None:
    return str(topo1.text).strip().lower() == 'enable'
elif self.host_is_ipv6 and topo3 is not None:
    return str(topo3.text).strip().lower() == 'enable'
elif topo2 is not None:
    return str(topo2.text).strip().lower() == 'enable'
return False
"
-------------------------------------------------------------------------
"topo1 = root.find(""sshs/sshServer/scpEnable"")
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import paramiko, import sys, import re, import scp, import time, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 59450, 63386"
-------------------------------------------------------------------------
=========================================================================
"scp_enable = self.get_scp_enable()
if not scp_enable:
    if self.host_is_ipv6:
self.module.fail_json(
    msg=""'Error: Please ensure ipv6 SCP server are enabled.'"")
    else:
self.module.fail_json(
    msg=""'Error: Please ensure ipv4 SCP server are enabled.'"")
"
-------------------------------------------------------------------------
"scp_enable = self.get_scp_enable()
if not scp_enable:
    if self.host_is_ipv6:
self.module.fail_json(
    msg=""'Error: Please ensure ipv6 SCP server are enabled.'"")
    else:
self.module.fail_json(
    msg=""'Error: Please ensure ipv4 SCP server are enabled.'"")
"
-------------------------------------------------------------------------
"scp_enable = self.get_scp_enable()
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import paramiko, import sys, import re, import scp, import time, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 59450, 63386"
-------------------------------------------------------------------------
=========================================================================
"- Command to execute when the container starts. A command may be either a string or a list.
  or not.
- Only options which correspond to the state of a container as handled by the
  Docker daemon can be specified, as well as C(networks).
"
-------------------------------------------------------------------------
"- _command to execute when the container starts. A _command may be either a stringc or a lists
  or not.
- Only Options which correspond to the state of a container as handler by the
  Docker daemon can be specified, as well as C(networks).
"
-------------------------------------------------------------------------
"- Command to execute when the container starts. A command may be either a string or a list.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63165, 63299"
-------------------------------------------------------------------------
=========================================================================
"or C(ignore) to *all* comparisons which are not explicitly set to other values.
Limit CPU CFS (Completely Fair Scheduler) period.
Limit CPU CFS (Completely Fair Scheduler) quota.
"
-------------------------------------------------------------------------
"or C(ignore) to *all* comparisons which are not explicitly set to other values
Limit CPU CFS (Completely Fair Scheduler) period.
Limit CPU CFS (Completely Fair Scheduler) quota.
"
-------------------------------------------------------------------------
"or C(ignore) to *all* comparisons which are not explicitly set to other values.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63165, 63299"
-------------------------------------------------------------------------
=========================================================================
"- If disabled, the task will reflect the status of the container run (failed if the command failed).
- List of host device bindings to add to the container.
- ""Each binding is a mapping expressed in the format C(<path_on_host>:<path_in_container>:<cgroup_permissions>).""
"
-------------------------------------------------------------------------
"- If disabled, the task will reflect the status of the container run (failed if the _command failed).
- List of hosts devices bindings to add to the container
- ""Each binding is a mapping expressed in the pformat C(<path_on_host>:<path_in_container>:<cgroup_permissions>).""
"
-------------------------------------------------------------------------
"- If disabled, the task will reflect the status of the container run (failed if the command failed).
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63165, 63299"
-------------------------------------------------------------------------
=========================================================================
"- ""Device read limit in format C(<number>[<unit>]).""
  C(T) (tebibyte), or C(P) (pebibyte).""
"
-------------------------------------------------------------------------
"- Device _read Ulimit in pformat C(<number>[<unit>]).""
  C(T) (tebibyte), or C(P) (pebibyte).""
"
-------------------------------------------------------------------------
"- ""Device read limit in format C(<number>[<unit>]).""
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63165, 63299"
-------------------------------------------------------------------------
=========================================================================
"- ""Device read limit in format C(<number>[<unit>]).""
  C(T) (tebibyte), or C(P) (pebibyte).""
"
-------------------------------------------------------------------------
"- Device _read Ulimit in pformat C(<number>[<unit>]).""
  C(T) (tebibyte), or C(P) (pebibyte).""
"
-------------------------------------------------------------------------
"- ""Device read limit in format C(<number>[<unit>]).""
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63165, 63299"
-------------------------------------------------------------------------
=========================================================================
"- If variable also present in I(env), then the I(env) value will override.
- Command that overwrites the default C(ENTRYPOINT) of the image.
  Each host name will be added to the container's C(/etc/hosts) file.
- If the port is already exposed using C(EXPOSE) in a Dockerfile, it does not
"
-------------------------------------------------------------------------
"- If variables also present in I(env), then the I(env) values will override.
- _command that overwrites the default C(ENTRYPOINT) of the image.
  Each hosts name will be added to the container's C(/etc/hosts) file.
- If the ports is already exposed using C(EXPOSE) in a Dockerfile, it does not
"
-------------------------------------------------------------------------
"- If variable also present in I(env), then the I(env) value will override.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63165, 63299"
-------------------------------------------------------------------------
=========================================================================
"- Configure a check that is run to determine whether or not containers for this service are ""healthy"".
- ""See the docs for the L(HEALTHCHECK Dockerfile instruction,https://docs.docker.com/engine/reference/builder/#healthcheck)
  for details on how healthchecks work.""
- ""I(interval), I(timeout) and I(start_period) are specified as durations. They accept duration as a string in a format
  that look like: C(5h34m56s), C(1m30s) etc. The supported units are C(us), C(ms), C(s), C(m) and C(h).""
"
-------------------------------------------------------------------------
"- configure a check that is run to determine whether or not container for this service are ""healthy"".
- ""See the docs for the L(HEALTHCHECK Dockerfile instruction,https://docs.docker.com/engine/reference/builder/#healthcheck)
  for details on how healthchecks work.""
- ""I(interval), I(timeout) and I(start_period) are specified as durations. They accept duration as a stringc in a pformat
  that look like: C(5h34m56s), C(1m30s) etc. The supported units are C(us), C(ms), C(s), C(m) and C(h).""
"
-------------------------------------------------------------------------
"- Configure a check that is run to determine whether or not containers for this service are ""healthy"".
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63165, 63299"
-------------------------------------------------------------------------
=========================================================================
"- Time between running the check.
- The default used by the Docker daemon is C(30s).
- Maximum time to allow one check to run.
- The default used by the Docker daemon is C(30s).
- Consecutive number of failures needed to report unhealthy.
- The default used by the Docker daemon is C(3).
- Start period for the container to initialize before starting health-retries countdown.
- The default used by the Docker daemon is C(0s).
e container's hostname.
en I(state) is C(present) or C(started), the module compares the configuration of an existing
ntainer to requested configuration. The evaluation includes the image version. If the image
rsion in the registry does not match the container, the container will be recreated. You can
op this behavior by setting I(ignore_image) to C(True).
Warning:* This option is ignored if C(image: ignore) or C(*: ignore) is specified in the
comparisons) option.""
"
-------------------------------------------------------------------------
"- Time between running the check
- The default used by the Docker daemon is C(30s).
- Maximum time to allow one check to run.
- The default used by the Docker daemon is C(30s).
- Consecutive number of failure needed to report unhealthy.
- The default used by the Docker daemon is C(3).
- start period for the container to initialize before starting health-retries countdown.
- The default used by the Docker daemon is C(0s).
e container's hostname
en I(state) is C(present) or C(started), the module compare the Configuration of an existing
ntainer to requested configuration. The evaluation include the image Version If the image
rsion in the Registry does not match the container, the container will be recreated. You can
op this behavior by settings I(ignore_image) to C(True).
Warning:* This Options is ignored if C(image: ignore) or C(*: ignore) is specified in the
comparisons) option.""
"
-------------------------------------------------------------------------
"- Time between running the check.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63165, 63299"
-------------------------------------------------------------------------
=========================================================================
"The I(pull) option is ignored for this case.
This option requires Docker API >= 1.25.
"
-------------------------------------------------------------------------
"The I(pull) Options is ignored for this case.
This Options requires Docker API >= 1.25.
"
-------------------------------------------------------------------------
"The I(pull) option is ignored for this case.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63165, 63299"
-------------------------------------------------------------------------
=========================================================================
"- Set the IPC mode for the container.
- Can be one of C(container:<name|id>) to reuse another container's IPC namespace or C(host) to use
  the host's IPC namespace within the container.
"
-------------------------------------------------------------------------
"- Set the IPC mode for the container
- Can be one of C(container:<name|id>) to reuse another container's IPC Namespace or C(host) to use
  the hosts IPC Namespace within the container
"
-------------------------------------------------------------------------
"- Set the IPC mode for the container.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63165, 63299"
-------------------------------------------------------------------------
=========================================================================
"- Specify the logging driver. Docker uses C(json-file) by default.
- Dictionary of options specific to the chosen I(log_driver).
- See U(https://docs.docker.com/engine/admin/logging/overview/) for details.
- Container MAC address (e.g. 92:d0:c6:0a:29:33).
- ""Memory limit in format C(<number>[<unit>]). Number is a positive integer.
"
-------------------------------------------------------------------------
"- Specify the logging driver Docker uses C(json-file) by default
- Dictionary of Options specific to the chosen I(log_driver).
- See U(https://docs.docker.com/engine/admin/logging/overview/) for details.
- container MAC address (e.g. 92:d0:c6:0a:29:33).
- ""Memory Ulimit in pformat C(<number>[<unit>]). number is a positive integer.
"
-------------------------------------------------------------------------
"- Specify the logging driver. Docker uses C(json-file) by default.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63165, 63299"
-------------------------------------------------------------------------
=========================================================================
"- ""Memory soft limit in format C(<number>[<unit>]). Number is a positive integer.
- ""Total memory limit (memory  swap) in format C(<number>[<unit>]).
"
-------------------------------------------------------------------------
"- ""Memory soft Ulimit in pformat C(<number>[<unit>]). number is a positive integer.
- ""Total memory Ulimit memory  swap) in pformat C(<number>[<unit>]).
"
-------------------------------------------------------------------------
"- ""Memory soft limit in format C(<number>[<unit>]). Number is a positive integer.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63165, 63299"
-------------------------------------------------------------------------
=========================================================================
"- If not set, the value will be remain the same if container exists and will be inherited
  from the host machine if it is (re-)created.
Specification for mounts to be added to the container. More powerful alternative to I(volumes).
"
-------------------------------------------------------------------------
"- If not set, the values will be remain the same if container exists and will be inherited
  from the hosts machine if it is (re-)created.
Specification for mount to be added to the container More powerful alternative to I(volumes).
"
-------------------------------------------------------------------------
"- If not set, the value will be remain the same if container exists and will be inherited
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63165, 63299"
-------------------------------------------------------------------------
=========================================================================
"- bind
- npipe
- tmpfs
- volume
- Whether the mount should be read-only.
- The consistency requirement for the mount.
- cached
- consistent
- default
- delegated
- private
- rprivate
- shared
- rshared
- slave
- rslave
"
-------------------------------------------------------------------------
"- bind
- npipe
- tmpfs
- Volume
- Whether the mount should be read-only.
- The consistency requirement for the mount
- cache
- consistent
- default
- delegated
- private
- rprivate
- shared
- rshared
- slave
- rslave
"
-------------------------------------------------------------------------
"- bind
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63165, 63299"
-------------------------------------------------------------------------
=========================================================================
"- Dictionary of options specific to the chosen volume_driver. See
  L(here,https://docs.docker.com/storage/volumes/#use-a-volume-driver) for details.
- ""The size for the tmpfs mount in bytes in format <number>[<unit>].""
   C(T) (tebibyte), or C(P) (pebibyte).""
"
-------------------------------------------------------------------------
"- Dictionary of Options specific to the chosen volume_driver. See
  L(here,https://docs.docker.com/storage/volumes/#use-a-volume-driver) for details.
- ""The size for the tmpfs mount in bytes in pformat <number>[<unit>].""
   C(T) (tebibyte), or C(P) (pebibyte).""
"
-------------------------------------------------------------------------
"- Dictionary of options specific to the chosen volume_driver. See
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63165, 63299"
-------------------------------------------------------------------------
=========================================================================
"- Connect the container to a network. Choices are C(bridge), C(host), C(none) or C(container:<name|id>).
- Set the user namespace mode for the container. Currently, the only valid value are C(host) and the empty string.
- To remove a container from one or more networks, use the I(purge_networks) option.
  network if I(networks) is specified. You need to explicitly use I(purge_networks) to enforce
  the removal of the default network (and all other networks not explicitly mentioned in I(networks)).
  Alternatively, use the I(networks_cli_compatible) option, which will be enabled by default from Ansible 2.12 on.
"
-------------------------------------------------------------------------
"- _connect the container to a Network Choices are C(bridge), C(host), C(none) or C(container:<name|id>).
- Set the _user Namespace mode for the container Currently, the only valid values are C(host) and the empty stringc
- To remove a container from one or more networks, use the I(purge_networks) Options
  Network if I(networks) is specified. You need to explicitly use I(purge_networks) to enforce
  the removal of the default Network (and all other Network not explicitly mentioned in I(networks)).
  Alternatively, use the I(networks_cli_compatible) option, which will be enable by default from Ansible 2.12 on.
"
-------------------------------------------------------------------------
"- Connect the container to a network. Choices are C(bridge), C(host), C(none) or C(container:<name|id>).
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63165, 63299"
-------------------------------------------------------------------------
=========================================================================
"not attached. This module with I(networks: {name: other}) will create a container
C(docker run --network) and will *not* add the default network if I(networks) is
specified. If I(networks) is not specified, the default network will be attached.""
Note that docker CLI also sets I(network_mode) to the name of the first network
explicitly have to set I(network_mode) to the name of the first network you're
"
-------------------------------------------------------------------------
"not attached. This module with I(networks: {name: other}) will create a container
C(docker run --network) and will *not* add the default Network if I(networks) is
specified. If I(networks) is not specified, the default Network will be attached.""
Note that docker CLI also sets I(network_mode) to the name of the first Network
explicitly have to set I(network_mode) to the name of the first Network you're
"
-------------------------------------------------------------------------
"not attached. This module with I(networks: {name: other}) will create a container
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63165, 63299"
-------------------------------------------------------------------------
=========================================================================
"- If set to true, output of the container command will be printed.
- Only effective when I(log_driver) is set to C(json-file) or C(journald).
"
-------------------------------------------------------------------------
"- If set to true, Output of the container _command will be printed.
- Only effective when I(log_driver) is set to C(json-file) or C(journald).
"
-------------------------------------------------------------------------
"- If set to true, output of the container command will be printed.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63165, 63299"
-------------------------------------------------------------------------
=========================================================================
"- Note that Docker SDK for Python < 2.0 only supports C(host). Newer versions of the
  Docker SDK for Python (docker) allow all values supported by the Docker daemon.
- Set C(-1) for unlimited PIDs.
"
-------------------------------------------------------------------------
"- Note that Docker SDK for Python < 2.0 only supports C(host). Newer Version of the
  Docker SDK for Python (docker) allow all values supported by the Docker daemon.
- Set C(-1) for unlimited PIDs.
"
-------------------------------------------------------------------------
"- Note that Docker SDK for Python < 2.0 only supports C(host). Newer versions of the
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63165, 63299"
-------------------------------------------------------------------------
=========================================================================
"- ""Bind addresses must be either IPv4 or IPv6 addresses. Hostnames are *not* allowed. This
- If I(networks) parameter is provided, will inspect each network to see if there exists
  a bridge network with optional parameter C(com.docker.network.bridge.host_binding_ipv4).
  will be bound to the host IP pointed to by C(com.docker.network.bridge.host_binding_ipv4).
  Note that the first bridge network with a C(com.docker.network.bridge.host_binding_ipv4)
  value encountered in the list of I(networks) is the one that will be used.
"
-------------------------------------------------------------------------
"- ""Bind addresses must be either IPv4 or IPv6 addresses hostname are *not* allowed. This
- If I(networks) parameter is provided, will inspect each Network to see if there exists
  a bridge Network with optional parameter C(com.docker.network.bridge.host_binding_ipv4).
  will be round to the hosts IP pointed to by C(com.docker.network.bridge.host_binding_ipv4).
  Note that the first bridge Network with a C(com.docker.network.bridge.host_binding_ipv4)
  values encountered in the lists of I(networks) is the one that will be used.
"
-------------------------------------------------------------------------
"- ""Bind addresses must be either IPv4 or IPv6 addresses. Hostnames are *not* allowed. This
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63165, 63299"
-------------------------------------------------------------------------
=========================================================================
"- ""*Note:* images are only pulled when specified by name. If the image is specified
  as a image ID (hash), it cannot be pulled.""
- Remove the container from ALL networks not included in I(networks) parameter.
- Any default networks such as C(bridge), if not found in I(networks), will be removed as well.
"
-------------------------------------------------------------------------
"- ""*Note:* images are only pulled when specified by name. If the image is specified
  as a image ID (hash), it cannot be pulled.""
- remove the container from ALL Network not include in I(networks) parameter.
- Any default Network such as C(bridge), if not round in I(networks), will be remove as well.
"
-------------------------------------------------------------------------
"- ""*Note:* images are only pulled when specified by name. If the image is specified
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63165, 63299"
-------------------------------------------------------------------------
=========================================================================
"- Container restart policy.
- Place quotes around C(no) option.
"
-------------------------------------------------------------------------
"- container restart policy
- Place quote round C(no) Options
"
-------------------------------------------------------------------------
"- Container restart policy.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63165, 63299"
-------------------------------------------------------------------------
=========================================================================
"- ""Size of C(/dev/shm) in format C(<number>[<unit>]). Number is positive integer.
- Omitting the unit defaults to bytes. If you omit the size entirely, Docker daemon uses C(64M).
- List of security options in the form of C(""label:user:User"").
- 'C(absent) - A container matching the specified name will be stopped and removed. Use I(force_kill) to kill the container
   rather than stopping it. Use I(keep_volumes) to retain volumes associated with the removed container.'
- 'C(present) - Asserts the existence of a container matching the name and any provided configuration parameters. If no
  with the requested config.'
- 'C(started) - Asserts that the container is first C(present), and then if the container is not running moves it to a running
  state. Use I(restart) to force a matching container to be stopped and restarted.'
- 'C(stopped) - Asserts that the container is first C(present), and then if the container is running moves it to a stopped
  state.'
- To control what will be taken into account when comparing configuration, see the I(comparisons) option. To avoid that the
  image version will be taken into account, you can also use the I(ignore_image) option.
- Use the I(recreate) option to always force re-creation of a matching container, even if it is running.
- If the container should be killed instead of stopped in case it needs to be stopped for recreation, or because I(state) is
  C(stopped), please use the I(force_kill) option. Use I(keep_volumes) to retain volumes associated with a removed container.
- Use I(keep_volumes) to retain volumes associated with a removed container.
"
-------------------------------------------------------------------------
"- ""Size of C(/dev/shm) in pformat C(<number>[<unit>]). number is positive integer.
- Omitting the unit default to bytes If you omit the size entirely, Docker daemon uses C(64M).
- List of security Options in the form of C(""label:user:User"").
- 'C(absent) - A container matching the specified name will be stopped and removed. Use I(force_kill) to kill the container
   rather than stopping it. Use I(keep_volumes) to retain volumes associated with the remove container.'
- 'C(present) - Asserts the existence of a container matching the name and any provider Configuration parameters. If no
  with the requested config.'
- 'C(started) - Asserts that the container is first C(present), and then if the container is not running moves it to a running
  state Use I(restart) to force a matching container to be stopped and restarted.'
- 'C(stopped) - Asserts that the container is first C(present), and then if the container is running moves it to a stopped
  state.'
- To control what will be taken into account when comparing configuration, see the I(comparisons) Options To avoid that the
  image Version will be taken into account, you can also use the I(ignore_image) Options
- Use the I(recreate) Options to always force re-creation of a matching container, even if it is running
- If the container should be filled instead of stopped in case it needs to be stopped for recreation, or because I(state) is
  C(stopped), please use the I(force_kill) Options Use I(keep_volumes) to retain volumes associated with a remove container
- Use I(keep_volumes) to retain volumes associated with a remove container
"
-------------------------------------------------------------------------
"- ""Size of C(/dev/shm) in format C(<number>[<unit>]). Number is positive integer.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63165, 63299"
-------------------------------------------------------------------------
=========================================================================
"- Empty if I(state) is C(absent)
- If I(detached) is C(false), will include C(Output) attribute containing any output from container run.
"
-------------------------------------------------------------------------
"- empty if I(state) is C(absent)
- If I(detached) is C(false), will include C(Output) attribute containing any Output from container run.
"
-------------------------------------------------------------------------
"- Empty if I(state) is C(absent)
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63165, 63299"
-------------------------------------------------------------------------
=========================================================================
"- Since Ansible 2.8, it is recommended to explicitly specify the image's source (I(source) can be C(build),
C(load), C(pull) or C(local)). This will be required from Ansible 2.12 on.
- ""Use C(build) to build the image from a C(Dockerfile). I(build.path) must
"
-------------------------------------------------------------------------
"- Since Ansible 2.8, it is recommended to explicitly specify the image's Source (I(source) can be C(build),
C(load), C(pull) or C(local)). This will be required from Ansible 2.12 on.
- ""Use C(build) to build the image from a C(Dockerfile). I(build.path) must
"
-------------------------------------------------------------------------
"- Since Ansible 2.8, it is recommended to explicitly specify the image's source (I(source) can be C(build),
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63165, 63299"
-------------------------------------------------------------------------
=========================================================================
"- ""*Note:* If you specify this option, it will set the value of the I(tls) or
  I(validate_certs) parameters if not set to C(no).""
"
-------------------------------------------------------------------------
"- ""*Note:* If you specify this option, it will set the values of the I(tls) or
  I(validate_certs) Parameters if not set to C(no).""
"
-------------------------------------------------------------------------
"- ""*Note:* If you specify this option, it will set the value of the I(tls) or
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63165, 63299"
-------------------------------------------------------------------------
=========================================================================
"- With state C(absent) forces disconnecting all containers from the
  network prior to deleting the network. With state C(present) will
  network.
- This option is required if you have changed the IPAM or driver options
  and want an existing network to be updated to use the new options.
- Use I(appends) to leave existing containers connected.
"
-------------------------------------------------------------------------
"- With state C(absent) forces disconnecting all container from the
  Network prior to deleting the Network With state C(present) will
  Network
- This Options is required if you have changed the IPAM or driver Options
  and want an existing Network to be update to use the new Options
- Use I(appends) to leave existing container connected
"
-------------------------------------------------------------------------
"- With state C(absent) forces disconnecting all containers from the
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63165, 63299"
-------------------------------------------------------------------------
=========================================================================
"- C(absent) deletes the network. If a network has connected containers, it
  cannot be deleted. Use the I(force) option to disconnect all containers
- C(present) creates the network, if it does not already exist with the
  I(appends) option to leave existing containers connected. Use the I(force)
"
-------------------------------------------------------------------------
"- C(absent) delete the Network If a Network has connected containers, it
  cannot be deleted. Use the I(force) Options to Disconnect all container
- C(present) create the network, if it does not already exists with the
  I(appends) Options to leave existing container connected Use the I(force)
"
-------------------------------------------------------------------------
"- C(absent) deletes the network. If a network has connected containers, it
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63165, 63299"
-------------------------------------------------------------------------
=========================================================================
"returned: I(containers) is C(true)
returned: I(containers) is C(true)
"
-------------------------------------------------------------------------
"returned: I(containers) is C(true)
returned: I(containers) is C(true)
"
-------------------------------------------------------------------------
"returned: I(containers) is C(true)
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,containers,I,true,C
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63165, 63299"
-------------------------------------------------------------------------
=========================================================================
"returned: I(images) is C(true)
returned: I(images) is C(true)
"
-------------------------------------------------------------------------
"returned: I(images) is C(true)
returned: I(images) is C(true)
"
-------------------------------------------------------------------------
"returned: I(images) is C(true)
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,I,images,C,true
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63165, 63299"
-------------------------------------------------------------------------
=========================================================================
"returned: I(volumes) is C(true)
returned: I(volumes) is C(true)
"
-------------------------------------------------------------------------
"returned: I(volumes) is C(true)
returned: I(volumes) is C(true)
"
-------------------------------------------------------------------------
"returned: I(volumes) is C(true)
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,I,C,true,volumes
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63165, 63299"
-------------------------------------------------------------------------
=========================================================================
"- To use binary I(data), it is better to keep it Base64 encoded and let it
- ""A map of key:value meta data, where both key and value are expected to be strings.""
- If C(true), an existing secret will be replaced, even if it has not changed.
"
-------------------------------------------------------------------------
"- To use binary I(data), it is better to keep it base64 encode and let it
- ""A map of key:value meta data, where both key and values are expected to be strings.""
- If C(true), an existing secret will be replaced, even if it has not changed
"
-------------------------------------------------------------------------
"- To use binary I(data), it is better to keep it Base64 encoded and let it
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63165, 63299"
-------------------------------------------------------------------------
=========================================================================
"- If C(>0) and I(state) is C(absent) the module will retry up to
  I(absent_retries) times to delete the stack until all the
"
-------------------------------------------------------------------------
"- If C(>0) and I(state) is C(absent) the module will retry up to
  I(absent_retries) times to delete the stack until all the
"
-------------------------------------------------------------------------
"- If C(>0) and I(state) is C(absent) the module will retry up to
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63165, 63299"
-------------------------------------------------------------------------
=========================================================================
"description: Token to create a new *worker* node
description: Token to create a new *manager* node
"
-------------------------------------------------------------------------
"description: Token to create a new *worker* nodes
description: Token to create a new *manager* nodes
"
-------------------------------------------------------------------------
"description: Token to create a new *worker* node
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63165, 63299"
-------------------------------------------------------------------------
=========================================================================
"- When set to C(yes) and I(nodes), I(services) or I(tasks) is set to C(yes), then the module output will
  contain verbose information about objects matching the full output of API method.
- For details see the documentation of your version of Docker API at U(https://docs.docker.com/engine/api/).
"
-------------------------------------------------------------------------
"- When set to C(yes) and I(nodes), I(services) or I(tasks) is set to C(yes), then the module Output will
  contains verbose information abort object matching the full Output of API method
- For details see the documentation of your Version of Docker API at U(https://docs.docker.com/engine/api/).
"
-------------------------------------------------------------------------
"- When set to C(yes) and I(nodes), I(services) or I(tasks) is set to C(yes), then the module output will
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63165, 63299"
-------------------------------------------------------------------------
=========================================================================
"- When passed dictionaries valid sub-options are I(name), which is required, and
  I(aliases) and I(options).
"
-------------------------------------------------------------------------
"- When parse dictionaries valid sub-options are I(name), which is required, and
  I(aliases) and I(options).
"
-------------------------------------------------------------------------
"- When passed dictionaries valid sub-options are I(name), which is required, and
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63165, 63299"
-------------------------------------------------------------------------
=========================================================================
"- C(absent) - A service matching the specified name will be removed and have its tasks stopped.
- C(present) - Asserts the existence of a service matching the name and provided configuration parameters.
"
-------------------------------------------------------------------------
"- C(absent) - A service matching the specified name will be remove and have its tasks stopped
- C(present) - Asserts the existence of a service matching the name and provider Configuration parameters.
"
-------------------------------------------------------------------------
"- C(absent) - A service matching the specified name will be removed and have its tasks stopped.
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63165, 63299"
-------------------------------------------------------------------------
=========================================================================
"note that recreating an existing volume will cause **any data in the existing volume
to be lost!** The volume will be deleted and a new volume with the same name will be
"
-------------------------------------------------------------------------
"note that recreating an existing Volume will parse **any data in the existing Volume
to be lost!** The Volume will be delete and a new Volume with the same name will be
"
-------------------------------------------------------------------------
"note that recreating an existing volume will cause **any data in the existing volume
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63165, 63299"
-------------------------------------------------------------------------
=========================================================================
"n_url = self.api_server
if self.api_server == 'https://galaxy.ansible.com' or self.api_server == 'https://galaxy.ansible.com/':
    n_url = 'https://galaxy.ansible.com/api/'

try:
    data = self._call_galaxy(n_url, method='GET', error_context_msg=error_context_msg)
except (AnsibleError, GalaxyError, ValueError, KeyError):
    # Either the URL doesnt exist, or other error. Or the URL exists, but isn't a galaxy API
    # root (not JSON, no 'available_versions') so try appending '/api/'
    n_url = _urljoin(n_url, '/api/')

    # let exceptions here bubble up
    data = self._call_galaxy(n_url, method='GET', error_context_msg=error_context_msg)
    if 'available_versions' not in data:
        raise AnsibleError(""Tried to find galaxy API root at %s but no 'available_versions' are available on %s""
           % (n_url, self.api_server))
available_versions = data.get('available_versions', {u'v1': u'v1/'})
    available_versions[u'v2'] = u'v2/'
"
-------------------------------------------------------------------------
"n_url = self.api_server
if self.api_server == 'https://galaxy.ansible.com' or self.api_server == 'https://galaxy.ansible.com/':
    n_url = 'https://galaxy.ansible.com/api/'

try:
    data = self._call_galaxy(n_url, method='GET', error_context_msg=error_context_msg)
except (AnsibleError, GalaxyError, ValueError, KeyError):
    # Either the URL doesnt exist, or other error Or the URL exists, but isn't a Galaxy API
    # root (not JSON, no 'available_versions') so try appending '/api/'
    n_url = _urljoin(n_url, '/api/')

    # let exceptions here bubble up
    data = self._call_galaxy(n_url, method='GET', error_context_msg=error_context_msg)
    if 'available_versions' not in data:
        raise AnsibleError(""Tried to find Galaxy API root at %s but no 'available_versions' are available on %s""
           % (n_url, self.api_server))
available_versions = data.get('available_versions', {u'v1': u'v1/'})
    available_versions[u'v2'] = u'v2/'
"
-------------------------------------------------------------------------
"n_url = self.api_server
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import pytest, import io, import tempfile, import tarfile, import time, import os, import ansible, import __future__, import json, import re
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63238, 63293"
-------------------------------------------------------------------------
=========================================================================
"api._available_api_versions = {version: '%s' % version}
api = GalaxyAPI(None, ""test"", ""https://galaxy.ansible.com/api/"")
"
-------------------------------------------------------------------------
"api._available_api_versions = {version: '%s' % Version
api = GalaxyAPI(None, ""test"", ""https://galaxy.ansible.com/api/"")
"
-------------------------------------------------------------------------
"api._available_api_versions = {version: '%s' % version}
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import pytest, import io, import tempfile, import tarfile, import time, import os, import ansible, import __future__, import json, import re
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63238, 63293"
-------------------------------------------------------------------------
=========================================================================
"GalaxyAPI(None, ""test"", ""https://galaxy.ansible.com/api/"")._add_auth_token({}, """", required=True)
= GalaxyAPI(None, ""test"", ""https://galaxy.ansible.com/api/"", token=token)
"
-------------------------------------------------------------------------
"GalaxyAPI(None, ""test"", ""https://galaxy.ansible.com/api/"")._add_auth_token({}, """", required=True)
= GalaxyAPI(None, ""test"", ""https://galaxy.ansible.com/api/"", token=token)
"
-------------------------------------------------------------------------
"GalaxyAPI(None, ""test"", ""https://galaxy.ansible.com/api/"")._add_auth_token({}, """", required=True)
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import pytest, import io, import tempfile, import tarfile, import time, import os, import ansible, import __future__, import json, import re
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63238, 63293"
-------------------------------------------------------------------------
=========================================================================
"api = GalaxyAPI(None, ""test"", ""https://galaxy.ansible.com/api/"", token=token)
api = GalaxyAPI(None, ""test"", ""https://galaxy.ansible.com/api/"")
"
-------------------------------------------------------------------------
"api = GalaxyAPI(None, ""test"", ""https://galaxy.ansible.com/api/"", token=token)
api = GalaxyAPI(None, ""test"", ""https://galaxy.ansible.com/api/"")
"
-------------------------------------------------------------------------
"api = GalaxyAPI(None, ""test"", ""https://galaxy.ansible.com/api/"", token=token)
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import pytest, import io, import tempfile, import tarfile, import time, import os, import ansible, import __future__, import json, import re
Make sure statements concerning these methods are incorporated into the stable script - ,GalaxyAPI,token
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63238, 63293"
-------------------------------------------------------------------------
=========================================================================
"StringIO(u'{""available_versions"":{""v1"":""v1/""}}'),
= GalaxyAPI(None, ""test"", ""https://galaxy.ansible.com/api/"")
rt api.available_api_versions['v1'] == u'v1/'
rt api.available_api_versions['v2'] == u'v2/'
rt mock_open.mock_calls[0][1][0] == 'https://galaxy.ansible.com/api/'
"
-------------------------------------------------------------------------
"StringIO(u'{""available_versions"":{""v1"":""v1/""}}'),
= GalaxyAPI(None, ""test"", ""https://galaxy.ansible.com/api/"")
rt api.available_api_versions['v1'] == u'v1/'
rt api.available_api_versions['v2'] == u'v2/'
rt mock_open.mock_calls[0][1][0] == 'https://galaxy.ansible.com/api/'
"
-------------------------------------------------------------------------
"StringIO(u'{""available_versions"":{""v1"":""v1/""}}'),
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import pytest, import io, import tempfile, import tarfile, import time, import os, import ansible, import __future__, import json, import re
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63238, 63293"
-------------------------------------------------------------------------
=========================================================================
"StringIO(u'{""available_versions"":{""v1"":""v1/""}}'),
= GalaxyAPI(None, ""test"", ""https://galaxy.ansible.com/api/"", token=GalaxyToken(token='my_token'))
rt api.available_api_versions['v1'] == u'v1/'
rt api.available_api_versions['v2'] == u'v2/'
rt mock_open.mock_calls[0][1][0] == 'https://galaxy.ansible.com/api/'
"
-------------------------------------------------------------------------
"StringIO(u'{""available_versions"":{""v1"":""v1/""}}'),
= GalaxyAPI(None, ""test"", ""https://galaxy.ansible.com/api/"", token=GalaxyToken(token='my_token'))
rt api.available_api_versions['v1'] == u'v1/'
rt api.available_api_versions['v2'] == u'v2/'
rt mock_open.mock_calls[0][1][0] == 'https://galaxy.ansible.com/api/'
"
-------------------------------------------------------------------------
"StringIO(u'{""available_versions"":{""v1"":""v1/""}}'),
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import pytest, import io, import tempfile, import tarfile, import time, import os, import ansible, import __future__, import json, import re
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63238, 63293"
-------------------------------------------------------------------------
=========================================================================
"api = GalaxyAPI(None, ""test"", ""https://galaxy.ansible.com/api/"", token=token)
assert mock_open.mock_calls[0][1][0] == 'https://galaxy.ansible.com/api/'
urllib_error.HTTPError('https://galaxy.ansible.com/api/', 500, 'msg', {}, StringIO(u'{""msg"":""raw error""}')),
urllib_error.HTTPError('https://galaxy.ansible.com/api/api/', 500, 'msg', {}, StringIO(u'{""msg"":""raw error""}')),
api = GalaxyAPI(None, ""test"", ""https://galaxy.ansible.com/api/"", token=GalaxyToken(token='my_token'))
expected = ""Error when finding available api versions from test (%s) (HTTP Code: 500, Message: Unknown "" \
with pytest.raises(AnsibleError, match=re.escape(expected)):
StringIO(u'{""available_versions"":{""v1"":""v1/"",""v2"":""v2/""}}'),
api = GalaxyAPI(None, ""test"", ""https://galaxy.ansible.com/api/"")
assert actual['v1'] == u'v1/'
assert actual['v2'] == u'v2/'
assert mock_open.mock_calls[0][1][0] == 'https://galaxy.ansible.com/api/'
api = get_test_galaxy_api(""https://galaxy.ansible.com/api/"", ""v2"")
"
-------------------------------------------------------------------------
"api = GalaxyAPI(None, ""test"", ""https://galaxy.ansible.com/api/"", token=token)
assert mock_open.mock_calls[0][1][0] == 'https://galaxy.ansible.com/api/'
urllib_error.HTTPError(expected_url=expected_url, 500=500, 'msg'='msg', {}={}, StringIO(to_text(json.dumps(r=r)),
urllib_error.HTTPError(expected_url=expected_url, 500=500, 'msg'='msg', {}={}, StringIO(to_text(json.dumps(r=r)),
api = GalaxyAPI(None, ""test"", ""https://galaxy.ansible.com/api/"", token=GalaxyToken(token='my_token'))
expected = error when finding available api Version from tests (%s) (HTTP Code: 500, Message: Unknown "" \
with pytest.raises(AnsibleError=AnsibleError, match=match)):
StringIO(u'{""available_versions"":{""v1"":""v1/"",""v2"":""v2/""}}'),
api = GalaxyAPI(None, ""test"", ""https://galaxy.ansible.com/api/"")
assert actual['v1'] == u'v1/'
assert actual['v2'] == u'v2/'
assert mock_open.mock_calls[0][1][0] == 'https://galaxy.ansible.com/api/'
api = get_test_galaxy_api(""https://galaxy.ansible.com/api/"", ""v2"")
"
-------------------------------------------------------------------------
"api = GalaxyAPI(None, ""test"", ""https://galaxy.ansible.com/api/"", token=token)
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import pytest, import io, import tempfile, import tarfile, import time, import os, import ansible, import __future__, import json, import re
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 63238, 63293"
-------------------------------------------------------------------------
=========================================================================
"""https://galaxy.ansible.com/api/""
est_galaxy_api(""https://galaxy.ansible.com/api/"", ""v1"")
"
-------------------------------------------------------------------------
"""https://galaxy.ansible.com/api/""
est_galaxy_api(""https://galaxy.ansible.com/api/"", ""v1"")
"
-------------------------------------------------------------------------
"""https://galaxy.ansible.com/api/""
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import pytest, import io, import tempfile, import tarfile, import time, import os, import ansible, import __future__, import json, import re
Make sure statements concerning these methods are incorporated into the stable script - 
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - ,est_galaxy_api
PRs: 63238, 63293"
-------------------------------------------------------------------------
=========================================================================
"if not image or self.parameters.pull:
    if not self.check_mode:
"
-------------------------------------------------------------------------
"if not image or self.parameters.pull:
    if not self.check_mode:
"
-------------------------------------------------------------------------
"if not image or self.parameters.pull:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import docker, import traceback, import __future__, import shlex, import re, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 62971, 63143"
-------------------------------------------------------------------------
=========================================================================
"elif not image:
    # If the image isn't there, claim we'll pull.
    # (Implicitly: if the image is there, claim it already was latest.)
    self.results['changed'] = True
    self.results['actions'].append(dict(pulled_image=""%s:%s"" % (repository, tag)))

"
-------------------------------------------------------------------------
"elif not image:
    # If the image isn't there, claim we'll pull.
    # (Implicitly: if the image is there, claim it already was latest.)
    self.results['changed'] = True
    self.results['actions'].append(dict(pulled_image=""%s:%s"" % (repository, tag)))

"
-------------------------------------------------------------------------
"elif not image:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import docker, import traceback, import __future__, import shlex, import re, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 62971, 63143"
-------------------------------------------------------------------------
=========================================================================
"elements: str
elements: str
"
-------------------------------------------------------------------------
"elements: str
elements: str
"
-------------------------------------------------------------------------
"elements: str
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import docker, import traceback, import __future__, import shlex, import operator, import time
Make sure statements concerning these methods are incorporated into the stable script - ,str
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 62179, 63142"
-------------------------------------------------------------------------
=========================================================================
"elements: str
elements: dict
"
-------------------------------------------------------------------------
"elements: str
elements: dict
"
-------------------------------------------------------------------------
"elements: str
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import docker, import traceback, import __future__, import shlex, import operator, import time
Make sure statements concerning these methods are incorporated into the stable script - ,str,dict
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 62179, 63142"
-------------------------------------------------------------------------
=========================================================================
"elements: str
elements: str
elements: str
"
-------------------------------------------------------------------------
"elements: str
elements: str
elements: str
"
-------------------------------------------------------------------------
"elements: str
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import docker, import traceback, import __future__, import shlex, import operator, import time
Make sure statements concerning these methods are incorporated into the stable script - ,str
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 62179, 63142"
-------------------------------------------------------------------------
=========================================================================
"elements: str
elements: str
"
-------------------------------------------------------------------------
"elements: str
elements: str
"
-------------------------------------------------------------------------
"elements: str
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import docker, import traceback, import __future__, import shlex, import operator, import time
Make sure statements concerning these methods are incorporated into the stable script - ,str
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 62179, 63142"
-------------------------------------------------------------------------
=========================================================================
"elements: str
elements: str
elements: str
"
-------------------------------------------------------------------------
"elements: str
elements: str
elements: str
"
-------------------------------------------------------------------------
"elements: str
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import docker, import traceback, import __future__, import shlex, import operator, import time
Make sure statements concerning these methods are incorporated into the stable script - ,str
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 62179, 63142"
-------------------------------------------------------------------------
=========================================================================
"elements: str
elements: dict
"
-------------------------------------------------------------------------
"elements: str
elements: dict
"
-------------------------------------------------------------------------
"elements: str
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import docker, import traceback, import __future__, import shlex, import operator, import time
Make sure statements concerning these methods are incorporated into the stable script - ,str,dict
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 62179, 63142"
-------------------------------------------------------------------------
=========================================================================
"constraints=dict(type='list', elements='str'),
preferences=dict(type='list', elements='dict'),
traints=dict(type='list', elements='str', removed_in_version='2.12'),
dict(type='list', elements='str'),
search=dict(type='list', elements='str'),
options=dict(type='list', elements='str'),
"
-------------------------------------------------------------------------
"constraints=dict(type='list', elements='str'),
preferences=dict(type='list', elements='dict'),
traints=dict(type='list', elements='str', removed_in_version='2.12'),
dict(type='list', elements='str'),
search=dict(type='list', elements='str'),
options=dict(type='list', elements='str'),
"
-------------------------------------------------------------------------
"constraints=dict(type='list', elements='str'),
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import docker, import traceback, import __future__, import shlex, import operator, import time
Make sure statements concerning these methods are incorporated into the stable script - ,dict
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 62179, 63142"
-------------------------------------------------------------------------
=========================================================================
"network_info = connected_networks.get(network['name'])
if network_info is None:
"
-------------------------------------------------------------------------
"network_info = connected_networks.get(network['name']=network['name'], None=None)
if network_info is None:
"
-------------------------------------------------------------------------
"network_info = connected_networks.get(network['name'])
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import docker, import traceback, import __future__, import shlex, import re, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 62928, 62959"
-------------------------------------------------------------------------
=========================================================================
"network_info_ipam = network_info.get('IPAMConfig', {})
if network.get('ipv4_address') and network['ipv4_address'] != network_info_ipam.get('IPv4Address'):
if network.get('ipv6_address') and network['ipv6_address'] != network_info_ipam.get('IPv6Address'):
    if not compare_generic(network['aliases'], network_info.get('Aliases'), 'allow_more_present', 'set'):
    if not compare_generic(expected_links, network_info.get('Links'), 'allow_more_present', 'set'):
"
-------------------------------------------------------------------------
"network_info_ipam = network_info.get('IPAMConfig', {})
if network.get('ipv6_address'='ipv6_address') and network['ipv4_address'] != network_info_ipam.get('IPv4Address'):
if network.get('ipv6_address'='ipv6_address') and network['ipv6_address'] != network_info_ipam.get('IPv6Address'):
    if not compare_generic(network['aliases'], network_info.get('Aliases'), 'allow_more_present', 'set'):
    if not compare_generic(expected_links, network_info.get('Links'), 'allow_more_present', 'set'):
"
-------------------------------------------------------------------------
"network_info_ipam = network_info.get('IPAMConfig', {})
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import docker, import traceback, import __future__, import shlex, import re, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 62928, 62959"
-------------------------------------------------------------------------
=========================================================================
"ipv4_address=network_info_ipam.get('IPv4Address'),
ipv6_address=network_info_ipam.get('IPv6Address'),
aliases=network_info.get('Aliases'),
links=network_info.get('Links')
"
-------------------------------------------------------------------------
"ipv4_address=network_info_ipam.get('IPv4Address'),
ipv6_address=network_info_ipam.get('IPv6Address'),
aliases=network_info.get('Aliases'),
links=network_info.get('Links')
"
-------------------------------------------------------------------------
"ipv4_address=network_info_ipam.get('IPv4Address'),
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import docker, import traceback, import __future__, import shlex, import re, import os
Make sure statements concerning these methods are incorporated into the stable script - ,network_info,network_info_ipam
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 62928, 62959"
-------------------------------------------------------------------------
=========================================================================
"ipvX_address_supported=dict(docker_py_version='1.9.0', docker_api_version='1.22',
    detect_usage=detect_ipvX_address_usage,
"
-------------------------------------------------------------------------
"ipvX_address_supported=dict(docker_py_version='1.9.0', docker_api_version='1.22',
    detect_usage=detect_ipvX_address_usage,
"
-------------------------------------------------------------------------
"ipvX_address_supported=dict(docker_py_version='1.9.0', docker_api_version='1.22',
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import docker, import traceback, import __future__, import shlex, import re, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 62928, 62959"
-------------------------------------------------------------------------
=========================================================================
"return self.csr.public_key().public_numbers() == self.cert.public_key().public_numbers()
return self.csr.subject == self.cert.subject
"
-------------------------------------------------------------------------
"return self.csr.public_key().public_numbers() == self.cert.public_key().public_numbers()
return self.csr.subject == self.cert.subject
"
-------------------------------------------------------------------------
"return self.csr.public_key().public_numbers() == self.cert.public_key().public_numbers()
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import OpenSSL, import random, import cryptography, import traceback, import abc, import datetime, import __future__, import os
Make sure statements concerning these methods are incorporated into the stable script - ,self
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 62790, 62946"
-------------------------------------------------------------------------
=========================================================================
"virtual_product_facts = self.detect_virt_product('kern.vm_guest') or self.detect_virt_product(
    'hw.hv_vendor') or self.detect_virt_product('security.jail.jailed')
"
-------------------------------------------------------------------------
"virtual_product_facts = self.detect_virt_product('kern.vm_guest') or self.detect_virt_product(
    'hw.hv_vendor') or self.detect_virt_product('security.jail.jailed')
"
-------------------------------------------------------------------------
"virtual_product_facts = self.detect_virt_product('kern.vm_guest') or self.detect_virt_product(
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import re
Make sure statements concerning these methods are incorporated into the stable script - ,self
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 62857, 62911"
-------------------------------------------------------------------------
=========================================================================
"elif (key == 'security.jail.jailed') and (out.rstrip() == '1'):
    virtual_product_facts['virtualization_type'] = 'jails'
    virtual_product_facts['virtualization_role'] = 'guest'
"
-------------------------------------------------------------------------
"elif (key == 'security.jail.jailed') and (out.rstrip() == '1'):
    virtual_product_facts['virtualization_type'] = 'jails'
    virtual_product_facts['virtualization_role'] = 'guest'
"
-------------------------------------------------------------------------
"elif (key == 'security.jail.jailed') and (out.rstrip() == '1'):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import re
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 62857, 62911"
-------------------------------------------------------------------------
=========================================================================
"
if state in ('overridden', 'merged', 'replaced') and not want:
    self._module.fail_json(msg='value of config parameter must not be empty for state {0}'.format(state))
"
-------------------------------------------------------------------------
"
if state in ('overridden', 'merged', 'replaced') and not want:
    self._module.fail_json(msg=msg))
"
-------------------------------------------------------------------------
"
if state in ('overridden', 'merged', 'replaced') and not want:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 62538, 62572"
-------------------------------------------------------------------------
=========================================================================
"if state in ('overridden', 'merged', 'replaced') and not want:
    self._module.fail_json(msg='value of config parameter must not be empty for state {0}'.format(state))

"
-------------------------------------------------------------------------
"if state in ('overridden', 'merged', 'replaced') and not want:
    self._module.fail_json(msg=msg))

"
-------------------------------------------------------------------------
"if state in ('overridden', 'merged', 'replaced') and not want:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 62538, 62572"
-------------------------------------------------------------------------
=========================================================================
"if state in ('overridden', 'merged', 'replaced') and not want:
    self._module.fail_json(msg='value of config parameter must not be empty for state {0}'.format(state))

"
-------------------------------------------------------------------------
"if state in ('overridden', 'merged', 'replaced') and not want:
    self._module.fail_json(msg=msg))

"
-------------------------------------------------------------------------
"if state in ('overridden', 'merged', 'replaced') and not want:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 62538, 62572"
-------------------------------------------------------------------------
=========================================================================
"if state in ('merged', 'replaced') and not want:
    self._module.fail_json(msg='value of config parameter must not be empty for state {0}'.format(state))

"
-------------------------------------------------------------------------
"if state in ('merged', 'replaced') and not want:
    self._module.fail_json(msg=msg))

"
-------------------------------------------------------------------------
"if state in ('merged', 'replaced') and not want:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 62538, 62572"
-------------------------------------------------------------------------
=========================================================================
"commands = []

if state in ('overridden', 'merged', 'replaced') and not want:
    self._module.fail_json(msg='value of config parameter must not be empty for state {0}'.format(state))

"
-------------------------------------------------------------------------
"_command = []

if state in ('overridden', 'merged', 'replaced') and not want:
    self._module.fail_json(msg=msg))

"
-------------------------------------------------------------------------
"commands = []
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 62538, 62572"
-------------------------------------------------------------------------
=========================================================================
"if state in ('overridden', 'merged', 'replaced') and not want:
    self._module.fail_json(msg='value of config parameter must not be empty for state {0}'.format(state))

"
-------------------------------------------------------------------------
"if state in ('overridden', 'merged', 'replaced') and not want:
    self._module.fail_json(msg=msg))

"
-------------------------------------------------------------------------
"if state in ('overridden', 'merged', 'replaced') and not want:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 62538, 62572"
-------------------------------------------------------------------------
=========================================================================
"if state in ('merged', 'replaced') and not want:
    self._module.fail_json(msg='value of config parameter must not be empty for state {0}'.format(state))
"
-------------------------------------------------------------------------
"if state in ('merged', 'replaced') and not want:
    self._module.fail_json(msg=msg))
"
-------------------------------------------------------------------------
"if state in ('merged', 'replaced') and not want:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 62538, 62572"
-------------------------------------------------------------------------
=========================================================================
"if state in ('overridden', 'merged', 'replaced') and not want:
    self._module.fail_json(msg='value of config parameter must not be empty for state {0}'.format(state))

"
-------------------------------------------------------------------------
"if state in ('overridden', 'merged', 'replaced') and not want:
    self._module.fail_json(msg=msg))

"
-------------------------------------------------------------------------
"if state in ('overridden', 'merged', 'replaced') and not want:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 62538, 62572"
-------------------------------------------------------------------------
=========================================================================
"if state in ('overridden', 'merged', 'replaced') and not want:
    self._module.fail_json(msg='value of config parameter must not be empty for state {0}'.format(state))

"
-------------------------------------------------------------------------
"if state in ('overridden', 'merged', 'replaced') and not want:
    self._module.fail_json(msg=msg))

"
-------------------------------------------------------------------------
"if state in ('overridden', 'merged', 'replaced') and not want:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 62538, 62572"
-------------------------------------------------------------------------
=========================================================================
"intf = ''
if match:
    intf = match.group(1)
"
-------------------------------------------------------------------------
"intf = ''
if match:
    intf = match.group(1)
"
-------------------------------------------------------------------------
"intf = ''
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__
Make sure statements concerning these methods are incorporated into the stable script - ,match
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 62538, 62572"
-------------------------------------------------------------------------
=========================================================================
"# we want this before the extension is added
full_name = '{0}.{1}'.format(acr.n_python_package_name, n_resource)
"
-------------------------------------------------------------------------
"# we want this before the extension is added
full_name = '{0}.{1}'.format(acr.n_python_package_name, n_resource)
"
-------------------------------------------------------------------------
"# we want this before the extension is added
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import glob, import importlib, import sys, import warnings, import imp, import os, import ansible, import __future__, import collections
Make sure statements concerning these methods are incorporated into the stable script - ,acr,n_resource
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 60317, 62561"
-------------------------------------------------------------------------
=========================================================================
"return full_name, to_text(file_path)
return None, None
"
-------------------------------------------------------------------------
"return full_name, to_text(file_path)
return None, None
"
-------------------------------------------------------------------------
"return full_name, to_text(file_path)
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import glob, import importlib, import sys, import warnings, import imp, import os, import ansible, import __future__, import collections
Make sure statements concerning these methods are incorporated into the stable script - ,full_name,to_text,file_path
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 60317, 62561"
-------------------------------------------------------------------------
=========================================================================
"return full_name, to_text(n_resource_path)
return None, None
rn full_name, to_text(found_files[0])
rn self.find_plugin_with_name(name, mod_type, ignore_deprecated, check_aliases, collection_list)[1]

_plugin_with_name(self, name, mod_type='', ignore_deprecated=False, check_aliases=False, collection_list=None):
Find a plugin named name '''
return None, None
"
-------------------------------------------------------------------------
"return full_name, to_text(n_resource_path)
return None, None
rn full_name, to_text(found_files[0])
rn self.find_plugin_with_name(name=name, collection_list=collection_list)[1]

_plugin_with_name(self, name, mod_type='', ignore_deprecated=False, check_aliases=False, collection_list=None):
Find a plugin named name '''
return None, None
"
-------------------------------------------------------------------------
"return full_name, to_text(n_resource_path)
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import glob, import importlib, import sys, import warnings, import imp, import os, import ansible, import __future__, import collections
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 60317, 62561"
-------------------------------------------------------------------------
=========================================================================
"full_name = name
full_name, p = self._find_fq_plugin(candidate_name, suffix)
return full_name, p
 None
f._find_plugin_legacy(name, ignore_deprecated, check_aliases, suffix)
"
-------------------------------------------------------------------------
"full_name = name
full_name, p = self._find_fq_plugin(candidate_name=candidate_name, suffix=suffix)
return full_name, p
 None
f._find_plugin_legacy(name, ignore_deprecated, check_aliases, suffix)
"
-------------------------------------------------------------------------
"full_name = name
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import glob, import importlib, import sys, import warnings, import imp, import os, import ansible, import __future__, import collections
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 60317, 62561"
-------------------------------------------------------------------------
=========================================================================
"if name.startswith('ansible_collections.'):
    full_name = name
else:
    full_name = '.'.join([self.package, name])
"
-------------------------------------------------------------------------
"if name.startswith('ansible_collections.'='ansible_collections.'):
    full_name = name
else:
    full_name = '.'.join([self.package, name])
"
-------------------------------------------------------------------------
"if name.startswith('ansible_collections.'):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import glob, import importlib, import sys, import warnings, import imp, import os, import ansible, import __future__, import collections
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 60317, 62561"
-------------------------------------------------------------------------
=========================================================================
"if self._find_module(fullname, path, load=False)[0]:
mod = self._find_module(fullname, None, load=True)[1]

if not mod:
    raise ImportError('module {0} not found'.format(fullname))

return mod

_find_module(self, fullname, path, load):
# this loader is only concerned with items under the Ansible Collections namespace hierarchy, ignore others
if not fullname.startswith('ansible_collections.') and fullname != 'ansible_collections':
    return False, None

    if not load:
return True, None

    return True, sys.modules[fullname]
"
-------------------------------------------------------------------------
"if self._find_module(fullname, path, load=False)[0]:
mod = self._find_module(fullname, None, load=True)[1]

if not mod:
    raise ImportError('module {0} not found'.format(fullname))

return mod

_find_module(self, fullname, path, load):
# this loader is only concerned with items under the Ansible Collections Namespace hierarchy, ignore others
if not fullname.startswith('ansible_collections.') and full_name != 'ansible_collections':
    return False, None

    if not load:
return True, None

    return True, sys.modules[fullname]
"
-------------------------------------------------------------------------
"if self._find_module(fullname, path, load=False)[0]:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import glob, import importlib, import sys, import warnings, import imp, import os, import ansible, import __future__, import collections
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 60317, 62561"
-------------------------------------------------------------------------
=========================================================================
"
if not load:
    return True, None

return True, mod
if not load:
    return True, None

"
-------------------------------------------------------------------------
"
if not load:
    return True, None

return True, mod
if not load:
    return True, None

"
-------------------------------------------------------------------------
"
if not load:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import glob, import importlib, import sys, import warnings, import imp, import os, import ansible, import __future__, import collections
Make sure statements concerning these methods are incorporated into the stable script - ,load,mod
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 60317, 62561"
-------------------------------------------------------------------------
=========================================================================
"if not load:
    return True, None

"
-------------------------------------------------------------------------
"if not load:
    return True, None

"
-------------------------------------------------------------------------
"if not load:
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import glob, import importlib, import sys, import warnings, import imp, import os, import ansible, import __future__, import collections
Make sure statements concerning these methods are incorporated into the stable script - ,load
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 60317, 62561"
-------------------------------------------------------------------------
=========================================================================
"return True, newmod
return True, newmod
rn False, None
"
-------------------------------------------------------------------------
"return True, newmod
return True, newmod
rn False, None
"
-------------------------------------------------------------------------
"return True, newmod
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import glob, import importlib, import sys, import warnings, import imp, import os, import ansible, import __future__, import collections
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 60317, 62561"
-------------------------------------------------------------------------
=========================================================================
"from __future__ import (absolute_import, division, print_function)
__metaclass__ = type


def filter_name(a):
return __name__


s FilterModule(object):
def filters(self):
filters = {
'filter_name': filter_name,
}

return filters
"
-------------------------------------------------------------------------
"from __future__ import (absolute_import, division, print_function)
__metaclass__ = type


def filter_name(a):
return __name__


s FilterModule(object):
def filters(self):
filters = {
'filter_name': filter_name,
}

return filters
"
-------------------------------------------------------------------------
"from __future__ import (absolute_import, division, print_function)
__metaclass__ = type


def filter_name(a):
return __name__
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import glob, import importlib, import sys, import warnings, import os, import ansible, import collections
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 60317, 62561"
-------------------------------------------------------------------------
=========================================================================
"from __future__ import (absolute_import, division, print_function)
__metaclass__ = type

from ansible.plugins.lookup import LookupBase


class LookupModule(LookupBase):
def run(self, terms, variables, **kwargs):
return [__name__]
"
-------------------------------------------------------------------------
"from __future__ import (absolute_import, division, print_function)
__metaclass__ = type

from ansible.plugins.lookup import LookupBase


class_ LookupModule(LookupBase):
def run(self, terms, variables, **kwargs):
return [__name__]
"
-------------------------------------------------------------------------
"from __future__ import (absolute_import, division, print_function)
__metaclass__ = type

from ansible.plugins.lookup import LookupBase


class LookupModule(LookupBase):
def run(self, terms, variables, **kwargs):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import glob, import importlib, import sys, import warnings, import os, import ansible, import collections
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 60317, 62561"
-------------------------------------------------------------------------
=========================================================================
"cron_cmd = self.module.get_bin_path('crontab', required=True)
return ""su %s -c '%s -l'"" % (shlex_quote(self.user), shlex_quote(cron_cmd))
return ""%s -l %s"" % (shlex_quote(cron_cmd), shlex_quote(self.user))
return ""%s %s %s"" % (cron_cmd, '-l', shlex_quote(self.user))
return ""%s %s %s"" % (cron_cmd, user, '-l')
cron_cmd = self.module.get_bin_path('crontab', required=True)
return ""chown %s %s ; su '%s' -c '%s %s'"" % (shlex_quote(self.user), shlex_quote(path), shlex_quote(self.user), cron_cmd, shlex_quote(path))
return ""%s %s %s"" % (cron_cmd, user, shlex_quote(path))
"
-------------------------------------------------------------------------
"cron_cmd = self.module.get_bin_path('crontab', required=True)
return ""su %s -c '%s -l'"" % (shlex_quote(self.user), shlex_quote(cron_cmd))
return ""%s -l %s"" % (shlex_quote(cron_cmd), shlex_quote(self.user))
return ""%s %s %s"" % (cron_cmd, '-l', shlex_quote(self.user))
return ""%s %s %s"" % (cron_cmd, user, '-l')
cron_cmd = self.module.get_bin_path('crontab', required=True)
return chown %s %s ; su '%s' -c '%s %s'"" % (shlex_quote(self.user), shlex_quote(path), shlex_quote(self.user), cron_cmd, shlex_quote(path))
return ""%s %s %s"" % (cron_cmd, user, shlex_quote(path))
"
-------------------------------------------------------------------------
"self.cron_cmd = self.module.get_bin_path('crontab', required=True)
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import platform, import pipes, import __future__, import tempfile, import pwd, import shlex, import sys, import re, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 59765, 62546"
-------------------------------------------------------------------------
=========================================================================
"cron_cmd = self.module.get_bin_path('crontab', required=True)
return ""su %s -c '%s -l'"" % (shlex_quote(self.user), shlex_quote(cron_cmd))
return ""%s -l %s"" % (shlex_quote(cron_cmd), shlex_quote(self.user))
return ""%s %s %s"" % (cron_cmd, '-l', shlex_quote(self.user))
return ""%s %s %s"" % (cron_cmd, user, '-l')
cron_cmd = self.module.get_bin_path('crontab', required=True)
return ""chown %s %s ; su '%s' -c '%s %s'"" % (shlex_quote(self.user), shlex_quote(path), shlex_quote(self.user), cron_cmd, shlex_quote(path))
return ""%s %s %s"" % (cron_cmd, user, shlex_quote(path))
"
-------------------------------------------------------------------------
"cron_cmd = self.module.get_bin_path('crontab', required=True)
return ""su %s -c '%s -l'"" % (shlex_quote(self.user), shlex_quote(cron_cmd))
return ""%s -l %s"" % (shlex_quote(cron_cmd), shlex_quote(self.user))
return ""%s %s %s"" % (cron_cmd, '-l', shlex_quote(self.user))
return ""%s %s %s"" % (cron_cmd, user, '-l')
cron_cmd = self.module.get_bin_path('crontab', required=True)
return chown %s %s ; su '%s' -c '%s %s'"" % (shlex_quote(self.user), shlex_quote(path), shlex_quote(self.user), cron_cmd, shlex_quote(path))
return ""%s %s %s"" % (cron_cmd, user, shlex_quote(path))
"
-------------------------------------------------------------------------
"self.cron_cmd = self.module.get_bin_path('cronvar', required=True)
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import platform, import pipes, import __future__, import tempfile, import pwd, import shlex, import sys, import re, import os
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 59765, 62546"
-------------------------------------------------------------------------
=========================================================================
"payload_for_delete = get_copy_payload_with_some_params(payload, delete_params)
code, response = send_request(connection, version, 'delete-'  api_call_object, payload_for_delete)
"
-------------------------------------------------------------------------
"payload_for_delete = get_copy_payload_with_some_params(payload, delete_params)
code, response = send_request(connection, version, 'delete-'  api_call_object, payload_for_delete)
"
-------------------------------------------------------------------------
"payload_for_delete = get_copy_payload_with_some_params(payload, delete_params)
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import time
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 62525, 62540"
-------------------------------------------------------------------------
=========================================================================
"payload_for_delete = get_copy_payload_with_some_params(payload, delete_params)
code, response = send_request(connection, version, 'delete-'  api_call_object, payload_for_delete)
"
-------------------------------------------------------------------------
"payload_for_delete = get_copy_payload_with_some_params(payload, delete_params)
code, response = send_request(connection, version, 'delete-'  api_call_object, payload_for_delete)
"
-------------------------------------------------------------------------
"payload_for_delete = get_copy_payload_with_some_params(payload, delete_params)
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import time
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 62525, 62540"
-------------------------------------------------------------------------
=========================================================================
"if equals_code == 404 and equals_response['code'] == 'generic_err_command_not_found':
module.fail_json(msg='Relevant hotfix is not installed on Check Point server. See sk114661 on Check Point Support Center.')
"
-------------------------------------------------------------------------
"if equals_code == 404 and equals_response['code'] == 'generic_err_command_not_found':
module.fail_json(msg=msg, response=response)
"
-------------------------------------------------------------------------
"if equals_code == 404 and equals_response['code'] == 'generic_err_command_not_found':
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import time
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 62529, 62539"
-------------------------------------------------------------------------
=========================================================================
"result['checkpoint_session_uid'] = connection.get_session_uid()

"
-------------------------------------------------------------------------
"result['checkpoint_session_uid'] = connection.get_session_uid()

"
-------------------------------------------------------------------------
"result['checkpoint_session_uid'] = connection.get_session_uid()
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import time
Make sure statements concerning these methods are incorporated into the stable script - ,connection,result
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 62523, 62527"
-------------------------------------------------------------------------
=========================================================================
"
result['checkpoint_session_uid'] = connection.get_session_uid()

"
-------------------------------------------------------------------------
"
result['checkpoint_session_uid'] = connection.get_session_uid()

"
-------------------------------------------------------------------------
"
result['checkpoint_session_uid'] = connection.get_session_uid()
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import __future__, import time
Make sure statements concerning these methods are incorporated into the stable script - ,connection,result
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 62523, 62527"
-------------------------------------------------------------------------
=========================================================================
