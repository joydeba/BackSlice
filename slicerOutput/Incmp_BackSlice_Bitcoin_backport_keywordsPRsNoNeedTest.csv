"assert_raises_rpc_error(-4, ""Fee exceeds maximum configured by -maxtxfee"", self.nodes[3].fundrawtransaction, rawtx, {""feeRate"": 1})
"
-------------------------------------------------------------------------
"assert_raises_rpc_error(-4, ""Fee exceeds maximum configured by -maxtxfee"", self.nodes[3].fundrawtransaction, rawtx, {""feeRate"": 1})
"
-------------------------------------------------------------------------
"# previously this was silently capped at -maxtxfee
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import decimal, import io
Make sure statements concerning these methods are incorporated into the stable script - 
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 16257, 16639"
-------------------------------------------------------------------------
=========================================================================
"assert_greater_than,
"
-------------------------------------------------------------------------
"assert_greater_than,
"
-------------------------------------------------------------------------
"test_maxtxfee_fails(self, rbf_node, dest_address)
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import decimal, import io
Make sure statements concerning these methods are incorporated into the stable script - 
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 16257, 16639"
-------------------------------------------------------------------------
=========================================================================
"# feeRate of 0.1 BTC / KB produces a total fee slightly below -maxtxfee (~0.05280000):
res = self.nodes[1].walletcreatefundedpsbt([{""txid"":txid,""vout"":p2wpkh_pos},{""txid"":txid,""vout"":p2sh_p2wpkh_pos},{""txid"":txid,""vout"":p2pkh_pos}], {self.nodes[1].getnewaddress():29.99}, 0, {""feeRate"": 0.1})
assert_greater_than(res[""fee""], 0.05)
assert_greater_than(0.06, res[""fee""])

# feeRate of 10 BTC / KB produces a total fee well above -maxtxfee
# previously this was silenty capped at -maxtxfee
assert_raises_rpc_error(-4, ""Fee exceeds maximum configured by -maxtxfee"", self.nodes[1].walletcreatefundedpsbt, [{""txid"":txid,""vout"":p2wpkh_pos},{""txid"":txid,""vout"":p2sh_p2wpkh_pos},{""txid"":txid,""vout"":p2pkh_pos}], {self.nodes[1].getnewaddress():29.99}, 0, {""feeRate"": 10})

"
-------------------------------------------------------------------------
"# feeRate of 0.1 BTC / KB produces a total fee slightly below -maxtxfee (~0.05280000):
res = self.nodes[1].walletcreatefundedpsbt([{""txid"":txid,""vout"":p2wpkh_pos},{""txid"":txid,""vout"":p2sh_p2wpkh_pos},{""txid"":txid,""vout"":p2pkh_pos}], {self.nodes[1].getnewaddress():29.99}, 0, {""feeRate"": 0.1})
assert_greater_than(res[""fee""], 0.05)
assert_greater_than(0.06, res[""fee""])

# feeRate of 10 BTC / KB produces a total fee well above -maxtxfee
# previously this was silenty capped at -maxtxfee
assert_raises_rpc_error(-4, ""Fee exceeds maximum configured by -maxtxfee"", self.nodes[1].walletcreatefundedpsbt, [{""txid"":txid,""vout"":p2wpkh_pos},{""txid"":txid,""vout"":p2sh_p2wpkh_pos},{""txid"":txid,""vout"":p2pkh_pos}], {self.nodes[1].getnewaddress():29.99}, 0, {""feeRate"": 10})

"
-------------------------------------------------------------------------
"def test_maxtxfee_fails(test, rbf_node, dest_address):
test.restart_node(1, ['-maxtxfee=0.00003']  test.extra_args[1])
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import decimal, import io
Make sure statements concerning these methods are incorporated into the stable script - 
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 16257, 16639"
-------------------------------------------------------------------------
=========================================================================
"assert_greater_than(tx_in[""sequence""], MAX_BIP125_RBF_SEQUENCE)
"
-------------------------------------------------------------------------
"assert_greater_than(tx_in[""sequence""], MAX_BIP125_RBF_SEQUENCE)
"
-------------------------------------------------------------------------
"[""-walletrbf=0""],
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import decimal, import os, import json
Make sure statements concerning these methods are incorporated into the stable script - 
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 15911, 16608"
-------------------------------------------------------------------------
=========================================================================
"# Same construction without optional arguments, for a node with -walletrbf=0
unspent1 = self.nodes[1].listunspent()[0]
psbtx_info = self.nodes[1].walletcreatefundedpsbt([{""txid"":unspent1[""txid""], ""vout"":unspent1[""vout""]}], [{self.nodes[2].getnewaddress():unspent1[""amount""]1}], block_height)
decoded_psbt = self.nodes[1].decodepsbt(psbtx_info[""psbt""])
for tx_in in decoded_psbt[""tx""][""vin""]:
    assert_greater_than(tx_in[""sequence""], MAX_BIP125_RBF_SEQUENCE)

"
-------------------------------------------------------------------------
"# Same construction without optional arguments, for a node with -walletrbf=0
unspent1 = self.nodes[1].listunspent()[0]
psbtx_info = self.nodes[1].walletcreatefundedpsbt([{""txid"":unspent1[""txid""], ""vout"":unspent1[""vout""]}], [{self.nodes[2].getnewaddress():unspent1[""amount""]1}], block_height)
decoded_psbt = self.nodes[1].decodepsbt(psbtx_info[""psbt""])
for tx_in in decoded_psbt[""tx""][""vin""]:
    assert_greater_than(tx_in[""sequence""], MAX_BIP125_RBF_SEQUENCE)

"
-------------------------------------------------------------------------
"assert_greater_than(tx_in[""sequence""], MAX_BIP125_RBF_SEQUENCE)
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import decimal, import os, import json
Make sure statements concerning these methods are incorporated into the stable script - 
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 15911, 16608"
-------------------------------------------------------------------------
=========================================================================
"prevtx_err = dict(prevtxs[0])
del prevtx_err[""redeemScript""]

assert_raises_rpc_error(-8, ""Missing redeemScript/witnessScript"", node2.signrawtransactionwithkey, rawtx, self.priv[0:self.nsigs-1], [prevtx_err])

"
-------------------------------------------------------------------------
"prevtx_err = dict(prevtxs[0])
del prevtx_err[""redeemScript""]

assert_raises_rpc_error(-8, ""Missing redeemScript/witnessScript"", node2.signrawtransactionwithkey, rawtx, self.priv[0:self.nsigs-1], [prevtx_err])

"
-------------------------------------------------------------------------
"prevtx_err = dict(prevtxs[0])
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import binascii, import decimal, import itertools
Make sure statements concerning these methods are incorporated into the stable script - 
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 16250, 16342"
-------------------------------------------------------------------------
=========================================================================
"success=True,
warnings=[""Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.""])
"
-------------------------------------------------------------------------
"success=True,
warnings=[""Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.""])
"
-------------------------------------------------------------------------
"success=True,
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - 
Make sure statements concerning these methods are incorporated into the stable script - 
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 15749, 15803"
-------------------------------------------------------------------------
=========================================================================
"# Also ensure unload works during walletpassphrase timeout
w2.encryptwallet('test')
w2.walletpassphrase('test', 1)
time.sleep(1.1)
"
-------------------------------------------------------------------------
"# Also ensure unload works during walletpassphrase timeout
w2.encryptwallet('test')
w2.walletpassphrase('test', 1)
time.sleep(1.1)
"
-------------------------------------------------------------------------
"# Also ensure unload works during walletpassphrase timeout
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import os, import shutil
Make sure statements concerning these methods are incorporated into the stable script - 
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 14453, 14880"
-------------------------------------------------------------------------
=========================================================================
"# Make sure change address wallet does not have P2SH innerscript access to results in success
# when attempting BnB coin selection
self.nodes[0].walletcreatefundedpsbt([], [{self.nodes[2].getnewaddress():unspent[""amount""]1}], block_height2, {""changeAddress"":self.nodes[1].getnewaddress()}, False)

"
-------------------------------------------------------------------------
"# Make sure change address wallet does not have P2SH innerscript access to results in success
# when attempting BnB coin selection
self.nodes[0].walletcreatefundedpsbt([], [{self.nodes[2].getnewaddress():unspent[""amount""]1}], block_height2, {""changeAddress"":self.nodes[1].getnewaddress()}, False)

"
-------------------------------------------------------------------------
"# Make sure change address wallet does not have P2SH innerscript access to results in success
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import os, import json
Make sure statements concerning these methods are incorporated into the stable script - 
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 14380, 14851"
-------------------------------------------------------------------------
=========================================================================
"# Regression test for 14473 (mishandling of already-signed witness transaction):
psbtx_info = self.nodes[0].walletcreatefundedpsbt([{""txid"":unspent[""txid""], ""vout"":unspent[""vout""]}], [{self.nodes[2].getnewaddress():unspent[""amount""]1}])
complete_psbt = self.nodes[0].walletprocesspsbt(psbtx_info[""psbt""])
double_processed_psbt = self.nodes[0].walletprocesspsbt(complete_psbt[""psbt""])
assert_equal(complete_psbt, double_processed_psbt)
# We don't care about the decode result, but decoding must succeed.
self.nodes[0].decodepsbt(double_processed_psbt[""psbt""])
"
-------------------------------------------------------------------------
"# Regression test for 14473 (mishandling of already-signed witness transaction):
psbtx_info = self.nodes[0].walletcreatefundedpsbt([{""txid"":unspent[""txid""], ""vout"":unspent[""vout""]}], [{self.nodes[2].getnewaddress():unspent[""amount""]1}])
complete_psbt = self.nodes[0].walletprocesspsbt(psbtx_info[""psbt""])
double_processed_psbt = self.nodes[0].walletprocesspsbt(complete_psbt[""psbt""])
assert_equal(complete_psbt, double_processed_psbt)
# We don't care about the decode result, but decoding must succeed.
self.nodes[0].decodepsbt(double_processed_psbt[""psbt""])
"
-------------------------------------------------------------------------
"from test_framework.util import assert_equal, assert_raises_rpc_error, find_output, disconnect_nodes, connect_nodes_bi, sync_blocks
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import os, import json
Make sure statements concerning these methods are incorporated into the stable script - 
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 14588, 14780"
-------------------------------------------------------------------------
=========================================================================
"# Check transactions for duplicate inputs
self.log.info(""Test duplicate input block."")

block2_orig.vtx[2].vin.append(block2_orig.vtx[2].vin[0])
block2_orig.vtx[2].rehash()
block2_orig.hashMerkleRoot = block2_orig.calc_merkle_root()
block2_orig.rehash()
block2_orig.solve()
node.p2p.send_blocks_and_test([block2_orig], node, success=False, request_block=False, reject_reason='bad-txns-inputs-duplicate')

"
-------------------------------------------------------------------------
"# Check transactions for duplicate inputs
self.log.info(""Test duplicate input block."")

block2_orig.vtx[2].vin.append(block2_orig.vtx[2].vin[0])
block2_orig.vtx[2].rehash()
block2_orig.hashMerkleRoot = block2_orig.calc_merkle_root()
block2_orig.rehash()
block2_orig.solve()
node.p2p.send_blocks_and_test([block2_orig], node, success=False, request_block=False, reject_reason='bad-txns-inputs-duplicate')

"
-------------------------------------------------------------------------
"yield TestInstance([[block2, RejectResult(16, b'bad-txns-duplicate')]])
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import copy, import time
Make sure statements concerning these methods are incorporated into the stable script - 
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 14247, 14249"
-------------------------------------------------------------------------
=========================================================================
"# Check transactions for duplicate inputs
self.log.info(""Test duplicate input block."")

block2_orig.vtx[2].vin.append(block2_orig.vtx[2].vin[0])
block2_orig.vtx[2].rehash()
block2_orig.hashMerkleRoot = block2_orig.calc_merkle_root()
block2_orig.rehash()
block2_orig.solve()
node.p2p.send_blocks_and_test([block2_orig], node, success=False, request_block=False, reject_reason='bad-txns-inputs-duplicate')

"
-------------------------------------------------------------------------
"# Check transactions for duplicate inputs
self.log.info(""Test very broken block.""=""Test very broken block."")

block2_orig.vtx[2].vin.append(block2_orig.vtx[2].vin[0])
block2_orig.vtx[2].rehash()
block2_orig.hashMerkleRoot = block2_orig.calc_merkle_root()
block2_orig.rehash()
block2_orig.solve()
node.p2p.send_blocks_and_test([block3]=[block3], node=node, False=False, False=False, 16=16, b'bad-cb-amount'=b'bad-cb-amount')

"
-------------------------------------------------------------------------
"# Check transactions for duplicate inputs
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import copy
Make sure statements concerning these methods are incorporated into the stable script - 
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 14247, 14248"
-------------------------------------------------------------------------
=========================================================================
"from test_framework.script import CScript, OP_HASH160, OP_CHECKSIG, OP_0, hash160, OP_EQUAL, OP_DUP, OP_EQUALVERIFY, OP_1, OP_2, OP_CHECKMULTISIG, hash160, OP_TRUE
from test_framework.mininode import ToHex, FromHex, COIN
"
-------------------------------------------------------------------------
"from test_framework.script import CScript, OP_HASH160, OP_CHECKSIG, OP_0, hash160, OP_EQUAL, OP_DUP, OP_EQUALVERIFY, OP_1, OP_2, OP_CHECKMULTISIG, hash160, OP_TRUE
from test_framework.mininode import ToHex, FromHex, COIN
"
-------------------------------------------------------------------------
"from test_framework.script import CScript, OP_HASH160, OP_CHECKSIG, OP_0, hash160, OP_EQUAL, OP_DUP, OP_EQUALVERIFY, OP_1, OP_2, OP_CHECKMULTISIG, OP_TRUE
from test_framework.mininode import ToHex, FromHex, COIN
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import io
Make sure statements concerning these methods are incorporated into the stable script - 
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 9955, 10006"
-------------------------------------------------------------------------
=========================================================================
"self.nodes[0].generate(1) # Mine a block to clear the gbt cache

# Create a 3-tx chain: tx1 (non-segwit input, paying to a segwit output) ->
#      tx2 (segwit input, paying to a non-segwit output) ->
#      tx3 (non-segwit input, paying to a non-segwit output).
# tx1 is allowed to appear in the block, but no others.
txid1 = send_to_witness(1, self.nodes[0], find_unspent(self.nodes[0], 50), self.pubkey[0], False, Decimal(""49.996""))
hex_tx = self.nodes[0].gettransaction(txid)['hex']
tx = FromHex(CTransaction(), hex_tx)
assert(tx.wit.is_null()) # This should not be a segwit input
assert(txid1 in self.nodes[0].getrawmempool())

# Now create tx2, which will spend from txid1.
tx = CTransaction()
tx.vin.append(CTxIn(COutPoint(int(txid1, 16), 0), b''))
tx.vout.append(CTxOut(int(49.99*COIN), CScript([OP_TRUE])))
tx2_hex = self.nodes[0].signrawtransaction(ToHex(tx))['hex']
txid2 = self.nodes[0].sendrawtransaction(tx2_hex)
tx = FromHex(CTransaction(), tx2_hex)
assert(not tx.wit.is_null())

# Now create tx3, which will spend from txid2
tx = CTransaction()
tx.vin.append(CTxIn(COutPoint(int(txid2, 16), 0), b""""))
tx.vout.append(CTxOut(int(49.95*COIN), CScript([OP_TRUE]))) # Huge fee
tx.calc_sha256()
txid3 = self.nodes[0].sendrawtransaction(ToHex(tx))
assert(tx.wit.is_null())
assert(txid3 in self.nodes[0].getrawmempool())

# Now try calling getblocktemplate() without segwit support.
template = self.nodes[0].getblocktemplate()

# Check that tx1 is the only transaction of the 3 in the template.
template_txids = [ t['txid'] for t in template['transactions'] ]
assert(txid2 not in template_txids and txid3 not in template_txids)
assert(txid1 in template_txids)

# Check that running with segwit support results in all 3 being included.
template = self.nodes[0].getblocktemplate({""rules"": [""segwit""]})
template_txids = [ t['txid'] for t in template['transactions'] ]
assert(txid1 in template_txids)
assert(txid2 in template_txids)
assert(txid3 in template_txids)

# Mine a block to clear the gbt cache again.
self.nodes[0].generate(1)
"
-------------------------------------------------------------------------
"self.nodes[0].generate(1) # Mine a block to clear the gbt cache

# Create a 3-tx chain: tx1 (non-segwit input, paying to a segwit output) ->
#      tx2 (segwit input, paying to a non-segwit output) ->
#      tx3 (non-segwit input, paying to a non-segwit output).
# tx1 is allowed to appear in the block, but no others.
txid1 = send_to_witness(1, self.nodes[0], find_unspent(self.nodes[0], 50), self.pubkey[0], False, Decimal(""49.996""))
hex_tx = self.nodes[0].gettransaction(txid)['hex']
tx = FromHex(CTransaction(), hex_tx)
assert(tx.wit.is_null()) # This should not be a segwit input
assert(txid1 in self.nodes[0].getrawmempool())

# Now create tx2, which will spend from txid1.
tx = CTransaction()
tx.vin.append(CTxIn(COutPoint(int('0x'+i=CTxIn(COutPoint(int('0x'+i, 0=0), 0), b''))
tx.vout.append(CTxOut(0=CTxOut(0, CScript(=CScript(), CScript([OP_TRUE])))
tx2_hex = self.nodes[0].signrawtransaction(ToHex(tx))['hex']
txid2 = self.nodes[0].sendrawtransaction(tx2_hex)
tx = FromHex(CTransaction(), tx2_hex)
assert(not tx.wit.is_null())

# Now create tx3, which will spend from txid2
tx = CTransaction()
tx.vin.append(CTxIn(COutPoint(int('0x'+i=CTxIn(COutPoint(int('0x'+i, 0=0), 0), b""""))
tx.vout.append(CTxOut(0=CTxOut(0, CScript(=CScript(), CScript([OP_TRUE]))) # Huge fee
tx.calc_sha256()
txid3 = self.nodes[0].sendrawtransaction(ToHex(tx))
assert(tx.wit.is_null())
assert(txid3 in self.nodes[0].getrawmempool())

# Now try calling getblocktemplate() without segwit support.
template = self.nodes[0].getblocktemplate()

# Check that tx1 is the only transaction of the 3 in the template.
template_txids = [ t['txid'] for t in template['transactions'] ]
assert(txid2 not in template_txids and txid3 not in template_txids)
assert(txid1 in template_txids)

# Check that running with segwit support results in all 3 being included.
template = self.nodes[0].getblocktemplate({""rules"": [""segwit""]})
template_txids = [ t['txid'] for t in template['transactions'] ]
assert(txid1 in template_txids)
assert(txid2 in template_txids)
assert(txid3 in template_txids)

# Mine a block to clear the gbt cache again.
self.nodes[0].generate(1)
"
-------------------------------------------------------------------------
"self.nodes[0].generate(1) # Mine a block to clear the gbt cache
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import io
Make sure statements concerning these methods are incorporated into the stable script - 
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 9955, 10006"
-------------------------------------------------------------------------
=========================================================================
"def test_compactblock_reconstruction_multiple_peers(self, node, stalling_peer, delivery_peer):
assert(len(self.utxos))

def announce_cmpct_block(node, peer):
utxo = self.utxos.pop(0)
block = self.build_block_with_transactions(node, utxo, 5)

cmpct_block = HeaderAndShortIDs()
cmpct_block.initialize_from_block(block)
msg = msg_cmpctblock(cmpct_block.to_p2p())
peer.send_and_ping(msg)
with mininode_lock:
assert(peer.last_getblocktxn is not None)
return block, cmpct_block

block, cmpct_block = announce_cmpct_block(node, stalling_peer)

for tx in block.vtx[1:]:
delivery_peer.send_message(msg_tx(tx))
delivery_peer.sync_with_ping()
mempool = node.getrawmempool()
for tx in block.vtx[1:]:
assert(tx.hash in mempool)

delivery_peer.send_and_ping(msg_cmpctblock(cmpct_block.to_p2p()))
assert_equal(int(node.getbestblockhash(), 16), block.sha256)

self.utxos.append([block.vtx[-1].sha256, 0, block.vtx[-1].vout[0].nValue])

# Now test that delivering an invalid compact block won't break relay

block, cmpct_block = announce_cmpct_block(node, stalling_peer)
for tx in block.vtx[1:]:
delivery_peer.send_message(msg_tx(tx))
delivery_peer.sync_with_ping()

cmpct_block.prefilled_txn[0].tx.wit.vtxinwit = [ CTxInWitness() ]
cmpct_block.prefilled_txn[0].tx.wit.vtxinwit[0].scriptWitness.stack = [ser_uint256(0)]

cmpct_block.use_witness = True
delivery_peer.send_and_ping(msg_cmpctblock(cmpct_block.to_p2p()))
assert(int(node.getbestblockhash(), 16) != block.sha256)

msg = msg_blocktxn()
msg.block_transactions.blockhash = block.sha256
msg.block_transactions.transactions = block.vtx[1:]
stalling_peer.send_and_ping(msg)
assert_equal(int(node.getbestblockhash(), 16), block.sha256)
"
-------------------------------------------------------------------------
"def test_compactblock_reconstruction_multiple_peers(self, node, stalling_peer, delivery_peer):
assert(len(self.utxos))

def announce_cmpct_block(node, peer):
utxo = self.utxos.pop(0=0)
block = self.build_block_with_transactions(node=node, utxo=utxo, 5=5)

cmpct_block = HeaderAndShortIDs()
cmpct_block.initialize_from_block(block)
msg = msg_cmpctblock(cmpct_block.to_p2p())
peer.send_and_ping(msg=msg)
with mininode_lock:
assert(peer.last_getblocktxn is not None)
return block, cmpct_block

block, cmpct_block = announce_cmpct_block(node, stalling_peer)

for tx in block.vtx[1:]:
delivery_peer.send_message(msg_tx(tx))
delivery_peer.sync_with_ping()
mempool = node.getrawmempool()
for tx in block.vtx[1:]:
assert(tx.hash in mempool)

delivery_peer.send_and_ping(msg_cmpctblock(cmpct_block.to_p2p()))
assert_equal(int(node.getbestblockhash(), 16), block.sha256)

self.utxos.append([block.vtx[-1].sha256=[block.vtx[-1].sha256, 0=0, block.vtx[-1].vout[0].nValue]=block.vtx[-1].vout[0].nValue])

# Now test that delivering an invalid compact block won't break relay

block, cmpct_block = announce_cmpct_block(node, stalling_peer)
for tx in block.vtx[1:]:
delivery_peer.send_message(msg_tx(tx))
delivery_peer.sync_with_ping()

cmpct_block.prefilled_txn[0].tx.wit.vtxinwit = [ CTxInWitness() ]
cmpct_block.prefilled_txn[0].tx.wit.vtxinwit[0].scriptWitness.stack = [ser_uint256(0)]

cmpct_block.use_witness = True
delivery_peer.send_and_ping(msg_cmpctblock(cmpct_block.to_p2p()))
assert(int(node.getbestblockhash(), 16) != block.sha256)

msg = msg_blocktxn()
msg.block_transactions.blockhash = block.sha256
msg.block_transactions.transactions = block.vtx[1:]
stalling_peer.send_and_ping(msg)
assert_equal(int(node.getbestblockhash(), 16), block.sha256)
"
-------------------------------------------------------------------------
"def test_compactblock_reconstruction_multiple_peers(self, node, stalling_peer, delivery_peer):
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - 
Make sure statements concerning these methods are incorporated into the stable script - 
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 9352, 9357"
-------------------------------------------------------------------------
=========================================================================
"print(""\tTesting reconstructing compact blocks from all peers..."")
self.test_compactblock_reconstruction_multiple_peers(self.nodes[1], self.segwit_node, self.old_node)
sync_blocks(self.nodes)

"
-------------------------------------------------------------------------
"print(""\tTesting reconstructing compact blocks from all peers..."")
self.test_compactblock_reconstruction_multiple_peers(self.nodes[1], self.segwit_node, self.old_node)
sync_blocks(self.nodes)

"
-------------------------------------------------------------------------
"print(""\tTesting reconstructing compact blocks from all peers..."")
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - 
Make sure statements concerning these methods are incorporated into the stable script - 
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 9352, 9357"
-------------------------------------------------------------------------
=========================================================================
