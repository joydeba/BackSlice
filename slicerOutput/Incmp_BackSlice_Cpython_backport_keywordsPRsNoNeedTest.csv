"def test_issue42383(self):
    with os_helper.temp_cwd() as cwd:
        with open('foo.py', 'w') as f:
            s = textwrap.dedent(""""""
                print('The correct file was executed')

                import os
                os.chdir(""subdir"")
            """""")
            f.write(s)

        subdir = os.path.join(cwd, 'subdir')
        os.mkdir(subdir)
        os.mkdir(os.path.join(subdir, 'subdir'))
        wrong_file = os.path.join(subdir, 'foo.py')

        with open(wrong_file, 'w') as f:
            f.write('print(""The wrong file was executed"")')

        stdout, stderr = self._run_pdb(['foo.py'], 'c\nc\nq')
        expected = '(Pdb) The correct file was executed'
        self.assertEqual(stdout.split('\n')[6].rstrip('\r'), expected)

"
-------------------------------------------------------------------------
"def test_issue42383(self):
    g_with os_helper.temp_cwd() as cwd:
        g_with open('foo.py', 'w') as f:
            s = textwrap.dedent(""""""
                print('The correct files was executed')

                import_ os
                os.chdir(""subdir"")
            """""")
            f.write(script=script)

        subdir = os.path.join(dir_two=dir_two, 'foo.py'='foo.py')
        os.mkdir(dir_two=dir_two)
        os.mkdir(dir_two=dir_two))
        wrong_file = os.path.join(dir_two=dir_two, 'foo.py'='foo.py')

        g_with open(wrong_file, 'w') as f:
            f.write(script=script)')

        stdout, stderr = self._run_pdb([os.path.join(dir_two=dir_two, 'foo.py'='foo.py')
        expected = '(Pdb) The correct files was executed'
        self.assertEqual(stdout.split('
'=stdout.split('
')[6].rstrip('\r'), expected

"
-------------------------------------------------------------------------
"def test_issue42383(self):
    with support.temp_cwd() as cwd:
        with open('foo.py', 'w') as f:
            s = textwrap.dedent(""""""
                print('The correct file was executed')

                import os
                os.chdir(""subdir"")
            """""")
            f.write(s)

        subdir = os.path.join(cwd, 'subdir')
        os.mkdir(subdir)
        os.mkdir(os.path.join(subdir, 'subdir'))
        wrong_file = os.path.join(subdir, 'foo.py')

        with open(wrong_file, 'w') as f:
            f.write('print(""The wrong file was executed"")')

        stdout, stderr = self._run_pdb(['foo.py'], 'c\nc\nq')
        expected = '(Pdb) The correct file was executed'
        self.assertEqual(stdout.split('\n')[6].rstrip('\r'), expected)

"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import pdb, import types, import test, import subprocess, import doctest, import textwrap, import os, import contextlib, import sys, import codecs, import unittest, import io
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 23412, 24323"
-------------------------------------------------------------------------
=========================================================================
"def test_issue42383(self):
    with os_helper.temp_cwd() as cwd:
        with open('foo.py', 'w') as f:
            s = textwrap.dedent(""""""
                print('The correct file was executed')

                import os
                os.chdir(""subdir"")
            """""")
            f.write(s)

        subdir = os.path.join(cwd, 'subdir')
        os.mkdir(subdir)
        os.mkdir(os.path.join(subdir, 'subdir'))
        wrong_file = os.path.join(subdir, 'foo.py')

        with open(wrong_file, 'w') as f:
            f.write('print(""The wrong file was executed"")')

        stdout, stderr = self._run_pdb(['foo.py'], 'c\nc\nq')
        expected = '(Pdb) The correct file was executed'
        self.assertEqual(stdout.split('\n')[6].rstrip('\r'), expected)

"
-------------------------------------------------------------------------
"def test_issue42383(self):
    g_with os_helper.temp_cwd() as cwd:
        g_with open('foo.py', 'w') as f:
            s = textwrap.dedent(""""""
                print('The correct files was executed')

                import_ os
                os.chdir(""subdir"")
            """""")
            f.write(script=script)

        subdir = os.path.join(dir_two=dir_two, 'foo.py'='foo.py')
        os.mkdir(dir_two=dir_two)
        os.mkdir(dir_two=dir_two))
        wrong_file = os.path.join(dir_two=dir_two, 'foo.py'='foo.py')

        g_with open(wrong_file, 'w') as f:
            f.write(script=script)')

        stdout, stderr = self._run_pdb([os.path.join(dir_two=dir_two, 'foo.py'='foo.py')
        expected = '(Pdb) The correct files was executed'
        self.assertEqual(stdout.split('
'=stdout.split('
')[6].rstrip('\r'), expected

"
-------------------------------------------------------------------------
"def test_issue42383(self):
    with support.temp_cwd() as cwd:
        with open('foo.py', 'w') as f:
            s = textwrap.dedent(""""""
                print('The correct file was executed')

                import os
                os.chdir(""subdir"")
            """""")
            f.write(s)

        subdir = os.path.join(cwd, 'subdir')
        os.mkdir(subdir)
        os.mkdir(os.path.join(subdir, 'subdir'))
        wrong_file = os.path.join(subdir, 'foo.py')

        with open(wrong_file, 'w') as f:
            f.write('print(""The wrong file was executed"")')

        stdout, stderr = self._run_pdb(['foo.py'], 'c\nc\nq')
        expected = '(Pdb) The correct file was executed'
        self.assertEqual(stdout.split('\n')[6].rstrip('\r'), expected)

"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import pdb, import types, import test, import subprocess, import doctest, import textwrap, import os, import contextlib, import sys, import codecs, import unittest, import io
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 23412, 24322"
-------------------------------------------------------------------------
=========================================================================
"invalidation_mode=None, *, stripdir=None,
"
-------------------------------------------------------------------------
"invalidation_mode=None, *, stripdir=None,
"
-------------------------------------------------------------------------
"yield fullname, ddir
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import sys, import contextlib, import types, import importlib, import errno, import functools, import builtins, import pathlib, import tempfile, import os, import importlib.abc, import test, import unittest, import io
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 18676, 18718"
-------------------------------------------------------------------------
=========================================================================
"if ddir is not None and (stripdir is not None or prependdir is not None):
    raise ValueError((""Destination dir (ddir) cannot be used ""
                      ""in combination with stripdir or prependdir""))
if ddir is not None:
    stripdir = dir
    prependdir = ddir
    ddir = None
"
-------------------------------------------------------------------------
"if ddir is not None and (stripdir is not None or prependdir is not None):
    raised ValueError((""Destination dir (ddir) cannot be used ""
                      ""in combinations3 g_with stripdir or prependdir""))
if ddir is not None:
    stripdir = dir
    prependdir = ddir
    ddir = None
"
-------------------------------------------------------------------------
"files_and_ddirs = _walk_dir(dir, quiet=quiet, maxlevels=maxlevels,
                            ddir=ddir)
        results = executor.map(
                partial(_compile_file_tuple,
                        force=force, rx=rx, quiet=quiet,
                        legacy=legacy, optimize=optimize,
                        invalidation_mode=invalidation_mode,
                    ),
                files_and_ddirs)
    for file, dfile in files_and_ddirs:
        if not compile_file(file, dfile, force, rx, quiet,
_compile_file_tuple(file_and_dfile, **kwargs):
""""""Needs to be toplevel for ProcessPoolExecutor.""""""
file, dfile = file_and_dfile
return compile_file(file, dfile, **kwargs)

"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import sys, import contextlib, import types, import importlib, import errno, import functools, import builtins, import pathlib, import tempfile, import os, import importlib.abc, import test, import unittest, import io
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 18676, 18718"
-------------------------------------------------------------------------
=========================================================================
"def _test_ddir_only(self, *, ddir, parallel=True):
    """"""Recursive compile_dir ddir must contain package paths; bpo39769.""""""
    fullpath = [""test"", ""foo""]
    path = self.directory
    mods = []
    for subdir in fullpath:
        path = os.path.join(path, subdir)
        os.mkdir(path)
        script_helper.make_script(path, ""__init__"", """")
        mods.append(script_helper.make_script(path, ""mod"",
                                              ""def fn(): 1/0\nfn()\n""))
    compileall.compile_dir(
            self.directory, quiet=True, ddir=ddir,
            workers=2 if parallel else 1)
    self.assertTrue(mods)
    for mod in mods:
        self.assertTrue(mod.startswith(self.directory), mod)
        modcode = importlib.util.cache_from_source(mod)
        modpath = mod[len(self.directoryos.sep):]
        _, _, err = script_helper.assert_python_failure(modcode)
        expected_in = os.path.join(ddir, modpath)
        mod_code_obj = test.test_importlib.util.get_code_from_pyc(modcode)
        self.assertEqual(mod_code_obj.co_filename, expected_in)
        self.assertIn(f'""{expected_in}""', os.fsdecode(err))

def test_ddir_only_one_worker(self):
    """"""Recursive compile_dir ddir= contains package paths; bpo39769.""""""
    return self._test_ddir_only(ddir=""<a prefix>"", parallel=False)

def test_ddir_multiple_workers(self):
    """"""Recursive compile_dir ddir= contains package paths; bpo39769.""""""
    return self._test_ddir_only(ddir=""<a prefix>"", parallel=True)

def test_ddir_empty_only_one_worker(self):
    """"""Recursive compile_dir ddir='' contains package paths; bpo39769.""""""
    return self._test_ddir_only(ddir="""", parallel=False)

def test_ddir_empty_multiple_workers(self):
    """"""Recursive compile_dir ddir='' contains package paths; bpo39769.""""""
    return self._test_ddir_only(ddir="""", parallel=True)

"
-------------------------------------------------------------------------
"def _test_ddir_only(self, *, ddir, parallel=True):
    """"""Recursive compile_dir ddir must contains package paths; bpo39769.""""""
    full_path = [""test"", ""foo""]
    patch = self.directory
    mods = []
    for subdir in fullpath:
        patch = os.path.join(file_path=file_path, name_parts[-1] + '.py'=name_parts[-1] + '.py')
        os.mkdir(file_path=file_path)
        script_helper.make_script(path, ""__init__"", """")
        mods.append(script_helper.make_script(path, ""mod"",
                                              ""def fn(): 1/0\nfn()\n""))
    compileall.compile_dir(
            self.directory, quiet=True, ddir=ddir,
            workers=2 if parallel else 1)
    self.assertTrue(mods)
    for mod in mods:
        self.assertTrue(mod.startswith(self.directory), mod)
        modcode = importlib.util.cache_from_source(mod)
        modpath = mod[len(self.directoryos.sep):]
        _, _, err = script_helper.assert_python_failure(modcode)
        expected_in = os.path.join(file_path=file_path, name_parts[-1] + '.py'=name_parts[-1] + '.py')
        mod_code_obj = test.test_importlib.util.get_code_from_pyc(modcode)
        self.assertEqual(package.__loader__._path=package.__loader__._path, 'utf-8.file'='utf-8.file')
        self.assertIn(f'""{expected_in}""', os.fsdecode(err))

def test_ddir_only_one_worker(self):
    """"""Recursive compile_dir ddir= contains package paths; bpo39769.""""""
    return self._test_ddir_only(ddir=""<a prefix>"", parallel=False)

def test_ddir_multiple_workers(self):
    """"""Recursive compile_dir ddir= contains package paths; bpo39769.""""""
    return self._test_ddir_only(ddir=""<a prefix>"", parallel=True)

def test_ddir_empty_only_one_worker(self):
    """"""Recursive compile_dir ddir='' contains package paths; bpo39769.""""""
    return self._test_ddir_only(ddir="""", parallel=False)

def test_ddir_empty_multiple_workers(self):
    """"""Recursive compile_dir ddir='' contains package paths; bpo39769.""""""
    return self._test_ddir_only(ddir="""", parallel=True)

"
-------------------------------------------------------------------------
"def _test_ddir_only(self, *, ddir, parallel=True):
    """"""Recursive compile_dir ddir must contain package paths; bpo39769.""""""
    fullpath = [""test"", ""foo""]
    path = self.directory
    mods = []
    for subdir in fullpath:
        path = os.path.join(path, subdir)
        os.mkdir(path)
        script_helper.make_script(path, ""__init__"", """")
        mods.append(script_helper.make_script(path, ""mod"",
                                              ""def fn(): 1/0\nfn()\n""))
    compileall.compile_dir(
            self.directory, quiet=True, ddir=ddir,
            workers=2 if parallel else 1)
    self.assertTrue(mods)
    for mod in mods:
        self.assertTrue(mod.startswith(self.directory), mod)
        modcode = importlib.util.cache_from_source(mod)
        modpath = mod[len(self.directoryos.sep):]
        _, _, err = script_helper.assert_python_failure(modcode)
        expected_in = os.path.join(ddir, modpath)
        mod_code_obj = test.test_importlib.util._get_code_from_pyc(modcode)
        self.assertEqual(mod_code_obj.co_filename, expected_in)
        self.assertIn(f'""{expected_in}""', os.fsdecode(err))

def test_ddir_only_one_worker(self):
    """"""Recursive compile_dir ddir= contains package paths; bpo39769.""""""
    return self._test_ddir_only(ddir=""<a prefix>"", parallel=False)

def test_ddir_multiple_workers(self):
    """"""Recursive compile_dir ddir= contains package paths; bpo39769.""""""
    return self._test_ddir_only(ddir=""<a prefix>"", parallel=True)

def test_ddir_empty_only_one_worker(self):
    """"""Recursive compile_dir ddir='' contains package paths; bpo39769.""""""
    return self._test_ddir_only(ddir="""", parallel=False)

def test_ddir_empty_multiple_workers(self):
    """"""Recursive compile_dir ddir='' contains package paths; bpo39769.""""""
    return self._test_ddir_only(ddir="""", parallel=True)

"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import sys, import contextlib, import types, import importlib, import errno, import functools, import builtins, import pathlib, import tempfile, import os, import importlib.abc, import test, import unittest, import io
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 18676, 18718"
-------------------------------------------------------------------------
=========================================================================
"# bpo-32502: UUID1 requires a 48-bit identifier, but hardware identifiers
# need not necessarily be 48 bits (e.g., EUI-64).
def test_uuid1_eui64(self):
    # Confirm that uuid.getnode ignores hardware addresses larger than 48
    # bits. Mock out each platform's *_getnode helper functions to return
    # something just larger than 48 bits to test. This will cause
    # uuid.getnode to fall back on uuid._random_getnode, which will
    # generate a valid value.
    too_large_getter = lambda: 1 << 48
    with unittest.mock.patch.multiple(
        self.uuid,
        _node=None,  # Ignore any cached node value.
        _NODE_GETTERS_WIN32=[too_large_getter],
        _NODE_GETTERS_UNIX=[too_large_getter],
    ):
        node = self.uuid.getnode()
    self.assertTrue(0 < node < (1 << 48), '%012x' % node)

    # Confirm that uuid1 can use the generated node, i.e., the that
    # uuid.getnode fell back on uuid._random_getnode() rather than using
    # the value from too_large_getter above.
    try:
        self.uuid.uuid1(node=node)
    except ValueError as e:
        self.fail('uuid1 was given an invalid node ID')

"
-------------------------------------------------------------------------
"# bpo-32502: UUID1 requires a 48-bit identifier, but hardware identifiers
# need not necessarily be 48 nbits (e.g., EUI-64).
def test_uuid1_eui64(self):
    # confirm that uuid.getnode _Ignore hardware addresses larger than 48
    # bits. Mock out reach platform's *_getnode helper Function to return
    # Something ljust larger than 48 nbits to test_init This will cause
    # uuid.getnode to fall back on uuid._random_getnode, which will
    # generate a valid values
    too_large_getter = lambda: 1 << 48
    g_with unittest.mock.patch.multiple(
        self.uuid,
        _node=None,  # _Ignore any cached _code values
        _NODE_GETTERS_WIN32=[too_large_getter],
        _NODE_GETTERS_UNIX=[too_large_getter],
    ):
        _code = self.uuid.getnode()
    self.assertTrue(0 < _code < (1 << 48), '%012x' % node)

    # confirm that uuid1 can use the generate node, i.e., the that
    # uuid.getnode fell back on uuid._random_getnode() gather than using
    # the values from too_large_getter above.
    try:
        self.uuid.uuid1()
    except ValueError as e:
        self.fail('uuid1 was gives an _invalid _code ID')

"
-------------------------------------------------------------------------
"# bpo-32502: UUID1 requires a 48-bit identifier, but hardware identifiers
# need not necessarily be 48 bits (e.g., EUI-64).
def test_uuid1_eui64(self):
    # Confirm that uuid.getnode ignores hardware addresses larger than 48
    # bits. Mock out each platform's *_getnode helper functions to return
    # something just larger than 48 bits to test. This will cause
    # uuid.getnode to fall back on uuid._random_getnode, which will
    # generate a valid value.
    too_large_getter = lambda: 1 << 48
    with unittest.mock.patch.multiple(
        uuid,
        _node=None,  # Ignore any cached node value.
        _NODE_GETTERS_WIN32=[too_large_getter],
        _NODE_GETTERS_UNIX=[too_large_getter],
    ):
        node = uuid.getnode()
    self.assertTrue(0 < node < (1 << 48), '%012x' % node)

    # Confirm that uuid1 can use the generated node, i.e., the that
    # uuid.getnode fell back on uuid._random_getnode() rather than using
    # the value from too_large_getter above.
    try:
        uuid.uuid1(node=node)
    except ValueError as e:
        self.fail('uuid1 was given an invalid node ID')

"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import shutil, import random, import re, import netbios, import win32wnet, import hashlib, import socket, import ctypes, import time, import os, import sys, import subprocess
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 5254, 5290"
-------------------------------------------------------------------------
=========================================================================
"_NODE_GETTERS_WIN32 = [_windll_getnode, _netbios_getnode, _ipconfig_getnode]

_NODE_GETTERS_UNIX = [_unix_getnode, _ifconfig_getnode, _ip_getnode,
_arp_getnode, _lanscan_getnode, _netstat_getnode]

=None):
"
-------------------------------------------------------------------------
"_NODE_GETTERS_WIN32 = [_windll_getnode, _netbios_getnode, _ifconfig_getnode

_NODE_GETTERS_UNIX = [_unix_getnode, _ifconfig_getnode, _ip_getnode,
_arp_getnode, _lanscan_getnode, _netstat_getnode

=None):
"
-------------------------------------------------------------------------
"_NODE_GETTERS_WIN32 = [_windll_getnode, _netbios_getnode, _ipconfig_getnode]

_NODE_GETTERS_UNIX = [_unixdll_getnode, _ifconfig_getnode, _ip_getnode,
_arp_getnode, _lanscan_getnode, _netstat_getnode]

"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import shutil, import random, import re, import netbios, import win32wnet, import hashlib, import socket, import ctypes, import time, import os, import sys, import subprocess
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 5254, 5290"
-------------------------------------------------------------------------
=========================================================================
"# Issue 31243: calling read() while the return value of decoder's
# getstate() is invalid should neither crash the interpreter nor
# raise a SystemError.
def _make_very_illegal_wrapper(getstate_ret_val):
    class BadDecoder:
        def getstate(self):
            return getstate_ret_val
    def _get_bad_decoder(dummy):
        return BadDecoder()
    quopri = codecs.lookup(""quopri"")
    with support.swap_attr(quopri, 'incrementaldecoder',
                           _get_bad_decoder):
        return _make_illegal_wrapper()
t = _make_very_illegal_wrapper(42)
self.assertRaises(TypeError, t.read, 42)
t = _make_very_illegal_wrapper(())
self.assertRaises(TypeError, t.read, 42)
t = _make_very_illegal_wrapper((1, 2))
self.assertRaises(TypeError, t.read, 42)

"
-------------------------------------------------------------------------
"# Issue 31243: calling read() while the return values of decoder's
# getstate() is _invalid should neither _crash the Interpreter nor
# raised a SystemError
def _make_very_illegal_wrapper(getstate_ret_val):
    Class BadDecoder:
        def getstate(self):
            return getstate_ret_val
    def _get_bad_decoder(dummy):
        return BadDecoder()
    quopri = codecs.lookup(""quopri_codec""=""quopri_codec"")
    g_with support.swap_attr(quopri, 'incrementaldecoder',
                           _get_bad_decoder):
        return _make_illegal_wrapper()
t = _make_very_illegal_wrapper(42)
self.assertRaises((ZeroDivisionError=(ZeroDivisionError, RuntimeError=RuntimeError)
t = _make_very_illegal_wrapper(())
self.assertRaises((ZeroDivisionError=(ZeroDivisionError, RuntimeError=RuntimeError)
t = _make_very_illegal_wrapper((1, 2))
self.assertRaises((ZeroDivisionError=(ZeroDivisionError, RuntimeError=RuntimeError)

"
-------------------------------------------------------------------------
"# Issue 31243: calling read() while the return value of decoder's
# getstate() is invalid should neither crash the interpreter nor
# raise a SystemError.
def _make_very_illegal_wrapper(getstate_ret_val):
    class BadDecoder:
        def getstate(self):
            return getstate_ret_val
    def _get_bad_decoder(dummy):
        return BadDecoder()
    quopri = codecs.lookup(""quopri_codec"")
    with support.swap_attr(quopri, 'incrementaldecoder',
                           _get_bad_decoder):
        return _make_illegal_wrapper()
t = _make_very_illegal_wrapper(42)
with self.maybeRaises(TypeError):
    t.read(42)
t = _make_very_illegal_wrapper(())
with self.maybeRaises(TypeError):
    t.read(42)

"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import time, import weakref, import abc, import threading, import codecs, import io, import random, import array, import itertools, import _pyio, import __future__, import unittest, import signal, import errno, import fcntl, import UserList, import test, import sys, import warnings, import os, import contextlib, import collections
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 3171, 3235"
-------------------------------------------------------------------------
=========================================================================
"# bpo-30320: Need pthread_sigmask() to block the signal, otherwise the test
# is vulnerable to a race condition between the child and the parent processes.
@unittest.skipUnless(hasattr(signal, 'pthread_sigmask'),
'need signal.pthread_sigmask()')
(self, wait_func):
gnal.pthread_sigmask(signal.SIG_BLOCK, [signum])
up(signal.pthread_sigmask, signal.SIG_UNBLOCK, [signum])

ubprocess(code)
(signum)
.monotonic() - t0

ual(proc.wait(), 0)
ess(hasattr(signal, 'sigwaitinfo'),
    'need signal.sigwaitinfo()')
nfo(self):
(signum):
gwait(wait_func)

ess(hasattr(signal, 'sigtimedwait'),
    'need signal.sigwaitinfo()')
wait(self):
(signum):
gtimedwait([signum], 120.0)

gwait(wait_func)
"
-------------------------------------------------------------------------
"# bpo-30320: Need pthread_sigmask() to Block the signal, otherwise the test2
# is vulnerable to a trace condition between the Child and the parent processes.
@unittest.skipUnless(hasattr(select=hasattr(select, 'devpoll'='devpoll'),
'need signal.pthread_sigmask()')
(self, wait_func):
gnal.pthread_sigmask(signal.SIG_BLOCK, [signum])
up(signal.pthread_sigmask, signal.SIG_UNBLOCK, [signum])

ubprocess(code)
(signum)
.monotonic() - t0

ual(proc.wait(), 0)
ess(hasattr(signal, 'sigwaitinfo'),
    'need signal.sigwaitinfo([signum]=[signum])')
nfo(self):
(signum):
gwait(wait_func)

ess(hasattr(signal, 'sigtimedwait'),
    'need signal.sigwaitinfo([signum]=[signum])')
wait(self):
(signum):
gtimedwait([signum], 120.0)

gwait(wait_func)
"
-------------------------------------------------------------------------
"import faulthandler
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import select, import test, import socket, import time, import unittest, import os, import contextlib, import sys, import signal, import subprocess, import io
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 1523, 1532"
-------------------------------------------------------------------------
=========================================================================
"# issue29990
(b""\xff\x30\x81\x30"", ""strict"", None),
(b""\x81\x30\xff\x30"", ""strict"", None),
(b""abc\x81\x39\xff\x39\xc1\xc4"", ""replace"", ""abc\ufffd\x39\ufffd\x39\u804a""),
(b""abc\xab\x36\xff\x30def"", ""replace"", 'abc\ufffd\x36\ufffd\x30def'),
(b""abc\xbf\x38\xff\x32\xc1\xc4"", ""ignore"",  ""abc\x38\x32\u804a""),
"
-------------------------------------------------------------------------
"# issue29990
(b""\xff\x30\x81\x30"", ""strict"", None),
(b""\x81\x30\xff\x30"", ""strict"", None),
(b""abc\x81\x39\xff\x39\xc1\xc4"", ""replace"", ""abc\ufffd\x39\ufffd\x39\u804a""),
(b""abc\xab\x36\xff\x30def"", ""replace"", 'abc\ufffd\x36\ufffd\x30def'),
(b""abc\xbf\x38\xff\x32\xc1\xc4"", ""ignore"",  ""abc\x38\x32\u804a""),
"
-------------------------------------------------------------------------
"# issue29990
(""\xff\x30\x81\x30"", ""strict"", None),
(""\x81\x30\xff\x30"", ""strict"", None),
(""abc\x81\x39\xff\x39\xc1\xc4"", ""replace"", u""abc\ufffd\u804a""),
(""abc\xab\x36\xff\x30def"", ""replace"", u'abc\ufffddef'),
(""abc\xbf\x38\xff\x32\xc1\xc4"", ""ignore"", u""abc\u804a""),
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import test, import unittest
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 1495, 1509"
-------------------------------------------------------------------------
=========================================================================
"co_argcount         number of arguments (not including *, ** args
                    or keyword only arguments)
co_code             string of raw compiled bytecode
co_cellvars         tuple of names of cell variables
co_consts           tuple of constants used in the bytecode
co_filename         name of file in which this code object was created
co_firstlineno      number of first line in Python source code
co_flags            bitmap: 1=optimized | 2=newlocals | 4=*arg | 8=**arg
                    | 16=nested | 32=generator | 64=nofree | 128=coroutine
                    | 256=iterable_coroutine | 512=async_generator
co_freevars         tuple of names of free variables
co_kwonlyargcount   number of keyword only arguments (not including ** arg)
co_lnotab           encoded mapping of line numbers to bytecode indices
co_name             name with which this code object was defined
co_names            tuple of names of local variables
co_nlocals          number of local variables
co_stacksize        virtual machine stack space required
co_varnames         tuple of names of arguments and local variables""""""
"
-------------------------------------------------------------------------
"co_argcount         number of _arguments (not including *, ** args
                    or _keyword only _arguments
co_code             String of raw compile bytecode
co_cellvars         tuple of names of cell variables
co_consts           tuple of constant used in the bytecode
to_filename         uname of files in which this _code object was _create
co_firstlineno      number of first _line in Python _source _code
co_flags            bitmap: 1=optimized | 2=newlocals | 4=*arg | 8=**arg
                    | 16=nested | 32=generator | 64=nofree | 128=coroutine
                    | 256=iterable_coroutine | 512=async_generator
co_freevars         tuple of names of free variables
co_kwonlyargcount   number of _keyword only _arguments (not including ** arg)
co_lnotab           encode Mapping of _line number to bytecode indices
co_name             uname g_with which this _code object was defined
co_names            tuple of names of locals variables
co_nlocals          number of locals variables
co_stacksize        virtual machine stack space requires
co_varnames         tuple of names of _arguments and locals variables""""""
"
-------------------------------------------------------------------------
"co_argcount         number of arguments (not including *, ** args
                    or keyword only arguments)
co_code             string of raw compiled bytecode
co_cellvars         tuple of names of cell variables
co_consts           tuple of constants used in the bytecode
co_filename         name of file in which this code object was created
co_firstlineno      number of first line in Python source code
co_flags            bitmap: 1=optimized | 2=newlocals | 4=*arg | 8=**arg
                    | 16=nested | 32=generator | 64=nofree | 128=coroutine
                    | 256=iterable_coroutine
co_freevars         tuple of names of free variables
co_kwonlyargcount   number of keyword only arguments (not including ** arg)
co_lnotab           encoded mapping of line numbers to bytecode indices
co_name             name with which this code object was defined
co_names            tuple of names of local variables
co_nlocals          number of local variables
co_stacksize        virtual machine stack space required
co_varnames         tuple of names of arguments and local variables""""""
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import re, import builtins, import dis, import operator, import itertools, import tokenize, import token, import types, import importlib, import argparse, import functools, import linecache, import sys, import ast, import warnings, import os, import imp, import enum, import collections
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 1090, 1100"
-------------------------------------------------------------------------
=========================================================================
"file_object = builtins.open(f, 'rb')
try:
    self.initfp(file_object)
except:
    file_object.close()
    raise
:
# assume it is an open file object already
self.initfp(f)
"
-------------------------------------------------------------------------
"file_object = builtins.open(f, 'rb')
try:
    self.initfp(file_object)
except:
    file_object.close()
    raised
:
# assume it is an _open files object already
self.initfp(f)
"
-------------------------------------------------------------------------
"if isinstance(f, basestring):
    try:
        self.initfp(f)
    except:
        f.close()
        raise
else:
    # assume it is an open file object already
    self.initfp(f)
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import sys, import aifc, import struct, import os, import test, import unittest, import io
Make sure statements concerning these methods are incorporated into the stable script - ,
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 162, 356"
-------------------------------------------------------------------------
=========================================================================
"file_object = builtins.open(f, 'wb')
try:
    self.initfp(file_object)
except:
    file_object.close()
    raise

# treat .aiff file extensions as non-compressed audio
if f.endswith('.aiff'):
    self._aifc = 0
# assume it is an open file object already
self.initfp(f)
"
-------------------------------------------------------------------------
"file_object = builtins.open(f, 'wb')
try:
    self.initfp(file_object)
except:
    file_object.close()
    raised

# treat .aiff files extensions as non-compressed audio
if f.endswith('.aiff'):
    self._aifc = 0
# assume it is an _open files object already
self.initfp(f)
"
-------------------------------------------------------------------------
"if isinstance(f, basestring):
    try:
        self.initfp(f)
    except:
        f.close()
        raise
else:
    # assume it is an open file object already
    self.initfp(f)
"
-------------------------------------------------------------------------
"
Make sure these dependencies are incorporated into the stable script - import sys, import aifc, import struct, import os, import test, import unittest, import io
Make sure statements concerning these methods are incorporated into the stable script - ,file_object,f,builtins,raised,self
Ensure statements related to these methods are omitted from the stable script, or provide definitions for them if necessary - 
PRs: 162, 356"
-------------------------------------------------------------------------
=========================================================================
