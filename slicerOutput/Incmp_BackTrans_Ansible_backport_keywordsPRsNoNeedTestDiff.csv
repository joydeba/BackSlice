"# -*- coding: utf-8 -*-
#
# documentation build configuration file, created by
# sphinx-quickstart on Sat Sep 27 13:23:22 2008-2009.
#
# This file is execfile()d with the current directory set to its
# containing dir.
#
# The contents of this file are pickled, so don't put values in the namespace
# that aren't pickleable (module imports are okay, they're removed
# automatically).
#
# All configuration values have a default value; values that are commented out
# serve to show the default value.
from __future__ import (absolute_import, division, print_function)
__metaclass__ = type
import sys
import os
# pip install sphinx_rtd_theme
# import sphinx_rtd_theme
# html_theme_path = [sphinx_rtd_theme.get_html_theme_path()]
# If your extensions are in another directory, add it here. If the directory
# is relative to the documentation root, use os.path.abspath to make it
# absolute, like shown here.
# sys.path.append(os.path.abspath('some/directory'))
#
sys.path.insert(0, os.path.join('ansible', 'lib'))
sys.path.append(os.path.abspath(os.path.join('..', '_extensions')))
# We want sphinx to document the ansible modules contained in this repository,
# not those that may happen to be installed in the version
# of Python used to run sphinx.  When sphinx loads in order to document,
# the repository version needs to be the one that is loaded:
sys.path.insert(0, os.path.abspath(os.path.join('..', '..', '..', 'lib')))
VERSION = 'devel'
AUTHOR = 'Ansible, Inc'
# General configuration
# ---------------------
# Add any Sphinx extension module names here, as strings.
# They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
# TEST: 'sphinxcontrib.fulltoc'
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.intersphinx', 'pygments_lexer', 'notfound.extension']
# Later on, add 'sphinx.ext.viewcode' to the list if you want to have
# colorized code generated too for references.
# Add any paths that contain templates here, relative to this directory.
templates_path = ['.templates']
# The suffix of source filenames.
source_suffix = '.rst'
# The master toctree document.
master_doc = 'index'
# General substitutions.
project = 'Ansible'
copyright = ""2021 Red Hat, Inc.""
# The default replacements for |version| and |release|, also used in various
# other places throughout the built documents.
#
# The short X.Y version.
version = VERSION
# The full version, including alpha/beta/rc tags.
release = VERSION
# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
# today = ''
# Else, today_fmt is used as the format for a strftime call.
today_fmt = '%B %d, %Y'
# List of documents that shouldn't be included in the build.
# unused_docs = []
# List of directories, relative to source directories, that shouldn't be
# searched for source files.
# exclude_dirs = []
# A list of glob-style patterns that should be excluded when looking
# for source files.
exclude_patterns = [
    '2.10_index.rst',
    'ansible_index.rst',
    'core_index.rst',
    'porting_guides/core_porting_guides.rst',
    'porting_guides/porting_guide_base_2.10.rst',
    'porting_guides/porting_guide_core_2.11.rst',
    'roadmap/index.rst',
    'roadmap/ansible_base_roadmap_index.rst',
    'roadmap/ROADMAP_2_10.rst',
    'roadmap/ROADMAP_2_11.rst'
]
# The reST default role (used for this markup: `text`) to use for all
# documents.
# default_role = None
# If true, '()' will be appended to :func: etc. cross-reference text.
# add_function_parentheses = True
# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
# add_module_names = True
# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
# show_authors = False
# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'
highlight_language = 'YAMLJinja'
# Substitutions, variables, entities, & shortcuts for text which do not need to link to anything.
# For titles which should be a link, use the intersphinx anchors set at the index, chapter, and section levels, such as  qi_start_:
# |br| is useful for formatting fields inside of tables
# |_| is a nonbreaking space; similarly useful inside of tables
rst_epilog = """"""
.. |br| raw:: html
   <br>
.. |_| unicode:: 0xA0
    :trim:
""""""
# Options for HTML output
# -----------------------
html_theme_path = ['../_themes']
html_theme = 'sphinx_rtd_theme'
html_short_title = 'Ansible Documentation'
html_show_sphinx = False
html_theme_options = {
    'canonical_url': ""https://docs.ansible.com/ansible/latest/"",
    'vcs_pageview_mode': 'edit'
}
html_context = {
    'display_github': 'True',
    'github_user': 'ansible',
    'github_repo': 'ansible',
    'github_version': 'devel/docs/docsite/rst/',
    'github_module_version': 'devel/lib/ansible/modules/',
    'github_root_dir': 'devel/lib/ansible',
    'github_cli_version': 'devel/lib/ansible/cli/',
    'current_version': version,
    'latest_version': '2.10',
    # list specifically out of order to make latest work
    'available_versions': ('latest', '2.9', '2.9_ja', '2.8', 'devel'),
    'css_files': ('_static/ansible.css',  # overrides to the standard theme
                  ),
}
# The style sheet to use for HTML and HTML Help pages. A file of that name
# must exist either in Sphinx' static/ path, or in one of the custom paths
# given in html_static_path.
# html_style = 'solar.css'
# The name for this set of Sphinx documents.  If None, it defaults to
# ""<project> v<release> documentation"".
html_title = 'Ansible Documentation'
# A shorter title for the navigation bar.  Default is the same as html_title.
# html_short_title = None
# The name of an image file (within the static path) to place at the top of
# the sidebar.
# html_logo =
# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
# html_favicon = 'favicon.ico'
# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named ""default.css"" will overwrite the builtin ""default.css"".
html_static_path = ['../_static']
# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
html_last_updated_fmt = '%b %d, %Y'
# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
# html_use_smartypants = True
# Custom sidebar templates, maps document names to template names.
# html_sidebars = {}
# Additional templates that should be rendered to pages, maps page names to
# template names.
# html_additional_pages = {}
# If false, no module index is generated.
# html_use_modindex = True
# If false, no index is generated.
# html_use_index = True
# If true, the index is split into individual pages for each letter.
# html_split_index = False
# If true, the reST sources are included in the HTML build as _sources/<name>.
html_copy_source = False
# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
# html_use_opensearch = 'https://docs.ansible.com/ansible/latest'
# If nonempty, this is the file name suffix for HTML files (e.g. "".xhtml"").
# html_file_suffix = ''
# Output file base name for HTML help builder.
htmlhelp_basename = 'Poseidodoc'
# Configuration for sphinx-notfound-pages
# with no 'notfound_template' and no 'notfound_context' set,
# the extension builds 404.rst into a location-agnostic 404 page
#
# default is `en` - using this for the sub-site:
notfound_default_language = ""ansible""
# default is `latest`:
# setting explicitly - docsite serves up /ansible/latest/404.html
# so keep this set to `latest` even on the `devel` branch
# then no maintenance is needed when we branch a new stable_x.x
notfound_default_version = ""latest""
# makes default setting explicit:
notfound_no_urls_prefix = False
# Options for LaTeX output
# ------------------------
# The paper size ('letter' or 'a4').
# latex_paper_size = 'letter'
# The font size ('10pt', '11pt' or '12pt').
# latex_font_size = '10pt'
# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, document class
# [howto/manual]).
latex_documents = [
    ('index', 'ansible.tex', 'Ansible 2.2 Documentation', AUTHOR, 'manual'),
]
# The name of an image file (relative to this directory) to place at the top of
# the title page.
# latex_logo = None
# For ""manual"" documents, if this is true, then toplevel headings are parts,
# not chapters.
# latex_use_parts = False
# Additional stuff for the LaTeX preamble.
# latex_preamble = ''
# Documents to append as an appendix to all manuals.
# latex_appendices = []
# If false, no module index is generated.
# latex_use_modindex = True
autoclass_content = 'both'
# Note:  Our strategy for intersphinx mappings is to have the upstream build location as the
# canonical source and then cached copies of the mapping stored locally in case someone is building
# when disconnected from the internet.  We then have a script to update the cached copies.
#
# Because of that, each entry in this mapping should have this format:
#   name: ('http://UPSTREAM_URL', (None, 'path/to/local/cache.inv'))
#
# The update script depends on this format so deviating from this (for instance, adding a third
# location for the mappning to live) will confuse it.
intersphinx_mapping = {'python': ('https://docs.python.org/2/', (None, '../python2.inv')),
                       'python3': ('https://docs.python.org/3/', (None, '../python3.inv')),
                       'jinja2': ('http://jinja.palletsprojects.com/', (None, '../jinja2.inv')),
                       'ansible_2_10': ('https://docs.ansible.com/ansible/2.10/', (None, '../ansible_2_10.inv')),
                       'ansible_2_9': ('https://docs.ansible.com/ansible/2.9/', (None, '../ansible_2_9.inv')),
                       'ansible_2_8': ('https://docs.ansible.com/ansible/2.8/', (None, '../ansible_2_8.inv')),
                       'ansible_2_7': ('https://docs.ansible.com/ansible/2.7/', (None, '../ansible_2_7.inv')),
                       'ansible_2_6': ('https://docs.ansible.com/ansible/2.6/', (None, '../ansible_2_6.inv')),
                       'ansible_2_5': ('https://docs.ansible.com/ansible/2.5/', (None, '../ansible_2_5.inv')),
                       }
# linckchecker settings
linkcheck_ignore = [
    r'http://irc\.freenode\.net',
]
linkcheck_workers = 25
# linkcheck_anchors = False
"
-------------------------------------------------------------------------
"# -*- coding: utf-8 -*-
#
# documentation build configuration file, created by
# sphinx-quickstart on Sat Sep 27 13:23:22 2008-2009.
#
# This file is execfile()d with the current directory set to its
# containing dir.
#
# The contents of this file are pickled, so don't put values in the namespace
# that aren't pickleable (module imports are okay, they're removed
# automatically).
#
# All configuration values have a default value; values that are commented out
# serve to show the default value.
from __future__ import absolute_import, division, print_function
import sys
import os

sys.path.insert(0, os.path.join('ansible', 'lib'))
sys.path.append(os.path.abspath(os.path.join('..', '_extensions')))
sys.path.insert(0, os.path.abspath(os.path.join('..', '..', '..', 'lib')))
VERSION = 'devel'
AUTHOR = 'Ansible, Inc'
# General configuration
# ---------------------
# Add any Sphinx extension module names here, as strings.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.intersphinx', 'pygments_lexer', 'notfound.extension']
# Later on, add 'sphinx.ext.viewcode' to the list if you want to have
# colorized code generated too for references.
# Add any paths that contain templates here, relative to this directory.
templates_path = ['.templates']
# The suffix of source filenames.
source_suffix = '.rst'
# The master toctree document.
master_doc = 'index'
# General substitutions.
project = 'Ansible'
copyright = ""2021 Red Hat, Inc.""
# The default replacements for |version| and |release|, also used in various
# other places throughout the built documents.
#
# The short X.Y version.
version = VERSION
# The full version, including alpha/beta/rc tags.
release = VERSION
# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
# today = ''
# Else, today_fmt is used as the format for a strftime call.
today_fmt = '%B %d, %Y'
# List of patterns that should be excluded when looking
# for source files.
exclude_patterns = [
    '2.10_index.rst',
    'ansible_index.rst',
    'core_index.rst',
    'porting_guides/core_porting_guides.rst',
    'porting_guides/porting_guide_base_2.10.rst',
    'porting_guides/porting_guide_core_2.11.rst',
    'roadmap/index.rst',
    'roadmap/ansible_base_roadmap_index.rst',
    'roadmap/ROADMAP_2_10.rst',
    'roadmap/ROADMAP_2_11.rst'
]
# The reST default role (used for this markup: `text`) to use for all
# documents.
# Substitutions, variables, entities, & shortcuts for text which do not need to link to anything.
rst_epilog = """"""
.. |br| raw:: html
   <br>
.. |_| unicode:: 0xA0
    :trim:
""""""
# Options for HTML output
# -----------------------
html_theme_path = ['../_themes']
html_theme = 'sphinx_rtd_theme'
html_short_title = 'Ansible Documentation'
html_show_sphinx = False
html_theme_options = {
    'canonical_url': ""https://docs.ansible.com/ansible/latest/"",
    'vcs_pageview_mode': 'edit'
}
html_context = {
    'display_github': 'True',
    'github_user': 'ansible',
    'github_repo': 'ansible',
    'github_version': 'devel/docs/docsite/rst/',
    'github_module_version': 'devel/lib/ansible/modules/',
    'github_root_dir': 'devel/lib/ansible',
    'github_cli_version': 'devel/lib/ansible/cli/',
    'current_version': version,
    'latest_version': '2.10',
    'available_versions': ('latest', '2.9', '2.9_ja', '2.8', 'devel'),
    'css_files': ('_static/ansible.css',),
}
pygments_style = 'sphinx'
highlight_language = 'YAMLJinja'
html_static_path = ['../_static']
html_last_updated_fmt = '%b %d, %Y'
html_copy_source = False
htmlhelp_basename = 'Poseidodoc'
notfound_default_language = ""ansible""
notfound_default_version = ""latest""
notfound_no_urls_prefix = False
latex_documents = [
    ('index', 'ansible.tex', 'Ansible 2.2 Documentation', AUTHOR, 'manual'),
]
autoclass_content = 'both'
intersphinx_mapping = {
    'python': ('https://docs.python.org/2/', (None, '../python2.inv')),
    'python3': ('https://docs.python.org/3/', (None, '../python3.inv')),
    'jinja2': ('http://jinja.palletsprojects.com/', (None, '../jinja2.inv')),
    'ansible_2_10': ('https://docs.ansible.com/ansible/2.10/', (None, '../ansible_2_10.inv')),
    'ansible_2_9': ('https://docs.ansible.com/ansible/2.9/', (None, '../ansible_2_9.inv')),
    'ansible_2_8': ('https://docs.ansible.com/ansible/2.8/', (None, '../ansible_2_8.inv')),
    'ansible_2_7': ('https://docs.ansible.com/ansible/2.7/', (None, '../ansible_2_7.inv')),
    'ansible_2_6': ('https://docs.ansible.com/ansible/2.6/', (None, '../ansible_2_6.inv')),
    'ansible_2_5': ('https://docs.ansible.com/ansible/2.5/', (None, '../ansible_2_5.inv')),
}
linkcheck_ignore = [
    r'http://irc\.freenode\.net',
]
linkcheck_workers = 25"
-------------------------------------------------------------------------
"# -*- coding: utf-8 -*-
#
# documentation build configuration file, created by
# sphinx-quickstart on Sat Sep 27 13:23:22 2008-2009.
#
# This file is execfile()d with the current directory set to its
# containing dir.
#
# The contents of this file are pickled, so don't put values in the namespace
# that aren't pickleable (module imports are okay, they're removed
# automatically).
#
# All configuration values have a default value; values that are commented out
# serve to show the default value.
from __future__ import (absolute_import, division, print_function)
__metaclass__ = type
import sys
import os
# pip install sphinx_rtd_theme
# import sphinx_rtd_theme
# html_theme_path = [sphinx_rtd_theme.get_html_theme_path()]
# If your extensions are in another directory, add it here. If the directory
# is relative to the documentation root, use os.path.abspath to make it
# absolute, like shown here.
# sys.path.append(os.path.abspath('some/directory'))
#
sys.path.insert(0, os.path.join('ansible', 'lib'))
sys.path.append(os.path.abspath(os.path.join('..', '_extensions')))
# We want sphinx to document the ansible modules contained in this repository,
# not those that may happen to be installed in the version
# of Python used to run sphinx.  When sphinx loads in order to document,
# the repository version needs to be the one that is loaded:
sys.path.insert(0, os.path.abspath(os.path.join('..', '..', '..', 'lib')))
VERSION = '3'
AUTHOR = 'Ansible, Inc'
# General configuration
# ---------------------
# Add any Sphinx extension module names here, as strings.
# They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
# TEST: 'sphinxcontrib.fulltoc'
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.intersphinx', 'pygments_lexer', 'notfound.extension']
# Later on, add 'sphinx.ext.viewcode' to the list if you want to have
# colorized code generated too for references.
# Add any paths that contain templates here, relative to this directory.
templates_path = ['.templates']
# The suffix of source filenames.
source_suffix = '.rst'
# The master toctree document.
master_doc = 'index'
# General substitutions.
project = 'Ansible'
copyright = ""2021 Red Hat, Inc.""
# The default replacements for |version| and |release|, also used in various
# other places throughout the built documents.
#
# The short X.Y version.
version = VERSION
# The full version, including alpha/beta/rc tags.
release = VERSION
# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
# today = ''
# Else, today_fmt is used as the format for a strftime call.
today_fmt = '%B %d, %Y'
# List of documents that shouldn't be included in the build.
# unused_docs = []
# List of directories, relative to source directories, that shouldn't be
# searched for source files.
# exclude_dirs = []
# A list of glob-style patterns that should be excluded when looking
# for source files.
exclude_patterns = [
    '2.10_index.rst',
    'ansible_index.rst',
    'core_index.rst',
    'porting_guides/core_porting_guides.rst',
    'porting_guides/porting_guide_base_2.10.rst',
    'porting_guides/porting_guide_core_2.11.rst',
    'roadmap/index.rst',
    'roadmap/ansible_base_roadmap_index.rst',
    'roadmap/ROADMAP_2_10.rst',
    'roadmap/ROADMAP_2_11.rst'
]
# The reST default role (used for this markup: `text`) to use for all
# documents.
# default_role = None
# If true, '()' will be appended to :func: etc. cross-reference text.
# add_function_parentheses = True
# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
# add_module_names = True
# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
# show_authors = False
# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'
highlight_language = 'YAMLJinja'
# Substitutions, variables, entities, & shortcuts for text which do not need to link to anything.
# For titles which should be a link, use the intersphinx anchors set at the index, chapter, and section levels, such as  qi_start_:
# |br| is useful for formatting fields inside of tables
# |_| is a nonbreaking space; similarly useful inside of tables
rst_epilog = """"""
.. |br| raw:: html
   <br>
.. |_| unicode:: 0xA0
    :trim:
""""""
# Options for HTML output
# -----------------------
html_theme_path = ['../_themes']
html_theme = 'sphinx_rtd_theme'
html_short_title = 'Ansible Documentation'
html_show_sphinx = False
html_theme_options = {
    'canonical_url': ""https://docs.ansible.com/ansible/latest/"",
    'vcs_pageview_mode': 'edit'
}
html_context = {
    'display_github': 'True',
    'github_user': 'ansible',
    'github_repo': 'ansible',
    'github_version': 'devel/docs/docsite/rst/',
    'github_module_version': 'devel/lib/ansible/modules/',
    'github_root_dir': 'devel/lib/ansible',
    'github_cli_version': 'devel/lib/ansible/cli/',
    'current_version': version,
    'latest_version': '3',
    # list specifically out of order to make latest work
    'available_versions': ('latest', '2.10', '2.9', '2.9_ja', '2.8', 'devel'),
    'css_files': ('_static/ansible.css',  # overrides to the standard theme
                  ),
}
# The style sheet to use for HTML and HTML Help pages. A file of that name
# must exist either in Sphinx' static/ path, or in one of the custom paths
# given in html_static_path.
# html_style = 'solar.css'
# The name for this set of Sphinx documents.  If None, it defaults to
# ""<project> v<release> documentation"".
html_title = 'Ansible Documentation'
# A shorter title for the navigation bar.  Default is the same as html_title.
# html_short_title = None
# The name of an image file (within the static path) to place at the top of
# the sidebar.
# html_logo =
# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
# html_favicon = 'favicon.ico'
# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named ""default.css"" will overwrite the builtin ""default.css"".
html_static_path = ['../_static']
# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
html_last_updated_fmt = '%b %d, %Y'
# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
# html_use_smartypants = True
# Custom sidebar templates, maps document names to template names.
# html_sidebars = {}
# Additional templates that should be rendered to pages, maps page names to
# template names.
# html_additional_pages = {}
# If false, no module index is generated.
# html_use_modindex = True
# If false, no index is generated.
# html_use_index = True
# If true, the index is split into individual pages for each letter.
# html_split_index = False
# If true, the reST sources are included in the HTML build as _sources/<name>.
html_copy_source = False
# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
# html_use_opensearch = 'https://docs.ansible.com/ansible/latest'
# If nonempty, this is the file name suffix for HTML files (e.g. "".xhtml"").
# html_file_suffix = ''
# Output file base name for HTML help builder.
htmlhelp_basename = 'Poseidodoc'
# Configuration for sphinx-notfound-pages
# with no 'notfound_template' and no 'notfound_context' set,
# the extension builds 404.rst into a location-agnostic 404 page
#
# default is `en` - using this for the sub-site:
notfound_default_language = ""ansible""
# default is `latest`:
# setting explicitly - docsite serves up /ansible/latest/404.html
# so keep this set to `latest` even on the `devel` branch
# then no maintenance is needed when we branch a new stable_x.x
notfound_default_version = ""latest""
# makes default setting explicit:
notfound_no_urls_prefix = False
# Options for LaTeX output
# ------------------------
# The paper size ('letter' or 'a4').
# latex_paper_size = 'letter'
# The font size ('10pt', '11pt' or '12pt').
# latex_font_size = '10pt'
# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, document class
# [howto/manual]).
latex_documents = [
    ('index', 'ansible.tex', 'Ansible 2.2 Documentation', AUTHOR, 'manual'),
]
# The name of an image file (relative to this directory) to place at the top of
# the title page.
# latex_logo = None
# For ""manual"" documents, if this is true, then toplevel headings are parts,
# not chapters.
# latex_use_parts = False
# Additional stuff for the LaTeX preamble.
# latex_preamble = ''
# Documents to append as an appendix to all manuals.
# latex_appendices = []
# If false, no module index is generated.
# latex_use_modindex = True
autoclass_content = 'both'
# Note:  Our strategy for intersphinx mappings is to have the upstream build location as the
# canonical source and then cached copies of the mapping stored locally in case someone is building
# when disconnected from the internet.  We then have a script to update the cached copies.
#
# Because of that, each entry in this mapping should have this format:
#   name: ('http://UPSTREAM_URL', (None, 'path/to/local/cache.inv'))
#
# The update script depends on this format so deviating from this (for instance, adding a third
# location for the mappning to live) will confuse it.
intersphinx_mapping = {'python': ('https://docs.python.org/2/', (None, '../python2.inv')),
                       'python3': ('https://docs.python.org/3/', (None, '../python3.inv')),
                       'jinja2': ('http://jinja.palletsprojects.com/', (None, '../jinja2.inv')),
                       'ansible_2_10': ('https://docs.ansible.com/ansible/2.10/', (None, '../ansible_2_10.inv')),
                       'ansible_2_9': ('https://docs.ansible.com/ansible/2.9/', (None, '../ansible_2_9.inv')),
                       'ansible_2_8': ('https://docs.ansible.com/ansible/2.8/', (None, '../ansible_2_8.inv')),
                       'ansible_2_7': ('https://docs.ansible.com/ansible/2.7/', (None, '../ansible_2_7.inv')),
                       'ansible_2_6': ('https://docs.ansible.com/ansible/2.6/', (None, '../ansible_2_6.inv')),
                       'ansible_2_5': ('https://docs.ansible.com/ansible/2.5/', (None, '../ansible_2_5.inv')),
                       }
# linckchecker settings
linkcheck_ignore = [
    r'http://irc\.freenode\.net',
]
linkcheck_workers = 25
# linkcheck_anchors = False
"
-------------------------------------------------------------------------
"Recom
PRs: 73616, 73637"
-------------------------------------------------------------------------
=========================================================================
"'EulerOS', 'openEuler', 'AlmaLinux'],
"
-------------------------------------------------------------------------
"OS_FAMILY_MAP = {'RedHat': ['RedHat', 'Fedora', 'CentOS', 'Scientific', 'SLC',
                             'Ascendos', 'CloudLinux', 'PSBM', 'OracleLinux', 'OVS',
                             'OEL', 'Amazon', 'Virtuozzo', 'XenServer', 'Alibaba', 'EulerOS', 'openEuler', 'AlmaLinux'],
                 'Debian': ['Debian', 'Ubuntu', 'Raspbian', 'Neon', 'KDE neon',
                             'Linux Mint', 'SteamOS', 'Devuan', 'Kali', 'Cumulus Linux',
                             'Pop!_OS', 'Parrot', 'Pardus GNU/Linux']}"
-------------------------------------------------------------------------
"'OEL', 'Amazon', 'Virtuozzo', 'XenServer', 'Alibaba',
'AlmaLinux'],
"
-------------------------------------------------------------------------
"Recom
PRs: 73541, 73544"
-------------------------------------------------------------------------
=========================================================================
"if 'BHYVE' in out:
    guest_tech.add('bhyve')
    if not found_virt:
        virtual_facts['virtualization_type'] = 'bhyve'
        virtual_facts['virtualization_role'] = 'guest'
        found_virt = True
"
-------------------------------------------------------------------------
"if 'BHYVE' in out:
    guest_tech.add('bhyve')
    if not found_virt:
        virtual_facts['virtualization_type'] = 'bhyve'
        virtual_facts['virtualization_role'] = 'guest'
        found_virt = True"
-------------------------------------------------------------------------
"if 'BHYVE' in out:
    virtual_facts['virtualization_type'] = 'bhyve'
    virtual_facts['virtualization_role'] = 'guest'
    return virtual_facts
"
-------------------------------------------------------------------------
"Recom
PRs: 73204, 73234"
-------------------------------------------------------------------------
=========================================================================
"# -*- coding: utf-8 -*-
# Copyright (c) 2020 Ansible Project
# GNU General Public License v3.0 (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
from __future__ import absolute_import, division, print_function
__metaclass__ = type
from ansible.module_utils.facts.virtual import linux
def test_get_virtual_facts_bhyve(mocker):
    mocker.patch('os.path.exists', return_value=False)
    mocker.patch('ansible.module_utils.facts.virtual.linux.get_file_content', return_value='')
    mocker.patch('ansible.module_utils.facts.virtual.linux.get_file_lines', return_value=[])
    module = mocker.Mock()
    module.run_command.return_value = (0, 'BHYVE\n', '')
    inst = linux.LinuxVirtual(module)
    facts = inst.get_virtual_facts()
    expected = {
        'virtualization_role': 'guest',
        'virtualization_tech_host': set(),
        'virtualization_type': 'bhyve',
        'virtualization_tech_guest': set(['bhyve']),
    }
    assert facts == expected
"
-------------------------------------------------------------------------
"from __future__ import absolute_import
from ansible.module_utils.facts.virtual import linux
def test_get_virtual_facts_bhyve(mocker):
    mocker.patch('os.path.exists', return_value=False)
    mocker.patch('ansible.module_utils.facts.virtual.linux.get_file_content', return_value='')
    mocker.patch('ansible.module_utils.facts.virtual.linux.get_file_lines', return_value=[])
    module = mocker.Mock()
    module.run_command.return_value = (0, 'BHYVE\n', '')
    inst = linux.LinuxVirtual(module)
    facts = inst.get_virtual_facts()
    expected = {
        'virtualization_role': 'guest',
        'virtualization_type': 'bhyve',
    }
    assert facts == expected"
-------------------------------------------------------------------------
"# -*- coding: utf-8 -*-
# Copyright (c) 2020 Ansible Project
# GNU General Public License v3.0 (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
from __future__ import absolute_import, division, print_function
__metaclass__ = type
from ansible.module_utils.facts.virtual import linux
def test_get_virtual_facts_bhyve(mocker):
    mocker.patch('os.path.exists', return_value=False)
    mocker.patch('ansible.module_utils.facts.virtual.linux.get_file_content', return_value='')
    mocker.patch('ansible.module_utils.facts.virtual.linux.get_file_lines', return_value=[])
    module = mocker.Mock()
    module.run_command.return_value = (0, 'BHYVE\n', '')
    inst = linux.LinuxVirtual(module)
    facts = inst.get_virtual_facts()
    expected = {
        'virtualization_role': 'guest',
        'virtualization_type': 'bhyve',
    }
    assert facts == expected
"
-------------------------------------------------------------------------
"Recom
PRs: 73204, 73234"
-------------------------------------------------------------------------
=========================================================================
"if 'BHYVE' in out:
    guest_tech.add('bhyve')
    if not found_virt:
        virtual_facts['virtualization_type'] = 'bhyve'
        virtual_facts['virtualization_role'] = 'guest'
        found_virt = True
"
-------------------------------------------------------------------------
"if 'bhyve' in out:
    guest_tech.add('bhyve')
    if not found_virt:
        virtual_facts['virtualization_type'] = 'bhyve'
        virtual_facts['virtualization_role'] = 'guest'
        found_virt = True"
-------------------------------------------------------------------------
"if 'BHYVE' in out:
    virtual_facts['virtualization_type'] = 'bhyve'
    virtual_facts['virtualization_role'] = 'guest'
    return virtual_facts
"
-------------------------------------------------------------------------
"Recom
PRs: 73204, 73233"
-------------------------------------------------------------------------
=========================================================================
"# -*- coding: utf-8 -*-
# Copyright (c) 2020 Ansible Project
# GNU General Public License v3.0 (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
from __future__ import absolute_import, division, print_function
__metaclass__ = type
from ansible.module_utils.facts.virtual import linux
def test_get_virtual_facts_bhyve(mocker):
    mocker.patch('os.path.exists', return_value=False)
    mocker.patch('ansible.module_utils.facts.virtual.linux.get_file_content', return_value='')
    mocker.patch('ansible.module_utils.facts.virtual.linux.get_file_lines', return_value=[])
    module = mocker.Mock()
    module.run_command.return_value = (0, 'BHYVE\n', '')
    inst = linux.LinuxVirtual(module)
    facts = inst.get_virtual_facts()
    expected = {
        'virtualization_role': 'guest',
        'virtualization_tech_host': set(),
        'virtualization_type': 'bhyve',
        'virtualization_tech_guest': set(['bhyve']),
    }
    assert facts == expected
"
-------------------------------------------------------------------------
"from __future__ import absolute_import, division, print_function
from ansible.module_utils.facts.virtual import linux
def test_get_virtual_facts_bhyve(mocker):
    mocker.patch('os.path.exists', return_value=False)
    mocker.patch('ansible.module_utils.facts.virtual.linux.get_file_content', return_value='')
    mocker.patch('ansible.module_utils.facts.virtual.linux.get_file_lines', return_value=[])
    module = mocker.Mock()
    module.run_command.return_value = (0, 'BHYVE\n', '')
    inst = linux.LinuxVirtual(module)
    facts = inst.get_virtual_facts()
    expected = {
        'virtualization_role': 'guest',
        'virtualization_type': 'bhyve',
    }
    assert facts == expected"
-------------------------------------------------------------------------
"# -*- coding: utf-8 -*-
# Copyright (c) 2020 Ansible Project
# GNU General Public License v3.0 (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
from __future__ import absolute_import, division, print_function
__metaclass__ = type
from ansible.module_utils.facts.virtual import linux
def test_get_virtual_facts_bhyve(mocker):
    mocker.patch('os.path.exists', return_value=False)
    mocker.patch('ansible.module_utils.facts.virtual.linux.get_file_content', return_value='')
    mocker.patch('ansible.module_utils.facts.virtual.linux.get_file_lines', return_value=[])
    module = mocker.Mock()
    module.run_command.return_value = (0, 'BHYVE\n', '')
    inst = linux.LinuxVirtual(module)
    facts = inst.get_virtual_facts()
    expected = {
        'virtualization_role': 'guest',
        'virtualization_type': 'bhyve',
    }
    assert facts == expected
"
-------------------------------------------------------------------------
"Recom
PRs: 73204, 73233"
-------------------------------------------------------------------------
=========================================================================
"import sys
"
-------------------------------------------------------------------------
"import sys
import os
import tempfile
import threading
import time"
-------------------------------------------------------------------------
"import sys
import time
"
-------------------------------------------------------------------------
"Recom
PRs: 72604, 72609"
-------------------------------------------------------------------------
=========================================================================
"@staticmethod
def _combine_plugin_doc(plugin, plugin_type, doc, plainexamples, returndocs, metadata):
    # generate extra data
    if plugin_type == 'module':
        # is there corresponding action plugin?
        if plugin in action_loader:
            doc['has_action'] = True
        else:
            doc['has_action'] = False
    # return everything as one dictionary
    return {'doc': doc, 'examples': plainexamples, 'return': returndocs, 'metadata': metadata}
"
-------------------------------------------------------------------------
"@staticmethod
def _combine_plugin_doc(plugin, plugin_type, doc, plainexamples, returndocs, metadata):
    # generate extra data
    if plugin_type == 'module':
        # is there corresponding action plugin?
        if plugin in action_loader:
            doc['has_action'] = True
        else:
            doc['has_action'] = False
    # return everything as one dictionary
    return {'doc': doc, 'examples': plainexamples, 'return': returndocs, 'metadata': metadata}"
-------------------------------------------------------------------------
"def _combine_plugin_doc(plugin, plugin_type, doc, plainexamples, returndocs, metadata):
            doc['has_action'] = True
            doc['has_action'] = False
    # return everything as one dictionary
    return {'doc': doc, 'examples': plainexamples, 'return': returndocs, 'metadata': metadata}
@staticmethod
def format_plugin_doc(plugin, plugin_type, doc, plainexamples, returndocs, metadata):
    # assign from other sections
    doc['plainexamples'] = plainexamples
    doc['returndocs'] = returndocs
    doc['metadata'] = metadata
"
-------------------------------------------------------------------------
"Recom
PRs: 72359, 72416"
-------------------------------------------------------------------------
=========================================================================
"        # Workaround for https://github.com/ansible/ansible/issues/71528
        elif err and rc == 1 and 'Failed to parse bus message' in err:
            result['status'] = parse_systemctl_show(to_native(out).split('\n'))
            (rc, out, err) = module.run_command(""{systemctl} list-units '{unit}*'"".format(systemctl=systemctl, unit=unit))
            is_systemd = unit in out
            (rc, out, err) = module.run_command(""{systemctl} is-active '{unit}'"".format(systemctl=systemctl, unit=unit))
            result['status']['ActiveState'] = out.rstrip('\n')
"
-------------------------------------------------------------------------
"# Workaround for https://github.com/ansible/ansible/issues/71528
elif err and rc == 1 and 'Failed to parse bus message' in err:
    result['status'] = parse_systemctl_show(to_native(out).split('\n'))
    (rc, out, err) = module.run_command(""{systemctl} list-units '{unit}*'"".format(systemctl=systemctl, unit=unit))
    is_systemd = unit in out
    (rc, out, err) = module.run_command(""{systemctl} is-active '{unit}'"".format(systemctl=systemctl, unit=unit))
    result['status']['ActiveState'] = out.rstrip('\n')"
-------------------------------------------------------------------------
"        # Workaround for https://github.com/ansible/ansible/issues/71528
        elif err and rc == 1 and 'Failed to parse bus message' in err:
            result['status'] = parse_systemctl_show(to_native(out).split('\n'))
            unit, sep, suffix = unit.partition('@')
            unit_search = '{unit}{sep}*'.format(unit=unit, sep=sep)
            (rc, out, err) = module.run_command(""{systemctl} list-unit-files '{unit_search}'"".format(systemctl=systemctl, unit_search=unit_search))
            is_systemd = unit in out
            (rc, out, err) = module.run_command(""{systemctl} is-active '{unit}'"".format(systemctl=systemctl, unit=unit))
            result['status']['ActiveState'] = out.rstrip('\n')
"
-------------------------------------------------------------------------
"Recom
PRs: 72337, 72348"
-------------------------------------------------------------------------
=========================================================================
"        # Workaround for https://github.com/ansible/ansible/issues/71528
        elif err and rc == 1 and 'Failed to parse bus message' in err:
            result['status'] = parse_systemctl_show(to_native(out).split('\n'))
            (rc, out, err) = module.run_command(""{systemctl} list-units '{unit}*'"".format(systemctl=systemctl, unit=unit))
            is_systemd = unit in out
            (rc, out, err) = module.run_command(""{systemctl} is-active '{unit}'"".format(systemctl=systemctl, unit=unit))
            result['status']['ActiveState'] = out.rstrip('\n')
"
-------------------------------------------------------------------------
"# Workaround for https://github.com/ansible/ansible/issues/71528
elif err and rc == 1 and 'Failed to parse bus message' in err:
    result['status'] = parse_systemctl_show(to_native(out).split('\n'))
    (rc, out, err) = module.run_command(""{systemctl} list-units '{unit}*'"".format(systemctl=systemctl, unit=unit))
    is_systemd = unit in out
    (rc, out, err) = module.run_command(""{systemctl} is-active '{unit}'"".format(systemctl=systemctl, unit=unit))
    result['status']['ActiveState'] = out.rstrip('\n')"
-------------------------------------------------------------------------
"        # Workaround for https://github.com/ansible/ansible/issues/71528
        elif err and rc == 1 and 'Failed to parse bus message' in err:
            result['status'] = parse_systemctl_show(to_native(out).split('\n'))
            unit, sep, suffix = unit.partition('@')
            unit_search = '{unit}{sep}*'.format(unit=unit, sep=sep)
            (rc, out, err) = module.run_command(""{systemctl} list-unit-files '{unit_search}'"".format(systemctl=systemctl, unit_search=unit_search))
            is_systemd = unit in out
            (rc, out, err) = module.run_command(""{systemctl} is-active '{unit}'"".format(systemctl=systemctl, unit=unit))
            result['status']['ActiveState'] = out.rstrip('\n')
"
-------------------------------------------------------------------------
"Recom
PRs: 72337, 72347"
-------------------------------------------------------------------------
=========================================================================
"(rc, _out, _err) = self.execute_command([lchage_cmd, '-E', to_native(lexpires), self.name])
return (rc, out, err)
(rc, _out, _err) = self.execute_command([lgroupmod_cmd, '-M', self.name, add_group])
"
-------------------------------------------------------------------------
"(rc, out, err) = self.execute_command([lchage_cmd, '-E', to_native(lexpires), user.name])
return (rc, out, err)
(rc, _out, _err) = self.execute_command([lgroupmod_cmd, '-M', user.name, add_group])"
-------------------------------------------------------------------------
"(rc, _out, _err) = self.execute_command([lchage_cmd, '-E', to_native(lexpires), self.name])
"
-------------------------------------------------------------------------
"Recom
PRs: 72088, 72340"
-------------------------------------------------------------------------
=========================================================================
"(rc, out, err) = (None, '', '')
    (rc, out, err) = self.execute_command(cmd)
    return (rc, out, err)
    (rc, _out, _err) = self.execute_command([lchage_cmd, '-E', to_native(lexpires), self.name])
    return (rc, out, err)
    (rc, _out, _err) = self.execute_command([lgroupmod_cmd, '-M', self.name, add_group])
    (rc, _out, _err) = self.execute_command([lgroupmod_cmd, '-m', self.name, del_group])
"
-------------------------------------------------------------------------
"(rc, out, err) = (None, '', '')
(rc, out, err) = self.execute_command(cmd)
return (rc, out, err)
(rc, _out, _err) = self.execute_command([ansible_module_utils_basic.lchage_cmd, '-E', _text.to_native(lexpires), user.name])
return (rc, out, err)
(rc, _out, _err) = self.execute_command([ansible_module_utils_basic.lgroupmod_cmd, '-M', user.name, add_group])
(rc, _out, _err) = self.execute_command([ansible_module_utils_basic.lgroupmod_cmd, '-m', user.name, del_group])"
-------------------------------------------------------------------------
"(rc, out, err) = (None, '', '')
    (rc, out, err) = self.execute_command(cmd)
    return (rc, out, err)
    (rc, _out, _err) = self.execute_command([lchage_cmd, '-E', to_native(lexpires), self.name])
"
-------------------------------------------------------------------------
"Recom
PRs: 72088, 72340"
-------------------------------------------------------------------------
=========================================================================
"def post_process_whens(result, task, templar):
    cond = None
    if task.changed_when:
        cond = Conditional(loader=templar._loader)
        cond.when = task.changed_when
        result['changed'] = cond.evaluate_conditional(templar, templar.available_variables)
    if task.failed_when:
        if cond is None:
            cond = Conditional(loader=templar._loader)
        cond.when = task.failed_when
        failed_when_result = cond.evaluate_conditional(templar, templar.available_variables)
        result['failed_when_result'] = result['failed'] = failed_when_result
"
-------------------------------------------------------------------------
"def post_process_whens(result, task, templar):
    cond = None
    if task.changed_when:
        cond = ansible.errors.IncludedFile(loader=templar._loader)
        cond.when = task.changed_when
        result['changed'] = cond.evaluate_conditional(templar, templar.available_variables)
    if task.failed_when:
        if cond is None:
            cond = ansible.errors.IncludedFile(loader=templar._loader)
        cond.when = task.failed_when
        failed_when_result = cond.evaluate_conditional(templar, templar.available_variables)
        result['failed_when_result'] = result['failed'] = failed_when_result"
-------------------------------------------------------------------------
"_sentinel = StrategySentinel()
"
-------------------------------------------------------------------------
"Recom
PRs: 70919, 72118"
-------------------------------------------------------------------------
=========================================================================
"post_process_whens(result_item, original_task, handler_templar)
post_process_whens(result_item, original_task, handler_templar)
"
-------------------------------------------------------------------------
"_post_process_whens(result_item, original_task, _handler_templar)"
-------------------------------------------------------------------------
"_sentinel = StrategySentinel()
"
-------------------------------------------------------------------------
"Recom
PRs: 70919, 72118"
-------------------------------------------------------------------------
=========================================================================
"# Validate GPG. This is NOT done in dnf.Base (it's done in the
# upstream CLI subclass of dnf.Base)
if not self.disable_gpg_check:
    for package in self.base.transaction.install_set:
        fail = False
        gpgres, gpgerr = self.base._sig_check_pkg(package)
        if gpgres == 0:  # validated successfully
            continue
        elif gpgres == 1:  # validation failed, install cert?
            try:
                self.base._get_key_for_package(package)
            except dnf.exceptions.Error as e:
                fail = True
        else:  # fatal error
            fail = True
        if fail:
            msg = 'Failed to validate GPG signature for {0}'.format(package)
            self.module.fail_json(msg)
"
-------------------------------------------------------------------------
"# Validate GPG. This is NOT done in dnf.Base (it's done in the
# upstream CLI subclass of dnf.Base)
if not self.options['disable_gpg_check']:
    for package in self.base.transaction.install_set:
        fail = False
        gpgres, gpgerr = self.base._sig_check_pkg(package)
        if gpgres == dnf.const.SGNKEY_GOOD:  # validated successfully
            continue
        elif gpgres == dnf.const.SGNKEY_UNDEFINED:  # validation failed, install cert?
            try:
                self.base._get_key_for_package(package)
            except dnf.exceptions.Error as e:
                fail = True
        else:  # fatal error
            fail = True
        if fail:
            msg = 'Failed to validate GPG signature for {0}'.format(package)
            self.module.fail_json(msg)"
-------------------------------------------------------------------------
"# Validate GPG. This is NOT done in dnf.Base (it's done in the
# upstream CLI subclass of dnf.Base)
if not self.disable_gpg_check:
    for package in self.base.transaction.install_set:
        fail = False
        gpgres, gpgerr = self.base._sig_check_pkg(package)
        if gpgres == 0:  # validated successfully
            continue
        elif gpgres == 1:  # validation failed, install cert?
            try:
                self.base._get_key_for_package(package)
            except dnf.exceptions.Error as e:
                fail = True
        else:  # fatal error
            fail = True
        if fail:
            msg = 'Failed to validate GPG signature for {0}'.format(package)
            self.module.fail_json(msg=msg)
"
-------------------------------------------------------------------------
"Recom
PRs: 71537, 71541"
-------------------------------------------------------------------------
=========================================================================
"# Validate GPG. This is NOT done in dnf.Base (it's done in the
# upstream CLI subclass of dnf.Base)
if not self.disable_gpg_check:
    for package in self.base.transaction.install_set:
        fail = False
        gpgres, gpgerr = self.base._sig_check_pkg(package)
        if gpgres == 0:  # validated successfully
            continue
        elif gpgres == 1:  # validation failed, install cert?
            try:
                self.base._get_key_for_package(package)
            except dnf.exceptions.Error as e:
                fail = True
        else:  # fatal error
            fail = True
        if fail:
            msg = 'Failed to validate GPG signature for {0}'.format(package)
            self.module.fail_json(msg)
"
-------------------------------------------------------------------------
"if not self.verify_gpg:
    for package in self.base.transaction.install_set:
        fail = False
        gpgres, gpgerr = self.base.verify_package_signature(package)
        if gpgres == 0:  # validated successfully
            continue
        elif gpgres == 1:  # validation failed, install cert?
            try:
                self.base.retrieve_key_for_package(package)
            except dnf.exceptions.Error as e:
                fail = True
        else:  # fatal error
            fail = True
        if fail:
            msg = 'Failed to validate GPG signature for {0}'.format(package)
            self.module.fail_json(msg)"
-------------------------------------------------------------------------
"# Validate GPG. This is NOT done in dnf.Base (it's done in the
# upstream CLI subclass of dnf.Base)
if not self.disable_gpg_check:
    for package in self.base.transaction.install_set:
        fail = False
        gpgres, gpgerr = self.base._sig_check_pkg(package)
        if gpgres == 0:  # validated successfully
            continue
        elif gpgres == 1:  # validation failed, install cert?
            try:
                self.base._get_key_for_package(package)
            except dnf.exceptions.Error as e:
                fail = True
        else:  # fatal error
            fail = True
        if fail:
            msg = 'Failed to validate GPG signature for {0}'.format(package)
            self.module.fail_json(msg=msg)
"
-------------------------------------------------------------------------
"Recom
PRs: 71537, 71540"
-------------------------------------------------------------------------
=========================================================================
"self._created_files = set()
    self._uses_common_file_args = True
"
-------------------------------------------------------------------------
"from __future__ import generators
import errno
import itertools
import os
import pytest
import ansible.module_utils
import json

class AnsibleModule(object):
    def __init__(self):
        self._options_context = list()
        self._tmpdir = None
        self._created_files = set()
        self._uses_common_file_args = True

        if add_file_common_args:
            for k, v in FILE_COMMON_ARGUMENTS.items():
                if k not in self.argument_spec:
                    self.argument_spec[k] = v"
-------------------------------------------------------------------------
"if mode is None:
    return changed
"
-------------------------------------------------------------------------
"Recom
PRs: 71260, 71514"
-------------------------------------------------------------------------
=========================================================================
"# Remove paths so we do not warn about creating with default permissions
# since we are calling this method on the path and setting the specified mode.
try:
    self._created_files.remove(path)
except KeyError:
    pass
"
-------------------------------------------------------------------------
"from ansible.module_utils.basic import AnsibleModule

try:
    self._created_files.remove(b_path)
except KeyError:
    pass"
-------------------------------------------------------------------------
"_DEFAULT_PERM = 0o0666       # default file permission bits
"
-------------------------------------------------------------------------
"Recom
PRs: 71260, 71514"
-------------------------------------------------------------------------
=========================================================================
"_DEFAULT_PERM = 0o0600       # default file permission bits
"
-------------------------------------------------------------------------
_DEFAULT_PERM_BITS = 0o0600       # default file permission bits
-------------------------------------------------------------------------
"stat1.st_mode = 0o0644
"
-------------------------------------------------------------------------
"Recom
PRs: 71260, 71514"
-------------------------------------------------------------------------
=========================================================================
"#!/usr/bin/python
# -*- coding: utf-8 -*-
# Copyright (c) 2020 Ansible Project
# GNU General Public License v3.0 (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
from __future__ import absolute_import, division, print_function
__metaclass__ = type
import tempfile
from ansible.module_utils.basic import AnsibleModule
def main():
    module = AnsibleModule(
        argument_spec={
            'dest': {'type': 'path'},
            'call_fs_attributes': {'type': 'bool', 'default': True},
        },
        add_file_common_args=True,
    )
    results = {}
    with tempfile.NamedTemporaryFile(delete=False) as tf:
        file_args = module.load_file_common_arguments(module.params)
        module.atomic_move(tf.name, module.params['dest'])
        if module.params['call_fs_attributes']:
            results['changed'] = module.set_fs_attributes_if_different(file_args, True)
    module.exit_json(**results)
if __name__ == '__main__':
    main()
"
-------------------------------------------------------------------------
"import errno
import itertools
import os
import json
from future import absolute_import, division, print_function

import ansible.module_utils as module_utils

__metaclass__ = type

def target_method():
    module = module_utils.basic.AnsibleModule(
        argument_spec={
            'dest': {'type': 'path'},
            'call_fs_attributes': {'type': 'bool', 'default': True},
        },
        add_file_common_args=True,
    )
    results = {}
    with tempfile.NamedTemporaryFile(delete=False) as tf:
        file_args = module.load_file_common_arguments(module.params)
        module.atomic_move(tf.name, module.params['dest'])
        if module.params['call_fs_attributes']:
            results['changed'] = module.set_fs_attributes_if_different(file_args, True)
    module.exit_json(**results)

if __name__ == '__main__':
    target_method()"
-------------------------------------------------------------------------
"assert atomic_mocks['chmod'].call_args_list == [mocker.call(b'/path/to/dest', basic.DEFAULT_PERM & ~18)]
"
-------------------------------------------------------------------------
"Recom
PRs: 71260, 71514"
-------------------------------------------------------------------------
=========================================================================
"stat1.st_mode = 0o0600
"
-------------------------------------------------------------------------
stat1.st_mode = 0o0600
-------------------------------------------------------------------------
"assert atomic_mocks['chmod'].call_args_list == [mocker.call(b'/path/to/src', basic.DEFAULT_PERM & ~18)]
"
-------------------------------------------------------------------------
"Recom
PRs: 71260, 71514"
-------------------------------------------------------------------------
=========================================================================
"assert atomic_mocks['chmod'].call_args_list == [mocker.call(b'/path/to/dest', basic.DEFAULT_PERM & ~0o022)]
"
-------------------------------------------------------------------------
"assert atomic_mocks['chmod'].call_args_list == [mocker.call(b'/path/to/dest', module_utils.basic.DEFAULT_PERM & ~0o022)]"
-------------------------------------------------------------------------
"assert atomic_mocks['chmod'].call_args_list == [mocker.call(b'/path/to/src', basic.DEFAULT_PERM & ~18)]
"
-------------------------------------------------------------------------
"Recom
PRs: 71260, 71514"
-------------------------------------------------------------------------
=========================================================================
"assert atomic_mocks['chmod'].call_args_list == [mocker.call(b'/path/to/src', basic.DEFAULT_PERM & ~0o022)]
"
-------------------------------------------------------------------------
"assert atomic_mocks['chmod'].call_args_list == [mocker.call(b'/path/to/src', ansible.module_utils.basic.DEFAULT_PERM & ~0o022)]"
-------------------------------------------------------------------------
"# assert atomic_mocks['chmod'].call_args_list == [mocker.call(b'/path/to/src', basic.DEFAULT_PERM & ~18)]
"
-------------------------------------------------------------------------
"Recom
PRs: 71260, 71514"
-------------------------------------------------------------------------
=========================================================================
"assert atomic_mocks['chmod'].call_args_list == [mocker.call(b'/path/to/src', basic.DEFAULT_PERM & ~0o022)]
"
-------------------------------------------------------------------------
"assert atomic_am.chmod.call_args_list == [mocker.call(b'/path/to/src', ansible.module_utils.basic.DEFAULT_PERM & ~0o022)]"
-------------------------------------------------------------------------
"assert atomic_mocks['chmod'].call_args_list == [mocker.call(b'/path/to/dest', basic.DEFAULT_PERM & ~18)]
"
-------------------------------------------------------------------------
"Recom
PRs: 71260, 71514"
-------------------------------------------------------------------------
=========================================================================
"- module: ansible.builtin.blockinfile
- module: ansible.builtin.copy
- module: ansible.builtin.file
- module: ansible.builtin.replace
- module: ansible.builtin.template
- module: ansible.windows.win_lineinfile
"
-------------------------------------------------------------------------
"from ansible.plugins.lookup import LookupBase
from ansible.errors import AnsibleFileNotFound
from ansible.module_utils._text import to_bytes, to_text
import os
import glob
from __future__ import absolute_import, print_function, division

class LookupModule(LookupBase):
    def run(self, terms, variables=None, **kwargs):
        found_paths = []
        ret = []
        for term in terms:
            term = to_text(term, errors='surrogate_or_strict')
            for basedir in self.get_basedir(variables):
                for path in glob.glob(os.path.join(basedir, term)):
                    found_paths.append(path)
        ret.extend(found_paths)
        return ret"
-------------------------------------------------------------------------
"- module: ansible.builtin.blockinfile
- module: ansible.builtin.copy
- module: ansible.builtin.file
- module: ansible.builtin.replace
- module: ansible.builtin.template
- module: community.windows.win_lineinfile
"
-------------------------------------------------------------------------
"Recom
PRs: 70530, 71380"
-------------------------------------------------------------------------
=========================================================================
"- module: ansible.builtin.copy
- module: ansible.windows.win_copy
- module: ansible.windows.win_template
"
-------------------------------------------------------------------------
"- module: copy
  options:
    type: str
    version_added: '2.0'
    seealso:
      - ansible.plugins.lookup.LookupBase
      - ansible.errors.AnsibleFileNotFound
      - os
      - glob
      - ansible.module_utils._text.to_text
      - ansible.module_utils._text.to_bytes
    author:
      - Stephen Fromm (@sfromm)

- module: win_copy
  options:
    type: str
    version_added: '2.0'
    seealso:
      - ansible.plugins.lookup.LookupBase
      - ansible.errors.AnsibleFileNotFound
      - os
      - glob
      - ansible.module_utils._text.to_text
      - ansible.module_utils._text.to_bytes
    author:
      - Stephen Fromm (@sfromm)

- module: win_template
  options:
    type: str
    version_added: '2.0'
    seealso:
      - ansible.plugins.lookup.LookupBase
      - ansible.errors.AnsibleFileNotFound
      - os
      - glob
      - ansible.module_utils._text.to_text
      - ansible.module_utils._text.to_bytes
    author:
      - Stephen Fromm (@sfromm)"
-------------------------------------------------------------------------
"- For Windows you can use M(ansible.windows.win_template) which uses '\\r\\n' as C(newline_sequence) by default.
- module: ansible.builtin.copy
- module: ansible.windows.win_copy
- module: ansible.windows.win_template
"
-------------------------------------------------------------------------
"Recom
PRs: 70530, 71380"
-------------------------------------------------------------------------
=========================================================================
"- module: ansible.builtin.authorized_key
- module: ansible.builtin.group
- module: ansible.windows.win_user
"
-------------------------------------------------------------------------
"from ansible.plugins.lookup import LookupBase
from ansible.errors import AnsibleFileNotFound
import os
import glob
from ansible.module_utils._text import to_bytes, to_text

# Adapted code 
from ansible.plugins.lookup import LookupBase
from ansible.errors import AnsibleFileNotFound
import os
import glob
from ansible.module_utils._text import to_bytes, to_text
from ansible.module_utils._text import to_bytes, to_text

# You may add functionality specific to the adapted target method here"
-------------------------------------------------------------------------
"- module: ansible.posix.authorized_key
- module: ansible.builtin.group
- module: ansible.windows.win_user
"
-------------------------------------------------------------------------
"Recom
PRs: 70530, 71380"
-------------------------------------------------------------------------
=========================================================================
"- module: ansible.builtin.wait_for
- module: ansible.windows.win_wait_for
- module: ansible.windows.win_wait_for_process
"
-------------------------------------------------------------------------
"- module: ansible.builtin.wait_for
- module: ansible.windows.win_wait_for
- module: ansible.windows.win_wait_for_process"
-------------------------------------------------------------------------
"- module: ansible.builtin.wait_for
- module: ansible.windows.win_wait_for
- module: community.windows.win_wait_for_process
"
-------------------------------------------------------------------------
"Recom
PRs: 70530, 71380"
-------------------------------------------------------------------------
=========================================================================
"- If you wish to update an existing repository definition use M(ansible.builtin.ini_file) instead.
"
-------------------------------------------------------------------------
"if options:
        msg = ""If you wish to update an existing repository definition use ansible.builtin.ini_file instead."""
-------------------------------------------------------------------------
"- If you wish to update an existing repository definition use M(community.general.ini_file) instead.
"
-------------------------------------------------------------------------
"Recom
PRs: 70530, 71380"
-------------------------------------------------------------------------
=========================================================================
"from ansible.module_utils.common.collections import is_sequence, Mapping
def _fail_on_undefined(data):
    """"""Recursively find an undefined value in a nested data structure
    and properly raise the undefined exception.
    """"""
    if isinstance(data, Mapping):
        for value in data.values():
            _fail_on_undefined(value)
    elif is_sequence(data):
        for item in data:
            _fail_on_undefined(item)
    else:
        if isinstance(data, StrictUndefined):
            # To actually raise the undefined exception we need to
            # access the undefined object otherwise the exception would
            # be raised on the next access which might not be properly
            # handled.
            # See https://github.com/ansible/ansible/issues/52158
            # and StrictUndefined implementation in upstream Jinja2.
            str(data)
    return data
    https://github.com/pallets/jinja/blob/master/src/jinja2/nativetypes.py
    """"""
        out = _fail_on_undefined(head[0])
        out = u''.join([to_text(_fail_on_undefined(v)) for v in nodes])
"
-------------------------------------------------------------------------
"def _fail_on_undefined(data):
    """"""Recursively find an undefined value in a nested data structure
    and properly raise the undefined exception.
    """"""
    if isinstance(data, Mapping):
        for value in data.values():
            _fail_on_undefined(value)
    elif is_sequence(data):
        for item in data:
            _fail_on_undefined(item)
    else:
        if isinstance(data, StrictUndefined):
            # A hack to raise proper UndefinedError/AnsibleUndefinedVariable exception.
            # We need to access the AnsibleUndefined(StrictUndefined) object by either of the following:
            # __iter__, __str__, __len__, __nonzero__, __eq__, __ne__, __bool__, __hash__
            # to actually raise the exception.
            # (see Jinja2 source of StrictUndefined to get up to date info)
            # Otherwise the undefined error would be raised on the next access which might not be properly handled.
            # See https://github.com/ansible/ansible/issues/52158
            # We do that only here because it is taken care of by to_text() in the else block below already.
            str(data)
    return data"
-------------------------------------------------------------------------
"from ansible.module_utils.common.collections import is_sequence, Mapping
"
-------------------------------------------------------------------------
"Recom
PRs: 68432, 71105"
-------------------------------------------------------------------------
=========================================================================
"# Instantiate our ResultsCollector for handling results as
# they come in. Ansible expects this to be one of its main
# display outlets.
callback = ResultsCollector()
# Instantiate task queue manager, which takes care of forking
# and setting up all objects to iterate over host list and tasks.
# IMPORTANT: This also adds library dirs paths to the module loader
# IMPORTANT: and so it must be initialized before calling `Play.load()`.
tqm = TaskQueueManager(
    inventory=inventory,
    variable_manager=variable_manager,
    loader=loader,
    passwords=passwords,
    stdout_callback=callback,
)
"
-------------------------------------------------------------------------
"# Instantiate our ResultsCollector for handling results as
# they come in. Ansible expects this to be one of its main
# display outlets.
results_collector = ResultsCollector()
# Instantiate task queue manager, which takes care of forking
# and setting up all objects to iterate over host list and tasks.
# IMPORTANT: This also adds library dirs paths to the module loader
# IMPORTANT: and so it must be initialized before calling `Play.load()`.
task_queue_manager = TaskQueueManager(
    inventory=inventory,
    variable_manager=variable_manager,
    loader=loader,
    passwords=passwords,
    stdout_callback=results_collector,
)"
-------------------------------------------------------------------------
"loader = DataLoader()  # Takes care of finding and reading yaml, json and ini files
passwords = dict(vault_pass='secret')
# Instantiate our ResultsCollectorJSONCallback for handling results as they come in. Ansible expects this to be one of its main display outlets
results_callback = ResultsCollectorJSONCallback()
# create inventory, use path to host config file as source or hosts in a comma separated string
# variable manager takes care of merging all the different sources to give you a unified view of variables available in each context
# instantiate task queue manager, which takes care of forking and setting up all objects to iterate over host list and tasks
"
-------------------------------------------------------------------------
"Recom
PRs: 70842, 70851"
-------------------------------------------------------------------------
=========================================================================
"# Instantiate our ResultsCollector for handling results as
# they come in. Ansible expects this to be one of its main
# display outlets.
callback = ResultsCollector()
# Instantiate task queue manager, which takes care of forking
# and setting up all objects to iterate over host list and tasks.
# IMPORTANT: This also adds library dirs paths to the module loader
# IMPORTANT: and so it must be initialized before calling `Play.load()`.
tqm = TaskQueueManager(
    inventory=inventory,
    variable_manager=variable_manager,
    loader=loader,
    passwords=passwords,
    stdout_callback=callback,
)
"
-------------------------------------------------------------------------
"callback = ResultsCollector()

    tqm = TaskQueueManager(
        inventory=inventory,
        variable_manager=variable_manager,
        loader=loader,
        passwords=passwords,
        stdout_callback=callback
    )"
-------------------------------------------------------------------------
"loader = DataLoader()  # Takes care of finding and reading yaml, json and ini files
passwords = dict(vault_pass='secret')
# Instantiate our ResultsCollectorJSONCallback for handling results as they come in. Ansible expects this to be one of its main display outlets
results_callback = ResultsCollectorJSONCallback()
# create inventory, use path to host config file as source or hosts in a comma separated string
# variable manager takes care of merging all the different sources to give you a unified view of variables available in each context
# instantiate task queue manager, which takes care of forking and setting up all objects to iterate over host list and tasks
"
-------------------------------------------------------------------------
"Recom
PRs: 70445, 70850"
-------------------------------------------------------------------------
=========================================================================
"# `distutils` must be imported after `setuptools` or it will cause explosions
# with `setuptools >=48.0.0, <49.1`.
# Refs:
# * https://github.com/ansible/ansible/issues/70456
# * https://github.com/pypa/setuptools/issues/2230
# * https://github.com/pypa/setuptools/commit/bd110264
from distutils.command.build_scripts import build_scripts as BuildScripts
from distutils.command.sdist import sdist as SDist
"
-------------------------------------------------------------------------
"# `distutils` must be imported after `setuptools` or it will cause explosions
# with `setuptools >=48.0.0, <49.1`.
# Refs:
# * https://github.com/ansible/ansible/issues/70456
# * https://github.com/pypa/setuptools/issues/2230
# * https://github.com/pypa/setuptools/commit/bd110264
from setuptools.command.build_scripts import build_scripts as BuildScripts
from setuptools.command.sdist import sdist as SDist"
-------------------------------------------------------------------------
"# `distutils` must be imported after `setuptools` or it will cause explosions
# with `setuptools >=48.0.0, <49.1`.
# Refs:
# * https://github.com/ansible/ansible/issues/70456
# * https://github.com/pypa/setuptools/issues/2230
# * https://github.com/pypa/setuptools/commit/bd110264
from distutils.command.build_scripts import build_scripts as BuildScripts
from distutils.command.sdist import sdist as SDist
def find_package_info(*file_paths):
    try:
        with open(os.path.join(*file_paths), 'r') as f:
            info_file = f.read()
    except Exception:
        raise RuntimeError(""Unable to find package info."")
    # The version line must have the form
    # __version__ = 'ver'
    version_match = re.search(r""^__version__ = ['\""]([^'\""]*)['\""]"",
                              info_file, re.M)
    author_match = re.search(r""^__author__ = ['\""]([^'\""]*)['\""]"",
                             info_file, re.M)
    if version_match and author_match:
        return version_match.group(1), author_match.group(1)
    raise RuntimeError(""Unable to find package info."")
def _validate_install_ansible_base():
    """"""Validate that we can install ansible-base. Currently this only
    cares about upgrading to ansible-base from ansible<2.10
    """"""
    if os.getenv('ANSIBLE_SKIP_CONFLICT_CHECK', '') not in ('', '0'):
        return
    # Save these for later restoring things to pre invocation
    sys_modules = sys.modules.copy()
    sys_modules_keys = set(sys_modules)
    # Make sure `lib` isn't in `sys.path` that could confuse this
    sys_path = sys.path[:]
    abspath = os.path.abspath
    sys.path[:] = [p for p in sys.path if abspath(p) != abspath('lib')]
    try:
        from ansible.release import __version__
    except ImportError:
        pass
    else:
        version_tuple = tuple(int(v) for v in __version__.split('.')[:2])
        if version_tuple < (2, 10):
            stars = '*' * 76
            raise RuntimeError(
                '''
    %s
    Cannot install ansible-base with a pre-existing ansible==%s
    installation.
    Installing ansible-base with ansible-2.9 or older currently installed with
    pip is known to cause problems. Please uninstall ansible and install the new
    version:
        pip uninstall ansible
        pip install ansible-base
    If you want to skip the conflict checks and manually resolve any issues
    afterwards, set the ANSIBLE_SKIP_CONFLICT_CHECK environment variable:
        ANSIBLE_SKIP_CONFLICT_CHECK=1 pip install ansible-base
    %s
                ''' % (stars, __version__, stars)
            )
    finally:
        sys.path[:] = sys_path
        for key in sys_modules_keys.symmetric_difference(sys.modules):
            sys.modules.pop(key, None)
        sys.modules.update(sys_modules)
_validate_install_ansible_base()
"
-------------------------------------------------------------------------
"Recom
PRs: 70525, 70760"
-------------------------------------------------------------------------
=========================================================================
"from ansible.module_utils.common.text.converters import container_to_text, to_native
from ansible.module_utils.six import string_types, PY2
"
-------------------------------------------------------------------------
"from ansible.module_utils.common.text.converters import container_to_text
from ansible.module_utils.six import string_types"
-------------------------------------------------------------------------
"from ansible.module_utils._text import to_native
from ansible.module_utils.common.text.converters import container_to_text
from ansible.module_utils.six import string_types, PY2
"
-------------------------------------------------------------------------
"Recom
PRs: 68576, 69626"
-------------------------------------------------------------------------
=========================================================================
"def get_fingerprint(path, passphrase=None, content=None, backend='pyopenssl'):
    privatekey = load_privatekey(path, passphrase=passphrase, content=content, check_passphrase=False, backend=backend)
    if backend == 'pyopenssl':
            publickey = crypto.dump_publickey(crypto.FILETYPE_ASN1, privatekey)
            # If PyOpenSSL < 16.0 crypto.dump_publickey() will fail.
            try:
                bio = crypto._new_mem_buf()
                rc = crypto._lib.i2d_PUBKEY_bio(bio, privatekey._pkey)
                if rc != 1:
                    crypto._raise_current_error()
                publickey = crypto._bio_to_string(bio)
            except AttributeError:
                # By doing this we prevent the code from raising an error
                # yet we return no value in the fingerprint hash.
                return None
    elif backend == 'cryptography':
        publickey = privatekey.public_key().public_bytes(
            serialization.Encoding.DER,
            serialization.PublicFormat.SubjectPublicKeyInfo
        )
"
-------------------------------------------------------------------------
"def get_fingerprint(path, passphrase=None, content=None, backend='pyopenssl'):
    privatekey = crypto_utils.load_privatekey(path, passphrase=passphrase, content=content, check_passphrase=False, backend=backend)
    if backend == 'pyopenssl':
        publickey = crypto.dump_publickey(crypto.FILETYPE_ASN1, privatekey)
        # If PyOpenSSL < 16.0 crypto.dump_publickey() will fail.
        try:
            bio = crypto._new_mem_buf()
            rc = crypto._lib.i2d_PUBKEY_bio(bio, privatekey._pkey)
            if rc != 1:
                crypto._raise_current_error()
            publickey = crypto._bio_to_string(bio)
        except AttributeError:
            # By doing this we prevent the code from raising an error
            # yet we return no value in the fingerprint hash.
            return None
    elif backend == 'cryptography':
        publickey = privatekey.public_key().public_bytes(
            crypto_serialization.Encoding.DER,
            crypto_serialization.PublicFormat.SubjectPublicKeyInfo
        )"
-------------------------------------------------------------------------
"def get_fingerprint(path, passphrase=None, backend='pyopenssl'):
    privatekey = load_privatekey(path, passphrase, check_passphrase=False, backend=backend)
    if backend == 'pyopenssl':
            publickey = crypto.dump_publickey(crypto.FILETYPE_ASN1, privatekey)
            # If PyOpenSSL < 16.0 crypto.dump_publickey() will fail.
            try:
                bio = crypto._new_mem_buf()
                rc = crypto._lib.i2d_PUBKEY_bio(bio, privatekey._pkey)
                if rc != 1:
                    crypto._raise_current_error()
                publickey = crypto._bio_to_string(bio)
            except AttributeError:
                # By doing this we prevent the code from raising an error
                # yet we return no value in the fingerprint hash.
                return None
    elif backend == 'cryptography':
        publickey = privatekey.public_key().public_bytes(
            serialization.Encoding.DER,
            serialization.PublicFormat.SubjectPublicKeyInfo
        )
"
-------------------------------------------------------------------------
"Recom
PRs: 67036, 67039"
-------------------------------------------------------------------------
=========================================================================
"'CREATE ROLE', 'DROP ROLE', 'APPLICATION_PASSWORD_ADMIN',
'AUDIT_ADMIN', 'BACKUP_ADMIN', 'BINLOG_ADMIN',
'BINLOG_ENCRYPTION_ADMIN', 'CLONE_ADMIN', 'CONNECTION_ADMIN',
'ENCRYPTION_KEY_ADMIN', 'FIREWALL_ADMIN', 'FIREWALL_USER',
'GROUP_REPLICATION_ADMIN', 'INNODB_REDO_LOG_ARCHIVE',
'NDB_STORED_USER', 'PERSIST_RO_VARIABLES_ADMIN',
'REPLICATION_APPLIER', 'REPLICATION_SLAVE_ADMIN',
'RESOURCE_GROUP_ADMIN', 'RESOURCE_GROUP_USER',
'ROLE_ADMIN', 'SESSION_VARIABLES_ADMIN', 'SET_USER_ID',
'SYSTEM_USER', 'SYSTEM_VARIABLES_ADMIN', 'SYSTEM_USER',
'TABLE_ENCRYPTION_ADMIN', 'VERSION_TOKEN_ADMIN',
'XA_RECOVER_ADMIN', 'LOAD FROM S3', 'SELECT INTO S3'))
"
-------------------------------------------------------------------------
"current_toplevel = privileges[:idx]
        removed_privs = [priv for priv in current_toplevel if (priv in [
            'CREATE ROLE', 'DROP ROLE', 'APPLICATION_PASSWORD_ADMIN',
            'AUDIT_ADMIN', 'BACKUP_ADMIN', 'BINLOG_ADMIN',
            'BINLOG_ENCRYPTION_ADMIN', 'CLONE_ADMIN', 'CONNECTION_ADMIN',
            'ENCRYPTION_KEY_ADMIN', 'FIREWALL_ADMIN', 'FIREWALL_USER',
            'GROUP_REPLICATION_ADMIN', 'INNODB_REDO_LOG_ARCHIVE',
            'NDB_STORED_USER', 'PERSIST_RO_VARIABLES_ADMIN',
            'REPLICATION_APPLIER', 'REPLICATION_SLAVE_ADMIN',
            'RESOURCE_GROUP_ADMIN', 'RESOURCE_GROUP_USER',
            'ROLE_ADMIN', 'SESSION_VARIABLES_ADMIN', 'SET_USER_ID',
            'SYSTEM_USER', 'SYSTEM_VARIABLES_ADMIN', 'SYSTEM_USER',
            'TABLE_ENCRYPTION_ADMIN', 'VERSION_TOKEN_ADMIN',
            'XA_RECOVER_ADMIN', 'LOAD FROM S3', 'SELECT INTO S3'
            ])]"
-------------------------------------------------------------------------
"'CREATE ROLE', 'DROP ROLE', 'APPLICATION_PASSWORD_ADMIN',
'AUDIT_ADMIN', 'BACKUP_ADMIN', 'BINLOG_ADMIN',
'BINLOG_ENCRYPTION_ADMIN', 'CONNECTION_ADMIN',
'ENCRYPTION_KEY_ADMIN', 'FIREWALL_ADMIN', 'FIREWALL_USER',
'GROUP_REPLICATION_ADMIN', 'PERSIST_RO_VARIABLES_ADMIN',
'REPLICATION_SLAVE_ADMIN', 'RESOURCE_GROUP_ADMIN', 'RESOURCE_GROUP_USER',
'ROLE_ADMIN', 'SESSION_VARIABLES_ADMIN', 'SET_USER_ID',
'SYSTEM_VARIABLES_ADMIN', 'VERSION_TOKEN_ADMIN', 'XA_RECOVER_ADMIN'))
"
-------------------------------------------------------------------------
"Recom
PRs: 66995, 66999"
-------------------------------------------------------------------------
=========================================================================
"if not container.exists or container.removing:
    if container.removing:
        self.log('Found container in removal phase')
    else:
        self.log('No container found')
    if container.removing:
        # Wait for container to be removed before trying to create it
        self.wait_for_state(container.Id, wait_states=['removing'], accept_removal=True)
"
-------------------------------------------------------------------------
"if not client.exists or client.removing:
    if client.removing:
        self.log('Found container in removal phase')
    else:
        self.log('No container found')
    if client.removing:
        self.wait_for_state(client.container.Id, wait_states=['removing'], accept_removal=True)"
-------------------------------------------------------------------------
"if not container.exists or container.removing:
    if container.removing:
        self.log('Found container in removal phase')
    else:
        self.log('No container found')
    if container.removing and not self.check_mode:
        # Wait for container to be removed before trying to create it
        self.wait_for_state(container.Id, wait_states=['removing'], accept_removal=True)
"
-------------------------------------------------------------------------
"Recom
PRs: 65854, 66118"
-------------------------------------------------------------------------
=========================================================================
"self.wait_for_state(container.Id, wait_states=['removing'], accept_removal=True)
"
-------------------------------------------------------------------------
"self.wait_for_state(container.id, wait_states=['removing'], accept_removal=True)"
-------------------------------------------------------------------------
"if not self.check_mode:
    self.wait_for_state(container.Id, wait_states=['removing'], accept_removal=True)
"
-------------------------------------------------------------------------
"Recom
PRs: 65854, 66118"
-------------------------------------------------------------------------
=========================================================================
"if not container.exists or container.removing:
    if container.removing:
        self.log('Found container in removal phase')
    else:
        self.log('No container found')
    if container.removing:
        # Wait for container to be removed before trying to create it
        self.wait_for_state(container.Id, wait_states=['removing'], accept_removal=True)
"
-------------------------------------------------------------------------
"if not client.exists(container) or client.removing(container):
    if client.removing(container):
        self.log('Found container in removal phase')
    else:
        self.log('No container found')
    if client.removing(container):
        # Wait for container to be removed before trying to create it
        client.wait_for_state(container.Id, wait_states=['removing'], accept_removal=True)"
-------------------------------------------------------------------------
"if not container.exists or container.removing:
    if container.removing:
        self.log('Found container in removal phase')
    else:
        self.log('No container found')
    if container.removing and not self.check_mode:
        # Wait for container to be removed before trying to create it
        self.wait_for_state(container.Id, wait_states=['removing'], accept_removal=True)
"
-------------------------------------------------------------------------
"Recom
PRs: 65854, 66117"
-------------------------------------------------------------------------
=========================================================================
"self.wait_for_state(container.Id, wait_states=['removing'], accept_removal=True)
"
-------------------------------------------------------------------------
"self.wait_for_state(container.Id, wait_states=[AnsibleDockerClientContainer.stable_states['running']], accept_removal=True)"
-------------------------------------------------------------------------
"if not self.check_mode:
    self.wait_for_state(container.Id, wait_states=['removing'], accept_removal=True)
"
-------------------------------------------------------------------------
"Recom
PRs: 65854, 66117"
-------------------------------------------------------------------------
=========================================================================
"@property
    if self._yum_base:
        return self._yum_base
    else:
        # Only init once
        self._yum_base = yum.YumBase()
        self._yum_base.preconf.debuglevel = 0
        self._yum_base.preconf.errorlevel = 0
        self._yum_base.preconf.plugins = True
        self._yum_base.preconf.enabled_plugins = self.enable_plugin
        self._yum_base.preconf.disabled_plugins = self.disable_plugin
        if self.releasever:
            self._yum_base.preconf.releasever = self.releasever
        if self.installroot != '/':
            # do not setup installroot by default, because of error
            # CRITICAL:yum.cli:Config Error: Error accessing file for config file:////etc/yum.conf
            # in old yum version (like in CentOS 6.6)
            self._yum_base.preconf.root = self.installroot
            self._yum_base.conf.installroot = self.installroot
        if self.conf_file and os.path.exists(self.conf_file):
            self._yum_base.preconf.fn = self.conf_file
        if os.geteuid() != 0:
            if hasattr(self._yum_base, 'setCacheDir'):
                self._yum_base.setCacheDir()
            else:
                cachedir = yum.misc.getCacheDir()
                self._yum_base.repos.setCacheDir(cachedir)
                self._yum_base.conf.cache = 0
        if self.disable_excludes:
            self._yum_base.conf.disable_excludes = self.disable_excludes
        # A sideeffect of accessing conf is that the configuration is
        # loaded and plugins are discovered
        self.yum_base.conf
        try:
            self._enablerepos_with_error_checking(self._yum_base)
            for rid in self.disablerepo:
                self.yum_base.repos.disableRepo(rid)
        except Exception as e:
            self.module.fail_json(msg=""Failure talking to yum: %s"" % to_native(e))
    return self._yum_base
"
-------------------------------------------------------------------------
"@property
    def yum_base(self):
        if self._yum_base:
            return self._yum_base
        else:
            # Only init once
            self._yum_base = yum.YumBase()
            self._yum_base.preconf.debuglevel = 0
            self._yum_base.preconf.errorlevel = 0
            self._yum_base.preconf.plugins = True
            self._yum_base.preconf.enabled_plugins = self.enable_plugin
            self._yum_base.preconf.disabled_plugins = self.disable_plugin
            if self.releasever:
                self._yum_base.preconf.releasever = self.releasever
            if self.installroot != '/':
                # do not setup installroot by default, because of error
                # CRITICAL:yum.cli:Config Error: Error accessing file for config file:////etc/yum.conf
                # in old yum version (like in CentOS 6.6)
                self._yum_base.preconf.root = self.installroot
                self._yum_base.conf.installroot = self.installroot
            if self.conf_file and os.path.exists(self.conf_file):
                self._yum_base.preconf.fn = self.conf_file
            if os.geteuid() != 0:
                if hasattr(self._yum_base, 'setCacheDir'):
                    self._yum_base.setCacheDir()
                else:
                    cachedir = yum.misc.getCacheDir()
                    self._yum_base.repos.setCacheDir(cachedir)
                    self._yum_base.conf.cache = 0
            if self.disable_excludes:
                self._yum_base.conf.disable_excludes = self.disable_excludes
            # A sideeffect of accessing conf is that the configuration is
            # loaded and plugins are discovered
            self._yum_base.conf
            try:
                self._enablerepos_with_error_checking(self._yum_base)
                for rid in self.disablerepo:
                    self._yum_base.repos.disableRepo(rid)
            except Exception as e:
                self.module.fail_json(msg=""Failure talking to yum: %s"" % to_native(e))
        return self._yum_base"
-------------------------------------------------------------------------
"self._yum_base = None
"
-------------------------------------------------------------------------
"Recom
PRs: 63713, 65575"
-------------------------------------------------------------------------
=========================================================================
"groups_list = self.yum_base.doGroupLists(return_evgrps=True)
groups_list = self.yum_base.doGroupLists()
"
-------------------------------------------------------------------------
"groups_list = my.doGroupLists(return_evgrps=True)
        groups_list = my.doGroupLists()"
-------------------------------------------------------------------------
"def _enablerepos_with_error_checking(self, yumbase):
    # NOTE: This seems unintuitive, but it mirrors yum's CLI bahavior
    if len(self.enablerepo) == 1:
        try:
            yumbase.repos.enableRepo(self.enablerepo[0])
        except yum.Errors.YumBaseError as e:
            if u'repository not found' in to_text(e):
                self.module.fail_json(msg=""Repository %s not found."" % self.enablerepo[0])
            else:
                raise e
    else:
        for rid in self.enablerepo:
            try:
                yumbase.repos.enableRepo(rid)
            except yum.Errors.YumBaseError as e:
                if u'repository not found' in to_text(e):
                    self.module.warn(""Repository %s not found."" % rid)
                else:
                    raise e
@property
    if self._yum_base:
        return self._yum_base
    else:
        # Only init once
        self._yum_base = yum.YumBase()
        self._yum_base.preconf.debuglevel = 0
        self._yum_base.preconf.errorlevel = 0
        self._yum_base.preconf.plugins = True
        self._yum_base.preconf.enabled_plugins = self.enable_plugin
        self._yum_base.preconf.disabled_plugins = self.disable_plugin
        if self.releasever:
            self._yum_base.preconf.releasever = self.releasever
        if self.installroot != '/':
            # do not setup installroot by default, because of error
            # CRITICAL:yum.cli:Config Error: Error accessing file for config file:////etc/yum.conf
            # in old yum version (like in CentOS 6.6)
            self._yum_base.preconf.root = self.installroot
            self._yum_base.conf.installroot = self.installroot
        if self.conf_file and os.path.exists(self.conf_file):
            self._yum_base.preconf.fn = self.conf_file
        if os.geteuid() != 0:
            if hasattr(self._yum_base, 'setCacheDir'):
                self._yum_base.setCacheDir()
            else:
                cachedir = yum.misc.getCacheDir()
                self._yum_base.repos.setCacheDir(cachedir)
                self._yum_base.conf.cache = 0
        if self.disable_excludes:
            self._yum_base.conf.disable_excludes = self.disable_excludes
        # A sideeffect of accessing conf is that the configuration is
        # loaded and plugins are discovered
        self.yum_base.conf
        try:
            self._enablerepos_with_error_checking(self._yum_base)
            for rid in self.disablerepo:
                self.yum_base.repos.disableRepo(rid)
        except Exception as e:
            self.module.fail_json(msg=""Failure talking to yum: %s"" % to_native(e))
    return self._yum_base
"
-------------------------------------------------------------------------
"Recom
PRs: 63713, 65575"
-------------------------------------------------------------------------
=========================================================================
"e, m, _ = self.yum_base.rpmdb.matchPackageNames([pkgspec])
    pkgs.extend(self.yum_base.returnInstalledPackagesByDep(pkgspec))
"
-------------------------------------------------------------------------
"packages, matched, unresolved = my.transaction_member(pkgspec) if isinstance(pkgspec, str) else my.transaction_member(*pkgspec)
        pkgs.extend(my.return_installed_packages_by_dep(matched))"
-------------------------------------------------------------------------
"groups_list = self.yum_base.doGroupLists(return_evgrps=True)
groups_list = self.yum_base.doGroupLists()
"
-------------------------------------------------------------------------
"Recom
PRs: 63713, 65575"
-------------------------------------------------------------------------
=========================================================================
"e, m, _ = self.yum_base.pkgSack.matchPackageNames([pkgspec])
    pkgs.extend(self.yum_base.returnPackagesByDep(pkgspec))
"
-------------------------------------------------------------------------
"e, m, _ = self.yum_base.packageSack.matchPackageNames([package_spec])
pkgs.extend(self.yum_base.returnPackagesByDep(package_spec))"
-------------------------------------------------------------------------
"e, m, _ = self.yum_base.rpmdb.matchPackageNames([pkgspec])
    pkgs.extend(self.yum_base.returnInstalledPackagesByDep(pkgspec))
"
-------------------------------------------------------------------------
"Recom
PRs: 63713, 65575"
-------------------------------------------------------------------------
=========================================================================
"pkgs = self.yum_base.returnPackagesByDep(pkgspec)  \
    self.yum_base.returnInstalledPackagesByDep(pkgspec)
    e, m, _ = self.yum_base.pkgSack.matchPackageNames([pkgspec])
updates = self.yum_base.doPackageLists(pkgnarrow='updates').updates
"
-------------------------------------------------------------------------
"pkgs = []
try:
    pkgs = yum_base.returnPackagesByDep(pkgspec)
    pkgs += yum_base.returnInstalledPackagesByDep(pkgspec)
    e, m, _ = yum_base.pkgSack.matchPackageNames([pkgspec])
    updates = yum_base.doPackageLists(pkgnarrow='updates').updates
except Exception as e:
    self.module.fail_json(msg=""Failure talking to yum: %s"" % to_native(e))"
-------------------------------------------------------------------------
"e, m, _ = self.yum_base.pkgSack.matchPackageNames([pkgspec])
    pkgs.extend(self.yum_base.returnPackagesByDep(pkgspec))
"
-------------------------------------------------------------------------
"Recom
PRs: 63713, 65575"
-------------------------------------------------------------------------
=========================================================================
"pkgs = self.yum_base.returnPackagesByDep(req_spec)  \
    self.yum_base.returnInstalledPackagesByDep(req_spec)
"
-------------------------------------------------------------------------
"pkgs = self.base.returnPackagesByDep(req_spec)  \
    self.base.returnInstalledPackagesByDep(req_spec)"
-------------------------------------------------------------------------
"pkgs = self.yum_base.returnPackagesByDep(pkgspec)  \
    self.yum_base.returnInstalledPackagesByDep(pkgspec)
    e, m, _ = self.yum_base.pkgSack.matchPackageNames([pkgspec])
updates = self.yum_base.doPackageLists(pkgnarrow='updates').updates
"
-------------------------------------------------------------------------
"Recom
PRs: 63713, 65575"
-------------------------------------------------------------------------
=========================================================================
"pkgs = self.yum_base.returnPackagesByDep(req_spec)  \
    self.yum_base.returnInstalledPackagesByDep(req_spec)
, _ = self.yum_base.pkgSack.matchPackageNames([req_spec])
, _ = self.yum_base.rpmdb.matchPackageNames([req_spec])
"
-------------------------------------------------------------------------
"pkgs = self.base.returnPackagesByDep(req_spec)
_, _ = self.base.pkgSack.matchPackageNames([req_spec])
_, _ = self.base.rpmdb.matchPackageNames([req_spec])"
-------------------------------------------------------------------------
"pkgs = self.yum_base.returnPackagesByDep(req_spec)  \
    self.yum_base.returnInstalledPackagesByDep(req_spec)
"
-------------------------------------------------------------------------
"Recom
PRs: 63713, 65575"
-------------------------------------------------------------------------
=========================================================================
"if self.yum_base.conf.proxy and self.yum_base.conf.proxy not in (""_none_"",):
    if self.yum_base.conf.proxy_username:
        namepass = namepass  self.yum_base.conf.proxy_username
        proxy_url = self.yum_base.conf.proxy
        if self.yum_base.conf.proxy_password:
            namepass = namepass  "":""  self.yum_base.conf.proxy_password
    elif '@' in self.yum_base.conf.proxy:
        namepass = self.yum_base.conf.proxy.split('@')[0].split('//')[-1]
        proxy_url = self.yum_base.conf.proxy.replace(""{0}@"".format(namepass), """")
"
-------------------------------------------------------------------------
"if self.yum_base.conf.proxy and self.yum_base.conf.proxy not in (""_none_"",):
    if self.yum_base.conf.proxy_username:
        user_pass = user_pass + self.yum_base.conf.proxy_username
        proxy_url = self.yum_base.conf.proxy
        if self.yum_base.conf.proxy_password:
            user_pass = user_pass + "":"" + self.yum_base.conf.proxy_password
    elif '@' in self.yum_base.conf.proxy:
        user_pass = self.yum_base.conf.proxy.split('@')[0].split('//')[-1]
        proxy_url = self.yum_base.conf.proxy.replace(""{0}@"".format(user_pass), """")"
-------------------------------------------------------------------------
"pkgs = self.yum_base.returnPackagesByDep(req_spec)  \
    self.yum_base.returnInstalledPackagesByDep(req_spec)
, _ = self.yum_base.pkgSack.matchPackageNames([req_spec])
, _ = self.yum_base.rpmdb.matchPackageNames([req_spec])
"
-------------------------------------------------------------------------
"Recom
PRs: 63713, 65575"
-------------------------------------------------------------------------
=========================================================================
"os.environ[item  ""_proxy""] = self.yum_base.conf.proxy
"
-------------------------------------------------------------------------
"os.environ[item + ""_proxy""] = my.conf.proxy"
-------------------------------------------------------------------------
"if self.yum_base.conf.proxy and self.yum_base.conf.proxy not in (""_none_"",):
    if self.yum_base.conf.proxy_username:
        namepass = namepass  self.yum_base.conf.proxy_username
        proxy_url = self.yum_base.conf.proxy
        if self.yum_base.conf.proxy_password:
            namepass = namepass  "":""  self.yum_base.conf.proxy_password
    elif '@' in self.yum_base.conf.proxy:
        namepass = self.yum_base.conf.proxy.split('@')[0].split('//')[-1]
        proxy_url = self.yum_base.conf.proxy.replace(""{0}@"".format(namepass), """")
"
-------------------------------------------------------------------------
"Recom
PRs: 63713, 65575"
-------------------------------------------------------------------------
=========================================================================
"self._yum_base = None  # previous YumBase package index is now invalid
"
-------------------------------------------------------------------------
self._yum_base_invalid = None  # previous YumBase package index is now invalid
-------------------------------------------------------------------------
"os.environ[item  ""_proxy""] = self.yum_base.conf.proxy
"
-------------------------------------------------------------------------
"Recom
PRs: 63713, 65575"
-------------------------------------------------------------------------
=========================================================================
"try: self.yum_base.repos.disableRepo(disablerepo)
try: self.yum_base.repos.enableRepo(enablerepo)
"
-------------------------------------------------------------------------
"try:
    self.yum_base.repos.disable(enablerepo)
except:
    pass

try:
    self.yum_base.repos.enable(enablerepo)
except:
    pass"
-------------------------------------------------------------------------
"self._yum_base = None  # previous YumBase package index is now invalid
"
-------------------------------------------------------------------------
"Recom
PRs: 63713, 65575"
-------------------------------------------------------------------------
=========================================================================
"current_repos = self.yum_base.repos.repos.keys()
        new_repos = self.yum_base.repos.repos.keys()
                rid = self.yum_base.repos.getRepo(i)
"
-------------------------------------------------------------------------
"current_repos = self.yum_base.repos.repos.keys()
new_repos = self.yum_base.repos.repos.keys()
rid = self.yum_base.repos.getRepo(i)"
-------------------------------------------------------------------------
"try: self.yum_base.repos.disableRepo(disablerepo)
try: self.yum_base.repos.enableRepo(enablerepo)
"
-------------------------------------------------------------------------
"Recom
PRs: 63713, 65575"
-------------------------------------------------------------------------
=========================================================================
"yum_plugins = self.yum_base.plugins._plugins
"
-------------------------------------------------------------------------
yum_plugins = self.yum_basecmd.plugins._plugins
-------------------------------------------------------------------------
"current_repos = self.yum_base.repos.repos.keys()
        new_repos = self.yum_base.repos.repos.keys()
                rid = self.yum_base.repos.getRepo(i)
"
-------------------------------------------------------------------------
"Recom
PRs: 63713, 65575"
-------------------------------------------------------------------------
=========================================================================
"elif current_condition['Field'] == condition['Field'] and current_condition['Values'] == condition['Values']:
"
-------------------------------------------------------------------------
elif current_condition['Field'] == condition['Field'] and current_condition['Values'] == condition['Values']:
-------------------------------------------------------------------------
"elif current_condition['Field'] == condition['Field'] and sorted(current_condition['Values']) == sorted(condition['Values']):
"
-------------------------------------------------------------------------
"Recom
PRs: 65021, 65212"
-------------------------------------------------------------------------
=========================================================================
"""WHERE indexrelname = %(name)s ""
""AND schemaname = %(schema)s"")
exec_sql(self, query, query_params={'name': self.name, 'schema': self.schema},
         add_to_executed=False)
"
-------------------------------------------------------------------------
"exec_sql(self, query, query_params={'name': self.name, 'schema': self.schema, add_to_executed=False})"
-------------------------------------------------------------------------
"""WHERE i.indexname = %(name)s"")
c_sql(self, query, query_params={'name': self.name}, add_to_executed=False)
"
-------------------------------------------------------------------------
"Recom
PRs: 64661, 65034"
-------------------------------------------------------------------------
=========================================================================
"feed_ca_cert:
      The ca_cert alias will be removed in Ansible 2.14.
  aliases: [ importer_ssl_ca_cert, ca_cert ]
feed_client_cert:
  version_added: ""2.10""
"
-------------------------------------------------------------------------
"aliases: [ importer_ssl_ca_cert, ca_cert ]
feed_client_cert:
  version_added: ""2.10"""
-------------------------------------------------------------------------
"feed_ca_cert:
      The ca_cert alias will be removed in Ansible 2.14.
  aliases: [ importer_ssl_ca_cert, ca_cert ]
feed_client_cert:
  version_added: ""2.9.2""
"
-------------------------------------------------------------------------
"Recom
PRs: 59522, 65014"
-------------------------------------------------------------------------
=========================================================================
"- If not specified the default value will come from client_cert. Which will
  change in Ansible 2.14.
_client_key:
rsion_added: ""2.10""
- If not specified the default value will come from client_key. Which will
  change in Ansible 2.14.
"
-------------------------------------------------------------------------
"client_cert:
        version_added: ""2.10""
        description:
          - If not specified the default value will come from feed_client_cert. Which will
            change in Ansible 2.14.
      client_key:
        version_added: ""2.10""
        description:
          - If not specified the default value will come from feed_client_key. Which will
            change in Ansible 2.14."
-------------------------------------------------------------------------
"- If not specified the default value will come from client_cert. Which will
  change in Ansible 2.14.
_client_key:
rsion_added: ""2.9.2""
- If not specified the default value will come from client_key. Which will
  change in Ansible 2.14.
"
-------------------------------------------------------------------------
"Recom
PRs: 59522, 65014"
-------------------------------------------------------------------------
=========================================================================
"importer_ssl_ca_cert = module.params['feed_ca_cert']
importer_ssl_client_cert = module.params['feed_client_cert']
if importer_ssl_client_cert is None and module.params['client_cert'] is not None:
    importer_ssl_client_cert = module.params['client_cert']
    module.deprecate((""To specify client certificates to be used with the repo to sync, and not for communication with pulp.io, use the new options ""
                      ""`feed_client_cert` and `feed_client_key` (available since Ansible 2.10). Until Ansible 2.14, the default value for ""
                      ""`feed_client_cert` will be taken from `client_cert` if only the latter is specified""), version=""2.14"")
importer_ssl_client_key = module.params['feed_client_key']
if importer_ssl_client_key is None and module.params['client_key'] is not None:
    importer_ssl_client_key = module.params['client_key']
    module.deprecate(""In Ansible 2.10 `feed_client_key` option was added. Until 2.14 the default value will come from client_key option"", version=""2.14"")
"
-------------------------------------------------------------------------
"importer_ssl_ca_cert = module.params['importer_ssl_ca_cert']
importer_ssl_client_cert = module.params['importer_ssl_client_cert']
if importer_ssl_client_cert is None and module.params['client_cert'] is not None:
    importer_ssl_client_cert = module.params['client_cert']
    module.deprecate((""To specify client certificates to be used with the repo to sync, and not for communication with pulp.io, use the new options ""
                      ""`feed_client_cert` and `feed_client_key` (available since Ansible 2.10). Until Ansible 2.14, the default value for ""
                      ""`feed_client_cert` will be taken from `client_cert` if only the latter is specified""), version=""2.14"")
importer_ssl_client_key = module.params['importer_ssl_client_key']
if importer_ssl_client_key is None and module.params['client_key'] is not None:
    importer_ssl_client_key = module.params['client_key']
    module.deprecate(""In Ansible 2.10 `feed_client_key` option was added. Until 2.14 the default value will come from client_key option"", version=""2.14"")"
-------------------------------------------------------------------------
"importer_ssl_ca_cert = module.params['feed_ca_cert']
importer_ssl_client_cert = module.params['feed_client_cert']
if importer_ssl_client_cert is None and module.params['client_cert'] is not None:
    importer_ssl_client_cert = module.params['client_cert']
    module.deprecate(""To specify client certificates to be used with the repo to sync, and not for communication with the ""
                     ""Pulp instance, use the new options `feed_client_cert` and `feed_client_key` (available since ""
                     ""Ansible 2.9.2). Until Ansible 2.14, the default value for `feed_client_cert` will be taken from ""
                     ""`client_cert` if only the latter is specified"", version=""2.14"")
importer_ssl_client_key = module.params['feed_client_key']
if importer_ssl_client_key is None and module.params['client_key'] is not None:
    importer_ssl_client_key = module.params['client_key']
    module.deprecate(""In Ansible 2.9.2 `feed_client_key` option was added. Until 2.14 the default value will come from client_key option"", version=""2.14"")
"
-------------------------------------------------------------------------
"Recom
PRs: 59522, 65014"
-------------------------------------------------------------------------
=========================================================================
"rc=rc,
out=out, err=err,  # Deprecated
stdout=out, stderr=err)
"
-------------------------------------------------------------------------
"stdout = out
stderr = err"
-------------------------------------------------------------------------
"module.exit_json(
    changed=False,
    rc=rc,
    stdout=out,
    stderr=err)
    rc=rc,
    stdout=out,
    stderr=err,
"
-------------------------------------------------------------------------
"Recom
PRs: 63467, 64120"
-------------------------------------------------------------------------
=========================================================================
"module.exit_json(
    changed=False,
    rc=rc,
    stdout=out,
    stderr=err)
    rc=rc,
    stdout=out,
    stderr=err,
"
-------------------------------------------------------------------------
"module.exit_json(
    changed=False,
    rc=rc,
    stdout=out,
    stderr=err
)"
-------------------------------------------------------------------------
"out=out, err=err,
stdout=out, stderr=err)
changed=True,
msg=out, rc=rc,
err=err,
stdout=out, stderr=err)
"
-------------------------------------------------------------------------
"Recom
PRs: 63467, 64120"
-------------------------------------------------------------------------
=========================================================================
"short_description: Gathers information for virtual machines running on Citrix Hypervisor/XenServer host or pool
"
-------------------------------------------------------------------------
short_description: Gathers information for virtual machines running on Citrix Hypervisor/XenServer host or pool
-------------------------------------------------------------------------
"short_description: Gathers facts for virtual machines running on Citrix Hypervisor/XenServer host or pool
"
-------------------------------------------------------------------------
"Recom
PRs: 63728, 63816"
-------------------------------------------------------------------------
=========================================================================
"- ""The only allowed value according to L(RFC 2986,https://tools.ietf.org/html/rfc2986#section-4.1)
   is 1.""
- This option will no longer accept unsupported values from Ansible 2.14 on.
"
-------------------------------------------------------------------------
"# The only allowed value according to RFC 2986 (https://tools.ietf.org/html/rfc2986#section-4.1) is 1.
# This option will no longer accept unsupported values from Ansible 2.14 on."
-------------------------------------------------------------------------
"- ""The only allowed value according to L(RFC 2986,https://tools.ietf.org/html/rfc2986#section-4.1)
   is 1.""
"
-------------------------------------------------------------------------
"Recom
PRs: 63432, 63675"
-------------------------------------------------------------------------
=========================================================================
"- ""The only allowed value according to L(RFC 2986,https://tools.ietf.org/html/rfc2986#section-4.1)
   is 1.""
- This option will no longer accept unsupported values from Ansible 2.14 on.
"
-------------------------------------------------------------------------
"# The version must be 1 according to RFC 2986 (https://tools.ietf.org/html/rfc2986#section-4.1).
# Any unsupported values will be ignored starting from Ansible 2.14."
-------------------------------------------------------------------------
"- ""The only allowed value according to L(RFC 2986,https://tools.ietf.org/html/rfc2986#section-4.1)
   is 1.""
"
-------------------------------------------------------------------------
"Recom
PRs: 63432, 63674"
-------------------------------------------------------------------------
=========================================================================
"- If not set, the value will be remain the same if container exists and will be inherited
  from the host machine if it is (re-)created.
Specification for mounts to be added to the container. More powerful alternative to I(volumes).
"
-------------------------------------------------------------------------
"- If 'ansible_key' is not present, the configuration value will remain the same if the configuration exists and will be inherited from the host machine if it is (re-)created.
- Specification for mounting configurations to be added to the configuration. A more robust alternative to using I(volumes)."
-------------------------------------------------------------------------
"- If not set, the value will be remain the same if container exists and will be inherited
  from the host machine if it is (re-)created.
"
-------------------------------------------------------------------------
"Recom
PRs: 63165, 63301"
-------------------------------------------------------------------------
=========================================================================
"- bind
- npipe
- tmpfs
- volume
- Whether the mount should be read-only.
- The consistency requirement for the mount.
- cached
- consistent
- default
- delegated
- private
- rprivate
- shared
- rshared
- slave
- rslave
"
-------------------------------------------------------------------------
"Options:
    bind:
        description:
            - 'Defines a path to be bind mounted into the container.'
        type: path
    npipe:
        description:
            - 'Connects to a Windows Named Pipe.'
        type: dict
    tmpfs:
        description: 
            - 'Mount a tmpfs directory.'
        type: dict
    volume:
        description:
            - 'Mount a volume from the Docker host.'
        type: path
    read_only:
        description:
            - 'Whether the mount should be read-only.'
        type: bool
        default: no
    consistency:
        description:
            - 'The consistency requirement for the mount.'
        type: str
        choices:
            - 'cached'
            - 'consistent'
            - 'default'
            - 'delegated'
            - 'private'
            - 'rprivate'
            - 'shared'
            - 'rshared'
            - 'slave'
            - 'rslave'"
-------------------------------------------------------------------------
"- Connect the container to a network. Choices are C(bridge), C(host), C(none) or C(container:<name|id>).
- Set the user namespace mode for the container. Currently, the only valid value are C(host) and the empty string.
- To remove a container from one or more networks, use the I(purge_networks) option.
  network if I(networks) is specified. You need to explicitly use I(purge_networks) to enforce
  the removal of the default network (and all other networks not explicitly mentioned in I(networks)).
  Alternatively, use the I(networks_cli_compatible) option, which will be enabled by default from Ansible 2.12 on.
"
-------------------------------------------------------------------------
"Recom
PRs: 63165, 63301"
-------------------------------------------------------------------------
=========================================================================
"- Dictionary of options specific to the chosen volume_driver. See
  L(here,https://docs.docker.com/storage/volumes/#use-a-volume-driver) for details.
- ""The size for the tmpfs mount in bytes in format <number>[<unit>].""
   C(T) (tebibyte), or C(P) (pebibyte).""
"
-------------------------------------------------------------------------
"# Dictionary of options specific to the chosen docker_volume_driver. See
# L(https://docs.docker.com/storage/volumes/#use-a-volume-driver) for details.
- ""The size for the tmpfs mount in bytes in format <number>[<unit>].
  Acceptable units are C(T) (tebibyte), or C(P) (pebibyte)."""
-------------------------------------------------------------------------
"not attached. This module with I(networks: {name: other}) will create a container
C(docker run --network) and will *not* add the default network if I(networks) is
specified. If I(networks) is not specified, the default network will be attached.""
Note that docker CLI also sets I(network_mode) to the name of the first network
explicitly have to set I(network_mode) to the name of the first network you're
"
-------------------------------------------------------------------------
"Recom
PRs: 63165, 63301"
-------------------------------------------------------------------------
=========================================================================
"- Connect the container to a network. Choices are C(bridge), C(host), C(none) or C(container:<name|id>).
- Set the user namespace mode for the container. Currently, the only valid value are C(host) and the empty string.
- To remove a container from one or more networks, use the I(purge_networks) option.
  network if I(networks) is specified. You need to explicitly use I(purge_networks) to enforce
  the removal of the default network (and all other networks not explicitly mentioned in I(networks)).
  Alternatively, use the I(networks_cli_compatible) option, which will be enabled by default from Ansible 2.12 on.
"
-------------------------------------------------------------------------
"- Connect the container to a network. Choices are ""bridge"", ""host"", ""none"", or ""container:<name|id>"".
- Set the user namespace mode for the container. Currently, the only valid value are ""host"" and the empty string.
- To remove a container from one or more networks, use the `purge_networks` option.
  network if `networks` is specified. You need to explicitly use `purge_networks` to enforce
  the removal of the default network (and all other networks not explicitly mentioned in `networks`).
  Alternatively, use the `networks_cli_compatible` option, which will be enabled by default from Ansible 2.12 on."
-------------------------------------------------------------------------
"- If set to true, output of the container command will be printed.
- Only effective when I(log_driver) is set to C(json-file) or C(journald).
"
-------------------------------------------------------------------------
"Recom
PRs: 63165, 63301"
-------------------------------------------------------------------------
=========================================================================
"not attached. This module with I(networks: {name: other}) will create a container
C(docker run --network) and will *not* add the default network if I(networks) is
specified. If I(networks) is not specified, the default network will be attached.""
Note that docker CLI also sets I(network_mode) to the name of the first network
explicitly have to set I(network_mode) to the name of the first network you're
"
-------------------------------------------------------------------------
"# This module with networks: {name: other} will create a container
# using docker run --network and will *not* add the default network if 
# networks is specified. If networks is not specified, the default network
# will be attached.""
# Note that docker CLI also sets network_mode to the name of the first network
# explicitly set network_mode to the name of the first network you're
if networks:
    # Creating a container with the specified network
    # (not adding the default network)
    docker run --network
else:
    # Adding the default network if networks is not specified
    # Attaching the default network to the container
    docker run
    # Setting the network_mode to the name of the first network
    network_mode = first_network_name"
-------------------------------------------------------------------------
"- Note that Docker SDK for Python < 2.0 only supports C(host). Newer versions of the
  Docker SDK for Python (docker) allow all values supported by the Docker daemon.
- Set C(-1) for unlimited PIDs.
"
-------------------------------------------------------------------------
"Recom
PRs: 63165, 63301"
-------------------------------------------------------------------------
=========================================================================
"- If set to true, output of the container command will be printed.
- Only effective when I(log_driver) is set to C(json-file) or C(journald).
"
-------------------------------------------------------------------------
"if options.get('version_added', '2.2') == '2.2':
        module = ModuleDocFragment(
            options=dict(
                version_added=""2.2""
            ),
            metadata=dict(
                description=[
                    'If set to true, output of the container command will be printed.',
                    'Only effective when I(log_driver) is set to C(json-file) or C(journald).'
                ]
            )
        )"
-------------------------------------------------------------------------
"- ""Bind addresses must be either IPv4 or IPv6 addresses. Hostnames are *not* allowed. This
- If I(networks) parameter is provided, will inspect each network to see if there exists
  a bridge network with optional parameter C(com.docker.network.bridge.host_binding_ipv4).
  will be bound to the host IP pointed to by C(com.docker.network.bridge.host_binding_ipv4).
  Note that the first bridge network with a C(com.docker.network.bridge.host_binding_ipv4)
  value encountered in the list of I(networks) is the one that will be used.
"
-------------------------------------------------------------------------
"Recom
PRs: 63165, 63301"
-------------------------------------------------------------------------
=========================================================================
"- Note that Docker SDK for Python < 2.0 only supports C(host). Newer versions of the
  Docker SDK for Python (docker) allow all values supported by the Docker daemon.
- Set C(-1) for unlimited PIDs.
"
-------------------------------------------------------------------------
"- Note that Docker SDK for Python < 2.0 only supports C(host). Newer versions of the
  Docker SDK for Python (docker) allow all values supported by the Docker daemon.
- Set C(cpu_period) to -1 for unlimited PIDs."
-------------------------------------------------------------------------
"- ""*Note:* images are only pulled when specified by name. If the image is specified
  as a image ID (hash), it cannot be pulled.""
- Remove the container from ALL networks not included in I(networks) parameter.
- Any default networks such as C(bridge), if not found in I(networks), will be removed as well.
"
-------------------------------------------------------------------------
"Recom
PRs: 63165, 63301"
-------------------------------------------------------------------------
=========================================================================
"- ""Bind addresses must be either IPv4 or IPv6 addresses. Hostnames are *not* allowed. This
- If I(networks) parameter is provided, will inspect each network to see if there exists
  a bridge network with optional parameter C(com.docker.network.bridge.host_binding_ipv4).
  will be bound to the host IP pointed to by C(com.docker.network.bridge.host_binding_ipv4).
  Note that the first bridge network with a C(com.docker.network.bridge.host_binding_ipv4)
  value encountered in the list of I(networks) is the one that will be used.
"
-------------------------------------------------------------------------
"# Bind addresses must be either IPv4 or IPv6 addresses. Hostnames are *not* allowed.
# If `cpuset_mems` parameter is provided, it will inspect each network to see if there exists
# a bridge network with optional parameter `cpuset_mems`.
# The bind address will be the value of `cpuset_mems`.
# Note that the first bridge network with a `cpuset_mems` value encountered in the list of `networks` is the one that will be used."
-------------------------------------------------------------------------
"- Container restart policy.
- Place quotes around C(no) option.
"
-------------------------------------------------------------------------
"Recom
PRs: 63165, 63301"
-------------------------------------------------------------------------
=========================================================================
"- ""*Note:* images are only pulled when specified by name. If the image is specified
  as a image ID (hash), it cannot be pulled.""
- Remove the container from ALL networks not included in I(networks) parameter.
- Any default networks such as C(bridge), if not found in I(networks), will be removed as well.
"
-------------------------------------------------------------------------
"- Remove the container from all networks not included in the ""networks"" parameter.
- Any default networks such as ""bridge"", if not found in the ""networks"", will be removed as well."
-------------------------------------------------------------------------
"- ""Size of C(/dev/shm) in format C(<number>[<unit>]). Number is positive integer.
- Omitting the unit defaults to bytes. If you omit the size entirely, Docker daemon uses C(64M).
- List of security options in the form of C(""label:user:User"").
- 'C(absent) - A container matching the specified name will be stopped and removed. Use I(force_kill) to kill the container
   rather than stopping it. Use I(keep_volumes) to retain volumes associated with the removed container.'
- 'C(present) - Asserts the existence of a container matching the name and any provided configuration parameters. If no
  with the requested config.'
- 'C(started) - Asserts that the container is first C(present), and then if the container is not running moves it to a running
  state. Use I(restart) to force a matching container to be stopped and restarted.'
- 'C(stopped) - Asserts that the container is first C(present), and then if the container is running moves it to a stopped
  state.'
- To control what will be taken into account when comparing configuration, see the I(comparisons) option. To avoid that the
  image version will be taken into account, you can also use the I(ignore_image) option.
- Use the I(recreate) option to always force re-creation of a matching container, even if it is running.
- If the container should be killed instead of stopped in case it needs to be stopped for recreation, or because I(state) is
  C(stopped), please use the I(force_kill) option. Use I(keep_volumes) to retain volumes associated with a removed container.
- Use I(keep_volumes) to retain volumes associated with a removed container.
"
-------------------------------------------------------------------------
"Recom
PRs: 63165, 63301"
-------------------------------------------------------------------------
=========================================================================
"- Container restart policy.
- Place quotes around C(no) option.
"
-------------------------------------------------------------------------
"options:
    required: yes
    rate:
        description:
        - ""Number is a positive integer. Unit can be one of C(B) (byte), C(K) (kibibyte, 1024B), C(M) (mebibyte), C(G) (gibibyte),
        - ""Omitting the unit defaults to bytes.""
        type: str
        required: yes
    ""restart_policy"":
        description:
        - ""A string representing the restart policy. Quotes must be placed around the C(no) option."""
-------------------------------------------------------------------------
"- Number of seconds to wait for the container to stop before sending C(SIGKILL).
"
-------------------------------------------------------------------------
"Recom
PRs: 63165, 63301"
-------------------------------------------------------------------------
=========================================================================
"- ""Size of C(/dev/shm) in format C(<number>[<unit>]). Number is positive integer.
- Omitting the unit defaults to bytes. If you omit the size entirely, Docker daemon uses C(64M).
- List of security options in the form of C(""label:user:User"").
- 'C(absent) - A container matching the specified name will be stopped and removed. Use I(force_kill) to kill the container
   rather than stopping it. Use I(keep_volumes) to retain volumes associated with the removed container.'
- 'C(present) - Asserts the existence of a container matching the name and any provided configuration parameters. If no
  with the requested config.'
- 'C(started) - Asserts that the container is first C(present), and then if the container is not running moves it to a running
  state. Use I(restart) to force a matching container to be stopped and restarted.'
- 'C(stopped) - Asserts that the container is first C(present), and then if the container is running moves it to a stopped
  state.'
- To control what will be taken into account when comparing configuration, see the I(comparisons) option. To avoid that the
  image version will be taken into account, you can also use the I(ignore_image) option.
- Use the I(recreate) option to always force re-creation of a matching container, even if it is running.
- If the container should be killed instead of stopped in case it needs to be stopped for recreation, or because I(state) is
  C(stopped), please use the I(force_kill) option. Use I(keep_volumes) to retain volumes associated with a removed container.
- Use I(keep_volumes) to retain volumes associated with a removed container.
"
-------------------------------------------------------------------------
"Size of C(/dev/shm) in format C(<rate>[<options>]).
Omitting the unit defaults to bytes. If you omit the size entirely, Docker daemon uses C(64M).
List of security options in the form of C(""label:user:User"").
'C(absent) - A container matching the specified name will be stopped and removed. Use I(force_kill) to kill the container
   rather than stopping it. Use I(keep_volumes) to retain volumes associated with the removed container.'
'C(present) - Asserts the existence of a container matching the name and any provided configuration parameters. If no
  with the requested config.'
'C(started) - Asserts that the container is first C(present), and then if the container is not running moves it to a running
  state. Use I(restart) to force a matching container to be stopped and restarted.'
'C(stopped) - Asserts that the container is first C(present), and then if the container is running moves it to a stopped
  state.'
To control what will be taken into account when comparing configuration, see the I(comparisons) option. To avoid that the
  image version will be taken into account, you can also use the I(ignore_image) option.
Use the I(recreate) option to always force re-creation of a matching container, even if it is running.
If the container should be killed instead of stopped in case it needs to be stopped for recreation, or because I(state) is
  C(stopped), please use the I(force_kill) option. Use I(keep_volumes) to retain volumes associated with a removed container.
Use I(keep_volumes) to retain volumes associated with a removed container."
-------------------------------------------------------------------------
"- Mount a tmpfs directory.
"
-------------------------------------------------------------------------
"Recom
PRs: 63165, 63301"
-------------------------------------------------------------------------
=========================================================================
"- Number of seconds to wait for the container to stop before sending C(SIGKILL).
"
-------------------------------------------------------------------------
"options:
      timeout:
        description:
          - ""Number of seconds to wait for the container to stop before sending C(SIGKILL).""
        version_added: ""2.8""
        type: int"
-------------------------------------------------------------------------
"- ""List of ulimit options. A ulimit is specified as C(nofile:262144:262144).""
"
-------------------------------------------------------------------------
"Recom
PRs: 63165, 63301"
-------------------------------------------------------------------------
=========================================================================
"- Mount a tmpfs directory.
"
-------------------------------------------------------------------------
- Mount a tmpfs directory.
-------------------------------------------------------------------------
"- ""Can be of the forms C(user), C(user:group), C(uid), C(uid:gid), C(user:gid) or C(uid:group).""
"
-------------------------------------------------------------------------
"Recom
PRs: 63165, 63301"
-------------------------------------------------------------------------
=========================================================================
"- ""List of ulimit options. A ulimit is specified as C(nofile:262144:262144).""
"
-------------------------------------------------------------------------
# List of options for ulimit. A ulimit is specified as C(nofile:262144:262144).
-------------------------------------------------------------------------
"- SELinux hosts can additionally use C(z) or C(Z) to use a shared or private label for the volume.
"
-------------------------------------------------------------------------
"Recom
PRs: 63165, 63301"
-------------------------------------------------------------------------
=========================================================================
"- ""Can be of the forms C(user), C(user:group), C(uid), C(uid:gid), C(user:gid) or C(uid:group).""
"
-------------------------------------------------------------------------
"""Can be of the forms {{C(USER)}}, {{C(USER:GROUP)}}, {{C(UID)}}, {{C(UID:GID)}}, {{C(USER:GID)}} or {{C(UID:GROUP)}}."""
-------------------------------------------------------------------------
"- List of container names or IDs to get volumes from.
"
-------------------------------------------------------------------------
"Recom
PRs: 63165, 63301"
-------------------------------------------------------------------------
=========================================================================
"- SELinux hosts can additionally use C(z) or C(Z) to use a shared or private label for the volume.
"
-------------------------------------------------------------------------
"The given line seems to be related to Docker documentation for the `docker_volume` module in the Ansible codebase. Based on the stable metadata provided, no specific changes are needed for this line in the target method. You can use the source code directly for adaptation."
-------------------------------------------------------------------------
"- Enable auto-removal of the container on daemon side when the container's process exits.
"
-------------------------------------------------------------------------
"Recom
PRs: 63165, 63301"
-------------------------------------------------------------------------
=========================================================================
"- When passed dictionaries valid sub-options are I(name), which is required, and
  I(aliases) and I(options).
"
-------------------------------------------------------------------------
"when passed dictionaries valid sub-options are name , which is required, and aliases and options."
-------------------------------------------------------------------------
"- ""Service memory reservation in format C(<number>[<unit>]). Number is a positive integer.
"
-------------------------------------------------------------------------
"Recom
PRs: 63165, 63301"
-------------------------------------------------------------------------
=========================================================================
"- ""Service memory reservation in format C(<number>[<unit>]). Number is a positive integer.
"
-------------------------------------------------------------------------
"options:
     type: str
     service_memory:
        description:
            Service memory reservation in format C(<number>[<unit>]). Number is a positive integer."
-------------------------------------------------------------------------
"- C(absent) - A service matching the specified name will be removed and have its tasks stopped.
- C(present) - Asserts the existence of a service matching the name and provided configuration parameters.
"
-------------------------------------------------------------------------
"Recom
PRs: 63165, 63301"
-------------------------------------------------------------------------
=========================================================================
"n_url = self.api_server
if self.api_server == 'https://galaxy.ansible.com' or self.api_server == 'https://galaxy.ansible.com/':
    n_url = 'https://galaxy.ansible.com/api/'
try:
    data = self._call_galaxy(n_url, method='GET', error_context_msg=error_context_msg)
except (AnsibleError, GalaxyError, ValueError, KeyError):
    # Either the URL doesnt exist, or other error. Or the URL exists, but isn't a galaxy API
    # root (not JSON, no 'available_versions') so try appending '/api/'
    n_url = _urljoin(n_url, '/api/')
    # let exceptions here bubble up
    data = self._call_galaxy(n_url, method='GET', error_context_msg=error_context_msg)
    if 'available_versions' not in data:
        raise AnsibleError(""Tried to find galaxy API root at %s but no 'available_versions' are available on %s""
                           % (n_url, self.api_server))
available_versions = data.get('available_versions', {u'v1': u'v1/'})
    available_versions[u'v2'] = u'v2/'
"
-------------------------------------------------------------------------
"n_url = self.api_server
if self.api_server == 'https://galaxy.ansible.com' or self.api_server == 'https://galaxy.ansible.com/':
    n_url = 'https://galaxy.ansible.com/api/'
try:
    data = self._call_galaxy(n_url, method='GET', error_context_msg=error_context_msg)
except (AnsibleError, GalaxyError, ValueError, KeyError):
    # Either the URL doesnt exist, or other error. Or the URL exists, but isn't a galaxy API
    # root (not JSON, no 'available_versions') so try appending '/api/'
    n_url = _urljoin(n_url, '/api/')
    # let exceptions here bubble up
    data = self._call_galaxy(n_url, method='GET', error_context_msg=error_context_msg)
    if 'available_versions' not in data:
        raise AnsibleError(""Tried to find galaxy API root at %s but no 'available_versions' are available on %s""
                           % (n_url, self.api_server))
available_versions = data.get('available_versions', {u'v1': u'v1/'})
if list(available_versions.keys()) == [u'v1']:
    available_versions[u'v2'] = u'v2/'"
-------------------------------------------------------------------------
"n_url = self.api_server
if self.api_server == 'https://galaxy.ansible.com' or self.api_server == 'https://galaxy.ansible.com/':
    n_url = 'https://galaxy.ansible.com/api/'
try:
    data = self._call_galaxy(n_url, method='GET', error_context_msg=error_context_msg)
except (AnsibleError, GalaxyError, ValueError, KeyError):
    # Either the URL doesnt exist, or other error. Or the URL exists, but isn't a galaxy API
    # root (not JSON, no 'available_versions') so try appending '/api/'
    n_url = _urljoin(n_url, '/api/')
    # let exceptions here bubble up
    data = self._call_galaxy(n_url, method='GET', error_context_msg=error_context_msg)
    if 'available_versions' not in data:
        raise AnsibleError(""Tried to find galaxy API root at %s but no 'available_versions' are available on %s""
                           % (n_url, self.api_server))
    # Update api_server to point to the ""real"" API root, which in this case
    # was the configured url  '/api/' appended.
    self.api_server = n_url
available_versions = data.get('available_versions', {u'v1': u'v1/'})
    available_versions[u'v2'] = u'v2/'
"
-------------------------------------------------------------------------
"Recom
PRs: 63238, 63293"
-------------------------------------------------------------------------
=========================================================================
"cron_cmd = self.module.get_bin_path('crontab', required=True)
        return ""su %s -c '%s -l'"" % (shlex_quote(self.user), shlex_quote(cron_cmd))
        return ""%s -l %s"" % (shlex_quote(cron_cmd), shlex_quote(self.user))
        return ""%s %s %s"" % (cron_cmd, '-l', shlex_quote(self.user))
return ""%s %s %s"" % (cron_cmd, user, '-l')
cron_cmd = self.module.get_bin_path('crontab', required=True)
        return ""chown %s %s ; su '%s' -c '%s %s'"" % (shlex_quote(self.user), shlex_quote(path), shlex_quote(self.user), cron_cmd, shlex_quote(path))
return ""%s %s %s"" % (cron_cmd, user, shlex_quote(path))
"
-------------------------------------------------------------------------
"cron_cmd = self.module.get_bin_path('crontab', required=True)
return ""su %s -c '%s -l'"" % (pipes.quote(self.user), pipes.quote(cron_cmd))
return ""%s -l %s"" % (pipes.quote(cron_cmd), pipes.quote(self.user))
return ""%s %s %s"" % (cron_cmd, '-l', pipes.quote(self.user))
return ""%s %s %s"" % (cron_cmd, user, '-l')
cron_cmd = self.module.get_bin_path('crontab', required=True)
return ""chown %s %s ; su '%s' -c '%s %s'"" % (pipes.quote(self.user), pipes.quote(path), pipes.quote(self.user), cron_cmd, pipes.quote(path))
return ""%s %s %s"" % (cron_cmd, user, pipes.quote(path))"
-------------------------------------------------------------------------
"self.cron_cmd = self.module.get_bin_path('crontab', required=True)
"
-------------------------------------------------------------------------
"Recom
PRs: 59765, 62546"
-------------------------------------------------------------------------
=========================================================================
"cron_cmd = self.module.get_bin_path('crontab', required=True)
        return ""su %s -c '%s -l'"" % (shlex_quote(self.user), shlex_quote(cron_cmd))
        return ""%s -l %s"" % (shlex_quote(cron_cmd), shlex_quote(self.user))
        return ""%s %s %s"" % (cron_cmd, '-l', shlex_quote(self.user))
return ""%s %s %s"" % (cron_cmd, user, '-l')
cron_cmd = self.module.get_bin_path('crontab', required=True)
        return ""chown %s %s ; su '%s' -c '%s %s'"" % (shlex_quote(self.user), shlex_quote(path), shlex_quote(self.user), cron_cmd, shlex_quote(path))
return ""%s %s %s"" % (cron_cmd, user, shlex_quote(path))
"
-------------------------------------------------------------------------
"cron_cmd = self.module.get_bin_path('crontab', required=True)
        return ""chown %s %s ; su '%s' -c '%s %s'"" % (pipes.quote(self.user), pipes.quote(path), pipes.quote(self.user), cron_cmd, pipes.quote(path))
return ""%s %s %s"" % (cron_cmd, user, pipes.quote(path))"
-------------------------------------------------------------------------
"self.cron_cmd = self.module.get_bin_path('cronvar', required=True)
"
-------------------------------------------------------------------------
"Recom
PRs: 59765, 62546"
-------------------------------------------------------------------------
=========================================================================
"# Ansible module to manage CheckPoint Firewall (c) 2019
"
-------------------------------------------------------------------------
"## Stable version information
Library: ansible.module_utils.network.checkpoint.checkpoint

## Adapted code
# Ansible module to manage CheckPoint Firewall (c) 2019
from __future__ import ansible.module_utils.network.checkpoint.checkpoint"
-------------------------------------------------------------------------
"# Ansible module to manage CheckPoint Firewall (c) 2019
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#
from __future__ import absolute_import, division, print_function
__metaclass__ = type
import pytest
from units.modules.utils import set_module_args, exit_json, fail_json, AnsibleExitJson
from ansible.module_utils import basic
from ansible.modules.network.check_point import cp_mgmt_address_range
OBJECT = {
    ""name"": ""New Address Range 1"",
    ""ip_address_first"": ""192.0.2.1"",
    ""ip_address_last"": ""192.0.2.10""
}
CREATE_PAYLOAD = {
    ""name"": ""New Address Range 1"",
    ""ip_address_first"": ""192.0.2.1"",
    ""ip_address_last"": ""192.0.2.10""
}
UPDATE_PAYLOAD = {
    ""name"": ""New Address Range 1"",
    ""color"": ""blue"",
    ""ip_address_first"": ""192.0.2.1"",
    ""ip_address_last"": ""192.0.2.1""
}
OBJECT_AFTER_UPDATE = UPDATE_PAYLOAD
DELETE_PAYLOAD = {
    ""name"": ""New Address Range 1"",
    ""state"": ""absent""
}
function_path = 'ansible.modules.network.check_point.cp_mgmt_address_range.api_call'
api_call_object = 'address-range'
class TestCheckpointAddressRange(object):
    module = cp_mgmt_address_range
    @pytest.fixture(autouse=True)
    def module_mock(self, mocker):
        return mocker.patch.multiple(basic.AnsibleModule, exit_json=exit_json, fail_json=fail_json)
    @pytest.fixture
    def connection_mock(self, mocker):
        connection_class_mock = mocker.patch('ansible.module_utils.network.checkpoint.checkpoint.Connection')
        return connection_class_mock.return_value
    def test_create(self, mocker, connection_mock):
        mock_function = mocker.patch(function_path)
        mock_function.return_value = {'changed': True, api_call_object: OBJECT}
        result = self._run_module(CREATE_PAYLOAD)
        assert result['changed']
        assert OBJECT.items() == result[api_call_object].items()
    def test_create_idempotent(self, mocker, connection_mock):
        mock_function = mocker.patch(function_path)
        mock_function.return_value = {'changed': False, api_call_object: OBJECT}
        result = self._run_module(CREATE_PAYLOAD)
        assert not result['changed']
    def test_update(self, mocker, connection_mock):
        mock_function = mocker.patch(function_path)
        mock_function.return_value = {'changed': True, api_call_object: OBJECT_AFTER_UPDATE}
        result = self._run_module(UPDATE_PAYLOAD)
        assert result['changed']
        assert OBJECT_AFTER_UPDATE.items() == result[api_call_object].items()
    def test_update_idempotent(self, mocker, connection_mock):
        mock_function = mocker.patch(function_path)
        mock_function.return_value = {'changed': False, api_call_object: OBJECT_AFTER_UPDATE}
        result = self._run_module(UPDATE_PAYLOAD)
        assert not result['changed']
    def test_delete(self, mocker, connection_mock):
        mock_function = mocker.patch(function_path)
        mock_function.return_value = {'changed': True}
        result = self._run_module(DELETE_PAYLOAD)
        assert result['changed']
    def test_delete_idempotent(self, mocker, connection_mock):
        mock_function = mocker.patch(function_path)
        mock_function.return_value = {'changed': False}
        result = self._run_module(DELETE_PAYLOAD)
        assert not result['changed']
    def _run_module(self, module_args):
        set_module_args(module_args)
        with pytest.raises(AnsibleExitJson) as ex:
            self.module.main()
        return ex.value.args[0]
"
-------------------------------------------------------------------------
"Recom
PRs: 62338, 62390"
-------------------------------------------------------------------------
=========================================================================
"# This is a helper class to sort the changes in a valid order
# ""Greater than"" means a change has to happen after another one.
# As an example, let's say self is daily (key == 1) and other is weekly (key == 2)
class ChangeHelper:
    def __init__(self, old, new):
        self.key = new.key
        self.old = old
        self.new = new
    def __gt__(self, other):
        if self.key < other.key:
            # You cannot disable daily if weekly is enabled, so later
            if self.new.enabled < other.old.enabled:
                return True
            # Enabling daily is OK if weekly is disabled
            elif self.new.enabled > other.old.enabled:
                return False
            # Otherwise, decreasing the daily level below the current weekly level has to be done later
            else:
                return self.new.level < other.old.level
        else:
            return not (self.old > self.new)
"
-------------------------------------------------------------------------
"class ChangeHelper:
    def __init__(self, old, new):
        self.key = new.key
        self.old = old
        self.new = new
    
    def __gt__(self, other):
        if self.key < other.key:
            # You cannot disable daily if weekly is enabled, so later
            if self.new.enabled < other.old.enabled:
                return True
            # Enabling daily is OK if weekly is disabled
            elif self.new.enabled > other.old.enabled:
                return False
            # Otherwise, decreasing the daily level below the current weekly level has to be done later
            else:
                return self.new.level < other.old.level
        else:
            return not (self.old > self.new)"
-------------------------------------------------------------------------
"# This is a helper class to sort the changes in a valid order
# ""Greater than"" means a change has to happen after another one.
# As an example, let's say self is daily (key == 1) and other is weekly (key == 2)
class ChangeHelper:
    def __init__(self, old, new):
        self.key = new.key
        self.old = old
        self.new = new
    def __eq__(self, other):
        return ((self.key, self.new.enabled, self.new.level) ==
                (other.key, other.new.enabled, other.new.level))
    def __gt__(self, other):
        if self.key < other.key:
            # You cannot disable daily if weekly is enabled, so later
            if self.new.enabled < other.old.enabled:
                return True
            # Enabling daily is OK if weekly is disabled
            elif self.new.enabled > other.old.enabled:
                return False
            # Otherwise, decreasing the daily level below the current weekly level has to be done later
            else:
                return self.new.level < other.old.level
        else:
            return not (other > self)
    def __ge__(self, other):
        return (self > other) or (self == other)
    def __lt__(self, other):
        return not (self >= other)
    def __le__(self, other):
        return not (self > other)
"
-------------------------------------------------------------------------
"Recom
PRs: 61345, 62088"
-------------------------------------------------------------------------
=========================================================================
"- To create a disabled account on OpenBSD, set this to C('*************').
"
-------------------------------------------------------------------------
"# Optionally set the user's password to this crypted value. 
# On macOS systems, this value has to be cleartext. Beware of security issues.
# To create a disabled account on OpenBSD, set this to '*************'.

options:
  type: str"
-------------------------------------------------------------------------
"- To create a disabled account on OpenBSD, set this to C('*************').
- See U(https://docs.ansible.com/ansible/faq.html#how-do-i-generate-encrypted-passwords-for-the-user-module)
"
-------------------------------------------------------------------------
"Recom
PRs: 54893, 61791"
-------------------------------------------------------------------------
=========================================================================
"if module.params.get('permission') and not module.params.get('ignore_nonexistent_bucket'):
    # Wait for the bucket to exist before setting ACLs
    s3.get_waiter('bucket_exists').wait(Bucket=bucket)
"
-------------------------------------------------------------------------
"if module.params.get('permission') and not module.params.get('ignore_nonexistent_bucket'):
        # Wait for the bucket to exist before setting ACLs
        waiter = s3.get_waiter('bucket_exists')
        waiter.wait(Bucket=bucket)"
-------------------------------------------------------------------------
"if module.params.get('permission'):
"
-------------------------------------------------------------------------
"Recom
PRs: 61735, 61769"
-------------------------------------------------------------------------
=========================================================================
"if module.params.get('permission') and not module.params.get('ignore_nonexistent_bucket'):
    # Wait for the bucket to exist before setting ACLs
    s3.get_waiter('bucket_exists').wait(Bucket=bucket)
"
-------------------------------------------------------------------------
"if 'permission' in module.params and not module.params.get('ignore_nonexistent_bucket'):
    # Wait for the bucket to exist before setting ACLs
    s3.get_waiter('bucket_exists').wait(Bucket=bucket)"
-------------------------------------------------------------------------
"if module.params.get('permission'):
    # Wait for the bucket to exist before setting ACLs
    s3.get_waiter('bucket_exists').wait(Bucket=bucket)
"
-------------------------------------------------------------------------
"Recom
PRs: 61735, 61768"
-------------------------------------------------------------------------
=========================================================================
"if self._cache is not None:
"
-------------------------------------------------------------------------
if self._cache:
-------------------------------------------------------------------------
"if self._cache is not None:
# Store the cache to avoid running pkg_cache() for each item in the comprehension, which is very slow
cache = self.pkg_cache
return [pk for pk in cache.keys() if cache[pk].is_installed]
"
-------------------------------------------------------------------------
"Recom
PRs: 60511, 60574"
-------------------------------------------------------------------------
=========================================================================
"cluster = self.param('template_cluster') if self.param('template_cluster') else self.param('cluster')
    search='name=%s and cluster=%s' % (self.param('template'), cluster)
if not templates:
    templates = templates_service.list(
        search='name=%s' % self.param('template')
    )
"
-------------------------------------------------------------------------
"template_cluster = self.param('template_cluster') if self.param('template_cluster') else self.param('cluster')
search='name=%s and cluster=%s' % (self.param('template'), template_cluster)
if not templates:
    templates = templates_service.list(
        search='name=%s' % self.param('template')
    )"
-------------------------------------------------------------------------
"""Template with name '%s' and version '%s' in data center '%s' was not found'"" % (
    data_center.name
"
-------------------------------------------------------------------------
"Recom
PRs: 59378, 60478"
-------------------------------------------------------------------------
=========================================================================
"- ""Port mirroring, QoS and network filters are not supported on passthrough profiles.""
"
-------------------------------------------------------------------------
"- ""Port mirroring, QoS and network filters are not supported on passthrough profiles.""
+ ""Enables passthrough to an SR-IOV-enabled host NIC."""
-------------------------------------------------------------------------
"- ""When enabled and C(migratable) not specified then C(migratable) is enabled.""
- ""Port mirroring, QoS and network filters are not supported on passthrough profiles.""
"
-------------------------------------------------------------------------
"Recom
PRs: 59727, 60198"
-------------------------------------------------------------------------
=========================================================================
"pass_through = getattr(entity.pass_through.mode, 'name', None)
    self._get_network_filter_id() == getattr(entity.network_filter, 'id', None) and
    self._get_qos_id() == getattr(entity.qos, 'id', None) and
    equal(self.param('pass_through'), pass_through.lower() if pass_through else None) and
"
-------------------------------------------------------------------------
"pass_through = getattr(entitynics_module.pass_through.mode, 'name', None)
self._get_network_filter_id() == getattr(entitynics_module.entity.network_filter, 'id', None) and
self._get_qos_id() == getattr(entitynics_module.entity.qos, 'id', None) and
equal(self.param('pass_through'), pass_through.lower() if pass_through else None) and"
-------------------------------------------------------------------------
"pass_through = getattr(entity.pass_through.mode, 'name', None)
    # The reason why we can't use equal method, is we get None from _get_network_filter_id or _get_qos_id method, when passing empty string.
    # And when first param of equal method is None it retruns true.
    self._get_network_filter_id() == getattr(entity.network_filter, 'id', None) and
    self._get_qos_id() == getattr(entity.qos, 'id', None) and
    equal(self.param('pass_through'), pass_through.lower() if pass_through else None) and
"
-------------------------------------------------------------------------
"Recom
PRs: 59727, 60198"
-------------------------------------------------------------------------
=========================================================================
"if module.params['api']:
        user_token['user_api'] = array.create_api_token(module.params['name'])['api_token']
"
-------------------------------------------------------------------------
"if module.params['options']:
    user_token['user_api'] = array.create_api_token(module.params['name'])['api_token']"
-------------------------------------------------------------------------
"if module.params['api']:
        user_token['user_api'] = array.create_api_token(module.params['name'])['api_token']
        # Added for 2.8.2: Not breaking user's playbooks in minor releases.
        user_token['api_token'] = user_token['user_api']
"
-------------------------------------------------------------------------
"Recom
PRs: 57588, 58544"
-------------------------------------------------------------------------
=========================================================================
"if module.params['api']:
        user_token['user_api'] = array.create_api_token(module.params['name'])['api_token']
"
-------------------------------------------------------------------------
"if module.params['api']:
        user_token['user_api'] = array.get_api_token(module.params['name'])['api_token']"
-------------------------------------------------------------------------
"if module.params['api']:
        user_token['user_api'] = array.create_api_token(module.params['name'])['api_token']
        # Added for 2.8.2: Not breaking user's playbooks in minor releases.
        user_token['api_token'] = user_token['user_api']
"
-------------------------------------------------------------------------
"Recom
PRs: 57588, 58544"
-------------------------------------------------------------------------
=========================================================================
"- Has no effect when C(local) is C(True)
- Has no effect when C(local) is C(True)
"
-------------------------------------------------------------------------
"This statement can be adapted as follows:


- Does not have any effect if C(local) is set to C(True)"
-------------------------------------------------------------------------
"- Mutually exclusive with C(local)
- Mutually exclusive with C(local)
"
-------------------------------------------------------------------------
"Recom
PRs: 55401, 58480"
-------------------------------------------------------------------------
=========================================================================
"if groups_need_mod and not self.local:
"
-------------------------------------------------------------------------
"if groups_need_mod and not self.local:
    if not self.remote_user.startswith('root'):
        self.fail_json(msg=""User %s must be managed as 'root' when -G|-L are specified"" % (self.remote_user))
else:
    cmd.append('-N')

groups = self.get_groups_set()
cmd.append('-G')
cmd.append(','.join(groups))"
-------------------------------------------------------------------------
"if self.groups is not None and not self.local and len(self.groups):
"
-------------------------------------------------------------------------
"Recom
PRs: 55401, 58480"
-------------------------------------------------------------------------
=========================================================================
"from pygments.lexer import DelegatingLexer, RegexLexer, bygroups, include
from pygments.lexers import DiffLexer
"
-------------------------------------------------------------------------
"from pygments.lexer import RegexLexer
from pygments.lexers import PythonLexer"
-------------------------------------------------------------------------
"from pygments.lexer import LexerContext, ExtendedRegexLexer, DelegatingLexer, RegexLexer, bygroups, include
from pygments.lexers import DjangoLexer, DiffLexer
"
-------------------------------------------------------------------------
"Recom
PRs: 58101, 58356"
-------------------------------------------------------------------------
=========================================================================
"#
# (c) 2019 Red Hat Inc.
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#
from __future__ import (absolute_import, division, print_function)
__metaclass__ = type
from os import path
import json
from mock import MagicMock, call
from units.compat import unittest
from ansible.plugins.cliconf import ios
FIXTURE_DIR = b'%s/fixtures/ios' % (
    path.dirname(path.abspath(__file__)).encode('utf-8')
)
def _connection_side_effect(*args, **kwargs):
    try:
        if args:
            value = args[0]
        else:
            value = kwargs.get('command')
        fixture_path = path.abspath(
            b'%s/%s' % (FIXTURE_DIR, b'_'.join(value.split(b' ')))
        )
        with open(fixture_path, 'rb') as file_desc:
            return file_desc.read()
    except (OSError, IOError):
        if args:
            value = args[0]
            return value
        elif kwargs.get('command'):
            value = kwargs.get('command')
            return value
        return 'Nope'
class TestPluginCLIConfIOS(unittest.TestCase):
    """""" Test class for IOS CLI Conf Methods
    """"""
    def setUp(self):
        self._mock_connection = MagicMock()
        self._mock_connection.send.side_effect = _connection_side_effect
        self._cliconf = ios.Cliconf(self._mock_connection)
        self.maxDiff = None
    def tearDown(self):
        pass
    def test_get_device_info(self):
        """""" Test get_device_info
        """"""
        device_info = self._cliconf.get_device_info()
        mock_device_info = {'network_os': 'ios',
                            'network_os_model': 'CSR1000V',
                            'network_os_version': '16.06.01',
                            'network_os_hostname': 'an-csr-01',
                            'network_os_image': 'bootflash:packages.conf'
                            }
        self.assertEqual(device_info, mock_device_info)
    def test_get_capabilities(self):
        """""" Test get_capabilities
        """"""
        capabilities = json.loads(self._cliconf.get_capabilities())
        mock_capabilities = {
            'network_api': 'cliconf',
            'rpc': [
                'get_config',
                'edit_config',
                'get_capabilities',
                'get',
                'enable_response_logging',
                'disable_response_logging',
                'edit_banner',
                'get_diff',
                'run_commands',
                'get_defaults_flag'
            ],
            'device_operations': {
                'supports_diff_replace': True,
                'supports_commit': False,
                'supports_rollback': False,
                'supports_defaults': True,
                'supports_onbox_diff': False,
                'supports_commit_comment': False,
                'supports_multiline_delimiter': True,
                'supports_diff_match': True,
                'supports_diff_ignore_lines': True,
                'supports_generate_diff': True,
                'supports_replace': False
            },
            'device_info': {
                'network_os_hostname': 'an-csr-01',
                'network_os_image': 'bootflash:packages.conf',
                'network_os_model': 'CSR1000V',
                'network_os_version': '16.06.01',
                'network_os': 'ios'
            },
            'format': ['text'],
            'diff_match': ['line', 'strict', 'exact', 'none'],
            'diff_replace': ['line', 'block'],
            'output': []
        }
        self.assertEqual(
            mock_capabilities,
            capabilities
        )
"
-------------------------------------------------------------------------
"# (c) 2019 Red Hat Inc.
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#
from __future__ import (absolute_import, division, print_function)
__metaclass__ = type
from os import path
import json
from mock import MagicMock, call
from units.compat import unittest
from ansible.plugins.cliconf import ios
FIXTURE_DIR = b'%s/fixtures/ios' % (
    path.dirname(path.abspath(__file__)).encode('utf-8')
)


def _connection_side_effect(*args, **kwargs):
    try:
        if args:
            value = args[0]
        else:
            value = kwargs.get('command')
        fixture_path = path.abspath(
            b'%s/%s' % (FIXTURE_DIR, b'_'.join(value.split(b' ')))
        )
        with open(fixture_path, 'rb') as file_desc:
            return file_desc.read()
    except (OSError, IOError):
        if args:
            value = args[0]
            return value
        elif kwargs.get('command'):
            value = kwargs.get('command')
            return value
        return 'Nope'


class TestPluginCLIConfIOS(unittest.TestCase):
    """"""Test class for ios_facts CLI Conf Methods""""""

    def setUp(self):
        self._mock_connection = MagicMock()
        self._mock_connection.send.side_effect = _connection_side_effect
        self._cliconf = ios.Cliconf(self._mock_connection)
        self.maxDiff = None

    def tearDown(self):
        pass

    def test_get_device_info(self):
        """"""Test get_device_info""""""
        device_info = self._cliconf.get_device_info()
        expected_device_info = {'network_os': 'ios',
                                'network_os_model': 'CSR1000V',
                                'network_os_version': '16.06.01',
                                'network_os_hostname': 'an-csr-01',
                                'network_os_image': 'bootflash:packages.conf'
                                }
        self.assertEqual(device_info, expected_device_info)

    def test_get_capabilities(self):
        """"""Test get_capabilities""""""
        capabilities = json.loads(self._cliconf.get_capabilities())
        expected_capabilities = {
            'network_api': 'cliconf',
            'rpc': [
                'get_config',
                'edit_config',
                'get_capabilities',
                'get',
                'enable_response_logging',
                'disable_response_logging',
                'edit_banner',
                'get_diff',
                'run_commands',
                'get_defaults_flag'
            ],
            'device_operations': {
                'supports_diff_replace': True,
                'supports_commit': False,
                'supports_rollback': False,
                'supports_defaults': True,
                'supports_onbox_diff': False,
                'supports_commit_comment': False,
                'supports_multiline_delimiter': True,
                'supports_diff_match': True,
                'supports_diff_ignore_lines': True,
                'supports_generate_diff': True,
                'supports_replace': False
            },
            'device_info': {
                'network_os_hostname': 'an-csr-01',
                'network_os_image': 'bootflash:packages.conf',
                'network_os_model': 'CSR1000V',
                'network_os_version': '16.06.01',
                'network_os': 'ios'
            },
            'format': ['text'],
            'diff_match': ['line', 'strict', 'exact', 'none'],
            'diff_replace': ['line', 'block'],
            'output': []
        }
        self.assertEqual(expected_capabilities, capabilities)"
-------------------------------------------------------------------------
"#
# (c) 2019 Red Hat Inc.
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#
from __future__ import (absolute_import, division, print_function)
__metaclass__ = type
from os import path
import json
from mock import MagicMock, call
from units.compat import unittest
from ansible.plugins.cliconf import ios
from ansible.module_utils._text import to_bytes
b_FIXTURE_DIR = b'%s/fixtures/ios' % (
    to_bytes(path.dirname(path.abspath(__file__)), errors='surrogate_or_strict')
)
def _connection_side_effect(*args, **kwargs):
    try:
        if args:
            value = args[0]
        else:
            value = kwargs.get('command')
        fixture_path = path.abspath(
            b'%s/%s' % (b_FIXTURE_DIR, b'_'.join(value.split(b' ')))
        )
        with open(fixture_path, 'rb') as file_desc:
            return file_desc.read()
    except (OSError, IOError):
        if args:
            value = args[0]
            return value
        elif kwargs.get('command'):
            value = kwargs.get('command')
            return value
        return 'Nope'
class TestPluginCLIConfIOS(unittest.TestCase):
    """""" Test class for IOS CLI Conf Methods
    """"""
    def setUp(self):
        self._mock_connection = MagicMock()
        self._mock_connection.send.side_effect = _connection_side_effect
        self._cliconf = ios.Cliconf(self._mock_connection)
        self.maxDiff = None
    def tearDown(self):
        pass
    def test_get_device_info(self):
        """""" Test get_device_info
        """"""
        device_info = self._cliconf.get_device_info()
        mock_device_info = {'network_os': 'ios',
                            'network_os_model': 'CSR1000V',
                            'network_os_version': '16.06.01',
                            'network_os_hostname': 'an-csr-01',
                            'network_os_image': 'bootflash:packages.conf'
                            }
        self.assertEqual(device_info, mock_device_info)
    def test_get_capabilities(self):
        """""" Test get_capabilities
        """"""
        capabilities = json.loads(self._cliconf.get_capabilities())
        mock_capabilities = {
            'network_api': 'cliconf',
            'rpc': [
                'get_config',
                'edit_config',
                'get_capabilities',
                'get',
                'enable_response_logging',
                'disable_response_logging',
                'edit_banner',
                'get_diff',
                'run_commands',
                'get_defaults_flag'
            ],
            'device_operations': {
                'supports_diff_replace': True,
                'supports_commit': False,
                'supports_rollback': False,
                'supports_defaults': True,
                'supports_onbox_diff': False,
                'supports_commit_comment': False,
                'supports_multiline_delimiter': True,
                'supports_diff_match': True,
                'supports_diff_ignore_lines': True,
                'supports_generate_diff': True,
                'supports_replace': False
            },
            'device_info': {
                'network_os_hostname': 'an-csr-01',
                'network_os_image': 'bootflash:packages.conf',
                'network_os_model': 'CSR1000V',
                'network_os_version': '16.06.01',
                'network_os': 'ios'
            },
            'format': ['text'],
            'diff_match': ['line', 'strict', 'exact', 'none'],
            'diff_replace': ['line', 'block'],
            'output': []
        }
        self.assertEqual(
            mock_capabilities,
            capabilities
        )
"
-------------------------------------------------------------------------
"Recom
PRs: 58159, 58174"
-------------------------------------------------------------------------
=========================================================================
"- Use with state C(present) and source C(build) to provide an alternate name for the Dockerfile to use when building an image.
- This can also include a relative path (relative to I(path)).
"
-------------------------------------------------------------------------
"# Use with state ImageManager(present) and source ImageManager(build) to provide an alternate name for the dockerfile to use when building an image.
# This can also include a relative path (relative to path)."
-------------------------------------------------------------------------
"- This can also include a relative path (relative to I(path)).
"
-------------------------------------------------------------------------
"Recom
PRs: 57570, 57632"
-------------------------------------------------------------------------
=========================================================================
"#   loop: ""{{ sample_com_challenge.challenge_data_dns | dictsort }}""
#   when: sample_com_challenge is changed
"
-------------------------------------------------------------------------
"loop: ""{{ ansible.module_utils.acme.process_links(sample_com_challenge.challenge_data_dns) | ansible.module_utils._text.sorted_dict }}""
    when: sample_com_challenge.changed"
-------------------------------------------------------------------------
"#   with_dict: sample_com_challenge.challenge_data_dns
#   when: sample_com_challenge is changed
"
-------------------------------------------------------------------------
"Recom
PRs: 57557, 57568"
-------------------------------------------------------------------------
=========================================================================
"def ensure_required_libs(module):
    if not HAS_PSYCOPG2:
        module.fail_json(msg=missing_required_lib('psycopg2'))
    if module.params.get('ca_cert') and LooseVersion(psycopg2.__version__) < LooseVersion('2.4.3'):
        module.fail_json(msg='psycopg2 must be at least 2.4.3 in order to use the ca_cert parameter')
def connect_to_db(module, autocommit=False, fail_on_conn=True, warn_db_default=True):
    ensure_required_libs(module)
    # To use defaults values, keyword arguments must be absent, so
    # check which values are empty and don't include in the **kw
    # dictionary
    params_map = {
        ""login_host"": ""host"",
        ""login_user"": ""user"",
        ""login_password"": ""password"",
        ""port"": ""port"",
        ""ssl_mode"": ""sslmode"",
        ""ca_cert"": ""sslrootcert""
    }
    # Might be different in the modules:
    if module.params.get('db'):
        params_map['db'] = 'database'
    elif module.params.get('database'):
        params_map['database'] = 'database'
    elif module.params.get('login_db'):
        params_map['login_db'] = 'database'
    else:
        if warn_db_default:
            module.warn('Database name has not been passed, '
                        'used default database to connect to.')
    kw = dict((params_map[k], v) for (k, v) in iteritems(module.params)
              if k in params_map and v != '' and v is not None)
    # If a login_unix_socket is specified, incorporate it here.
    is_localhost = ""host"" not in kw or kw[""host""] is None or kw[""host""] == ""localhost""
    if is_localhost and module.params[""login_unix_socket""] != """":
        kw[""host""] = module.params[""login_unix_socket""]
"
-------------------------------------------------------------------------
"def ensure_required_dependencies(module):
    if not HAS_PSYCOPG2:
        module.fail_json(msg=missing_required_lib('psycopg2'))
    if module.params.get('ca_cert') and StrictVersion(psycopg2.__version__) < StrictVersion('2.4.3'):
        module.fail_json(msg='psycopg2 must be at least 2.4.3 in order to use the ca_cert parameter')

def connect_to_db(module, autocommit=False, fail_on_conn=True, warn_db_default=True):
    ensure_required_dependencies(module)
    
    # To use defaults values, keyword arguments must be absent, so
    # check which values are empty and don't include in the **kw
    # dictionary
    params_mapping = {
        ""login_host"": ""host"",
        ""login_user"": ""user"",
        ""login_password"": ""password"",
        ""port"": ""port"",
        ""ssl_mode"": ""sslmode"",
        ""ca_cert"": ""sslrootcert""
    }
    
    # Compilation set for the hunk:
    # Include constants and conditionals for connection parameters mapping
    
    if module.params.get('db'):
        params_mapping['db'] = 'database'
    elif module.params.get('database'):
        params_mapping['database'] = 'database'
    elif module.params.get('login_db'):
        params_mapping['login_db'] = 'database'
    else:
        if warn_db_default:
            module.warn('Database name has not been passed, '
                        'used default database to connect to.')
    
    kw = dict((params_mapping[k], v) for (k, v) in six.iteritems(module.params)
              if k in params_mapping and v != '' and v is not None)
    
    # If a login_unix_socket is specified, incorporate it here.
    is_localhost = ""host"" not in kw or kw[""host""] is None or kw[""host""] == ""localhost""
    if is_localhost and module.params[""login_unix_socket""] != """":
        kw[""host""] = module.params[""login_unix_socket""]"
-------------------------------------------------------------------------
"def ensure_required_libs(module):
    if not HAS_PSYCOPG2:
        module.fail_json(msg=missing_required_lib('psycopg2'))
    if module.params.get('ca_cert') and LooseVersion(psycopg2.__version__) < LooseVersion('2.4.3'):
        module.fail_json(msg='psycopg2 must be at least 2.4.3 in order to use the ca_cert parameter')
def connect_to_db(module, conn_params, autocommit=False, fail_on_conn=True):
    """"""Connect to a PostgreSQL database.
    Return psycopg2 connection object.
    Args:
        module (AnsibleModule) -- object of ansible.module_utils.basic.AnsibleModule class
        conn_params (dict) -- dictionary with connection parameters
    Kwargs:
        autocommit (bool) -- commit automatically (default False)
        fail_on_conn (bool) -- fail if connection failed or just warn and return None (default True)
    """"""
    ensure_required_libs(module)
        db_connection = psycopg2.connect(**conn_params)
        # Switch role, if specified:
        cursor = db_connection.cursor(cursor_factory=DictCursor)
        if module.params.get('session_role'):
            try:
                cursor.execute('SET ROLE %s' % module.params['session_role'])
            except Exception as e:
                module.fail_json(msg=""Could not switch role: %s"" % to_native(e))
        cursor.close()
        if fail_on_conn:
            module.fail_json(msg=""unable to connect to database: %s"" % to_native(e))
        else:
            module.warn(""PostgreSQL server is unavailable: %s"" % to_native(e))
            db_connection = None
        if fail_on_conn:
            module.fail_json(msg=""unable to connect to database: %s"" % to_native(e))
        else:
            module.warn(""PostgreSQL server is unavailable: %s"" % to_native(e))
            db_connection = None
def get_conn_params(module, params_dict, warn_db_default=True):
    """"""Get connection parameters from the passed dictionary.
    Return a dictionary with parameters to connect to PostgreSQL server.
    Args:
        module (AnsibleModule) -- object of ansible.module_utils.basic.AnsibleModule class
        params_dict (dict) -- dictionary with variables
    Kwargs:
        warn_db_default (bool) -- warn that the default DB is used (default True)
    """"""
    # To use defaults values, keyword arguments must be absent, so
    # check which values are empty and don't include in the return dictionary
    params_map = {
        ""login_host"": ""host"",
        ""login_user"": ""user"",
        ""login_password"": ""password"",
        ""port"": ""port"",
        ""ssl_mode"": ""sslmode"",
        ""ca_cert"": ""sslrootcert""
    }
    # Might be different in the modules:
    if params_dict.get('db'):
        params_map['db'] = 'database'
    elif params_dict.get('database'):
        params_map['database'] = 'database'
    elif params_dict.get('login_db'):
        params_map['login_db'] = 'database'
    else:
        if warn_db_default:
            module.warn('Database name has not been passed, '
                        'used default database to connect to.')
    kw = dict((params_map[k], v) for (k, v) in iteritems(params_dict)
              if k in params_map and v != '' and v is not None)
    # If a login_unix_socket is specified, incorporate it here.
    is_localhost = ""host"" not in kw or kw[""host""] is None or kw[""host""] == ""localhost""
    if is_localhost and params_dict[""login_unix_socket""] != """":
        kw[""host""] = params_dict[""login_unix_socket""]
    return kw
"
-------------------------------------------------------------------------
"Recom
PRs: 55799, 57473"
-------------------------------------------------------------------------
=========================================================================
"from psycopg2.extras import DictCursor
# psycopg2 is checked by connect_to_db()
# from ansible.module_utils.postgres
pass
 ansible.module_utils.basic import AnsibleModule
"
-------------------------------------------------------------------------
"# Load required library information from stable version
from ansible.module_utils.basic import AnsibleModule
from ansible.module_utils.postgres import connect_to_db
from psycopg2 import extras

# psycopg2 is checked by connect_to_db()
# psycopg2.extras is necessary for DictCursor"
-------------------------------------------------------------------------
"from psycopg2.extras import DictCursor
# psycopg2 is checked by connect_to_db()
# from ansible.module_utils.postgres
pass
 ansible.module_utils.basic import AnsibleModule
 ansible.module_utils.postgres import (
connect_to_db,
get_conn_params,
postgres_common_argument_spec,
"
-------------------------------------------------------------------------
"Recom
PRs: 55799, 57473"
-------------------------------------------------------------------------
=========================================================================
"db_connection = connect_to_db(module, autocommit=True)
cursor = db_connection.cursor(cursor_factory=DictCursor)
"
-------------------------------------------------------------------------
"db_conn_params = get_conn_params(module)
db_connection = connect_to_db(module, autocommit=True, **db_conn_params)
cursor = db_connection.cursor(cursor_factory=DictCursor)"
-------------------------------------------------------------------------
"conn_params = get_conn_params(module, module.params)
db_connection = connect_to_db(module, conn_params, autocommit=True)
cursor = db_connection.cursor(cursor_factory=DictCursor)
"
-------------------------------------------------------------------------
"Recom
PRs: 55799, 57473"
-------------------------------------------------------------------------
=========================================================================
"from psycopg2.extras import DictCursor
# psycopg2 is checked by connect_to_db()
# from ansible.module_utils.postgres
pass
 ansible.module_utils.basic import AnsibleModule
"
-------------------------------------------------------------------------
"from ansible.module_utils.basic import AnsibleModule
from ansible.module_utils.postgres import connect_to_db
from ansible.module_utils.postgres import pg_quote_identifier
from ansible.module_utils.postgres import parse_privs
from ansible.module_utils.postgres import user_exists
from ansible.module_utils.postgres import user_alter
from ansible.module_utils.postgres import user_add
from ansible.module_utils.postgres import grant_privileges
from ansible.module_utils.postgres import revoke_privileges
from ansible.module_utils.postgres import user_delete
from ansible.module_utils.database import SQLParseError
from itertools import chain
import re
import psycopg2
import psycopg2.extras
import traceback
from ansible.module_utils.six import iteritems
from ansible.module_utils._text import to_native

def main():
    argument_spec = postgres_common_argument_spec()
    argument_spec.update(
        user=dict(type='str', required=True, aliases=['name']),
        password=dict(type='str', default=None, no_log=True),
        state=dict(type='str', default='present', choices=['absent', 'present']),
        priv=dict(type='str', default=None),
        db=dict(type='str', default='', aliases=['login_db']),
        fail_on_user=dict(type='bool', default='yes', aliases=['fail_on_role']),
        role_attr_flags=dict(type='str', default=''),
        encrypted=dict(type='bool', default='yes'),
        no_password_changes=dict(type='bool', default='no'),
        expires=dict(type='str', default=None),
        conn_limit=dict(type='int', default=None),
        session_role=dict(type='str'),
    )
    module = AnsibleModule(
        argument_spec=argument_spec,
        supports_check_mode=True
    )

    user = module.params[""user""]
    password = module.params[""password""]
    state = module.params[""state""]
    fail_on_user = module.params[""fail_on_user""]
    db = module.params[""db""]
    session_role = module.params[""session_role""]
    if db == '' and module.params[""priv""] is not None:
        module.fail_json(msg=""privileges require a database to be specified"")
    privs = parse_privs(module.params[""priv""], db)
    no_password_changes = module.params[""no_password_changes""]
    if module.params[""encrypted""]:
        encrypted = ""ENCRYPTED""
    else:
        encrypted = ""UNENCRYPTED""
    expires = module.params[""expires""]
    sslrootcert = module.params[""ca_cert""]
    conn_limit = module.params[""conn_limit""]
    role_attr_flags = module.params[""role_attr_flags""]

    if not HAS_PSYCOPG2:
        module.fail_json(msg=missing_required_lib('psycopg2'), exception=PSYCOPG2_IMP_ERR)

    # To use defaults values, keyword arguments must be absent, so
    # check which values are empty and don't include in the **kw
    # dictionary
    params_map = {
        ""login_host"": ""host"",
        ""login_user"": ""user"",
        ""login_password"": ""password"",
        ""port"": ""port"",
        ""db"": ""database"",
        ""ssl_mode"": ""sslmode"",
        ""ca_cert"": ""sslrootcert""
    }
    kw = dict((params_map[k], v) for (k, v) in iteritems(module.params)
              if k in params_map and v != """" and v is not None)

    # If a login_unix_socket is specified, incorporate it here.
    is_localhost = ""host"" not in kw or kw[""host""] == """" or kw[""host""] == ""localhost""
    if is_localhost and module.params[""login_unix_socket""] != """":
        kw[""host""] = module.params[""login_unix_socket""]

    if psycopg2.__version__ < '2.4.3' and sslrootcert is not None:
        module.fail_json(
            msg='psycopg2 must be at least 2.4.3 in order to user the ca_cert parameter')

    try:
        db_connection = psycopg2.connect(**kw)
        cursor = db_connection.cursor(
            cursor_factory=psycopg2.extras.DictCursor)

    except TypeError as e:
        if 'sslrootcert' in e.args[0]:
            module.fail_json(
                msg='Postgresql server must be at least version 8.4 to support sslrootcert')
        module.fail_json(msg=""Unable to connect to database: %s"" % to_native(e), exception=traceback.format_exc())

    except Exception as e:
        module.fail_json(msg=""Unable to connect to database: %s"" % to_native(e), exception=traceback.format_exc())

    if session_role:
        try:
            cursor.execute('SET ROLE %s' % pg_quote_identifier(session_role, 'role'))
        except Exception as e:
            module.fail_json(msg=""Could not switch role: %s"" % to_native(e), exception=traceback.format_exc())

    try:
        role_attr_flags = parse_role_attrs(cursor, role_attr_flags)
    except InvalidFlagsError as e:
        module.fail_json(msg=to_native(e), exception=traceback.format_exc())

    kw = dict(user=user)
    changed = False
    user_removed = False

    if state == ""present"":
        if user_exists(cursor, user):
            try:
                changed = user_alter(db_connection, module, user, password,
                                     role_attr_flags, encrypted, expires, no_password_changes, conn_limit)
            except SQLParseError as e:
                module.fail_json(msg=to_native(e), exception=traceback.format_exc())
        else:
            try:
                changed = user_add(cursor, user, password,
                                   role_attr_flags, encrypted, expires, conn_limit)
            except psycopg2.ProgrammingError as e:
                module.fail_json(msg=""Unable to add user with given requirement ""
                                     ""due to : %s"" % to_native(e),
                                 exception=traceback.format_exc())
            except SQLParseError as e:
                module.fail_json(msg=to_native(e), exception=traceback.format_exc())
        try:
            changed = grant_privileges(cursor, user, privs) or changed
        except SQLParseError as e:
            module.fail_json(msg=to_native(e), exception=traceback.format_exc())
    else:
        if user_exists(cursor, user):
            if module.check_mode:
                changed = True
                kw['user_removed'] = True
            else:
                try:
                    changed = revoke_privileges(cursor, user, privs)
                    user_removed = user_delete(cursor, user)
                except SQLParseError as e:
                    module.fail_json(msg=to_native(e), exception=traceback.format_exc())
                changed = changed or user_removed
                if fail_on_user and not user_removed:
                    msg = ""Unable to remove user""
                    module.fail_json(msg=msg)
                kw['user_removed'] = user_removed

    if changed:
        if module.check_mode:
            db_connection.rollback()
        else:
            db_connection.commit()

    kw['changed'] = changed
    kw['queries'] = executed_queries
    module.exit_json(**kw)"
-------------------------------------------------------------------------
"from psycopg2.extras import DictCursor
# psycopg2 is checked by connect_to_db()
# from ansible.module_utils.postgres
pass
 ansible.module_utils.basic import AnsibleModule
 ansible.module_utils.postgres import connect_to_db, get_conn_params, postgres_common_argument_spec
"
-------------------------------------------------------------------------
"Recom
PRs: 55799, 57473"
-------------------------------------------------------------------------
=========================================================================
"db_connection = connect_to_db(module, autocommit=True)
cursor = db_connection.cursor(cursor_factory=DictCursor)
"
-------------------------------------------------------------------------
"db_connection = ansible.module_utils.postgres.connect_to_db(module, autocommit=True)
cursor = db_connection.cursor(cursor_factory=psycopg2.extras.DictCursor)"
-------------------------------------------------------------------------
"conn_params = get_conn_params(module, module.params)
db_connection = connect_to_db(module, conn_params, autocommit=True)
cursor = db_connection.cursor(cursor_factory=DictCursor)
"
-------------------------------------------------------------------------
"Recom
PRs: 55799, 57473"
-------------------------------------------------------------------------
=========================================================================
"from psycopg2.extras import DictCursor
# psycopg2 is checked by connect_to_db()
# from ansible.module_utils.postgres
pass
 ansible.module_utils.postgres import connect_to_db, postgres_common_argument_spec
"
-------------------------------------------------------------------------
"# Required dependencies: psycopg2, ansible.module_utils.postgres

from ansible.module_utils.postgres import connect_to_db, postgres_common_argument_spec
from psycopg2 import extras

# psycopg2 is checked by connect_to_db()
# from ansible.module_utils.postgres"
-------------------------------------------------------------------------
"from psycopg2.extras import DictCursor
# psycopg2 is checked by connect_to_db()
# from ansible.module_utils.postgres
pass
 ansible.module_utils.postgres import connect_to_db, get_conn_params, postgres_common_argument_spec
"
-------------------------------------------------------------------------
"Recom
PRs: 55799, 57473"
-------------------------------------------------------------------------
=========================================================================
"def __init__(self, module):
    self.session_role = self.module.params.get('session_role')
        self.db_conn = connect_to_db(self.module, warn_db_default=False)
        self.cursor = self.db_conn.cursor(cursor_factory=DictCursor)
"
-------------------------------------------------------------------------
"def __init__(self, module):
    self.session_role = self.module.params.get('session_role')
    kw = get_conn_params(self.module)
    try:
        self.db_conn = psycopg2.connect(**kw)
        self.cursor = self.db_conn.cursor(cursor_factory=psycopg2.extras.DictCursor)
    except Exception as e:
        module.fail_json(msg=""Unable to connect to database: %s"" % ansible.module_utils._text.to_native(e), exception=traceback.format_exc())"
-------------------------------------------------------------------------
"def __init__(self, module):
    self.session_role = self.module.params.get('session_role')
    conn_params = get_conn_params(self.module, self.module.params, warn_db_default=False)
    self.db_conn = connect_to_db(self.module, conn_params)
    return self.db_conn.cursor(cursor_factory=DictCursor)
    self.module.params['database'] = dbname
"
-------------------------------------------------------------------------
"Recom
PRs: 55799, 57473"
-------------------------------------------------------------------------
=========================================================================
"self.module.params['database'] = dbname
"
-------------------------------------------------------------------------
self.module.params['db'] = dbname
-------------------------------------------------------------------------
"except Exception as e:
"
-------------------------------------------------------------------------
"Recom
PRs: 55799, 57473"
-------------------------------------------------------------------------
=========================================================================
"from ansible.module_utils.basic import AnsibleModule
"
-------------------------------------------------------------------------
from ansible.module_utils.basic import AnsibleModule
-------------------------------------------------------------------------
"from ansible.module_utils.basic import AnsibleModule
from ansible.module_utils.postgres import (
    connect_to_db,
    get_conn_params,
    postgres_common_argument_spec,
)
"
-------------------------------------------------------------------------
"Recom
PRs: 55799, 57473"
-------------------------------------------------------------------------
=========================================================================
"db_connection = connect_to_db(module, autocommit=False)
cursor = db_connection.cursor()
"
-------------------------------------------------------------------------
"# Required dependencies: ansible.module_utils.postgres.connect_to_db

# Use the connect_to_db function to establish a database connection
db_connection = connect_to_db(self.module, autocommit=False)

# Create a cursor object to execute SQL queries
cursor = db_connection.cursor()"
-------------------------------------------------------------------------
"conn_params = get_conn_params(module, module.params)
db_connection = connect_to_db(module, conn_params, autocommit=False)
cursor = db_connection.cursor()
"
-------------------------------------------------------------------------
"Recom
PRs: 55799, 57473"
-------------------------------------------------------------------------
=========================================================================
"from psycopg2.extras import DictCursor
# psycopg2 is checked by connect_to_db()
# from ansible.module_utils.postgres
pass
 ansible.module_utils.basic import AnsibleModule
"
-------------------------------------------------------------------------
"from ansible.module_utils.basic import AnsibleModule
from ansible.module_utils.postgres import connect_to_db
from psycopg2.extras import DictCursor"
-------------------------------------------------------------------------
"from psycopg2.extras import DictCursor
# psycopg2 is checked by connect_to_db()
# from ansible.module_utils.postgres
pass
 ansible.module_utils.basic import AnsibleModule
 ansible.module_utils.postgres import connect_to_db, get_conn_params, postgres_common_argument_spec
"
-------------------------------------------------------------------------
"Recom
PRs: 55799, 57473"
-------------------------------------------------------------------------
=========================================================================
"    db_connection = connect_to_db(module, autocommit=False)
    cursor = db_connection.cursor(cursor_factory=DictCursor)
"
-------------------------------------------------------------------------
"db_connection = ansible.module_utils.postgres.connect_to_db(module, autocommit=False)
cursor = db_connection.cursor(cursor_factory=psycopg2.extras.DictCursor)"
-------------------------------------------------------------------------
"    conn_params = get_conn_params(module, module.params)
    db_connection = connect_to_db(module, conn_params, autocommit=False)
    cursor = db_connection.cursor(cursor_factory=DictCursor)
"
-------------------------------------------------------------------------
"Recom
PRs: 55799, 57473"
-------------------------------------------------------------------------
=========================================================================
"from psycopg2.extras import DictCursor
# psycopg2 is checked by connect_to_db()
# from ansible.module_utils.postgres
pass
 ansible.module_utils.basic import AnsibleModule
""""""
If you want to add handling of a new type of database objects:
1. Add a specific method for this like self.__set_db_owner(), etc.
2. Add a condition with a check of ownership for new type objects to self.__is_owner()
3. Add a condition with invocation of the specific method to self.set_owner()
4. Add the information to the module documentation
That's all.
""""""
"
-------------------------------------------------------------------------
"from psycopg2.extras import DictCursor
from ansible.module_utils.basic import AnsibleModule

""""""
If you want to add handling of a new type of database objects:
1. Add a specific method for this like class_method_add_db_owner(), etc.
2. Add a condition with a check of ownership for new type objects to class_method_is_owner()
3. Add a condition with invocation of the specific method to self.set_owner()
4. Add the information to the module documentation
That's all.
"""""""
-------------------------------------------------------------------------
"from psycopg2.extras import DictCursor
# psycopg2 is checked by connect_to_db()
# from ansible.module_utils.postgres
pass
 ansible.module_utils.basic import AnsibleModule
 ansible.module_utils.postgres import connect_to_db, get_conn_params, postgres_common_argument_spec
""""""
If you want to add handling of a new type of database objects:
1. Add a specific method for this like self.__set_db_owner(), etc.
2. Add a condition with a check of ownership for new type objects to self.__is_owner()
3. Add a condition with invocation of the specific method to self.set_owner()
4. Add the information to the module documentation
That's all.
""""""
"
-------------------------------------------------------------------------
"Recom
PRs: 55799, 57473"
-------------------------------------------------------------------------
=========================================================================
"    db_connection = connect_to_db(module, autocommit=False)
    cursor = db_connection.cursor(cursor_factory=DictCursor)
"
-------------------------------------------------------------------------
"db_connection = psycopg2.connect(**kw)
cursor = db_connection.cursor(cursor_factory=psycopg2.extras.DictCursor)"
-------------------------------------------------------------------------
"    conn_params = get_conn_params(module, module.params)
    db_connection = connect_to_db(module, conn_params, autocommit=False)
    cursor = db_connection.cursor(cursor_factory=DictCursor)
"
-------------------------------------------------------------------------
"Recom
PRs: 55799, 57473"
-------------------------------------------------------------------------
=========================================================================
"from psycopg2.extras import DictCursor
# psycopg2 is checked by connect_to_db()
# from ansible.module_utils.postgres
pass
 ansible.module_utils.postgres import connect_to_db, postgres_common_argument_spec
"
-------------------------------------------------------------------------
"# Library information from Stable
from ansible.module_utils.postgres import connect_to_db, postgres_common_argument_spec
from ansible.module_utils.postgres import exec_sql, get_conn_params, parse_privs, \
    user_exists, user_alter, user_add, user_delete, grant_privileges, revoke_privileges
from ansible.module_utils._text import to_native, to_bytes
from ansible.module_utils.database import SQLParseError
from ansible.module_utils.basic import AnsibleModule
from ansible.module_utils.postgres import pg_quote_identifier

# psycopg2 is checked by connect_to_db()
# from ansible.module_utils.postgres
from psycopg2.extras import DictCursor"
-------------------------------------------------------------------------
"from psycopg2.extras import DictCursor
# psycopg2 is checked by connect_to_db()
# from ansible.module_utils.postgres
pass
 ansible.module_utils.postgres import connect_to_db, get_conn_params, postgres_common_argument_spec
"
-------------------------------------------------------------------------
"Recom
PRs: 55799, 57473"
-------------------------------------------------------------------------
=========================================================================
"db_connection = connect_to_db(module, fail_on_conn=False)
if db_connection is not None:
    cursor = db_connection.cursor(cursor_factory=DictCursor)
"
-------------------------------------------------------------------------
"# Required library information from Stable:
from ansible.module_utils.postgres.connect_to_db import connect_to_db
from psycopg2.extras import DictCursor

# Remaining code using stable identifiers
db_connection = connect_to_db(module, fail_on_conn=False)
if db_connection is not None:
    cursor = db_connection.cursor(cursor_factory=DictCursor)"
-------------------------------------------------------------------------
"conn_params = get_conn_params(module, module.params)
db_connection = connect_to_db(module, conn_params, fail_on_conn=False)
if db_connection is not None:
    cursor = db_connection.cursor(cursor_factory=DictCursor)
"
-------------------------------------------------------------------------
"Recom
PRs: 55799, 57473"
-------------------------------------------------------------------------
=========================================================================
"from psycopg2 import ProgrammingError as Psycopg2ProgrammingError
from psycopg2.extras import DictCursor
# it is needed for checking 'no result to fetch' in main(),
# psycopg2 availability will be checked by connect_to_db() into
# ansible.module_utils.postgres
pass
 ansible.module_utils.basic import AnsibleModule
"
-------------------------------------------------------------------------
"from psycopg2 import ProgrammingError as Psycopg2ProgrammingError
from psycopg2.extras import DictCursor
# psycopg2 availability will be checked by connect_to_db() into ansible.module_utils.postgres
from ansible.module_utils.basic import AnsibleModule"
-------------------------------------------------------------------------
"from psycopg2 import ProgrammingError as Psycopg2ProgrammingError
from psycopg2.extras import DictCursor
# it is needed for checking 'no result to fetch' in main(),
# psycopg2 availability will be checked by connect_to_db() into
# ansible.module_utils.postgres
pass
 ansible.module_utils.basic import AnsibleModule
 ansible.module_utils.postgres import connect_to_db, get_conn_params, postgres_common_argument_spec
"
-------------------------------------------------------------------------
"Recom
PRs: 55799, 57473"
-------------------------------------------------------------------------
=========================================================================
"db_connection = connect_to_db(module, autocommit=False)
cursor = db_connection.cursor(cursor_factory=DictCursor)
if module.params.get(""positional_args""):
elif module.params.get(""named_args""):
"
-------------------------------------------------------------------------
"#######################################
# STABLE: PostgreSQL modules: move params mapping from main to connect_to_db() function
# STABLE: Backport/2.8/55799
#######################################

db_connection = connect_to_db(module, autocommit=False)
cursor = db_connection.cursor(cursor_factory=DictCursor)
if args := module.params.get(""positional_args""):
    # Include statements related to positional arguments
elif args := module.params.get(""named_args""):
    # Include statements related to named arguments"
-------------------------------------------------------------------------
"conn_params = get_conn_params(module, module.params)
db_connection = connect_to_db(module, conn_params, autocommit=False)
cursor = db_connection.cursor(cursor_factory=DictCursor)
if module.params.get(""positional_args""):
elif module.params.get(""named_args""):
"
-------------------------------------------------------------------------
"Recom
PRs: 55799, 57473"
-------------------------------------------------------------------------
=========================================================================
"from psycopg2.extras import DictCursor
# psycopg2 is checked by connect_to_db()
# from ansible.module_utils.postgres
pass
 ansible.module_utils.basic import AnsibleModule
"
-------------------------------------------------------------------------
"from ansible.module_utils.basic import AnsibleModule
from psycopg2.extras import DictCursor"
-------------------------------------------------------------------------
"from psycopg2.extras import DictCursor
# psycopg2 is checked by connect_to_db()
# from ansible.module_utils.postgres
pass
 ansible.module_utils.basic import AnsibleModule
 ansible.module_utils.postgres import (
connect_to_db,
get_conn_params,
postgres_common_argument_spec,
"
-------------------------------------------------------------------------
"Recom
PRs: 55799, 57473"
-------------------------------------------------------------------------
=========================================================================
"db_connection = connect_to_db(module, autocommit=True)
cursor = db_connection.cursor(cursor_factory=DictCursor)
"
-------------------------------------------------------------------------
"db_conn_params = get_conn_params(module)
db_connection = connect_to_db(db_conn_params, autocommit=True)
cursor = db_connection.cursor(cursor_factory=DictCursor)"
-------------------------------------------------------------------------
"conn_params = get_conn_params(module, module.params)
db_connection = connect_to_db(module, conn_params, autocommit=True)
cursor = db_connection.cursor(cursor_factory=DictCursor)
"
-------------------------------------------------------------------------
"Recom
PRs: 55799, 57473"
-------------------------------------------------------------------------
=========================================================================
"try:
    from psycopg2.extras import DictCursor
except Exception:
    # psycopg2 is checked by connect_to_db()
    # from ansible.module_utils.postgres
    pass
from ansible.module_utils.basic import AnsibleModule
from ansible.module_utils.postgres import connect_to_db, postgres_common_argument_spec
PG_REQ_VER = 90400
"
-------------------------------------------------------------------------
"try:
    from psycopg2.extras import DictCursor
except Exception:
    pass
from ansible.module_utils.basic import AnsibleModule
from ansible.module_utils.postgres import connect_to_db, postgres_common_argument_spec
from ansible.module_utils.postgres import HAS_PSYCOPG2 as PG_REQ_VER"
-------------------------------------------------------------------------
"try:
    from psycopg2.extras import DictCursor
except Exception:
    # psycopg2 is checked by connect_to_db()
    # from ansible.module_utils.postgres
    pass
from ansible.module_utils.basic import AnsibleModule
from ansible.module_utils.postgres import connect_to_db, get_conn_params, postgres_common_argument_spec
PG_REQ_VER = 90400
"
-------------------------------------------------------------------------
"Recom
PRs: 55799, 57473"
-------------------------------------------------------------------------
=========================================================================
"db_connection = connect_to_db(module, autocommit=True, warn_db_default=False)
cursor = db_connection.cursor(cursor_factory=DictCursor)
kw = {}
ver = db_connection.server_version
"
-------------------------------------------------------------------------
"db_conn = connect_to_db(module, autocommit=True, warn_db_default=False)
cursor = db_conn.cursor(cursor_factory=psycopg2.extras.DictCursor)
kw = {}
ver = db_conn.server_version"
-------------------------------------------------------------------------
"conn_params = get_conn_params(module, module.params, warn_db_default=False)
db_connection = connect_to_db(module, conn_params, autocommit=True)
cursor = db_connection.cursor(cursor_factory=DictCursor)
kw = {}
ver = db_connection.server_version
"
-------------------------------------------------------------------------
"Recom
PRs: 55799, 57473"
-------------------------------------------------------------------------
=========================================================================
"db_connection = connect_to_db(module, autocommit=True)
cursor = db_connection.cursor(cursor_factory=DictCursor)
"
-------------------------------------------------------------------------
"db_conn_params = get_conn_params(module)
db_connection = connect_to_db(db_conn_params, autocommit=True)
cursor = db_connection.cursor(cursor_factory=DictCursor)"
-------------------------------------------------------------------------
"db_connection = connect_to_db(module, conn_params, autocommit=True)
cursor = db_connection.cursor(cursor_factory=DictCursor)
"
-------------------------------------------------------------------------
"Recom
PRs: 55799, 57473"
-------------------------------------------------------------------------
=========================================================================
"from psycopg2.extras import DictCursor
# psycopg2 is checked by connect_to_db()
# from ansible.module_utils.postgres
pass
 ansible.module_utils.basic import AnsibleModule
 ansible.module_utils.postgres import connect_to_db, postgres_common_argument_spec
"
-------------------------------------------------------------------------
"from ansible.module_utils.basic import AnsibleModule
    from ansible.module_utils.postgres import connect_to_db, postgres_common_argument_spec
    from psycopg2.extras import DictCursor"
-------------------------------------------------------------------------
"from psycopg2.extras import DictCursor
# psycopg2 is checked by connect_to_db()
# from ansible.module_utils.postgres
pass
 ansible.module_utils.basic import AnsibleModule
 ansible.module_utils.postgres import connect_to_db, get_conn_params, postgres_common_argument_spec
"
-------------------------------------------------------------------------
"Recom
PRs: 55799, 57473"
-------------------------------------------------------------------------
=========================================================================
"db_connection = connect_to_db(module, autocommit=True)
cursor = db_connection.cursor(cursor_factory=DictCursor)
"
-------------------------------------------------------------------------
"# Import required libraries
from __future__ import print_function
import ansible.module_utils.postgres as pgutils
from ansible.module_utils.database import SQLParseError
from ansible.module_utils.postgres import connect_to_db, postgres_common_argument_spec
from ansible.module_utils._text import to_native
import psycopg2.extras

# Connect to the database
db_connection = connect_to_db(module, autocommit=True)
cursor = db_connection.cursor(cursor_factory=psycopg2.extras.DictCursor)"
-------------------------------------------------------------------------
"conn_params = get_conn_params(module, module.params)
db_connection = connect_to_db(module, conn_params, autocommit=True)
cursor = db_connection.cursor(cursor_factory=DictCursor)
"
-------------------------------------------------------------------------
"Recom
PRs: 55799, 57473"
-------------------------------------------------------------------------
=========================================================================
"from psycopg2.extras import DictCursor
# psycopg2 is checked by connect_to_db()
# from ansible.module_utils.postgres
pass
 ansible.module_utils.basic import AnsibleModule
"
-------------------------------------------------------------------------
"from ansible.module_utils.basic import AnsibleModule
from ansible.module_utils.postgres import connect_to_db
from psycopg2.extras import DictCursor"
-------------------------------------------------------------------------
"from psycopg2.extras import DictCursor
# psycopg2 is checked by connect_to_db()
# from ansible.module_utils.postgres
pass
 ansible.module_utils.basic import AnsibleModule
 ansible.module_utils.postgres import connect_to_db, get_conn_params, postgres_common_argument_spec
"
-------------------------------------------------------------------------
"Recom
PRs: 55799, 57473"
-------------------------------------------------------------------------
=========================================================================
"db_connection = connect_to_db(module, autocommit=False)
cursor = db_connection.cursor(cursor_factory=DictCursor)
"
-------------------------------------------------------------------------
"db_connection = ansible.module_utils.postgres.connect_to_db(module, autocommit=False)
cursor = db_connection.cursor(cursor_factory=psycopg2.extras.DictCursor)"
-------------------------------------------------------------------------
"conn_params = get_conn_params(module, module.params)
db_connection = connect_to_db(module, conn_params, autocommit=False)
cursor = db_connection.cursor(cursor_factory=DictCursor)
"
-------------------------------------------------------------------------
"Recom
PRs: 55799, 57473"
-------------------------------------------------------------------------
=========================================================================
"from psycopg2 import __version__ as PSYCOPG2_VERSION
from psycopg2.extras import DictCursor
from psycopg2.extensions import ISOLATION_LEVEL_AUTOCOMMIT as AUTOCOMMIT
from psycopg2.extensions import ISOLATION_LEVEL_READ_COMMITTED as READ_COMMITTED
# psycopg2 is checked by connect_to_db()
# from ansible.module_utils.postgres
pass
 ansible.module_utils.basic import AnsibleModule
"
-------------------------------------------------------------------------
"from psycopg2 import __version__ as PSYCOPG2_VERSION
from psycopg2.extras import DictCursor
from psycopg2.extensions import ISOLATION_LEVEL_AUTOCOMMIT as AUTOCOMMIT
from psycopg2.extensions import ISOLATION_LEVEL_READ_COMMITTED as READ_COMMITTED

from ansible.module_utils.basic import AnsibleModule"
-------------------------------------------------------------------------
"from psycopg2 import __version__ as PSYCOPG2_VERSION
from psycopg2.extras import DictCursor
from psycopg2.extensions import ISOLATION_LEVEL_AUTOCOMMIT as AUTOCOMMIT
from psycopg2.extensions import ISOLATION_LEVEL_READ_COMMITTED as READ_COMMITTED
# psycopg2 is checked by connect_to_db()
# from ansible.module_utils.postgres
pass
 ansible.module_utils.basic import AnsibleModule
 ansible.module_utils.postgres import connect_to_db, get_conn_params, postgres_common_argument_spec
"
-------------------------------------------------------------------------
"Recom
PRs: 55799, 57473"
-------------------------------------------------------------------------
=========================================================================
"db_connection = connect_to_db(module, autocommit=True)
cursor = db_connection.cursor(cursor_factory=DictCursor)
    if PSYCOPG2_VERSION >= '2.4.2':
        db_connection.set_isolation_level(READ_COMMITTED)
"
-------------------------------------------------------------------------
"db_connection = psycopg2.connect(**kw)
cursor = db_connection.cursor(cursor_factory=DictCursor)

if psycopg2.__version__ >= '2.4.2':
    db_connection.set_isolation_level(psycopg2.extensions.ISOLATION_LEVEL_READ_COMMITTED)"
-------------------------------------------------------------------------
"conn_params = get_conn_params(module, module.params)
db_connection = connect_to_db(module, conn_params, autocommit=True)
cursor = db_connection.cursor(cursor_factory=DictCursor)
    if PSYCOPG2_VERSION >= '2.4.2':
        db_connection.set_isolation_level(READ_COMMITTED)
"
-------------------------------------------------------------------------
"Recom
PRs: 55799, 57473"
-------------------------------------------------------------------------
=========================================================================
"from psycopg2.extras import DictCursor
# psycopg2 is checked by connect_to_db()
# from ansible.module_utils.postgres
pass
 ansible.module_utils.basic import AnsibleModule
 ansible.module_utils.postgres import connect_to_db, postgres_common_argument_spec
"
-------------------------------------------------------------------------
"from ansible.module_utils.basic import AnsibleModule
from ansible.module_utils.postgres import connect_to_db, postgres_common_argument_spec
from psycopg2 import extras as psycopg2__extras

# psycopg2 is checked by connect_to_db()
# from ansible.module_utils.postgres"
-------------------------------------------------------------------------
"from psycopg2.extras import DictCursor
# psycopg2 is checked by connect_to_db()
# from ansible.module_utils.postgres
pass
 ansible.module_utils.basic import AnsibleModule
 ansible.module_utils.postgres import (
connect_to_db,
get_conn_params,
postgres_common_argument_spec,
"
-------------------------------------------------------------------------
"Recom
PRs: 55799, 57473"
-------------------------------------------------------------------------
=========================================================================
"if module.params['db'] == '' and module.params[""priv""] is not None:
privs = parse_privs(module.params[""priv""], module.params[""db""])
db_connection = connect_to_db(module, warn_db_default=False)
cursor = db_connection.cursor(cursor_factory=DictCursor)
"
-------------------------------------------------------------------------
"if ansible_module.params['db'] == '' and ansible_module.params[""priv""] is not None:
    privs = parse_privs(ansible_module.params[""priv""], ansible_module.params[""db""])
    db_connection = ansible_module_utils_postgres_connect_to_db.connect_to_db(ansible_module, warn_db_default=False)
    cursor = db_connection.cursor(cursor_factory=psycopg2.extras.DictCursor)"
-------------------------------------------------------------------------
"if module.params['db'] == '' and module.params[""priv""] is not None:
privs = parse_privs(module.params[""priv""], module.params[""db""])
conn_params = get_conn_params(module, module.params, warn_db_default=False)
db_connection = connect_to_db(module, conn_params)
cursor = db_connection.cursor(cursor_factory=DictCursor)
"
-------------------------------------------------------------------------
"Recom
PRs: 55799, 57473"
-------------------------------------------------------------------------
=========================================================================
"if client.module.params['build'].get(build_option, default_value) != default_value:
"
-------------------------------------------------------------------------
"if parameters.get('build').get(build_option, default_value) != default_value:"
-------------------------------------------------------------------------
"if client.module.params['build'].get(build_option, default_value) != default_value:
client.fail('If ""source"" is set to ""build"", the ""build.path"" option must be specified.')
"
-------------------------------------------------------------------------
"Recom
PRs: 56610, 57085"
-------------------------------------------------------------------------
=========================================================================
"if to_text(out, errors='surrogate_then_replace').strip().endswith('#'):
"
-------------------------------------------------------------------------
"if _text.to_text(out, errors='surrogate_then_replace').strip().endswith('#'):"
-------------------------------------------------------------------------
"        if to_text(out, errors='surrogate_then_replace').strip().endswith('#'):
            conn.send_command('exit discard')
"
-------------------------------------------------------------------------
"Recom
PRs: 56389, 56401"
-------------------------------------------------------------------------
=========================================================================
"if to_text(out, errors='surrogate_then_replace').strip().endswith('#'):
"
-------------------------------------------------------------------------
"if _text.to_text(out, errors='surrogate_then_replace').strip().endswith('#'):"
-------------------------------------------------------------------------
"if to_text(out, errors='surrogate_then_replace').strip().endswith('#'):
    conn.send_command('exit discard')
"
-------------------------------------------------------------------------
"Recom
PRs: 56389, 56399"
-------------------------------------------------------------------------
=========================================================================
"p = subprocess.Popen(
    local_cmd,
    stdin=subprocess.PIPE,
    stdout=subprocess.PIPE,
    stderr=subprocess.PIPE,
)
if self.become and self.become.expect_prompt() and sudoable:
    display.debug(""handling privilege escalation"")
    fcntl.fcntl(p.stdout, fcntl.F_SETFL, fcntl.fcntl(p.stdout, fcntl.F_GETFL) | os.O_NONBLOCK)
    fcntl.fcntl(p.stderr, fcntl.F_SETFL, fcntl.fcntl(p.stderr, fcntl.F_GETFL) | os.O_NONBLOCK)
    selector = selectors.DefaultSelector()
    selector.register(p.stdout, selectors.EVENT_READ)
    selector.register(p.stderr, selectors.EVENT_READ)
    become_output = b''
    try:
        while not self.become.check_success(become_output) and not self.become.check_password_prompt(become_output):
            events = selector.select(self._play_context.timeout)
            if not events:
                stdout, stderr = p.communicate()
                raise AnsibleError('timeout waiting for privilege escalation password prompt:\n'  to_native(become_output))
            for key, event in events:
                if key.fileobj == p.stdout:
                    chunk = p.stdout.read()
                    break
                elif key.fileobj == p.stderr:
                    chunk = p.stderr.read()
            if not chunk:
                stdout, stderr = p.communicate()
                raise AnsibleError('privilege output closed while waiting for password prompt:\n'  to_native(become_output))
            become_output = chunk
    finally:
        selector.close()
    if not self.become.check_success(become_output):
        p.stdin.write(to_bytes(self._play_context.become_pass, errors='surrogate_or_strict')  b'\n')
    fcntl.fcntl(p.stdout, fcntl.F_SETFL, fcntl.fcntl(p.stdout, fcntl.F_GETFL) & ~os.O_NONBLOCK)
    fcntl.fcntl(p.stderr, fcntl.F_SETFL, fcntl.fcntl(p.stderr, fcntl.F_GETFL) & ~os.O_NONBLOCK)
display.debug(""getting output with communicate()"")
display.debug(""done communicating"")
display.debug(""done with docker.exec_command()"")
"
-------------------------------------------------------------------------
"p = subprocess.Popen(
    local_cmd,
    stdin=subprocess.PIPE,
    stdout=subprocess.PIPE,
    stderr=subprocess.PIPE,
)
if self.become and self.become.expect_prompt() and sudoable:
    display.debug(""handling privilege escalation"")
    fcntl.fcntl(p.stdout, fcntl.F_SETFL, fcntl.fcntl(p.stdout, fcntl.F_GETFL) | os.O_NONBLOCK)
    fcntl.fcntl(p.stderr, fcntl.F_SETFL, fcntl.fcntl(p.stderr, fcntl.F_GETFL) | os.O_NONBLOCK)
    import ansible.compat.selectors
    selector = selectors.DefaultSelector()
    selector.register(p.stdout, selectors.EVENT_READ)
    selector.register(p.stderr, selectors.EVENT_READ)
    become_output = b''
    try:
        while not self.become.check_success(become_output) and not self.become.check_password_prompt(become_output):
            events = selector.select(self._play_context.timeout)
            if not events:
                stdout, stderr = p.communicate()
                raise AnsibleError('timeout waiting for privilege escalation password prompt:\n'  to_native(become_output))
            for key, event in events:
                if key.fileobj == p.stdout:
                    chunk = p.stdout.read()
                    break
                elif key.fileobj == p.stderr:
                    chunk = p.stderr.read()
            if not chunk:
                stdout, stderr = p.communicate()
                raise AnsibleError('privilege output closed while waiting for password prompt:\n'  to_native(become_output))
            become_output = chunk
    finally:
        selector.close()
    if not self.become.check_success(become_output):
        p.stdin.write(to_bytes(self._play_context.become_pass, errors='surrogate_or_strict')  b'\n')
    fcntl.fcntl(p.stdout, fcntl.F_SETFL, fcntl.fcntl(p.stdout, fcntl.F_GETFL) & ~os.O_NONBLOCK)
    fcntl.fcntl(p.stderr, fcntl.F_SETFL, fcntl.fcntl(p.stderr, fcntl.F_GETFL) & ~os.O_NONBLOCK)
display.debug(""getting output with communicate()"")
display.debug(""done communicating"")
display.debug(""done with docker.exec_command()"")"
-------------------------------------------------------------------------
"p = subprocess.Popen(
    local_cmd,
    stdin=subprocess.PIPE,
    stdout=subprocess.PIPE,
    stderr=subprocess.PIPE,
)
if self._play_context.prompt and sudoable:
    fcntl.fcntl(p.stdout, fcntl.F_SETFL, fcntl.fcntl(p.stdout, fcntl.F_GETFL) | os.O_NONBLOCK)
    fcntl.fcntl(p.stderr, fcntl.F_SETFL, fcntl.fcntl(p.stderr, fcntl.F_GETFL) | os.O_NONBLOCK)
    selector = selectors.DefaultSelector()
    selector.register(p.stdout, selectors.EVENT_READ)
    selector.register(p.stderr, selectors.EVENT_READ)
    become_output = b''
    try:
        while not self.check_become_success(become_output) and not self.check_password_prompt(become_output):
            events = selector.select(self._play_context.timeout)
            if not events:
                stdout, stderr = p.communicate()
                raise AnsibleError('timeout waiting for privilege escalation password prompt:\n'  to_native(become_output))
            for key, event in events:
                if key.fileobj == p.stdout:
                    chunk = p.stdout.read()
                elif key.fileobj == p.stderr:
                    chunk = p.stderr.read()
            if not chunk:
                stdout, stderr = p.communicate()
                raise AnsibleError('privilege output closed while waiting for password prompt:\n'  to_native(become_output))
            become_output = chunk
    finally:
        selector.close()
    if not self.check_become_success(become_output):
        p.stdin.write(to_bytes(self._play_context.become_pass, errors='surrogate_or_strict')  b'\n')
    fcntl.fcntl(p.stdout, fcntl.F_SETFL, fcntl.fcntl(p.stdout, fcntl.F_GETFL) & ~os.O_NONBLOCK)
    fcntl.fcntl(p.stderr, fcntl.F_SETFL, fcntl.fcntl(p.stderr, fcntl.F_GETFL) & ~os.O_NONBLOCK)
display.debug(""getting output with communicate()"")
display.debug(""done communicating"")
display.debug(""done with docker.exec_command()"")
"
-------------------------------------------------------------------------
"Recom
PRs: 55816, 56278"
-------------------------------------------------------------------------
=========================================================================
"p = subprocess.Popen(
    local_cmd,
    stdin=subprocess.PIPE,
    stdout=subprocess.PIPE,
    stderr=subprocess.PIPE,
)
if self.become and self.become.expect_prompt() and sudoable:
    display.debug(""handling privilege escalation"")
    fcntl.fcntl(p.stdout, fcntl.F_SETFL, fcntl.fcntl(p.stdout, fcntl.F_GETFL) | os.O_NONBLOCK)
    fcntl.fcntl(p.stderr, fcntl.F_SETFL, fcntl.fcntl(p.stderr, fcntl.F_GETFL) | os.O_NONBLOCK)
    selector = selectors.DefaultSelector()
    selector.register(p.stdout, selectors.EVENT_READ)
    selector.register(p.stderr, selectors.EVENT_READ)
    become_output = b''
    try:
        while not self.become.check_success(become_output) and not self.become.check_password_prompt(become_output):
            events = selector.select(self._play_context.timeout)
            if not events:
                stdout, stderr = p.communicate()
                raise AnsibleError('timeout waiting for privilege escalation password prompt:\n'  to_native(become_output))
            for key, event in events:
                if key.fileobj == p.stdout:
                    chunk = p.stdout.read()
                    break
                elif key.fileobj == p.stderr:
                    chunk = p.stderr.read()
            if not chunk:
                stdout, stderr = p.communicate()
                raise AnsibleError('privilege output closed while waiting for password prompt:\n'  to_native(become_output))
            become_output = chunk
    finally:
        selector.close()
    if not self.become.check_success(become_output):
        p.stdin.write(to_bytes(self._play_context.become_pass, errors='surrogate_or_strict')  b'\n')
    fcntl.fcntl(p.stdout, fcntl.F_SETFL, fcntl.fcntl(p.stdout, fcntl.F_GETFL) & ~os.O_NONBLOCK)
    fcntl.fcntl(p.stderr, fcntl.F_SETFL, fcntl.fcntl(p.stderr, fcntl.F_GETFL) & ~os.O_NONBLOCK)
display.debug(""getting output with communicate()"")
display.debug(""done communicating"")
display.debug(""done with docker.exec_command()"")
"
-------------------------------------------------------------------------
"p = subprocess.Popen(
    local_cmd,
    stdin=subprocess.PIPE,
    stdout=subprocess.PIPE,
    stderr=subprocess.PIPE,
)
if self.become and self.become.expect_prompt() and sudoable:
    display.debug(""handling privilege escalation"")
    fcntl.fcntl(p.stdout, fcntl.F_SETFL, fcntl.fcntl(p.stdout, fcntl.F_GETFL) | os.O_NONBLOCK)
    fcntl.fcntl(p.stderr, fcntl.F_SETFL, fcntl.fcntl(p.stderr, fcntl.F_GETFL) | os.O_NONBLOCK)
    selector = selectors.DefaultSelector()
    selector.register(p.stdout, selectors.EVENT_READ)
    selector.register(p.stderr, selectors.EVENT_READ)
    become_output = b''
    try:
        while not self.become.check_success(become_output) and not self.become.check_password_prompt(become_output):
            events = selector.select(self._play_context.timeout)
            if not events:
                stdout, stderr = p.communicate()
                raise AnsibleError('timeout waiting for privilege escalation password prompt:\n'  to_native(become_output))
            for key, event in events:
                if key.fileobj == p.stdout:
                    chunk = key.fileobj.read()
                    break
                elif key.fileobj == p.stderr:
                    chunk = key.fileobj.read()
            if not chunk:
                stdout, stderr = p.communicate()
                raise AnsibleError('privilege output closed while waiting for password prompt:\n'  to_native(become_output))
            become_output = chunk
    finally:
        selector.close()
    if not self.become.check_success(become_output):
        p.stdin.write(to_bytes(self._play_context.become_pass, errors='surrogate_or_strict') + b'\n')
    fcntl.fcntl(p.stdout, fcntl.F_SETFL, fcntl.fcntl(p.stdout, fcntl.F_GETFL) & ~os.O_NONBLOCK)
    fcntl.fcntl(p.stderr, fcntl.F_SETFL, fcntl.fcntl(p.stderr, fcntl.F_GETFL) & ~os.O_NONBLOCK)
display.debug(""getting output with communicate()"")
display.debug(""done communicating"")
display.debug(""done with docker.exec_command()"")"
-------------------------------------------------------------------------
"display.vvv(u""EXEC {0}"".format(to_text(local_cmd)), host=self._play_context.remote_addr)
display.debug(""opening command with Popen()"")
p = subprocess.Popen(
    local_cmd,
    stdin=subprocess.PIPE,
    stdout=subprocess.PIPE,
    stderr=subprocess.PIPE,
)
display.debug(""done running command with Popen()"")
if self.become and self.become.expect_prompt() and sudoable:
    fcntl.fcntl(p.stdout, fcntl.F_SETFL, fcntl.fcntl(p.stdout, fcntl.F_GETFL) | os.O_NONBLOCK)
    fcntl.fcntl(p.stderr, fcntl.F_SETFL, fcntl.fcntl(p.stderr, fcntl.F_GETFL) | os.O_NONBLOCK)
    selector = selectors.DefaultSelector()
    selector.register(p.stdout, selectors.EVENT_READ)
    selector.register(p.stderr, selectors.EVENT_READ)
    become_output = b''
    try:
        while not self.become.check_success(become_output) and not self.become.check_password_prompt(become_output):
            events = selector.select(self._play_context.timeout)
            if not events:
                stdout, stderr = p.communicate()
                raise AnsibleError('timeout waiting for privilege escalation password prompt:\n'  to_native(become_output))
            for key, event in events:
                if key.fileobj == p.stdout:
                    chunk = p.stdout.read()
                elif key.fileobj == p.stderr:
                    chunk = p.stderr.read()
            if not chunk:
                stdout, stderr = p.communicate()
                raise AnsibleError('privilege output closed while waiting for password prompt:\n'  to_native(become_output))
            become_output = chunk
    finally:
        selector.close()
    if not self.become.check_success(become_output):
        p.stdin.write(to_bytes(self._play_context.become_pass, errors='surrogate_or_strict')  b'\n')
    fcntl.fcntl(p.stdout, fcntl.F_SETFL, fcntl.fcntl(p.stdout, fcntl.F_GETFL) & ~os.O_NONBLOCK)
    fcntl.fcntl(p.stderr, fcntl.F_SETFL, fcntl.fcntl(p.stderr, fcntl.F_GETFL) & ~os.O_NONBLOCK)
display.debug(""getting output with communicate()"")
display.debug(""done communicating"")
display.debug(""done with docker.exec_command()"")
"
-------------------------------------------------------------------------
"Recom
PRs: 55816, 56277"
-------------------------------------------------------------------------
=========================================================================
"- Seconds to wait before reboot. Passed as a parameter to the reboot command.
- Seconds to wait after the reboot command was successful before attempting to validate the system rebooted successfully.
- This timeout is evaluated separately for both reboot verification and test command success so the
"
-------------------------------------------------------------------------
"# Maximum seconds to wait for machine to reboot and respond to a test command
        # maximum execution time for the module is twice this amount.
        # On Linux, macOS, and OpenBSD, this is converted to minutes and rounded down. If less than 60, it will be set to 0.
        # On Solaris and FreeBSD, this will be seconds.
        reboot_timeout = dict(
            type='int',
            default=600,
            description=[
                'Maximum seconds to wait for machine to reboot and respond to a test command.',
                'Maximum execution time for the module is twice this amount.'
            ]
        )"
-------------------------------------------------------------------------
"- Seconds to wait before reboot. Passed as a parameter to the reboot command.
- On Linux, macOS and OpenBSD, this is converted to minutes and rounded down. If less than 60, it will be set to 0.
- On Solaris and FreeBSD, this will be seconds.
- Seconds to wait after the reboot command was successful before attempting to validate the system rebooted successfully.
- This timeout is evaluated separately for both reboot verification and test command success so the
"
-------------------------------------------------------------------------
"Recom
PRs: 55934, 55959"
-------------------------------------------------------------------------
=========================================================================
"- Seconds to wait before reboot. Passed as a parameter to the reboot command.
- Seconds to wait after the reboot command was successful before attempting to validate the system rebooted successfully.
"
-------------------------------------------------------------------------
"- Seconds to wait before reboot. Passed as a parameter to the reboot command.
    - Seconds to wait after the reboot command was successful before attempting to validate the system rebooted successfully."
-------------------------------------------------------------------------
"- Seconds to wait before reboot. Passed as a parameter to the reboot command.
- Seconds to wait after the reboot command was successful before attempting to validate the system rebooted successfully.
- This is useful if you want wait for something to settle despite your connection already working.
"
-------------------------------------------------------------------------
"Recom
PRs: 55934, 55959"
-------------------------------------------------------------------------
=========================================================================
"- This timeout is evaluated separately for both reboot verification and test command success so maximum clock time is actually twice this value.
"
-------------------------------------------------------------------------
# This timeout is evaluated separately for both reboot verification and test command success so maximum clock time is actually twice this value.
-------------------------------------------------------------------------
"- Maximum seconds to wait for machine to re-appear on the network and respond to a test command.
- This timeout is evaluated separately for both reboot verification and test command success so maximum clock time is actually twice this value.
"
-------------------------------------------------------------------------
"Recom
PRs: 55934, 55959"
-------------------------------------------------------------------------
=========================================================================
"from ansible.module_utils._text import to_native
from ansible.module_utils.basic import missing_required_lib
    HAS_NCCLIENT = True
    NCCLIENT_IMP_ERR = None
except (ImportError, AttributeError) as err:  # paramiko and gssapi are incompatible and raise AttributeError not ImportError
    HAS_NCCLIENT = False
    NCCLIENT_IMP_ERR = err
"
-------------------------------------------------------------------------
"from ansible.plugins.netconf import ensure_ncclient
from ansible.errors import AnsibleConnectionFailure
from ncclient.xml_ import to_ele

try:
    HAS_NCCLIENT = True
except (ImportError, AttributeError) as NCCLIENT_IMP_ERR:
    HAS_NCCLIENT = False"
-------------------------------------------------------------------------
"from ansible.module_utils._text import to_native
    HAS_NCCLIENT = True
    NCCLIENT_IMP_ERR = None
except (ImportError, AttributeError) as err:  # paramiko and gssapi are incompatible and raise AttributeError not ImportError
    HAS_NCCLIENT = False
    NCCLIENT_IMP_ERR = err
"
-------------------------------------------------------------------------
"Recom
PRs: 55384, 55648"
-------------------------------------------------------------------------
=========================================================================
"def ensure_ncclient(func):
    @wraps(func)
    def wrapped(self, *args, **kwargs):
        if not HAS_NCCLIENT:
            raise AnsibleError(""%s: %s"" % (missing_required_lib('ncclient'), to_native(NCCLIENT_IMP_ERR)))
        return func(self, *args, **kwargs)
    return wrapped
"
-------------------------------------------------------------------------
"def ensure_ncclient(func):
    @wraps(func)
    def wrapped(self, *args, **kwargs):
        from ansible.errors import AnsibleError
        from ansible.module_utils._text import to_native
        if not HAS_NCCLIENT:
            raise AnsibleError(""%s: %s"" % (missing_required_lib('ncclient'), to_native(NCCLIENT_IMP_ERR)))
        return func(self, *args, **kwargs)
    return wrapped"
-------------------------------------------------------------------------
"def ensure_ncclient(func):
    @wraps(func)
    def wrapped(self, *args, **kwargs):
        if not HAS_NCCLIENT:
            raise AnsibleError(""Package ncclient is not installed: %s. Please install it with `pip install ncclient`"" % to_native(NCCLIENT_IMP_ERR))
        return func(self, *args, **kwargs)
    return wrapped
"
-------------------------------------------------------------------------
"Recom
PRs: 55384, 55648"
-------------------------------------------------------------------------
=========================================================================
"from ansible.errors import AnsibleConnectionFailure
from ansible.plugins.netconf import ensure_connected, ensure_ncclient
    HAS_NCCLIENT = True
except (ImportError, AttributeError):  # paramiko and gssapi are incompatible and raise AttributeError not ImportError
    HAS_NCCLIENT = False
    @ensure_ncclient
    @ensure_ncclient
"
-------------------------------------------------------------------------
"from ansible.errors import AnsibleConnectionFailure
from ansible.plugins.netconf import ensure_ncclient
from ansible.plugins.netconf import ensure_ncclient
from ansible.plugins.netconf import ensure_ncclient

HAS_NCCLIENT = True
except (ImportError, AttributeError):  # paramiko and gssapi are incompatible and raise AttributeError not ImportError
    HAS_NCCLIENT = False"
-------------------------------------------------------------------------
"from ansible.errors import AnsibleConnectionFailure
from ansible.plugins.netconf import ensure_connected, ensure_ncclient
    HAS_NCCLIENT = True
except (ImportError, AttributeError):  # paramiko and gssapi are incompatible and raise AttributeError not ImportError
    HAS_NCCLIENT = False
"
-------------------------------------------------------------------------
"Recom
PRs: 55384, 55648"
-------------------------------------------------------------------------
=========================================================================
"from ansible.errors import AnsibleConnectionFailure
from ansible.plugins.netconf import ensure_connected, ensure_ncclient
    from ncclient.xml_ import to_xml
    HAS_NCCLIENT = True
except (ImportError, AttributeError):  # paramiko and gssapi are incompatible and raise AttributeError not ImportError
    HAS_NCCLIENT = False
"
-------------------------------------------------------------------------
"from ansible.errors import AnsibleConnectionFailure
from ansible.plugins.netconf import ensure_connected, ensure_ncclient
from ncclient.xml_ import to_xml
from ansible.module_utils._text import to_text, to_native
from ansible.plugins.netconf import ensure_ncclient
HAS_NCCLIENT = True
try:
    from ncclient import manager
    from ncclient.operations import RPCError
    from ncclient.transport.errors import SSHUnknownHostError
    from ncclient.xml_ import to_ele, to_xml, new_ele
except (ImportError, AttributeError):  # paramiko and gssapi are incompatible and raise AttributeError not ImportError
    HAS_NCCLIENT = False"
-------------------------------------------------------------------------
"@ensure_ncclient
"
-------------------------------------------------------------------------
"Recom
PRs: 55384, 55648"
-------------------------------------------------------------------------
=========================================================================
"@ensure_ncclient
"
-------------------------------------------------------------------------
from ansible.plugins.netconf import ensure_ncclient
-------------------------------------------------------------------------
"from ansible.errors import AnsibleConnectionFailure
from ansible.plugins.netconf import ensure_connected, ensure_ncclient
    from ncclient.xml_ import to_xml
    HAS_NCCLIENT = True
except (ImportError, AttributeError):  # paramiko and gssapi are incompatible and raise AttributeError not ImportError
    HAS_NCCLIENT = False
"
-------------------------------------------------------------------------
"Recom
PRs: 55384, 55648"
-------------------------------------------------------------------------
=========================================================================
"from ansible.module_utils._text import to_text, to_native
from ansible.errors import AnsibleConnectionFailure
from ansible.plugins.netconf import ensure_connected, ensure_ncclient
    HAS_NCCLIENT = True
except (ImportError, AttributeError):  # paramiko and gssapi are incompatible and raise AttributeError not ImportError
    HAS_NCCLIENT = False
    @ensure_ncclient
"
-------------------------------------------------------------------------
"from ansible.module_utils._text import to_text, to_native
from ansible.errors import AnsibleConnectionFailure
from ansible.plugins.netconf import ensure_ncclient
from ncclient.operations import RPCError
import json
import re

class Netconf(TerminalBase):    
    def guess_network_os(obj):    
        try:    
            m = manager.connect(    
                host=obj._play_context.remote_addr,    
                port=obj._play_context.port or 830,    
                username=obj._play_context.remote_user,    
                password=obj._play_context.password,    
                key_filename=obj.key_filename,    
                hostkey_verify=obj.get_option('host_key_checking'),    
                look_for_keys=obj.get_option('look_for_keys'),    
                allow_agent=obj._play_context.allow_agent,    
                timeout=obj._play_context.timeout    
            )    
        except RPCError as exc:    
            raise AnsibleConnectionFailure(str(exc))    
    
        guessed_os = None    
        for c in m.server_capabilities:    
            if re.search('urn:nokia.com:sros:ns:yang:sr', c):    
                guessed_os = 'sros'    
    
        m.close_session()    
        return guessed_os"
-------------------------------------------------------------------------
"@ensure_ncclient
"
-------------------------------------------------------------------------
"Recom
PRs: 55384, 55648"
-------------------------------------------------------------------------
=========================================================================
"@ensure_ncclient
"
-------------------------------------------------------------------------
@ensure_connected
-------------------------------------------------------------------------
"from ansible.module_utils._text import to_text
from ansible.errors import AnsibleConnectionFailure
from ansible.plugins.netconf import ensure_connected, ensure_ncclient
    HAS_NCCLIENT = True
except (ImportError, AttributeError):  # paramiko and gssapi are incompatible and raise AttributeError not ImportError
    HAS_NCCLIENT = False
    @ensure_ncclient
"
-------------------------------------------------------------------------
"Recom
PRs: 55384, 55648"
-------------------------------------------------------------------------
=========================================================================
"from ansible.module_utils._text import to_text, to_native
from ansible.errors import AnsibleConnectionFailure
from ansible.plugins.netconf import ensure_ncclient
    from ncclient.xml_ import to_ele
    HAS_NCCLIENT = True
except (ImportError, AttributeError):  # paramiko and gssapi are incompatible and raise AttributeError not ImportError
    HAS_NCCLIENT = False
"
-------------------------------------------------------------------------
"from ansible.errors import AnsibleConnectionFailure
from ansible.plugins.netconf import ensure_ncclient
from ncclient.xml_ import to_ele
from ansible.plugins.netconf import ensure_ncclient
HAS_NCCLIENT = True"
-------------------------------------------------------------------------
"@ensure_ncclient
"
-------------------------------------------------------------------------
"Recom
PRs: 55384, 55648"
-------------------------------------------------------------------------
=========================================================================
"@ensure_ncclient
"
-------------------------------------------------------------------------
"from ansible.plugins.netconf import ensure_ncclient

@ensure_ncclient
def get_config(self, *args, **kwargs):
    try:
        except RPCError as exc:
            raise Exception(to_xml(exc.xml))"
-------------------------------------------------------------------------
"from ansible.module_utils._text import to_text
from ansible.errors import AnsibleConnectionFailure
from ansible.plugins.netconf import ensure_ncclient
    from ncclient.xml_ import to_ele
    HAS_NCCLIENT = True
except (ImportError, AttributeError):  # paramiko and gssapi are incompatible and raise AttributeError not ImportError
    HAS_NCCLIENT = False
"
-------------------------------------------------------------------------
"Recom
PRs: 55384, 55648"
-------------------------------------------------------------------------
=========================================================================
"type: str
type: str
  - File access mode inside the container. Must be an octal number (like C(0644) or C(0444)).
type: int
"
-------------------------------------------------------------------------
"options:
  mode:
    description:
      - File access mode inside the container. Must be an octal number (like C(0644) or C(0444)).
    type: str
  uid:
    description:
      - UID of the config file's owner.
    type: str
  gid:
    description:
      - GID of the config file's group.
    type: str"
-------------------------------------------------------------------------
"- Every item must be a dictionary exposing the keys secret_id, secret_name, filename, uid (defaults to 0), gid (defaults to 0), mode (defaults to 0444)
"
-------------------------------------------------------------------------
"Recom
PRs: 55591, 55617"
-------------------------------------------------------------------------
=========================================================================
"type: str
type: str
  - File access mode inside the container. Must be an octal number (like C(0644) or C(0444)).
"
-------------------------------------------------------------------------
"mode:
         description:
           - File access mode inside the container. Must be an octal number (like C(0644) or C(0444)).
         type: int"
-------------------------------------------------------------------------
"- Every item must be a dictionary exposing the keys config_id, config_name, filename, uid (defaults to 0), gid (defaults to 0), mode (defaults to 0444)
"
-------------------------------------------------------------------------
"Recom
PRs: 55591, 55617"
-------------------------------------------------------------------------
=========================================================================
"'uid': config_data['File'].get('UID'),
'gid': config_data['File'].get('GID'),
"
-------------------------------------------------------------------------
"'uid': config_data['File'].get('UserID'),
'gid': config_data['File'].get('GroupID'),"
-------------------------------------------------------------------------
"service_c['uid'] = str(param_m.get('uid', ""0""))
service_c['gid'] = str(param_m.get('gid', ""0""))
service_c['mode'] = int(param_m.get('mode', 0o444))
"
-------------------------------------------------------------------------
"Recom
PRs: 55591, 55617"
-------------------------------------------------------------------------
=========================================================================
"'uid': secret_data['File'].get('UID'),
'gid': secret_data['File'].get('GID'),
"
-------------------------------------------------------------------------
"'uid': secret_data['File'].get('UID'),
'gid': secret_data['File'].get('GID'),"
-------------------------------------------------------------------------
"service_s['uid'] = str(param_m.get('uid', ""0""))
service_s['gid'] = str(param_m.get('gid', ""0""))
service_s['mode'] = int(param_m.get('mode', 0o444))
"
-------------------------------------------------------------------------
"Recom
PRs: 55591, 55617"
-------------------------------------------------------------------------
=========================================================================
"# check if user is trying to perform state operation on a vm which doesn't exists
elif state in ['present', 'powered_off', 'powered_on'] and not all((vm_extra_config,
                                               vm_hardware, vm_disk, vm_nic, esxi)):
    module.exit_json(changed=False, msg=""vm %s not present"" % guest)
"
-------------------------------------------------------------------------
"# check if user is trying to perform state operation on a vm which doesn't exist
elif state in ['present', 'powered_off', 'powered_on'] and not all((vm_disk, vm_nic, vm_hardware, esxi)):
    module.exit_json(changed=False, msg=""vm %s not present"" % guest)"
-------------------------------------------------------------------------
"elif state in ['present', 'powered_off', 'powered_on'] and not all((vm_hardware, vm_disk, vm_nic, esxi)):
    module.fail_json(msg=""vm %s not present and not all options neccessary to create are provided"" % guest)
"
-------------------------------------------------------------------------
"Recom
PRs: 19716, 55285"
-------------------------------------------------------------------------
=========================================================================
"if params['direction'] not in ['outgoing', 'incoming', 'routed', None]:
    module.fail_json(msg='For default, direction must be one of ""outgoing"", ""incoming"" and ""routed"", or direction must not be specified.')
"
-------------------------------------------------------------------------
"If ASTs from the commit history are available, they should be analyzed to ensure the adaptation corresponds accurately to the stable version."
-------------------------------------------------------------------------
"if params['direction'] not in ['outgoing', 'incoming', 'routed', None]:
    module.fail_json(msg='For default, direction must be one of ""outgoing"", ""incoming"" and ""routed"", or direction must not be specified.')
    module.fail_json(msg='For rules, direction must be one of ""in"" and ""out"", or direction must not be specified.')
"
-------------------------------------------------------------------------
"Recom
PRs: 54799, 54987"
-------------------------------------------------------------------------
=========================================================================
"- Backreferences can be used ambiguously like C(\1), or explicitly like C(\g<1>).
- If specified, only content after this match will be replaced/removed.
- Uses DOTALL, which means the C(.) special character I(can match newlines).
- If specified, only content before this match will be replaced/removed.
- Uses DOTALL, which means the C(.) special character I(can match newlines).
"
-------------------------------------------------------------------------
"Add the required imports and adapt the code snippet accordingly:


from __future__ import absolute_import, division, print_function
from ansible.module_utils.basic import AnsibleModule
from ansible.module_utils._text import to_bytes, to_text
import os
import tempfile
import re

def main():
    module = AnsibleModule(
        argument_spec=dict(
            path=dict(type='str', required=True),
            regexp=dict(type='str', required=True),
            replace=dict(type='str'),
            before=dict(type='str', version_added='2.4'),
            after=dict(type='str', version_added='2.4'),
            backup=dict(type='str')
        ),
        supports_check_mode=True
    )

    path = module.params['path']
    regexp = module.params['regexp']
    replace = module.params['replace']
    before = module.params['before']
    after = module.params['after']
    backup = module.params['backup']

    with open(path, 'r') as f:
        data = f.read()

    if before:
        data = re.sub(re.compile(regexp, re.DOTALL), replace, data, count=1)
    if after:
        data = re.sub(re.compile(regexp, re.DOTALL), replace, data[::-1], count=1)[::-1]

    with open(path, 'w') as f:
        f.write(data)

    module.exit_json(changed=True)

if __name__ == '__main__':
    main()"
-------------------------------------------------------------------------
"type: path
aliases: [ dest, destfile, name ]
"
-------------------------------------------------------------------------
"Recom
PRs: 31452, 54408"
-------------------------------------------------------------------------
=========================================================================
"- As of Ansible 2.7.10, the combined use of I(before) and I(after) works properly. If you were relying on the
  previous incorrect behavior, you may be need to adjust your tasks.
  See U(https://github.com/ansible/ansible/issues/31354) for details.
name: Before Ansible 2.3, option 'dest', 'destfile' or 'name' was used instead of 'path'
replace:
  path: /etc/apache2/sites-available/default.conf
  after: 'NameVirtualHost [*]'
  regexp: '^(.)$'
  replace: '# \1'
  path: /etc/apache2/sites-available/default.conf
  before: '# live site config'
  regexp: '^(.)$'
  replace: '# \1'
Prior to Ansible 2.7.10, using before and after in combination did the opposite of what was intended.
see https://github.com/ansible/ansible/issues/31354 for details.
  after: '<VirtualHost [*]>'
  before: '</VirtualHost>'
  regexp: '^(.)$'
  replace: '# \1'
name: Supports common file attributes
replace:
name: Supports a validate command
replace:
replace: path=/etc/hosts regexp='\\b(localhost)(\\d*)\\b' replace='\\1\\2.localdomain\\2 \\1\\2'
  path: /etc/hosts
name: Explicitly specifying positional matched groups in replacement
replace:
  path: /etc/ssh/sshd_config
  regexp: '^(ListenAddress[ ])[^\n]$'
  replace: '\g<1>0.0.0.0'
name: Explicitly specifying named matched groups
replace:
  path: /etc/ssh/sshd_config
  regexp: '^(?P<dctv>ListenAddress[ ])(?P<host>[^\n])$'
  replace: '#\g<dctv>\g<host>\n\g<dctv>0.0.0.0'
"
-------------------------------------------------------------------------
"'''
 
EXAMPLES:
- name: Before Ansible 2.3, option 'dest', 'destfile' or 'name' was used instead of 'path'
  replace:
    path: /etc/apache2/sites-available/default.conf
    after: 'NameVirtualHost [*]'
    regexp: '^(.)$'
    replace: '# \1'

- name: Before Ansible 2.3, option 'dest', 'destfile' or 'name' was used instead of 'path'
  replace:
    path: /etc/apache2/sites-available/default.conf
    before: '# live site config'
    regexp: '^(.)$'
    replace: '# \1'

- name: Prior to Ansible 2.7.10, using before and after in combination did the opposite of what was intended.
  replace:
    path: /etc/apache2/sites-available/default.conf
    after: '<VirtualHost [*]>'
    before: '</VirtualHost>'
    regexp: '^(.)$'
    replace: '# \1'

- name: Supports common file attributes
  replace:
 
- name: Supports a validate command
  replace:

- name: Explicitly specifying positional matched groups in replacement
  replace:
    path: /etc/ssh/sshd_config
    regexp: '^(ListenAddress[ ])[^\n]$'
    replace: '\\g<1>0.0.0.0'

- name: Explicitly specifying named matched groups
  replace:
    path: /etc/ssh/sshd_config
    regexp: '^(?P<dctv>ListenAddress[ ])(?P<host>[^\n])$'
    replace: '#\\g<dctv>\\g<host>\\n\\g<dctv>0.0.0.0'
'''"
-------------------------------------------------------------------------
"type: path
aliases: [ dest, destfile, name ]
"
-------------------------------------------------------------------------
"Recom
PRs: 31452, 54408"
-------------------------------------------------------------------------
=========================================================================
"indices = [match.start('subsection'), match.end('subsection')]
"
-------------------------------------------------------------------------
"indices = [match.start('subsection'), match.end('subsection')]"
-------------------------------------------------------------------------
"pattern = u'%s(?P<subsection>.*?)%s' % (params['after'], params['before'])
"
-------------------------------------------------------------------------
"Recom
PRs: 31452, 54408"
-------------------------------------------------------------------------
=========================================================================
"result = (contents[:indices[0]]  result[0]  contents[indices[1]:], result[1])
"
-------------------------------------------------------------------------
"result = (contents[:indices[0]] + result[0] + contents[indices[1]:], result[1])"
-------------------------------------------------------------------------
"pattern = u'%s(?P<subsection>.*?)%s' % (params['after'], params['before'])
"
-------------------------------------------------------------------------
"Recom
PRs: 31452, 54408"
-------------------------------------------------------------------------
=========================================================================
"crypto_utils.write_file(module, certificate.public_bytes(Encoding.PEM))
"
-------------------------------------------------------------------------
"crypto_utils.write_file(module, certificate.public_bytes(cryptography.hazmat.primitives.serialization.Encoding.PEM))"
-------------------------------------------------------------------------
"crypto_utils.write_file(module, crypto.dump_certificate(crypto.FILETYPE_PEM, self.cert))
"
-------------------------------------------------------------------------
"Recom
PRs: 54085, 54354"
-------------------------------------------------------------------------
=========================================================================
"crypto_utils.write_file(module, certificate.public_bytes(Encoding.PEM))
"
-------------------------------------------------------------------------
"cryptography.hazmat.primitives.serialization.Encoding.PEM
OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, certificate)"
-------------------------------------------------------------------------
"crypto_utils.write_file(module, to_bytes(crt))
"
-------------------------------------------------------------------------
"Recom
PRs: 54085, 54354"
-------------------------------------------------------------------------
=========================================================================
"crypto_utils.write_file(module, result)
"
-------------------------------------------------------------------------
"module_utils.write_file(module, result)"
-------------------------------------------------------------------------
"result = crypto.dump_certificate_request(crypto.FILETYPE_PEM, self.request)
crypto_utils.write_file(module, result)
"
-------------------------------------------------------------------------
"Recom
PRs: 54085, 54354"
-------------------------------------------------------------------------
=========================================================================
"crypto_utils.write_file(
    module,
    self.pkcs12.export(self.passphrase, self.iter_size, self.maciter_size),
    0o600
)
"
-------------------------------------------------------------------------
"OpenSSL.crypto.dump_pkcs12(
    self.passphrase,
    iter_size=self.iter_size,
    maciter_size=self.maciter_size
)"
-------------------------------------------------------------------------
"crypto_utils.write_file(
    module,
    self.pkcs12.export(self.passphrase, self.iter_size, self.maciter_size),
    0o600
)
    with open(self.src, 'rb') as pkcs12_fh:
        pkcs12_content = pkcs12_fh.read()
    p12 = crypto.load_pkcs12(pkcs12_content,
    crypto_utils.write_file(module, b'%s%s' % (pkey, crt))
"
-------------------------------------------------------------------------
"Recom
PRs: 54085, 54354"
-------------------------------------------------------------------------
=========================================================================
"crypto_utils.write_file(module, privatekey_data, 0o600)
self.changed = True
"
-------------------------------------------------------------------------
"ansible.module_utils.basic.write_file(module, privatekey_data, 0o600)
self.changed = True"
-------------------------------------------------------------------------
"if self.cipher and self.passphrase:
    privatekey_data = crypto.dump_privatekey(crypto.FILETYPE_PEM, self.privatekey,
                                             self.cipher, to_bytes(self.passphrase))
else:
    privatekey_data = crypto.dump_privatekey(crypto.FILETYPE_PEM, self.privatekey)
crypto_utils.write_file(module, privatekey_data, 0o600)
self.changed = True
"
-------------------------------------------------------------------------
"Recom
PRs: 54085, 54354"
-------------------------------------------------------------------------
=========================================================================
"def dump(self, check_mode=False):
    # Use only for absent
    result = {
        'changed': self.changed,
        'filename': self.path,
        'privatekey': self.privatekey_path,
        'csr': self.csr_path
    }
    return result
"
-------------------------------------------------------------------------
"def dump(self, check_mode=False):
        result = {
            'changed': self.changed,
            'filename': self.path,
            'privatekey': self.privatekey_path,
            'csr': self.csr_path
        }

        if check_mode:
            now = datetime.datetime.utcnow()
            ten = now.replace(year=now.year + 10)
            result.update({
                'notBefore': self.notBefore if self.notBefore else now.strftime(""%Y%m%d%H%M%SZ""),
                'notAfter': self.notAfter if self.notAfter else ten.strftime(""%Y%m%d%H%M%SZ""),
                'serial_number': self.serial_number,
            })
        else:
            result.update({
                'notBefore': self.cert.get_notBefore(),
                'notAfter': self.cert.get_notAfter(),
                'serial_number': self.cert.get_serial_number(),
            })

        return result"
-------------------------------------------------------------------------
"class CertificateAbsent(Certificate):
    def __init__(self, module):
        super(CertificateAbsent, self).__init__(module)
    def generate(self, module):
        pass
    def dump(self, check_mode=False):
        # Use only for absent
        result = {
            'changed': self.changed,
            'filename': self.path,
            'privatekey': self.privatekey_path,
            'csr': self.csr_path
        }
        return result
"
-------------------------------------------------------------------------
"Recom
PRs: 54298, 54348"
-------------------------------------------------------------------------
=========================================================================
"ret = []
rn ret.get('all_parameters')
"
-------------------------------------------------------------------------
"ret = []
if not ret or not isinstance(ret, ansible.module_utils.common._collections_compat.MutableMapping) or not ret.get('all_parameters', False):"
-------------------------------------------------------------------------
"return {}
rn ret.get('all_parameters')
"
-------------------------------------------------------------------------
"Recom
PRs: 51034, 54101"
-------------------------------------------------------------------------
=========================================================================
"- Tested with C(op) version 0.5.5
"
-------------------------------------------------------------------------
"This information does not have any impact on the code itself, and it does not necessitate any changes in the code adaptation. Feel free to proceed with the adaptation without incorporating this specific information."
-------------------------------------------------------------------------
"- C(op) 1Password command line utility (v0.5.5). See U(https://support.1password.com/command-line/)
"
-------------------------------------------------------------------------
"Recom
PRs: 51953, 53657"
-------------------------------------------------------------------------
=========================================================================
"if self.token:
    # Adds the session token to all commands if we're logged in.
    args = [to_bytes('--session=')  self.token]
"
-------------------------------------------------------------------------
"if self.token:
    args = [to_bytes('--session='), self.token]"
-------------------------------------------------------------------------
"self.token = None
if self.token:
    # Adds the session token to all commands if we're logged in.
    args = [to_bytes('--session=')  self.token]
"
-------------------------------------------------------------------------
"Recom
PRs: 51953, 53657"
-------------------------------------------------------------------------
=========================================================================
"return {'document': document[1].strip()}
"
-------------------------------------------------------------------------
return {'document': document[1].strip()}
-------------------------------------------------------------------------
"self.token = None
if self.token:
    # Adds the session token to all commands if we're logged in.
    args = [to_bytes('--session=')  self.token]
"
-------------------------------------------------------------------------
"Recom
PRs: 51953, 53657"
-------------------------------------------------------------------------
=========================================================================
"status_down = self.client.check_if_swarm_node_is_down(node_id=self.node_id, repeat_check=5)
"
-------------------------------------------------------------------------
"status_down = self.client.check_if_swarm_node_is_down(node_id=self.node_id, repeat_check=5)"
-------------------------------------------------------------------------
"node_info = self.client.inspect_node(node_id=self.node_id)
"
-------------------------------------------------------------------------
"Recom
PRs: 53503, 53557"
-------------------------------------------------------------------------
=========================================================================
"self.client.remove_node(node_id=self.node_id, force=self.force)
"
-------------------------------------------------------------------------
"self.client.remove_node(node_id=self.node.node_id, force=self.force)"
-------------------------------------------------------------------------
"if _x > 0:
    sleep(5)
"
-------------------------------------------------------------------------
"Recom
PRs: 53503, 53557"
-------------------------------------------------------------------------
=========================================================================
"# -*- coding: utf-8 -*-
# Copyright (c) 2019 Ansible Project
# GNU General Public License v3.0 (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
from __future__ import absolute_import, division, print_function
__metaclass__ = type
from units.compat.mock import Mock
from ansible.module_utils.facts.system.distribution import DistributionFiles
def mock_module():
    mock_module = Mock()
    mock_module.params = {'gather_subset': ['all'],
                          'gather_timeout': 5,
                          'filter': '*'}
    mock_module.get_bin_path = Mock(return_value=None)
    return mock_module
def test_parse_distribution_file_clear_linux():
    test_input = {
        'name': 'Clearlinux',
        'data': 'NAME=""Clear Linux OS""\nVERSION=1\nID=clear-linux-os\nID_LIKE=clear-linux-os\nVERSION_ID=28120\nPRETTY_NAME=""Clear Linux OS""\nANSI_COLOR=""1;35""'
                '\nHOME_URL=""https://clearlinux.org""\nSUPPORT_URL=""https://clearlinux.org""\nBUG_REPORT_URL=""mailto:dev@lists.clearlinux.org""',
        'path': '/usr/lib/os-release',
        'collected_facts': None,
    }
    result = (
        True,
        {
            'distribution': 'Clear Linux OS',
            'distribution_major_version': '28120',
            'distribution_release': 'clear-linux-os',
            'distribution_version': '28120'
        }
    )
    distribution = DistributionFiles(module=mock_module())
    assert result == distribution.parse_distribution_file_ClearLinux(**test_input)
def test_parse_distribution_file_clear_linux_no_match():
    # Test against data from Linux Mint and CoreOS to ensure we do not get a reported
    # match from parse_distribution_file_ClearLinux()
    scenarios = [
        {
            # CoreOS
            'case': {
                'name': 'Clearlinux',
                'data': 'NAME=""Container Linux by CoreOS""\nID=coreos\nVERSION=1911.5.0\nVERSION_ID=1911.5.0\nBUILD_ID=2018-12-15-2317\nPRETTY_NAME=""Container L'
                        'inux by CoreOS 1911.5.0 (Rhyolite)""\nANSI_COLOR=""38;5;75""\nHOME_URL=""https://coreos.com/""\nBUG_REPORT_URL=""https://issues.coreos.com""'
                        '\nCOREOS_BOARD=""amd64-usr""',
                'path': '/usr/lib/os-release',
                'collected_facts': None,
            },
            'result': (False, {}),
        },
        {
            # Linux Mint
            'case': {
                'name': 'Clearlinux',
                'data': 'NAME=""Linux Mint""\nVERSION=""19.1 (Tessa)""\nID=linuxmint\nID_LIKE=ubuntu\nPRETTY_NAME=""Linux Mint 19.1""\nVERSION_ID=""19.1""\nHOME_URL=""h'
                        'ttps://www.linuxmint.com/""\nSUPPORT_URL=""https://forums.ubuntu.com/""\nBUG_REPORT_URL=""http://linuxmint-troubleshooting-guide.readthedo'
                        'cs.io/en/latest/""\nPRIVACY_POLICY_URL=""https://www.linuxmint.com/""\nVERSION_CODENAME=tessa\nUBUNTU_CODENAME=bionic',
                'path': '/usr/lib/os-release',
                'collected_facts': None,
            },
            'result': (False, {}),
        },
    ]
    distribution = DistributionFiles(module=mock_module())
    for scenario in scenarios:
        assert scenario['result'] == distribution.parse_distribution_file_ClearLinux(**scenario['case'])
"
-------------------------------------------------------------------------
"# -*- coding: utf-8 -*-
# Copyright (c) 2019 Ansible Project
# GNU General Public License v3.0 (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
from __future__ import absolute_import, division, print_function
__metaclass__ = type
from ansible.compat.tests.mock import Mock
from ansible.module_utils.facts.system.distribution import DistributionFiles
def mock_module():
    mock_module = Mock()
    mock_module.params = {'gather_subset': ['all'],
                          'gather_timeout': 5,
                          'filter': '*'}
    mock_module.get_bin_path = Mock(return_value=None)
    return mock_module
def test_parse_distribution_file_clear_linux():
    test_input = {
        'name': 'Clearlinux',
        'data': 'NAME=""Clear Linux OS""\nVERSION=1\nID=clear-linux-os\nID_LIKE=clear-linux-os\nVERSION_ID=28120\nPRETTY_NAME=""Clear Linux OS""\nANSI_COLOR=""1;35""'
                '\nHOME_URL=""https://clearlinux.org""\nSUPPORT_URL=""https://clearlinux.org""\nBUG_REPORT_URL=""mailto:dev@lists.clearlinux.org""',
        'path': '/usr/lib/os-release',
        'collected_facts': None,
    }
    result = (
        True,
        {
            'distribution': 'Clear Linux OS',
            'distribution_major_version': '28120',
            'distribution_release': 'clear-linux-os',
            'distribution_version': '28120'
        }
    )
    distribution = DistributionFiles(module=mock_module())
    assert result == distribution.parse_distribution_file_ClearLinux(**test_input)
def test_parse_distribution_file_clear_linux_no_match():
    scenarios = [
        {
            # CoreOS
            'case': {
                'name': 'Clearlinux',
                'data': 'NAME=""Container Linux by CoreOS""\nID=coreos\nVERSION=1911.5.0\nVERSION_ID=1911.5.0\nBUILD_ID=2018-12-15-2317\nPRETTY_NAME=""Container L'
                        'inux by CoreOS 1911.5.0 (Rhyolite)""\nANSI_COLOR=""38;5;75""\nHOME_URL=""https://coreos.com/""\nBUG_REPORT_URL=""https://issues.coreos.com""'
                        '\nCOREOS_BOARD=""amd64-usr""',
                'path': '/usr/lib/os-release',
                'collected_facts': None,
            },
            'result': (False, {}),
        },
        {
            # Linux Mint
            'case': {
                'name': 'Clearlinux',
                'data': 'NAME=""Linux Mint""\nVERSION=""19.1 (Tessa)""\nID=linuxmint\nID_LIKE=ubuntu\nPRETTY_NAME=""Linux Mint 19.1""\nVERSION_ID=""19.1""\nHOME_URL=""h'
                        'ttps://www.linuxmint.com/""\nSUPPORT_URL=""https://forums.ubuntu.com/""\nBUG_REPORT_URL=""http://linuxmint-troubleshooting-guide.readthedo'
                        'cs.io/en/latest/""\nPRIVACY_POLICY_URL=""https://www.linuxmint.com/""\nVERSION_CODENAME=tessa\nUBUNTU_CODENAME=bionic',
                'path': '/usr/lib/os-release',
                'collected_facts': None,
            },
            'result': (False, {}),
        },
    ]
    distribution = DistributionFiles(module=mock_module())
    for scenario in scenarios:
        assert scenario['result'] == distribution.parse_distribution_file_ClearLinux(**scenario['case'])"
-------------------------------------------------------------------------
"# -*- coding: utf-8 -*-
# Copyright (c) 2019 Ansible Project
# GNU General Public License v3.0 (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
from __future__ import absolute_import, division, print_function
__metaclass__ = type
from ansible.compat.tests.mock import Mock
from ansible.module_utils.facts.system.distribution import DistributionFiles
def mock_module():
    mock_module = Mock()
    mock_module.params = {'gather_subset': ['all'],
                          'gather_timeout': 5,
                          'filter': '*'}
    mock_module.get_bin_path = Mock(return_value=None)
    return mock_module
def test_parse_distribution_file_clear_linux():
    test_input = {
        'name': 'Clearlinux',
        'data': 'NAME=""Clear Linux OS""\nVERSION=1\nID=clear-linux-os\nID_LIKE=clear-linux-os\nVERSION_ID=28120\nPRETTY_NAME=""Clear Linux OS""\nANSI_COLOR=""1;35""'
                '\nHOME_URL=""https://clearlinux.org""\nSUPPORT_URL=""https://clearlinux.org""\nBUG_REPORT_URL=""mailto:dev@lists.clearlinux.org""',
        'path': '/usr/lib/os-release',
        'collected_facts': None,
    }
    result = (
        True,
        {
            'distribution': 'Clear Linux OS',
            'distribution_major_version': '28120',
            'distribution_release': 'clear-linux-os',
            'distribution_version': '28120'
        }
    )
    distribution = DistributionFiles(module=mock_module())
    assert result == distribution.parse_distribution_file_ClearLinux(**test_input)
def test_parse_distribution_file_clear_linux_no_match():
    # Test against data from Linux Mint and CoreOS to ensure we do not get a reported
    # match from parse_distribution_file_ClearLinux()
    scenarios = [
        {
            # CoreOS
            'case': {
                'name': 'Clearlinux',
                'data': 'NAME=""Container Linux by CoreOS""\nID=coreos\nVERSION=1911.5.0\nVERSION_ID=1911.5.0\nBUILD_ID=2018-12-15-2317\nPRETTY_NAME=""Container L'
                        'inux by CoreOS 1911.5.0 (Rhyolite)""\nANSI_COLOR=""38;5;75""\nHOME_URL=""https://coreos.com/""\nBUG_REPORT_URL=""https://issues.coreos.com""'
                        '\nCOREOS_BOARD=""amd64-usr""',
                'path': '/usr/lib/os-release',
                'collected_facts': None,
            },
            'result': (False, {}),
        },
        {
            # Linux Mint
            'case': {
                'name': 'Clearlinux',
                'data': 'NAME=""Linux Mint""\nVERSION=""19.1 (Tessa)""\nID=linuxmint\nID_LIKE=ubuntu\nPRETTY_NAME=""Linux Mint 19.1""\nVERSION_ID=""19.1""\nHOME_URL=""h'
                        'ttps://www.linuxmint.com/""\nSUPPORT_URL=""https://forums.ubuntu.com/""\nBUG_REPORT_URL=""http://linuxmint-troubleshooting-guide.readthedo'
                        'cs.io/en/latest/""\nPRIVACY_POLICY_URL=""https://www.linuxmint.com/""\nVERSION_CODENAME=tessa\nUBUNTU_CODENAME=bionic',
                'path': '/usr/lib/os-release',
                'collected_facts': None,
            },
            'result': (False, {}),
        },
    ]
    distribution = DistributionFiles(module=mock_module())
    for scenario in scenarios:
        assert scenario['result'] == distribution.parse_distribution_file_ClearLinux(**scenario['case'])
"
-------------------------------------------------------------------------
"Recom
PRs: 53298, 53541"
-------------------------------------------------------------------------
=========================================================================
"kind: ssh
"
-------------------------------------------------------------------------
"AnnAssign(target=Name(id='kind', ctx=Store()), annotation=Name(id='ssh', ctx=Load()), simple=1)"
-------------------------------------------------------------------------
"kind: ssh
me: Create a valid SCM credential from a private_key file
wer_credential:
name: SCM Credential
organization: Default
state: present
kind: scm
username: joe
password: secret
ssh_key_data: ""{{ lookup('file', '/tmp/id_rsa') }}""
ssh_key_unlock: ""passphrase""
me: Add Credential Into Tower
wer_credential:
name: Workshop Credential
ssh_key_data: ""/home/{{ansible_user}}/.ssh/aws-private.pem""
kind: ssh
organization: Default
tower_username: admin
tower_password: ansible
tower_host: https://localhost
n_once: true
legate_to: localhost
"
-------------------------------------------------------------------------
"Recom
PRs: 47224, 53411"
-------------------------------------------------------------------------
=========================================================================
"swarm_service=facts,
"
-------------------------------------------------------------------------
"swarm_service=facts, ansible_docker_service=facts,"
-------------------------------------------------------------------------
"client.module.exit_json(
    msg=msg,
    changed=changed,
    rebuilt=rebuilt,
    changes=changes,
    swarm_service=facts,
    ansible_docker_service=facts  # kept for backwards-compatibility, will be removed in Ansible 2.8
)
"
-------------------------------------------------------------------------
"Recom
PRs: 53229, 53408"
-------------------------------------------------------------------------
=========================================================================
"from ansible.module_utils.six import string_types, integer_types
"
-------------------------------------------------------------------------
"from ansible.module_utils.six import string_types, integer_types"
-------------------------------------------------------------------------
"from ansible.module_utils.six import string_types, integer_types
    # Simple type=int with a large value (will be of type long under Python 2)
    ({'arg': {'type': 'int'}}, {'arg': 18765432109876543210}, 18765432109876543210),
    # Simple type=list, elements=int
    ({'arg': {'type': 'list', 'elements': 'int'}}, {'arg': [42, 32]}, [42, 32]),
"
-------------------------------------------------------------------------
"Recom
PRs: 53289, 53329"
-------------------------------------------------------------------------
=========================================================================
"if argspec['arg']['type'] == 'int':
    type_ = integer_types
else:
    type_ = getattr(builtins, argspec['arg']['type'])
"
-------------------------------------------------------------------------
"if argspec['arg']['type'] == 'int':
    type_ = integer_types
else:
    type_ = getattr(builtins, argspec['arg']['type'])"
-------------------------------------------------------------------------
"@pytest.mark.parametrize('stdin', [{'arg': 42}, {'arg': 18765432109876543210}], indirect=['stdin'])
    assert isinstance(am.params['arg'], integer_types)
"
-------------------------------------------------------------------------
"Recom
PRs: 53289, 53329"
-------------------------------------------------------------------------
=========================================================================
"- This is only used by the C(selfsigned) provider.
"
-------------------------------------------------------------------------
This is only used by the `C(SelfSignedCertificateCryptography)` provider.
-------------------------------------------------------------------------
"- Version of the C(selfsigned) certificate.
- Nowadays it should almost always be C(3).
- This is only used by the C(selfsigned) provider.
- This is only used by the C(selfsigned) provider.
- This is only used by the C(selfsigned) provider.
- This is only used by the C(selfsigned) provider.
- This is only used by the C(ownca) provider.
- This is only used by the C(ownca) provider.
- This is only used by the C(ownca) provider.
- This is only used by the C(ownca) provider.
- Version of the C(ownca) certificate.
- Nowadays it should almost always be C(3).
- This is only used by the C(ownca) provider.
- This is only used by the C(ownca) provider.
- This is only used by the C(ownca) provider.
- This is only used by the C(acme) provider.
- This is only used by the C(acme) provider.
- This is only used by the C(acme) provider.
- This is only used by the C(assertonly) provider.
- If you need to specify more than one value with the same key, use a list as value.
- This is only used by the C(assertonly) provider.
- This is only used by the C(assertonly) provider.
- This is only used by the C(assertonly) provider.
- This is only used by the C(assertonly) provider.
- Checks if the certificate is expired/not expired at the time the module is executed.
- This is only used by the C(assertonly) provider.
- The version of the certificate.
- Nowadays it should almost always be 3.
- This is only used by the C(assertonly) provider.
- The certificate must be valid at this point in time.
- The timestamp is formatted as an ASN.1 TIME.
- This is only used by the C(assertonly) provider.
- The certificate must be invalid at this point in time.
- The timestamp is formatted as an ASN.1 TIME.
- This is only used by the C(assertonly) provider.
- The certificate must start to become valid at this point in time.
- The timestamp is formatted as an ASN.1 TIME.
- This is only used by the C(assertonly) provider.
- The certificate must expire at this point in time.
- The timestamp is formatted as an ASN.1 TIME.
- This is only used by the C(assertonly) provider.
- This is only used by the C(assertonly) provider.
- This is only used by the C(assertonly) provider.
"
-------------------------------------------------------------------------
"Recom
PRs: 53208, 53283"
-------------------------------------------------------------------------
=========================================================================
"- This is only used by the C(selfsigned) provider.
"
-------------------------------------------------------------------------
# This is only used by the C(SelfSignedCertificate) provider.
-------------------------------------------------------------------------
"- This is only used by the C(assertonly) provider.
- This is only used by the C(assertonly) provider.
"
-------------------------------------------------------------------------
"Recom
PRs: 53208, 53283"
-------------------------------------------------------------------------
=========================================================================
"- This is only used by the C(selfsigned) provider.
"
-------------------------------------------------------------------------
Please provide the source code snippet that you would like to adapt.
-------------------------------------------------------------------------
"- This is only used by the C(assertonly) provider.
- This is only used by the C(assertonly) provider.
"
-------------------------------------------------------------------------
"Recom
PRs: 53208, 53283"
-------------------------------------------------------------------------
=========================================================================
"- This is only used by the C(selfsigned) provider.
"
-------------------------------------------------------------------------
# This is only used by the OwnCACertificateCryptography provider.
-------------------------------------------------------------------------
"- This is only used by the C(assertonly) provider.
"
-------------------------------------------------------------------------
"Recom
PRs: 53208, 53283"
-------------------------------------------------------------------------
=========================================================================
"- This is only used by the C(ownca) provider.
- This is only used by the C(ownca) provider.
- This is only used by the C(ownca) provider.
- This is only used by the C(ownca) provider.
"
-------------------------------------------------------------------------
# This is only used by the OwnCACertificateCryptography provider.
-------------------------------------------------------------------------
"- Version of the C(selfsigned) certificate.
- Nowadays it should almost always be C(3).
- This is only used by the C(selfsigned) provider.
- This is only used by the C(selfsigned) provider.
- This is only used by the C(selfsigned) provider.
- This is only used by the C(selfsigned) provider.
- This is only used by the C(ownca) provider.
- This is only used by the C(ownca) provider.
- This is only used by the C(ownca) provider.
- This is only used by the C(ownca) provider.
- Version of the C(ownca) certificate.
- Nowadays it should almost always be C(3).
- This is only used by the C(ownca) provider.
- This is only used by the C(ownca) provider.
- This is only used by the C(ownca) provider.
- This is only used by the C(acme) provider.
- This is only used by the C(acme) provider.
- This is only used by the C(acme) provider.
- This is only used by the C(assertonly) provider.
- If you need to specify more than one value with the same key, use a list as value.
- This is only used by the C(assertonly) provider.
- This is only used by the C(assertonly) provider.
- This is only used by the C(assertonly) provider.
- This is only used by the C(assertonly) provider.
- Checks if the certificate is expired/not expired at the time the module is executed.
- This is only used by the C(assertonly) provider.
- The version of the certificate.
- Nowadays it should almost always be 3.
- This is only used by the C(assertonly) provider.
- The certificate must be valid at this point in time.
- The timestamp is formatted as an ASN.1 TIME.
- This is only used by the C(assertonly) provider.
- The certificate must be invalid at this point in time.
- The timestamp is formatted as an ASN.1 TIME.
- This is only used by the C(assertonly) provider.
- The certificate must start to become valid at this point in time.
- The timestamp is formatted as an ASN.1 TIME.
- This is only used by the C(assertonly) provider.
- The certificate must expire at this point in time.
- The timestamp is formatted as an ASN.1 TIME.
- This is only used by the C(assertonly) provider.
- This is only used by the C(assertonly) provider.
- This is only used by the C(assertonly) provider.
"
-------------------------------------------------------------------------
"Recom
PRs: 53208, 53283"
-------------------------------------------------------------------------
=========================================================================
"if module.check_mode:
    if os.path.exists(tmpsrc):
        os.remove(tmpsrc)
    result['changed'] = ('checksum_dest' not in result or
                         result['checksum_src'] != result['checksum_dest'])
    module.exit_json(msg=info.get('msg', ''), **result)
"
-------------------------------------------------------------------------
"# If the remote URL exists, we're done with check mode
    if module.check_mode:
        if os.path.exists(tmpsrc):
            os.remove(tmpsrc)
        result['changed'] = ('checksum_dest' not in result or
                             result['checksum_src'] != result['checksum_dest'])
        res_args = dict(msg=info.get('msg', ''), **result)
        module.exit_json(**res_args)"
-------------------------------------------------------------------------
"if module.check_mode:
    if os.path.exists(tmpsrc):
        os.remove(tmpsrc)
    changed = (checksum_dest is None or
               checksum_src != checksum_dest)
    res_args = dict(url=url, changed=changed, dest=dest, src=tmpsrc,
                    checksum_dest=checksum_dest, checksum_src=checksum_src,
                    msg=info.get('msg', ''))
    module.exit_json(**res_args)
"
-------------------------------------------------------------------------
"Recom
PRs: 53070, 53172"
-------------------------------------------------------------------------
=========================================================================
"algorithms = ('md5', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512')
"
-------------------------------------------------------------------------
"AVAILABLE_HASH_ALGORITHMS = {}
for algorithm in AVAILABLE_HASH_ALGORITHMS.pop('md5', None):
    AVAILABLE_HASH_ALGORITHMS[algorithm] = getattr(hashlib, algorithm)"
-------------------------------------------------------------------------
"AVAILABLE_HASH_ALGORITHMS.pop('md5', None)
"
-------------------------------------------------------------------------
"Recom
PRs: 52994, 53135"
-------------------------------------------------------------------------
=========================================================================
"- name: Add a new VLAN pool range
  aci_encap_pool_range:
    pool_allocation_mode: static
    range_name: anstest
    range_start: 20
    range_end: 40
    allocation_mode: inherit
- name: Remove a VLAN pool range
  aci_encap_pool_range:
    pool_allocation_mode: static
    range_name: anstest
    range_start: 20
    range_end: 40
  aci_encap_pool_range:
    pool_allocation_mode: static
    range_name: anstest
    range_start: 20
    range_end: 50
- name: Query a VLAN pool for ranges by range_name
  aci_encap_pool_range:
    host: apic
    username: admin
    password: SomeSecretPassword
    pool_type: vlan
    range_name: anstest
    state: query
  delegate_to: localhost
  register: query_result
- name: Query a VLAN pool for ranges by range_start
  aci_encap_pool_range:
    host: apic
    username: admin
    password: SomeSecretPassword
    pool_type: vlan
    range_start: 20
    state: query
  delegate_to: localhost
  register: query_result
- name: Query a VLAN pool for ranges by range_start and range_end
  aci_encap_pool_range:
    range_start: 20
    range_end: 40
- name: Query all VLAN pool ranges
  aci_encap_pool_range:
"
-------------------------------------------------------------------------
"- name: Add a new VLAN pool range
  aci_encap_pool_range:
    pool: production
    pool_type: vlan
    range_name: anstest
    range_start: 20
    range_end: 40
    allocation_mode: inherit
    state: present
  delegate_to: localhost

- name: Remove a VLAN pool range
  aci_encap_pool_range:
    pool: production
    pool_type: vlan
    range_name: anstest
    range_start: 20
    range_end: 40
    allocation_mode: inherit
    state: absent
  delegate_to: localhost

- name: Query a VLAN pool for ranges by range_name
  aci_encap_pool_range:
    host: apic
    username: admin
    password: SomeSecretPassword
    pool: production
    pool_type: vlan
    range_name: anstest
    state: query
  delegate_to: localhost
  register: query_result

- name: Query a VLAN pool for ranges by range_start
  aci_encap_pool_range:
    host: apic
    username: admin
    password: SomeSecretPassword
    pool: production
    pool_type: vlan
    range_start: 20
    state: query
  delegate_to: localhost
  register: query_result

- name: Query a VLAN pool for ranges by range_start and range_end
  aci_encap_pool_range:
    host: apic
    username: admin
    password: SomeSecretPassword
    pool: production
    pool_type: vlan
    range_start: 20
    range_end: 40
    state: query
  delegate_to: localhost
  register: query_result

- name: Query all VLAN pool ranges
  aci_encap_pool_range:
    host: apic
    username: admin
    password: SomeSecretPassword
    pool_type: vlan
    state: query
  delegate_to: localhost
  register: query_result"
-------------------------------------------------------------------------
"- name: Add a new VLAN pool range
  aci_encap_pool_range:
    pool_allocation_mode: static
    range_name: anstest
    range_start: 20
    range_end: 40
    allocation_mode: inherit
- name: Remove a VLAN pool range
  aci_encap_pool_range:
    pool_allocation_mode: static
    range_name: anstest
    range_start: 20
    range_end: 40
- name: Query a VLAN range
  aci_encap_pool_range:
    pool_allocation_mode: static
    range_name: anstest
    range_start: 20
    range_end: 50
- name: Query a VLAN pool for ranges by range_name
  aci_encap_pool_range:
    host: apic
    username: admin
    password: SomeSecretPassword
    pool_type: vlan
    range_name: anstest
    state: query
  delegate_to: localhost
  register: query_result
- name: Query a VLAN pool for ranges by range_start
  aci_encap_pool_range:
    host: apic
    username: admin
    password: SomeSecretPassword
    pool_type: vlan
    range_start: 20
    state: query
  delegate_to: localhost
  register: query_result
- name: Query a VLAN pool for ranges by range_start and range_end
  aci_encap_pool_range:
    range_start: 20
    range_end: 40
- name: Query all VLAN pool ranges
  aci_encap_pool_range:
"
-------------------------------------------------------------------------
"Recom
PRs: 52958, 52965"
-------------------------------------------------------------------------
=========================================================================
"- name: Add a new VLAN pool range
  aci_encap_pool_range:
    pool_allocation_mode: static
    range_name: anstest
    range_start: 20
    range_end: 40
    allocation_mode: inherit
- name: Remove a VLAN pool range
  aci_encap_pool_range:
    pool_allocation_mode: static
    range_name: anstest
    range_start: 20
    range_end: 40
  aci_encap_pool_range:
    pool_allocation_mode: static
    range_name: anstest
    range_start: 20
    range_end: 50
- name: Query a VLAN pool for ranges by range_name
  aci_encap_pool_range:
    host: apic
    username: admin
    password: SomeSecretPassword
    pool_type: vlan
    range_name: anstest
    state: query
  delegate_to: localhost
  register: query_result
- name: Query a VLAN pool for ranges by range_start
  aci_encap_pool_range:
    host: apic
    username: admin
    password: SomeSecretPassword
    pool_type: vlan
    range_start: 20
    state: query
  delegate_to: localhost
  register: query_result
- name: Query a VLAN pool for ranges by range_start and range_end
  aci_encap_pool_range:
    range_start: 20
    range_end: 40
- name: Query all VLAN pool ranges
  aci_encap_pool_range:
"
-------------------------------------------------------------------------
"- name: Add a new VLAN pool range
  aci_encap_pool_range:
    pool_allocation_mode: static
    range_name: anstest
    range_start: 20
    range_end: 40
    allocation_mode: inherit
  delegate_to: localhost
  state: present

- name: Remove a VLAN pool range
  aci_encap_pool_range:
    pool_allocation_mode: static
    range_name: anstest
    range_start: 20
    range_end: 40
  delegate_to: localhost
  state: absent

- name: Query a VLAN pool for ranges by range_name
  aci_encap_pool_range:
    host: apic
    username: admin
    password: SomeSecretPassword
    pool_type: vlan
    range_name: anstest
    state: query
  delegate_to: localhost
  register: query_result

- name: Query a VLAN pool for ranges by range_start
  aci_encap_pool_range:
    host: apic
    username: admin
    password: SomeSecretPassword
    pool_type: vlan
    range_start: 20
    state: query
  delegate_to: localhost
  register: query_result

- name: Query a VLAN pool for ranges by range_start and range_end
  aci_encap_pool_range:
    range_start: 20
    range_end: 40
  delegate_to: localhost
  state: query

- name: Query all VLAN pool ranges
  aci_encap_pool_range:"
-------------------------------------------------------------------------
"- name: Add a new VLAN pool range
  aci_encap_pool_range:
    pool_allocation_mode: static
    range_name: anstest
    range_start: 20
    range_end: 40
    allocation_mode: inherit
- name: Remove a VLAN pool range
  aci_encap_pool_range:
    pool_allocation_mode: static
    range_name: anstest
    range_start: 20
    range_end: 40
- name: Query a VLAN range
  aci_encap_pool_range:
    pool_allocation_mode: static
    range_name: anstest
    range_start: 20
    range_end: 50
- name: Query a VLAN pool for ranges by range_name
  aci_encap_pool_range:
    host: apic
    username: admin
    password: SomeSecretPassword
    pool_type: vlan
    range_name: anstest
    state: query
  delegate_to: localhost
  register: query_result
- name: Query a VLAN pool for ranges by range_start
  aci_encap_pool_range:
    host: apic
    username: admin
    password: SomeSecretPassword
    pool_type: vlan
    range_start: 20
    state: query
  delegate_to: localhost
  register: query_result
- name: Query a VLAN pool for ranges by range_start and range_end
  aci_encap_pool_range:
    range_start: 20
    range_end: 40
- name: Query all VLAN pool ranges
  aci_encap_pool_range:
"
-------------------------------------------------------------------------
"Recom
PRs: 52958, 52963"
-------------------------------------------------------------------------
=========================================================================
"return self._module.from_json(to_text(resp.read()))
"
-------------------------------------------------------------------------
return self._module.from_json(json.loads(resp.read().decode('utf-8')))
-------------------------------------------------------------------------
"return self._module.from_json(to_text(resp.read(), errors='surrogate_or_strict'))
"
-------------------------------------------------------------------------
"Recom
PRs: 52822, 52915"
-------------------------------------------------------------------------
=========================================================================
"return self._module.from_json(to_text(resp.read()))
"
-------------------------------------------------------------------------
return AnsibleCloudscaleBase._module.from_json(AnsibleCloudscaleBase.to_text(resp.read()))
-------------------------------------------------------------------------
"return self._module.from_json(to_text(resp.read(), errors='surrogate_or_strict'))
"
-------------------------------------------------------------------------
"Recom
PRs: 52822, 52915"
-------------------------------------------------------------------------
=========================================================================
"'size': locale.atof(parts[1]),
"
-------------------------------------------------------------------------
"'size': float(parts[1]),"
-------------------------------------------------------------------------
"'size': float(parts[1]),
"
-------------------------------------------------------------------------
"Recom
PRs: 36811, 52836"
-------------------------------------------------------------------------
=========================================================================
"'size': locale.atof(parts[1]),
'free': locale.atof(parts[2]),
'ext_size': locale.atof(parts[3])
"
-------------------------------------------------------------------------
"'size': float(parts[1]),
        'free': float(parts[2]),
        'ext_size': float(parts[3])"
-------------------------------------------------------------------------
"'size': float(parts[1]),
'free': float(parts[2]),
'ext_size': float(parts[3])
"
-------------------------------------------------------------------------
"Recom
PRs: 36811, 52836"
-------------------------------------------------------------------------
=========================================================================
"locale.atof(size)
"
-------------------------------------------------------------------------
float(size)
-------------------------------------------------------------------------
"module.run_command_environ_update = LVOL_ENV_VARS
"
-------------------------------------------------------------------------
"Recom
PRs: 36811, 52836"
-------------------------------------------------------------------------
=========================================================================
"if locale.atof(size) > this_lv['size']:
elif shrink and locale.atof(size) < this_lv['size']:
    if locale.atof(size) == 0:
"
-------------------------------------------------------------------------
"if float(size) > this_lv['size']:
elif shrink and float(size) < this_lv['size']:
    if float(size) == 0:"
-------------------------------------------------------------------------
"if float(size) > this_lv['size']:
elif shrink and float(size) < this_lv['size']:
    if float(size) == 0:
"
-------------------------------------------------------------------------
"Recom
PRs: 36811, 52836"
-------------------------------------------------------------------------
=========================================================================
"-  For rebooting systems, use the M(reboot) or M(win_reboot) module.
"
-------------------------------------------------------------------------
"# For rebooting systems, use the M(reboot) module."
-------------------------------------------------------------------------
"-  For rebooting systems, use the M(reboot) or M(win_reboot) module.
lso:
dule: raw
dule: script
dule: shell
dule: win_command
"
-------------------------------------------------------------------------
"Recom
PRs: 51499, 52192"
-------------------------------------------------------------------------
=========================================================================
"- For rebooting systems, use the M(reboot) or M(win_reboot) module.
"
-------------------------------------------------------------------------
"disable_suffix = ""If you need to use {cmd} because {mod} is insufficient you can add"" \
                      "" ansible.cfg to get rid of this message.""
     substitutions = {'mod': None, 'cmd': command}
 
     if command in arguments:
         substitutions['mod'] = 'M(reboot)'
         substitutions['subcmd'] = arguments[command]
         module.warn(msg.format(**substitutions))
 
     if command in commands:
         substitutions['mod'] = 'M(win_reboot)'
         module.warn(msg.format(**substitutions))"
-------------------------------------------------------------------------
"- An alternative to using inline shell scripts with this module is to use
  the M(script) module possibly together with the M(template) module.
- For rebooting systems, use the M(reboot) or M(win_reboot) module.
ealso:
module: command
module: raw
module: script
"
-------------------------------------------------------------------------
"Recom
PRs: 51499, 52192"
-------------------------------------------------------------------------
=========================================================================
"if params['direction'] not in ['outgoing', 'incoming', 'routed']:
    module.fail_json(msg='For default, direction must be one of ""outgoing"", ""incoming"" and ""routed"".')
"
-------------------------------------------------------------------------
"if params['direction'] not in ['out', 'in', 'routed']:
    module.fail_json(msg='For default, direction must be one of ""out"", ""in"" and ""routed"".')"
-------------------------------------------------------------------------
"if params['direction'] not in ['outgoing', 'incoming', 'routed']:
    module.fail_json(msg='For default, direction must be one of ""outgoing"", ""incoming"" and ""routed"".')
if params['direction'] not in ['in', 'out', None]:
    module.fail_json(msg='For rules, direction must be one of ""in"" and ""out"".')
"
-------------------------------------------------------------------------
"Recom
PRs: 50402, 52027"
-------------------------------------------------------------------------
=========================================================================
"altnames = [altname.strip() for altname in str(altnames_ext).split(',') if altname.strip()]
"
-------------------------------------------------------------------------
"altnames = [altname.strip() for altname in str(altnames_ext).split(',') if altname.strip()]"
-------------------------------------------------------------------------
"altnames = [altname.strip() for altname in str(altnames_ext).split(',') if altname.strip() if altname.strip()]
"
-------------------------------------------------------------------------
"Recom
PRs: 51473, 52024"
-------------------------------------------------------------------------
=========================================================================
"res = re.match(""""""GRANT (.) ON (.) TO (['`""]).*\\3@(['`""]).*\\4( IDENTIFIED BY PASSWORD (['`""]).\5)? ?(.*)"""""", grant[0])
if ""WITH GRANT OPTION"" in res.group(7):
if ""REQUIRE SSL"" in res.group(7):
"
-------------------------------------------------------------------------
"res = re.match(""GRANT (.+) ON (.+) TO ('|`|\\\"")[^'\""]+\\3@('|`)[^'\""]+\\4( IDENTIFIED BY PASSWORD ('|`)[^'\""]+\\5)? ?(.*)"", grant[0])
if ""GRANT OPTION"" in res.group(7):
if ""REQUIRESSL"" in res.group(7):"
-------------------------------------------------------------------------
"res = re.match(""""""GRANT (.) ON (.) TO (['`""]).*\\3@(['`""]).*\\4( IDENTIFIED BY PASSWORD (['`""]).\\6)? ?(.*)"""""", grant[0])
if ""WITH GRANT OPTION"" in res.group(7):
if ""REQUIRE SSL"" in res.group(7):
"
-------------------------------------------------------------------------
"Recom
PRs: 40092, 51910"
-------------------------------------------------------------------------
=========================================================================
"res = re.match(""""""GRANT (.) ON (.) TO (['`""]).*\\3@(['`""]).*\\4( IDENTIFIED BY PASSWORD (['`""]).\5)? ?(.*)"""""", grant[0])
if ""WITH GRANT OPTION"" in res.group(7):
if ""REQUIRE SSL"" in res.group(7):
"
-------------------------------------------------------------------------
"res = re.match(""GRANT (.+) ON (.+) TO (['`']).*\\3@(['`']).*\\4( IDENTIFIED BY PASSWORD (['`']).\\5)? ?(.*)"", grant[0])
if ""WITH GRANT OPTION"" in res.group(7):
if ""REQUIRE SSL"" in res.group(7):"
-------------------------------------------------------------------------
"res = re.match(""""""GRANT (.) ON (.) TO (['`""]).*\\3@(['`""]).*\\4( IDENTIFIED BY PASSWORD (['`""]).\\6)? ?(.*)"""""", grant[0])
if ""WITH GRANT OPTION"" in res.group(7):
if ""REQUIRE SSL"" in res.group(7):
"
-------------------------------------------------------------------------
"Recom
PRs: 40092, 51909"
-------------------------------------------------------------------------
=========================================================================
"remaining_retries = remaining_tries - attempt - 1
_handle_error(remaining_retries, cmd[0], return_tuple, self._play_context.no_log, self.host)
= Invalid/incorrect password from sshpass
pt AnsibleAuthenticationFailure as e:
# Raising this exception, which is subclassed from AnsibleConnectionFailure, prevents further retries
raise
"
-------------------------------------------------------------------------
"remaining_retries = remaining_tries - attempt - 1
_handle_error(remaining_retries, cmd[0], return_tuple, self._play_context.no_log, self.host)
try:
    if 'Invalid/incorrect password' in message:
        raise AnsibleConnectionFailure('Invalid/incorrect password from sshpass')   # Raising this exception, which is subclassed from AnsibleConnectionFailure, prevents further retries
except AnsibleConnectionFailure as e:
    raise"
-------------------------------------------------------------------------
"remaining_retries = remaining_tries - attempt - 1
_handle_error(remaining_retries, cmd[0], return_tuple, self._play_context.no_log, self.host)
break
= Invalid/incorrect password from sshpass
pt AnsibleAuthenticationFailure as e:
# Raising this exception, which is subclassed from AnsibleConnectionFailure, prevents further retries
raise
"
-------------------------------------------------------------------------
"Recom
PRs: 50776, 51236"
-------------------------------------------------------------------------
=========================================================================
"from ansible.errors import (
    AnsibleAuthenticationFailure,
    AnsibleConnectionFailure,
    AnsibleError,
    AnsibleFileNotFound,
)
"
-------------------------------------------------------------------------
from ansible.errors import AnsibleConnectionFailure
-------------------------------------------------------------------------
"from ansible.errors import (
    AnsibleAuthenticationFailure,
    AnsibleConnectionFailure,
    AnsibleError,
    AnsibleFileNotFound,
)
from ansible.module_utils._text import to_bytes, to_native, to_text
"
-------------------------------------------------------------------------
"Recom
PRs: 50776, 51235"
-------------------------------------------------------------------------
=========================================================================
"- arg1: ""true""
- arg2: ""whatever""
"
-------------------------------------------------------------------------
"- arg1: ""True""
- arg2: ""whatever"""
-------------------------------------------------------------------------
"SECRET_KEY: ""ssssh""
# Values which might be parsed as numbers, booleans or other types by the YAML parser need to be quoted
BOOLEAN_KEY: ""yes""
"
-------------------------------------------------------------------------
"Recom
PRs: 49843, 50899"
-------------------------------------------------------------------------
=========================================================================
"if not differences.empty and self.parameters.force:
"
-------------------------------------------------------------------------
if not self.diff_tracker.empty and self.parameters.force:
-------------------------------------------------------------------------
"if differences and self.parameters.force:
"
-------------------------------------------------------------------------
"Recom
PRs: 50663, 50821"
-------------------------------------------------------------------------
=========================================================================
"if not differences.empty and self.parameters.force:
"
-------------------------------------------------------------------------
if not self.differences.empty and self.parameters.force:
-------------------------------------------------------------------------
"if differences and self.parameters.force:
"
-------------------------------------------------------------------------
"Recom
PRs: 50663, 50820"
-------------------------------------------------------------------------
=========================================================================
"user_password = module.params['user_password']
"
-------------------------------------------------------------------------
user_password = module.params['user_password']
-------------------------------------------------------------------------
"if user_password is None or check_user_password(module, client, user_name, user_password):
user_password = user_password or ''
"
-------------------------------------------------------------------------
"Recom
PRs: 49084, 49973"
-------------------------------------------------------------------------
=========================================================================
"current_boot_time = self.get_system_boot_time(distribution)
en(current_boot_time) == 0 or current_boot_time == previous_boot_time:
raise ValueError(""boot time has not changed"")
test_command(self, distribution, **kwargs):
_command = self._task.args.get('test_command', self._get_value_from_facts('TEST_COMMANDS', distribution, 'DEFAULT_TEST_COMMAND'))
lay.vvv(""{action}: attempting post-reboot test command"".format(action=self._task.action))
lay.debug(""{action}: attempting post-reboot test command '{command}'"".format(action=self._task.action, command=test_command))
"
-------------------------------------------------------------------------
"current_boot_time = self.get_system_boot_time(distribution)
if current_boot_time == 0 or current_boot_time == previous_boot_time:
    raise ValueError(""boot time has not changed"")

def test_command(self, distribution, **kwargs):
    command = self._task.args.get('test_command', self._get_value_from_facts('TEST_COMMANDS', distribution, 'DEFAULT_TEST_COMMAND'))
    self._display.vvv(""{action}: attempting post-reboot test command"".format(action=self._task.action))
    self._display.debug(""{action}: attempting post-reboot test command '{command}'"".format(action=self._task.action, command=command))"
-------------------------------------------------------------------------
"DEFAULT_SHUTDOWN_COMMAND_ARGS = '-r {delay_min} ""{message}""'
    'openbsd': '/sbin/sysctl kern.boottime',
    'macosx': 'who -b',
    'solaris': 'who -b',
    'alpine': 'reboot',
    'alpine': '',
    'linux': DEFAULT_SHUTDOWN_COMMAND_ARGS,
    'macosx': '-r {delay_min} ""{message}""',
    'solaris': '-y -g {delay_sec} -i 6 ""{message}""',
    'sunos': '-y -g {delay_sec} -i 6 ""{message}""',
}
TEST_COMMANDS = {
    'solaris': 'who'
@property
def pre_reboot_delay(self):
    return self._check_delay('pre_reboot_delay', self.DEFAULT_PRE_REBOOT_DELAY)
@property
def post_reboot_delay(self):
    return self._check_delay('post_reboot_delay', self.DEFAULT_POST_REBOOT_DELAY)
def _check_delay(self, key, default):
    """"""Ensure that the value is positive or zero""""""
    value = int(self._task.args.get(key, self._task.args.get(key  '_sec', default)))
    if value < 0:
        value = 0
    return value
def _get_value_from_facts(self, variable_name, distribution, default_value):
    """"""Get distversion specific args first, then distribution, then family, lastly use default""""""
    attr = getattr(self, variable_name)
    value = attr.get(
        distribution['name']  distribution['version'],
        attr.get(
            distribution['name'],
            attr.get(
                distribution['family'],
                getattr(self, default_value))))
    return value
def get_shutdown_command_args(self, distribution):
    args = self._get_value_from_facts('SHUTDOWN_COMMAND_ARGS', distribution, 'DEFAULT_SHUTDOWN_COMMAND_ARGS')
    # Convert seconds to minutes. If less that 60, set it to 0.
    delay_min = self.pre_reboot_delay // 60
    reboot_message = self._task.args.get('msg', self.DEFAULT_REBOOT_MESSAGE)
    return args.format(delay_sec=self.pre_reboot_delay, delay_min=delay_min, message=reboot_message)
def get_distribution(self, task_vars):
    distribution = {}
    display.debug('{action}: running setup module to get distribution'.format(action=self._task.action))
    module_output = self._execute_module(
        task_vars=task_vars,
        module_name='setup',
        module_args={'gather_subset': 'min'})
    try:
        if module_output.get('failed', False):
            raise AnsibleError('Failed to determine system distribution. {0}, {1}'.format(
                to_native(module_output['module_stdout']).strip(),
                to_native(module_output['module_stderr']).strip()))
        distribution['name'] = module_output['ansible_facts']['ansible_distribution'].lower()
        distribution['version'] = to_text(module_output['ansible_facts']['ansible_distribution_version'].split('.')[0])
        distribution['family'] = to_text(module_output['ansible_facts']['ansible_os_family'].lower())
        display.debug(""{action}: distribution: {dist}"".format(action=self._task.action, dist=distribution))
        return distribution
    except KeyError as ke:
        raise AnsibleError('Failed to get distribution information. Missing ""{0}"" in output.'.format(ke.args[0]))
def get_shutdown_command(self, task_vars, distribution):
    shutdown_bin = self._get_value_from_facts('SHUTDOWN_COMMANDS', distribution, 'DEFAULT_SHUTDOWN_COMMAND')
    display.debug('{action}: running find module to get path for ""{command}""'.format(action=self._task.action, command=shutdown_bin))
    find_result = self._execute_module(
        task_vars=task_vars,
        module_name='find',
        module_args={
            'paths': ['/sbin', '/usr/sbin', '/usr/local/sbin'],
            'patterns': [shutdown_bin],
            'file_type': 'any'
        }
    )
    full_path = [x['path'] for x in find_result['files']]
    if not full_path:
        raise AnsibleError('Unable to find command ""{0}"" in system paths.'.format(shutdown_bin))
    self._shutdown_command = full_path[0]
    return self._shutdown_command
            display.warning(""Since Ansible {version}, {arg} is no longer a valid option for {action}"".format(
                version=version,
                arg=arg,
                action=self._task.action))
def get_system_boot_time(self, distribution):
    boot_time_command = self._get_value_from_facts('BOOT_TIME_COMMANDS', distribution, 'DEFAULT_BOOT_TIME_COMMAND')
    display.debug(""{action}: getting boot time with command: '{command}'"".format(action=self._task.action, command=boot_time_command))
        stdout = command_result['stdout']
        stderr = command_result['stderr']
        raise AnsibleError(""{action}: failed to get host boot time info, rc: {rc}, stdout: {out}, stderr: {err}"".format(
                           action=self._task.action,
                           rc=command_result['rc'],
                           out=to_native(stdout),
                           err=to_native(stderr)))
    display.debug(""{action}: last boot time: {boot}"".format(action=self._task.action, boot=command_result['stdout'].strip()))
def check_boot_time(self, distribution, previous_boot_time):
    display.vvv(""{action}: attempting to get system boot time"".format(action=self._task.action))
            display.debug(""{action}: setting connect_timeout to {value}"".format(action=self._task.action, value=connect_timeout))
"
-------------------------------------------------------------------------
"Recom
PRs: 49272, 49777"
-------------------------------------------------------------------------
=========================================================================
"msg = 'Test command failed: {err} {out}'.format(
    err=to_native(command_result['stderr']),
    out=to_native(command_result['stdout']))
raise RuntimeError(msg)
lay.vvv(""{action}: system sucessfully rebooted"".format(action=self._task.action))
ntil_success_or_timeout(self, action, reboot_timeout, action_desc, distribution, action_kwargs=None):
ction_kwargs is None:
action_kwargs = {}
    action(distribution=distribution, **action_kwargs)
        display.debug('{action}: {desc} success'.format(action=self._task.action, desc=action_desc))
"
-------------------------------------------------------------------------
"err_msg = 'Test command failed: {err} {out}'.format(
    err=to_text(command_ret['stderr']),
    out=to_text(command_ret['stdout']))
raise RuntimeError(err_msg)

self._display.vvv('{action}: system successfully rebooted'.format(action=self._task.action))

if not wait_until_success_or_timeout(self, action, reboot_timeout, action_desc, distribution, action_kwargs=None):
    if action_kwargs is None:
        action_kwargs = {}
    action(distribution=distribution, **action_kwargs)
    self._display.debug('{action}: {desc} success'.format(action=self._task.action, desc=action_desc))"
-------------------------------------------------------------------------
"current_boot_time = self.get_system_boot_time(distribution)
en(current_boot_time) == 0 or current_boot_time == previous_boot_time:
raise ValueError(""boot time has not changed"")
test_command(self, distribution, **kwargs):
_command = self._task.args.get('test_command', self._get_value_from_facts('TEST_COMMANDS', distribution, 'DEFAULT_TEST_COMMAND'))
lay.vvv(""{action}: attempting post-reboot test command"".format(action=self._task.action))
lay.debug(""{action}: attempting post-reboot test command '{command}'"".format(action=self._task.action, command=test_command))
"
-------------------------------------------------------------------------
"Recom
PRs: 49272, 49777"
-------------------------------------------------------------------------
=========================================================================
"display.debug(""{action}: {desc} fail '{err}', retrying in {sleep:.4} seconds..."".format(
    action=self._task.action,
    desc=action_desc,
    err=error,
    sleep=fail_sleep))
utException('Timed out waiting for {desc} (timeout={timeout})'.format(desc=action_desc, timeout=reboot_timeout))
ot(self, task_vars, distribution):
mand = self.get_shutdown_command(task_vars, distribution)
mand_args = self.get_shutdown_command_args(distribution)
nd = '{0} {1}'.format(shutdown_command, shutdown_command_args)
vvv(""{action}: rebooting server..."".format(action=self._task.action))
debug(""{action}: rebooting server with command '{command}'"".format(action=self._task.action, command=reboot_command))
esult = self._low_level_execute_command(reboot_command, sudoable=self.DEFAULT_SUDOABLE)
debug('{action}: AnsibleConnectionFailure caught and handled: {error}'.format(action=self._task.action, error=to_native(e)))
"
-------------------------------------------------------------------------
"ansible.utils.display.vvv(""{action}: rebooting server..."".format(action=self._task.action))
ansible.utils.display.debug(""{action}: rebooting server with command '{command}'"".format(action=self._task.action, command=reboot_command))
result = self._low_level_execute_command(reboot_command, sudoable=self.DEFAULT_SUDOABLE)
ansible.errors.AnsibleConnectionFailure('Timed out waiting for {desc} (timeout={timeout})'.format(desc=action_desc, timeout=reboot_timeout))
ansible.utils.display.debug(""{action}: {desc} fail '{err}', retrying in {sleep:.4} seconds..."".format(
    action=self._task.action,
    desc=action_desc,
    err=error,
    sleep=fail_sleep))"
-------------------------------------------------------------------------
"msg = 'Test command failed: {err} {out}'.format(
    err=to_native(command_result['stderr']),
    out=to_native(command_result['stdout']))
raise RuntimeError(msg)
lay.vvv(""{action}: system sucessfully rebooted"".format(action=self._task.action))
ntil_success_or_timeout(self, action, reboot_timeout, action_desc, distribution, action_kwargs=None):
ction_kwargs is None:
action_kwargs = {}
    action(distribution=distribution, **action_kwargs)
        display.debug('{action}: {desc} success'.format(action=self._task.action, desc=action_desc))
"
-------------------------------------------------------------------------
"Recom
PRs: 49272, 49777"
-------------------------------------------------------------------------
=========================================================================
"result['msg'] = ""Reboot command failed. Error was {stdout}, {stderr}"".format(
    stdout=to_native(reboot_result['stdout'].strip()),
    stderr=to_native(reboot_result['stderr'].strip()))
date_reboot(self, distribution, original_connection_timeout=None, action_kwargs=None):
lay.vvv('{action}: validating reboot'.format(action=self._task.action))
self.do_until_success_or_timeout(
    action=self.check_boot_time,
    action_desc=""last boot time check"",
    reboot_timeout=reboot_timeout,
    distribution=distribution,
    action_kwargs=action_kwargs)
if connect_timeout and original_connection_timeout:
        display.debug(""{action}: setting connect_timeout back to original value of {value}"".format(
            action=self._task.action,
            value=original_connection_timeout))
        self._connection.set_option(""connection_timeout"", original_connection_timeout)
        display.debug(""{action}: failed to reset connection_timeout back to default: {error}"".format(action=self._task.action, error=to_text(e)))
self.do_until_success_or_timeout(
    action=self.run_test_command,
    action_desc=""post-reboot test command"",
    reboot_timeout=reboot_timeout,
    distribution=distribution,
    action_kwargs=action_kwargs)
"
-------------------------------------------------------------------------
"result['msg'] = ""Shutdown command failed, error was: {stdout} {stderr}"".format(
            stdout=to_native(stdout.strip()),
            stderr=to_native(stderr.strip())
        )
display.vvv('{action}: validating reboot'.format(
            action=self._task.action)
        )
self.do_until_success_or_timeout(
            action=self.check_boot_time,
            action_desc=""last boot time check"",
            reboot_timeout=self.reboot_timeout,
            distribution=self.distribution,
            action_kwargs=action_kwargs
        )
if connect_timeout and self._original_connection_timeout:
    display.debug(""{action}: setting connect_timeout back to original value of {value}"".format(
        action=self._task.action,
        value=self._original_connection_timeout)
    )
    self._connection.set_option(""connection_timeout"", self._original_connection_timeout)
    display.debug(""{action}: failed to reset connection_timeout back to default: {error}"".format(action=self._task.action, error=to_text(e)))
self.do_until_success_or_timeout(
            action=self.run_test_command,
            action_desc=""post-reboot test command"",
            reboot_timeout=self.reboot_timeout,
            distribution=self.distribution,
            action_kwargs=action_kwargs
        )"
-------------------------------------------------------------------------
"display.debug(""{action}: {desc} fail '{err}', retrying in {sleep:.4} seconds..."".format(
    action=self._task.action,
    desc=action_desc,
    err=error,
    sleep=fail_sleep))
utException('Timed out waiting for {desc} (timeout={timeout})'.format(desc=action_desc, timeout=reboot_timeout))
ot(self, task_vars, distribution):
mand = self.get_shutdown_command(task_vars, distribution)
mand_args = self.get_shutdown_command_args(distribution)
nd = '{0} {1}'.format(shutdown_command, shutdown_command_args)
vvv(""{action}: rebooting server..."".format(action=self._task.action))
debug(""{action}: rebooting server with command '{command}'"".format(action=self._task.action, command=reboot_command))
esult = self._low_level_execute_command(reboot_command, sudoable=self.DEFAULT_SUDOABLE)
debug('{action}: AnsibleConnectionFailure caught and handled: {error}'.format(action=self._task.action, error=to_native(e)))
"
-------------------------------------------------------------------------
"Recom
PRs: 49272, 49777"
-------------------------------------------------------------------------
=========================================================================
"return {'changed': False, 'elapsed': 0, 'rebooted': False, 'failed': True, 'msg': msg}
return {'changed': True, 'elapsed': 0, 'rebooted': True}
task_vars = {}
"
-------------------------------------------------------------------------
"return {'changed': False, 'elapsed': 0, 'rebooted': False, 'failed': True, 'msg': msg}
return {'changed': True, 'elapsed': 0, 'rebooted': True}
result = {}"
-------------------------------------------------------------------------
"result['msg'] = ""Reboot command failed. Error was {stdout}, {stderr}"".format(
    stdout=to_native(reboot_result['stdout'].strip()),
    stderr=to_native(reboot_result['stderr'].strip()))
date_reboot(self, distribution, original_connection_timeout=None, action_kwargs=None):
lay.vvv('{action}: validating reboot'.format(action=self._task.action))
self.do_until_success_or_timeout(
    action=self.check_boot_time,
    action_desc=""last boot time check"",
    reboot_timeout=reboot_timeout,
    distribution=distribution,
    action_kwargs=action_kwargs)
if connect_timeout and original_connection_timeout:
        display.debug(""{action}: setting connect_timeout back to original value of {value}"".format(
            action=self._task.action,
            value=original_connection_timeout))
        self._connection.set_option(""connection_timeout"", original_connection_timeout)
        display.debug(""{action}: failed to reset connection_timeout back to default: {error}"".format(action=self._task.action, error=to_text(e)))
self.do_until_success_or_timeout(
    action=self.run_test_command,
    action_desc=""post-reboot test command"",
    reboot_timeout=reboot_timeout,
    distribution=distribution,
    action_kwargs=action_kwargs)
"
-------------------------------------------------------------------------
"Recom
PRs: 49272, 49777"
-------------------------------------------------------------------------
=========================================================================
"distribution = self.get_distribution(task_vars)
    previous_boot_time = self.get_system_boot_time(distribution)
# Get the original connection_timeout option var so it can be reset after
original_connection_timeout = None
try:
    original_connection_timeout = self._connection.get_option('connection_timeout')
    display.debug(""{action}: saving original connect_timeout of {timeout}"".format(action=self._task.action, timeout=original_connection_timeout))
except AnsibleError:
    display.debug(""{action}: connect_timeout connection option has not been set"".format(action=self._task.action))
reboot_result = self.perform_reboot(task_vars, distribution)
"
-------------------------------------------------------------------------
"distribution = self.get_distribution(task_vars)
previous_boot_time = self.get_system_boot_time(distribution)

# Get the original connection_timeout option var so it can be reset after
original_connection_timeout = None
try:
    original_connection_timeout = self._connection.get_option('connection_timeout')
    self.display.debug(""{action}: saving original connect_timeout of {timeout}"".format(action=self._task.action, timeout=original_connection_timeout))
except ansible.errors.AnsibleError:
    self.display.debug(""{action}: connect_timeout connection option has not been set"".format(action=self._task.action))
reboot_result = self.perform_reboot(task_vars, distribution)"
-------------------------------------------------------------------------
"return {'changed': False, 'elapsed': 0, 'rebooted': False, 'failed': True, 'msg': msg}
return {'changed': True, 'elapsed': 0, 'rebooted': True}
task_vars = {}
"
-------------------------------------------------------------------------
"Recom
PRs: 49272, 49777"
-------------------------------------------------------------------------
=========================================================================
"if self.post_reboot_delay != 0:
    display.debug(""{action}: waiting an additional {delay} seconds"".format(action=self._task.action, delay=self.post_reboot_delay))
    display.vvv(""{action}: waiting an additional {delay} seconds"".format(action=self._task.action, delay=self.post_reboot_delay))
    time.sleep(self.post_reboot_delay)
result = self.validate_reboot(distribution, original_connection_timeout, action_kwargs={'previous_boot_time': previous_boot_time})
"
-------------------------------------------------------------------------
"if self.post_reboot_delay != 0:
    display.debug(""{action}: waiting an additional {delay} seconds"".format(action=self._task.action, delay=self.post_reboot_delay))
    display.vvv(""{action}: waiting an additional {delay} seconds"".format(action=self._task.action, delay=self.post_reboot_delay))
    time.sleep(self.post_reboot_delay)
validate_result = self.validate_reboot(distribution, original_connection_timeout, action_kwargs={'previous_boot_time': previous_boot_time})"
-------------------------------------------------------------------------
"distribution = self.get_distribution(task_vars)
    previous_boot_time = self.get_system_boot_time(distribution)
# Get the original connection_timeout option var so it can be reset after
original_connection_timeout = None
try:
    original_connection_timeout = self._connection.get_option('connection_timeout')
    display.debug(""{action}: saving original connect_timeout of {timeout}"".format(action=self._task.action, timeout=original_connection_timeout))
except AnsibleError:
    display.debug(""{action}: connect_timeout connection option has not been set"".format(action=self._task.action))
reboot_result = self.perform_reboot(task_vars, distribution)
"
-------------------------------------------------------------------------
"Recom
PRs: 49272, 49777"
-------------------------------------------------------------------------
=========================================================================
"if len(split_fields) == 2 and split_fields[0:2] == ['iam', 'info_instanceprofilearn']:
    new_fields[self._prefix % ""iam-instance-profile-role""] = value.split('/')[1]
"
-------------------------------------------------------------------------
"if len(split_fields) == 2 and split_fields[0:2] == ['iam', 'info_instanceprofilearn']:
    new_fields[self._prefix % ""iam-instance-profile-role""] = value.split('/')[1]"
-------------------------------------------------------------------------
"# Parse out the IAM role name (which is _not_ the same as the instance profile name)
if len(split_fields) == 3 and split_fields[0:2] == ['iam', 'security-credentials'] and ':' not in split_fields[2]:
    new_fields[self._prefix % ""iam-instance-profile-role""] = split_fields[2]
"
-------------------------------------------------------------------------
"Recom
PRs: 45534, 49428"
-------------------------------------------------------------------------
=========================================================================
"if len(split_fields) == 2 and split_fields[0:2] == ['iam', 'info_instanceprofilearn']:
    new_fields[self._prefix % ""iam-instance-profile-role""] = value.split('/')[1]
"
-------------------------------------------------------------------------
"if len(split_fields) == 2 and split_fields[0:2] == ['iam', 'info_instanceprofilearn']:
    new_fields[self._prefix % ""iam-instance-profile-role""] = value.split('/')[1]"
-------------------------------------------------------------------------
"# Parse out the IAM role name (which is _not_ the same as the instance profile name)
if len(split_fields) == 3 and split_fields[0:2] == ['iam', 'security-credentials'] and ':' not in split_fields[2]:
    new_fields[self._prefix % ""iam-instance-profile-role""] = split_fields[2]
"
-------------------------------------------------------------------------
"Recom
PRs: 45534, 49427"
-------------------------------------------------------------------------
=========================================================================
"- When connecting to Docker daemon with TLS, you might need to install additional Python packages.
  For the Docker SDK for Python, version 2.4 or newer, this can be done by installing C(docker[tls]) with M(pip).
"
-------------------------------------------------------------------------
"When connecting to Docker daemon with TLS, you might need to install additional Python packages.
  For the Docker SDK for Python, version 2.4 or newer, this can be done by installing `docker[tls]` with `pip`."
-------------------------------------------------------------------------
"U(https://docker-py.readthedocs.io/en/stable/machine/) for more details.
When connecting to Docker daemon with TLS, you might need to install additional Python packages.
For the Docker SDK for Python, version 2.4 or newer, this can be done by installing C(docker[tls]) with M(pip).
"
-------------------------------------------------------------------------
"Recom
PRs: 49095, 49153"
-------------------------------------------------------------------------
=========================================================================
"self.log(differences.get_legacy_docker_container_diffs(), pretty_print=True)
"
-------------------------------------------------------------------------
"self.log(self.differences.get_legacy_docker_container_diffs(), pretty_print=True)"
-------------------------------------------------------------------------
"if network.get('ipv4_address') is not None or network.get('ipv6_address') is not None:
"
-------------------------------------------------------------------------
"Recom
PRs: 49078, 49152"
-------------------------------------------------------------------------
=========================================================================
"#     value: ""{{ sample_com_challenge.challenge_data['sample.com']['dns-01'].resource_value | regex_replace('^(.*)$', '\""\\1\""') }}""
"
-------------------------------------------------------------------------
"#     value: ""{{ sample_com_challenge.challenge_data['sample.com']['dns-01'].resource_value }}"""
-------------------------------------------------------------------------
"#     state: present
#     value: ""{{ sample_com_challenge.challenge_data['sample.com']['dns-01'].resource_value | regex_replace('^(.*)$', '\""\\1\""') }}""
"
-------------------------------------------------------------------------
"Recom
PRs: 49031, 49082"
-------------------------------------------------------------------------
=========================================================================
"#     value: ""{{ item.value | map('regex_replace', '^(.*)$', '\""\\1\""' ) | list }}""
"
-------------------------------------------------------------------------
"#     value: ""{{ item.value | map('regex_replace', '^(.*)$', '\""\\1\""' ) | list }}"""
-------------------------------------------------------------------------
"#     state: present
#     value: ""{{ item.value | map('regex_replace', '^(.*)$', '\""\\1\""' ) | list }}""
"
-------------------------------------------------------------------------
"Recom
PRs: 49031, 49082"
-------------------------------------------------------------------------
=========================================================================
"# Copyright (c) 2018 Cisco and/or its affiliates.
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#
from __future__ import absolute_import
import copy
import json
import unittest
import pytest
from units.compat import mock
from ansible.module_utils.network.ftd.common import FtdServerError, HTTPMethod, ResponseParams, FtdConfigurationError
from ansible.module_utils.network.ftd.configuration import DUPLICATE_NAME_ERROR_MESSAGE, UNPROCESSABLE_ENTITY_STATUS, \
    MULTIPLE_DUPLICATES_FOUND_ERROR, BaseConfigurationResource, FtdInvalidOperationNameError, QueryParams
from ansible.module_utils.network.ftd.fdm_swagger_client import ValidationError
ADD_RESPONSE = {'status': 'Object added'}
EDIT_RESPONSE = {'status': 'Object edited'}
DELETE_RESPONSE = {'status': 'Object deleted'}
GET_BY_FILTER_RESPONSE = [{'name': 'foo', 'description': 'bar'}]
ARBITRARY_RESPONSE = {'status': 'Arbitrary request sent'}
class TestUpsertOperationUnitTests(unittest.TestCase):
    def setUp(self):
        conn = mock.MagicMock()
        self._resource = BaseConfigurationResource(conn)
    def test_get_operation_name(self):
        operation_a = mock.MagicMock()
        operation_b = mock.MagicMock()
        def checker_wrapper(expected_object):
            def checker(obj, *args, **kwargs):
                return obj == expected_object
            return checker
        operations = {
            operation_a: ""spec"",
            operation_b: ""spec""
        }
        assert operation_a == self._resource._get_operation_name(checker_wrapper(operation_a), operations)
        assert operation_b == self._resource._get_operation_name(checker_wrapper(operation_b), operations)
        self.assertRaises(
            FtdConfigurationError,
            self._resource._get_operation_name, checker_wrapper(None), operations
        )
    @mock.patch.object(BaseConfigurationResource, ""_get_operation_name"")
    @mock.patch.object(BaseConfigurationResource, ""add_object"")
    def test_add_upserted_object(self, add_object_mock, get_operation_mock):
        model_operations = mock.MagicMock()
        params = mock.MagicMock()
        add_op_name = get_operation_mock.return_value
        assert add_object_mock.return_value == self._resource._add_upserted_object(model_operations, params)
        get_operation_mock.assert_called_once_with(
            self._resource._operation_checker.is_add_operation,
            model_operations)
        add_object_mock.assert_called_once_with(add_op_name, params)
    @mock.patch.object(BaseConfigurationResource, ""_get_operation_name"")
    @mock.patch.object(BaseConfigurationResource, ""edit_object"")
    @mock.patch(""ansible.module_utils.network.ftd.configuration.copy_identity_properties"")
    @mock.patch(""ansible.module_utils.network.ftd.configuration._set_default"")
    def test_edit_upserted_object(self, _set_default_mock, copy_properties_mock, edit_object_mock, get_operation_mock):
        model_operations = mock.MagicMock()
        existing_object = mock.MagicMock()
        params = {
            'path_params': {},
            'data': {}
        }
        result = self._resource._edit_upserted_object(model_operations, existing_object, params)
        assert result == edit_object_mock.return_value
        _set_default_mock.assert_has_calls([
            mock.call(params, 'path_params', {}),
            mock.call(params, 'data', {})
        ])
        get_operation_mock.assert_called_once_with(
            self._resource._operation_checker.is_edit_operation,
            model_operations
        )
        copy_properties_mock.assert_called_once_with(
            existing_object,
            params['data']
        )
        edit_object_mock.assert_called_once_with(
            get_operation_mock.return_value,
            params
        )
    @mock.patch.object(BaseConfigurationResource, ""get_operation_specs_by_model_name"")
    @mock.patch(""ansible.module_utils.network.ftd.configuration.OperationChecker.is_upsert_operation_supported"")
    @mock.patch(""ansible.module_utils.network.ftd.configuration._extract_model_from_upsert_operation"")
    def test_is_upsert_operation_supported(self, extract_model_mock, is_upsert_supported_mock, get_operation_spec_mock):
        op_name = mock.MagicMock()
        result = self._resource.is_upsert_operation_supported(op_name)
        assert result == is_upsert_supported_mock.return_value
        extract_model_mock.assert_called_once_with(op_name)
        get_operation_spec_mock.assert_called_once_with(extract_model_mock.return_value)
        is_upsert_supported_mock.assert_called_once_with(get_operation_spec_mock.return_value)
    @mock.patch.object(BaseConfigurationResource, ""is_upsert_operation_supported"")
    @mock.patch.object(BaseConfigurationResource, ""get_operation_specs_by_model_name"")
    @mock.patch.object(BaseConfigurationResource, ""_add_upserted_object"")
    @mock.patch.object(BaseConfigurationResource, ""_edit_upserted_object"")
    @mock.patch(""ansible.module_utils.network.ftd.configuration._extract_model_from_upsert_operation"")
    def test_upsert_object_succesfully_added(self, extract_model_mock, edit_mock, add_mock, get_operation_mock,
                                             is_upsert_supported_mock):
        op_name = mock.MagicMock()
        params = mock.MagicMock()
        is_upsert_supported_mock.return_value = True
        result = self._resource.upsert_object(op_name, params)
        assert result == add_mock.return_value
        is_upsert_supported_mock.assert_called_once_with(op_name)
        extract_model_mock.assert_called_once_with(op_name)
        get_operation_mock.assert_called_once_with(extract_model_mock.return_value)
        add_mock.assert_called_once_with(get_operation_mock.return_value, params)
        edit_mock.assert_not_called()
    @mock.patch.object(BaseConfigurationResource, ""is_upsert_operation_supported"")
    @mock.patch.object(BaseConfigurationResource, ""get_operation_specs_by_model_name"")
    @mock.patch.object(BaseConfigurationResource, ""_add_upserted_object"")
    @mock.patch.object(BaseConfigurationResource, ""_edit_upserted_object"")
    @mock.patch(""ansible.module_utils.network.ftd.configuration._extract_model_from_upsert_operation"")
    def test_upsert_object_succesfully_edited(self, extract_model_mock, edit_mock, add_mock, get_operation_mock,
                                              is_upsert_supported_mock):
        op_name = mock.MagicMock()
        params = mock.MagicMock()
        is_upsert_supported_mock.return_value = True
        error = FtdConfigurationError(""Obj duplication error"")
        error.obj = mock.MagicMock()
        add_mock.side_effect = error
        result = self._resource.upsert_object(op_name, params)
        assert result == edit_mock.return_value
        is_upsert_supported_mock.assert_called_once_with(op_name)
        extract_model_mock.assert_called_once_with(op_name)
        get_operation_mock.assert_called_once_with(extract_model_mock.return_value)
        add_mock.assert_called_once_with(get_operation_mock.return_value, params)
        edit_mock.assert_called_once_with(get_operation_mock.return_value, error.obj, params)
    @mock.patch.object(BaseConfigurationResource, ""is_upsert_operation_supported"")
    @mock.patch.object(BaseConfigurationResource, ""get_operation_specs_by_model_name"")
    @mock.patch.object(BaseConfigurationResource, ""_add_upserted_object"")
    @mock.patch.object(BaseConfigurationResource, ""_edit_upserted_object"")
    @mock.patch(""ansible.module_utils.network.ftd.configuration._extract_model_from_upsert_operation"")
    def test_upsert_object_not_supported(self, extract_model_mock, edit_mock, add_mock, get_operation_mock,
                                         is_upsert_supported_mock):
        op_name = mock.MagicMock()
        params = mock.MagicMock()
        is_upsert_supported_mock.return_value = False
        self.assertRaises(
            FtdInvalidOperationNameError,
            self._resource.upsert_object, op_name, params
        )
        is_upsert_supported_mock.assert_called_once_with(op_name)
        extract_model_mock.assert_not_called()
        get_operation_mock.assert_not_called()
        add_mock.assert_not_called()
        edit_mock.assert_not_called()
    @mock.patch.object(BaseConfigurationResource, ""is_upsert_operation_supported"")
    @mock.patch.object(BaseConfigurationResource, ""get_operation_specs_by_model_name"")
    @mock.patch.object(BaseConfigurationResource, ""_add_upserted_object"")
    @mock.patch.object(BaseConfigurationResource, ""_edit_upserted_object"")
    @mock.patch(""ansible.module_utils.network.ftd.configuration._extract_model_from_upsert_operation"")
    def test_upsert_object_neither_added_nor_edited(self, extract_model_mock, edit_mock, add_mock, get_operation_mock,
                                                    is_upsert_supported_mock):
        op_name = mock.MagicMock()
        params = mock.MagicMock()
        is_upsert_supported_mock.return_value = True
        error = FtdConfigurationError(""Obj duplication error"")
        error.obj = mock.MagicMock()
        add_mock.side_effect = error
        edit_mock.side_effect = FtdConfigurationError(""Some object edit error"")
        self.assertRaises(
            FtdConfigurationError,
            self._resource.upsert_object, op_name, params
        )
        is_upsert_supported_mock.assert_called_once_with(op_name)
        extract_model_mock.assert_called_once_with(op_name)
        get_operation_mock.assert_called_once_with(extract_model_mock.return_value)
        add_mock.assert_called_once_with(get_operation_mock.return_value, params)
        edit_mock.assert_called_once_with(get_operation_mock.return_value, error.obj, params)
    @mock.patch.object(BaseConfigurationResource, ""is_upsert_operation_supported"")
    @mock.patch.object(BaseConfigurationResource, ""get_operation_specs_by_model_name"")
    @mock.patch.object(BaseConfigurationResource, ""_add_upserted_object"")
    @mock.patch.object(BaseConfigurationResource, ""_edit_upserted_object"")
    @mock.patch(""ansible.module_utils.network.ftd.configuration._extract_model_from_upsert_operation"")
    def test_upsert_object_with_fatal_error_during_add(self, extract_model_mock, edit_mock, add_mock,
                                                       get_operation_mock, is_upsert_supported_mock):
        op_name = mock.MagicMock()
        params = mock.MagicMock()
        is_upsert_supported_mock.return_value = True
        error = FtdConfigurationError(""Obj duplication error"")
        add_mock.side_effect = error
        self.assertRaises(
            FtdConfigurationError,
            self._resource.upsert_object, op_name, params
        )
        is_upsert_supported_mock.assert_called_once_with(op_name)
        extract_model_mock.assert_called_once_with(op_name)
        get_operation_mock.assert_called_once_with(extract_model_mock.return_value)
        add_mock.assert_called_once_with(get_operation_mock.return_value, params)
        edit_mock.assert_not_called()
# functional tests below
class TestUpsertOperationFunctionalTests(object):
    @pytest.fixture(autouse=True)
    def connection_mock(self, mocker):
        connection_class_mock = mocker.patch('ansible.modules.network.ftd.ftd_configuration.Connection')
        connection_instance = connection_class_mock.return_value
        connection_instance.validate_data.return_value = True, None
        connection_instance.validate_query_params.return_value = True, None
        connection_instance.validate_path_params.return_value = True, None
        return connection_instance
    def test_module_should_create_object_when_upsert_operation_and_object_does_not_exist(self, connection_mock):
        url = '/test'
        operations = {
            'getObjectList': {
                'method': HTTPMethod.GET,
                'url': url,
                'modelName': 'Object',
                'returnMultipleItems': True},
            'addObject': {
                'method': HTTPMethod.POST,
                'modelName': 'Object',
                'url': url},
            'editObject': {
                'method': HTTPMethod.PUT,
                'modelName': 'Object',
                'url': '/test/{objId}'},
            'otherObjectOperation': {
                'method': HTTPMethod.GET,
                'modelName': 'Object',
                'url': '/test/{objId}',
                'returnMultipleItems': False
            }
        }
        def get_operation_spec(name):
            return operations[name]
        connection_mock.get_operation_spec = get_operation_spec
        connection_mock.get_operation_specs_by_model_name.return_value = operations
        connection_mock.send_request.return_value = {
            ResponseParams.SUCCESS: True,
            ResponseParams.RESPONSE: ADD_RESPONSE
        }
        params = {
            'operation': 'upsertObject',
            'data': {'id': '123', 'name': 'testObject', 'type': 'object'},
            'path_params': {'objId': '123'},
            'register_as': 'test_var'
        }
        result = self._resource_execute_operation(params, connection=connection_mock)
        connection_mock.send_request.assert_called_once_with(url_path=url,
                                                             http_method=HTTPMethod.POST,
                                                             path_params=params['path_params'],
                                                             query_params={},
                                                             body_params=params['data'])
        assert ADD_RESPONSE == result
    # test when object exists but with different fields(except id)
    def test_module_should_update_object_when_upsert_operation_and_object_exists(self, connection_mock):
        url = '/test'
        obj_id = '456'
        version = 'test_version'
        url_with_id_templ = '{0}/{1}'.format(url, '{objId}')
        new_value = '0000'
        old_value = '1111'
        params = {
            'operation': 'upsertObject',
            'data': {'name': 'testObject', 'value': new_value, 'type': 'object'},
            'register_as': 'test_var'
        }
        def request_handler(url_path=None, http_method=None, body_params=None, path_params=None, query_params=None):
            if http_method == HTTPMethod.POST:
                assert url_path == url
                assert body_params == params['data']
                assert query_params == {}
                assert path_params == {}
                return {
                    ResponseParams.SUCCESS: False,
                    ResponseParams.RESPONSE: DUPLICATE_NAME_ERROR_MESSAGE,
                    ResponseParams.STATUS_CODE: UNPROCESSABLE_ENTITY_STATUS
                }
            elif http_method == HTTPMethod.GET:
                is_get_list_req = url_path == url
                is_get_req = url_path == url_with_id_templ
                assert is_get_req or is_get_list_req
                if is_get_list_req:
                    assert body_params == {}
                    assert query_params == {QueryParams.FILTER: 'name:testObject', 'limit': 10, 'offset': 0}
                    assert path_params == {}
                elif is_get_req:
                    assert body_params == {}
                    assert query_params == {}
                    assert path_params == {'objId': obj_id}
                return {
                    ResponseParams.SUCCESS: True,
                    ResponseParams.RESPONSE: {
                        'items': [
                            {'name': 'testObject', 'value': old_value, 'type': 'object', 'id': obj_id,
                             'version': version}
                        ]
                    }
                }
            elif http_method == HTTPMethod.PUT:
                assert url_path == url_with_id_templ
                return {
                    ResponseParams.SUCCESS: True,
                    ResponseParams.RESPONSE: body_params
                }
            else:
                assert False
        operations = {
            'getObjectList': {'method': HTTPMethod.GET, 'url': url, 'modelName': 'Object', 'returnMultipleItems': True},
            'addObject': {'method': HTTPMethod.POST, 'modelName': 'Object', 'url': url},
            'editObject': {'method': HTTPMethod.PUT, 'modelName': 'Object', 'url': url_with_id_templ},
            'otherObjectOperation': {
                'method': HTTPMethod.GET,
                'modelName': 'Object',
                'url': url_with_id_templ,
                'returnMultipleItems': False}
        }
        def get_operation_spec(name):
            return operations[name]
        connection_mock.get_operation_spec = get_operation_spec
        connection_mock.get_operation_specs_by_model_name.return_value = operations
        connection_mock.send_request = request_handler
        expected_val = {'name': 'testObject', 'value': new_value, 'type': 'object', 'id': obj_id, 'version': version}
        result = self._resource_execute_operation(params, connection=connection_mock)
        assert expected_val == result
    # test when object exists and all fields have the same value
    def test_module_should_not_update_object_when_upsert_operation_and_object_exists_with_the_same_fields(
            self, connection_mock):
        url = '/test'
        url_with_id_templ = '{0}/{1}'.format(url, '{objId}')
        params = {
            'operation': 'upsertObject',
            'data': {'name': 'testObject', 'value': '3333', 'type': 'object'},
            'register_as': 'test_var'
        }
        expected_val = copy.deepcopy(params['data'])
        expected_val['version'] = 'test_version'
        expected_val['id'] = 'test_id'
        def request_handler(url_path=None, http_method=None, body_params=None, path_params=None, query_params=None):
            if http_method == HTTPMethod.POST:
                assert url_path == url
                assert body_params == params['data']
                assert query_params == {}
                assert path_params == {}
                return {
                    ResponseParams.SUCCESS: False,
                    ResponseParams.RESPONSE: DUPLICATE_NAME_ERROR_MESSAGE,
                    ResponseParams.STATUS_CODE: UNPROCESSABLE_ENTITY_STATUS
                }
            elif http_method == HTTPMethod.GET:
                assert url_path == url
                assert body_params == {}
                assert query_params == {QueryParams.FILTER: 'name:testObject', 'limit': 10, 'offset': 0}
                assert path_params == {}
                return {
                    ResponseParams.SUCCESS: True,
                    ResponseParams.RESPONSE: {
                        'items': [expected_val]
                    }
                }
            else:
                assert False
        operations = {
            'getObjectList': {'method': HTTPMethod.GET, 'modelName': 'Object', 'url': url, 'returnMultipleItems': True},
            'addObject': {'method': HTTPMethod.POST, 'modelName': 'Object', 'url': url},
            'editObject': {'method': HTTPMethod.PUT, 'modelName': 'Object', 'url': url_with_id_templ},
            'otherObjectOperation': {
                'method': HTTPMethod.GET,
                'modelName': 'Object',
                'url': url_with_id_templ,
                'returnMultipleItems': False}
        }
        def get_operation_spec(name):
            return operations[name]
        connection_mock.get_operation_spec = get_operation_spec
        connection_mock.get_operation_specs_by_model_name.return_value = operations
        connection_mock.send_request = request_handler
        result = self._resource_execute_operation(params, connection=connection_mock)
        assert expected_val == result
    def test_module_should_fail_when_upsert_operation_is_not_supported(self, connection_mock):
        connection_mock.get_operation_specs_by_model_name.return_value = {
            'addObject': {'method': HTTPMethod.POST, 'modelName': 'Object', 'url': '/test'},
            'editObject': {'method': HTTPMethod.PUT, 'modelName': 'Object', 'url': '/test/{objId}'},
            'otherObjectOperation': {
                'method': HTTPMethod.GET,
                'modelName': 'Object',
                'url': '/test/{objId}',
                'returnMultipleItems': False}
        }
        operation_name = 'upsertObject'
        params = {
            'operation': operation_name,
            'data': {'id': '123', 'name': 'testObject', 'type': 'object'},
            'path_params': {'objId': '123'},
            'register_as': 'test_var'
        }
        result = self._resource_execute_operation_with_expected_failure(
            expected_exception_class=FtdInvalidOperationNameError,
            params=params, connection=connection_mock)
        connection_mock.send_request.assert_not_called()
        assert operation_name == result.operation_name
    # when create operation raised FtdConfigurationError exception without id and version
    def test_module_should_fail_when_upsert_operation_and_failed_create_without_id_and_version(self, connection_mock):
        url = '/test'
        url_with_id_templ = '{0}/{1}'.format(url, '{objId}')
        params = {
            'operation': 'upsertObject',
            'data': {'name': 'testObject', 'value': '3333', 'type': 'object'},
            'register_as': 'test_var'
        }
        def request_handler(url_path=None, http_method=None, body_params=None, path_params=None, query_params=None):
            if http_method == HTTPMethod.POST:
                assert url_path == url
                assert body_params == params['data']
                assert query_params == {}
                assert path_params == {}
                return {
                    ResponseParams.SUCCESS: False,
                    ResponseParams.RESPONSE: DUPLICATE_NAME_ERROR_MESSAGE,
                    ResponseParams.STATUS_CODE: UNPROCESSABLE_ENTITY_STATUS
                }
            elif http_method == HTTPMethod.GET:
                assert url_path == url
                assert body_params == {}
                assert query_params == {QueryParams.FILTER: 'name:testObject', 'limit': 10, 'offset': 0}
                assert path_params == {}
                return {
                    ResponseParams.SUCCESS: True,
                    ResponseParams.RESPONSE: {
                        'items': []
                    }
                }
            else:
                assert False
        operations = {
            'getObjectList': {'method': HTTPMethod.GET, 'modelName': 'Object', 'url': url, 'returnMultipleItems': True},
            'addObject': {'method': HTTPMethod.POST, 'modelName': 'Object', 'url': url},
            'editObject': {'method': HTTPMethod.PUT, 'modelName': 'Object', 'url': url_with_id_templ},
            'otherObjectOperation': {
                'method': HTTPMethod.GET,
                'modelName': 'Object',
                'url': url_with_id_templ,
                'returnMultipleItems': False}
        }
        def get_operation_spec(name):
            return operations[name]
        connection_mock.get_operation_spec = get_operation_spec
        connection_mock.get_operation_specs_by_model_name.return_value = operations
        connection_mock.send_request = request_handler
        result = self._resource_execute_operation_with_expected_failure(
            expected_exception_class=FtdServerError,
            params=params, connection=connection_mock)
        assert result.code == 422
        assert result.response == 'Validation failed due to a duplicate name'
    def test_module_should_fail_when_upsert_operation_and_failed_update_operation(self, connection_mock):
        url = '/test'
        obj_id = '456'
        version = 'test_version'
        url_with_id_templ = '{0}/{1}'.format(url, '{objId}')
        error_code = 404
        new_value = '0000'
        old_value = '1111'
        params = {
            'operation': 'upsertObject',
            'data': {'name': 'testObject', 'value': new_value, 'type': 'object'},
            'register_as': 'test_var'
        }
        error_msg = 'test error'
        def request_handler(url_path=None, http_method=None, body_params=None, path_params=None, query_params=None):
            if http_method == HTTPMethod.POST:
                assert url_path == url
                assert body_params == params['data']
                assert query_params == {}
                assert path_params == {}
                return {
                    ResponseParams.SUCCESS: False,
                    ResponseParams.RESPONSE: DUPLICATE_NAME_ERROR_MESSAGE,
                    ResponseParams.STATUS_CODE: UNPROCESSABLE_ENTITY_STATUS
                }
            elif http_method == HTTPMethod.GET:
                is_get_list_req = url_path == url
                is_get_req = url_path == url_with_id_templ
                assert is_get_req or is_get_list_req
                if is_get_list_req:
                    assert body_params == {}
                    assert query_params == {QueryParams.FILTER: 'name:testObject', 'limit': 10, 'offset': 0}
                elif is_get_req:
                    assert body_params == {}
                    assert query_params == {}
                    assert path_params == {'objId': obj_id}
                return {
                    ResponseParams.SUCCESS: True,
                    ResponseParams.RESPONSE: {
                        'items': [
                            {'name': 'testObject', 'value': old_value, 'type': 'object', 'id': obj_id,
                             'version': version}
                        ]
                    }
                }
            elif http_method == HTTPMethod.PUT:
                assert url_path == url_with_id_templ
                raise FtdServerError(error_msg, error_code)
            else:
                assert False
        operations = {
            'getObjectList': {'method': HTTPMethod.GET, 'modelName': 'Object', 'url': url, 'returnMultipleItems': True},
            'addObject': {'method': HTTPMethod.POST, 'modelName': 'Object', 'url': url},
            'editObject': {'method': HTTPMethod.PUT, 'modelName': 'Object', 'url': url_with_id_templ},
            'otherObjectOperation': {
                'method': HTTPMethod.GET,
                'modelName': 'Object',
                'url': url_with_id_templ,
                'returnMultipleItems': False}
        }
        def get_operation_spec(name):
            return operations[name]
        connection_mock.get_operation_spec = get_operation_spec
        connection_mock.get_operation_specs_by_model_name.return_value = operations
        connection_mock.send_request = request_handler
        result = self._resource_execute_operation_with_expected_failure(
            expected_exception_class=FtdServerError,
            params=params, connection=connection_mock)
        assert result.code == error_code
        assert result.response == error_msg
    def test_module_should_fail_when_upsert_operation_and_invalid_data_for_create_operation(self, connection_mock):
        new_value = '0000'
        params = {
            'operation': 'upsertObject',
            'data': {'name': 'testObject', 'value': new_value, 'type': 'object'},
            'register_as': 'test_var'
        }
        connection_mock.send_request.assert_not_called()
        operations = {
            'getObjectList': {
                'method': HTTPMethod.GET,
                'modelName': 'Object',
                'url': 'sd',
                'returnMultipleItems': True},
            'addObject': {'method': HTTPMethod.POST, 'modelName': 'Object', 'url': 'sdf'},
            'editObject': {'method': HTTPMethod.PUT, 'modelName': 'Object', 'url': 'sadf'},
            'otherObjectOperation': {
                'method': HTTPMethod.GET,
                'modelName': 'Object',
                'url': 'sdfs',
                'returnMultipleItems': False}
        }
        def get_operation_spec(name):
            return operations[name]
        connection_mock.get_operation_spec = get_operation_spec
        connection_mock.get_operation_specs_by_model_name.return_value = operations
        report = {
            'required': ['objects[0].type'],
            'invalid_type': [
                {
                    'path': 'objects[3].id',
                    'expected_type': 'string',
                    'actually_value': 1
                }
            ]
        }
        connection_mock.validate_data.return_value = (False, json.dumps(report, sort_keys=True, indent=4))
        key = 'Invalid data provided'
        result = self._resource_execute_operation_with_expected_failure(
            expected_exception_class=ValidationError,
            params=params, connection=connection_mock)
        assert len(result.args) == 1
        assert key in result.args[0]
        assert json.loads(result.args[0][key]) == {
            'invalid_type': [{'actually_value': 1, 'expected_type': 'string', 'path': 'objects[3].id'}],
            'required': ['objects[0].type']
        }
    def test_module_should_fail_when_upsert_operation_and_few_objects_found_by_filter(self, connection_mock):
        url = '/test'
        url_with_id_templ = '{0}/{1}'.format(url, '{objId}')
        sample_obj = {'name': 'testObject', 'value': '3333', 'type': 'object'}
        params = {
            'operation': 'upsertObject',
            'data': sample_obj,
            'register_as': 'test_var'
        }
        def request_handler(url_path=None, http_method=None, body_params=None, path_params=None, query_params=None):
            if http_method == HTTPMethod.POST:
                assert url_path == url
                assert body_params == params['data']
                assert query_params == {}
                assert path_params == {}
                return {
                    ResponseParams.SUCCESS: False,
                    ResponseParams.RESPONSE: DUPLICATE_NAME_ERROR_MESSAGE,
                    ResponseParams.STATUS_CODE: UNPROCESSABLE_ENTITY_STATUS
                }
            elif http_method == HTTPMethod.GET:
                assert url_path == url
                assert body_params == {}
                assert query_params == {QueryParams.FILTER: 'name:testObject', 'limit': 10, 'offset': 0}
                assert path_params == {}
                return {
                    ResponseParams.SUCCESS: True,
                    ResponseParams.RESPONSE: {
                        'items': [sample_obj, sample_obj]
                    }
                }
            else:
                assert False
        operations = {
            'getObjectList': {'method': HTTPMethod.GET, 'modelName': 'Object', 'url': url, 'returnMultipleItems': True},
            'addObject': {'method': HTTPMethod.POST, 'modelName': 'Object', 'url': url},
            'editObject': {'method': HTTPMethod.PUT, 'modelName': 'Object', 'url': url_with_id_templ},
            'otherObjectOperation': {
                'method': HTTPMethod.GET,
                'modelName': 'Object',
                'url': url_with_id_templ,
                'returnMultipleItems': False}
        }
        def get_operation_spec(name):
            return operations[name]
        connection_mock.get_operation_spec = get_operation_spec
        connection_mock.get_operation_specs_by_model_name.return_value = operations
        connection_mock.send_request = request_handler
        result = self._resource_execute_operation_with_expected_failure(
            expected_exception_class=FtdConfigurationError,
            params=params, connection=connection_mock)
        assert result.msg is MULTIPLE_DUPLICATES_FOUND_ERROR
        assert result.obj is None
    @staticmethod
    def _resource_execute_operation(params, connection):
        resource = BaseConfigurationResource(connection)
        op_name = params['operation']
        resp = resource.execute_operation(op_name, params)
        return resp
    def _resource_execute_operation_with_expected_failure(self, expected_exception_class, params, connection):
        with pytest.raises(expected_exception_class) as ex:
            self._resource_execute_operation(params, connection)
        # 'ex' here is the instance of '_pytest._code.code.ExceptionInfo' but not <expected_exception_class>
        # actual instance of <expected_exception_class> is in the value attribute of 'ex'. That's why we should return
        # 'ex.value' here, so it can be checked in a test later.
        return ex.value
"
-------------------------------------------------------------------------
"# Copyright (c) 2018 Cisco and/or its affiliates.
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#
from __future__ import absolute_import
import copy
import json
import unittest
import pytest
from ansible.module_utils.network.ftd.common import FtdServerError, HTTPMethod, ResponseParams, FtdConfigurationError
from ansible.module_utils.network.ftd.configuration import DUPLICATE_NAME_ERROR_MESSAGE, UNPROCESSABLE_ENTITY_STATUS, \
    MULTIPLE_DUPLICATES_FOUND_ERROR, BaseConfigurationResource, FtdInvalidOperationNameError, QueryParams
from ansible.module_utils.network.ftd.fdm_swagger_client import ValidationError
ADD_RESPONSE = {'status': 'Object added'}
EDIT_RESPONSE = {'status': 'Object edited'}
DELETE_RESPONSE = {'status': 'Object deleted'}
GET_BY_FILTER_RESPONSE = [{'name': 'foo', 'description': 'bar'}]
ARBITRARY_RESPONSE = {'status': 'Arbitrary request sent'}
class TestUpsertOperationUnitTests(unittest.TestCase):
    def setUp(self):
        conn = mock.MagicMock()
        self._resource = BaseConfigurationResource(conn)
    def test_get_operation_name(self):
        operation_a = mock.MagicMock()
        operation_b = mock.MagicMock()
        def checker_wrapper(expected_object):
            def checker(obj, *args, **kwargs):
                return obj == expected_object
            return checker
        operations = {
            operation_a: ""spec"",
            operation_b: ""spec""
        }
        assert operation_a == self._resource._get_operation_name(checker_wrapper(operation_a), operations)
        assert operation_b == self._resource._get_operation_name(checker_wrapper(operation_b), operations)
        self.assertRaises(
            FtdConfigurationError,
            self._resource._get_operation_name, checker_wrapper(None), operations
        )
    @mock.patch.object(BaseConfigurationResource, ""_get_operation_name"")
    @mock.patch.object(BaseConfigurationResource, ""add_object"")
    def test_add_upserted_object(self, add_object_mock, get_operation_mock):
        model_operations = mock.MagicMock()
        params = mock.MagicMock()
        add_op_name = get_operation_mock.return_value
        assert add_object_mock.return_value == self._resource._add_upserted_object(model_operations, params)
        get_operation_mock.assert_called_once_with(
            self._resource._operation_checker.is_add_operation,
            model_operations)
        add_object_mock.assert_called_once_with(add_op_name, params)
    @mock.patch.object(BaseConfigurationResource, ""_get_operation_name"")
    @mock.patch.object(BaseConfigurationResource, ""edit_object"")
    @mock.patch(""ansible.module_utils.network.ftd.configuration.copy_identity_properties"")
    @mock.patch(""ansible.module_utils.network.ftd.configuration._set_default"")
    def test_edit_upserted_object(self, _set_default_mock, copy_properties_mock, edit_object_mock, get_operation_mock):
        model_operations = mock.MagicMock()
        existing_object = mock.MagicMock()
        params = {
            'path_params': {},
            'data': {}
        }
        result = self._resource._edit_upserted_object(model_operations, existing_object, params)
        assert result == edit_object_mock.return_value
        _set_default_mock.assert_has_calls([
            mock.call(params, 'path_params', {}),
            mock.call(params, 'data', {})
        ])
        get_operation_mock.assert_called_once_with(
            self._resource._operation_checker.is_edit_operation,
            model_operations
        )
        copy_properties_mock.assert_called_once_with(
            existing_object,
            params['data']
        )
        edit_object_mock.assert_called_once_with(
            get_operation_mock.return_value,
            params
        )
    @mock.patch.object(BaseConfigurationResource, ""get_operation_specs_by_model_name"")
    @mock.patch(""ansible.module_utils.network.ftd.configuration.OperationChecker.is_upsert_operation_supported"")
    @mock.patch(""ansible.module_utils.network.ftd.configuration._extract_model_from_upsert_operation"")
    def test_is_upsert_operation_supported(self, extract_model_mock, is_upsert_supported_mock, get_operation_spec_mock):
        op_name = mock.MagicMock()
        result = self._resource.is_upsert_operation_supported(op_name)
        assert result == is_upsert_supported_mock.return_value
        extract_model_mock.assert_called_once_with(op_name)
        get_operation_spec_mock.assert_called_once_with(extract_model_mock.return_value)
        is_upsert_supported_mock.assert_called_once_with(get_operation_spec_mock.return_value)
    @mock.patch.object(BaseConfigurationResource, ""is_upsert_operation_supported"")
    @mock.patch.object(BaseConfigurationResource, ""get_operation_specs_by_model_name"")
    @mock.patch.object(BaseConfigurationResource, ""_add_upserted_object"")
    @mock.patch.object(BaseConfigurationResource, ""_edit_upserted_object"")
    @mock.patch(""ansible.module_utils.network.ftd.configuration._extract_model_from_upsert_operation"")
    def test_upsert_object_succesfully_added(self, extract_model_mock, edit_mock, add_mock, get_operation_mock,
                                             is_upsert_supported_mock):
        op_name = mock.MagicMock()
        params = mock.MagicMock()
        is_upsert_supported_mock.return_value = True
        result = self._resource.upsert_object(op_name, params)
        assert result == add_mock.return_value
        is_upsert_supported_mock.assert_called_once_with(op_name)
        extract_model_mock.assert_called_once_with(op_name)
        get_operation_mock.assert_called_once_with(extract_model_mock.return_value)
        add_mock.assert_called_once_with(get_operation_mock.return_value, params)
        edit_mock.assert_not_called()
    @mock.patch.object(BaseConfigurationResource, ""is_upsert_operation_supported"")
    @mock.patch.object(BaseConfigurationResource, ""get_operation_specs_by_model_name"")
    @mock.patch.object(BaseConfigurationResource, ""_add_upserted_object"")
    @mock.patch.object(BaseConfigurationResource, ""_edit_upserted_object"")
    @mock.patch(""ansible.module_utils.network.ftd.configuration._extract_model_from_upsert_operation"")
    def test_upsert_object_succesfully_edited(self, extract_model_mock, edit_mock, add_mock, get_operation_mock,
                                              is_upsert_supported_mock):
        op_name = mock.MagicMock()
        params = mock.MagicMock()
        is_upsert_supported_mock.return_value = True
        error = FtdConfigurationError(""Obj duplication error"")
        error.obj = mock.MagicMock()
        add_mock.side_effect = error
        result = self._resource.upsert_object(op_name, params)
        assert result == edit_mock.return_value
        is_upsert_supported_mock.assert_called_once_with(op_name)
        extract_model_mock.assert_called_once_with(op_name)
        get_operation_mock.assert_called_once_with(extract_model_mock.return_value)
        add_mock.assert_called_once_with(get_operation_mock.return_value, params)
        edit_mock.assert_called_once_with(get_operation_mock.return_value, error.obj, params)
    @mock.patch.object(BaseConfigurationResource, ""is_upsert_operation_supported"")
    @mock.patch.object(BaseConfigurationResource, ""get_operation_specs_by_model_name"")
    @mock.patch.object(BaseConfigurationResource, ""_add_upserted_object"")
    @mock.patch.object(BaseConfigurationResource, ""_edit_upserted_object"")
    @mock.patch(""ansible.module_utils.network.ftd.configuration._extract_model_from_upsert_operation"")
    def test_upsert_object_not_supported(self, extract_model_mock, edit_mock, add_mock, get_operation_mock,
                                         is_upsert_supported_mock):
        op_name = mock.MagicMock()
        params = mock.MagicMock()
        is_upsert_supported_mock.return_value = False
        self.assertRaises(
            FtdInvalidOperationNameError,
            self._resource.upsert_object, op_name, params
        )
        is_upsert_supported_mock.assert_called_once_with(op_name)
        extract_model_mock.assert_not_called()
        get_operation_mock.assert_not_called()
        add_mock.assert_not_called()
        edit_mock.assert_not_called()
    @mock.patch.object(BaseConfigurationResource, ""is_upsert_operation_supported"")
    @mock.patch.object(BaseConfigurationResource, ""get_operation_specs_by_model_name"")
    @mock.patch.object(BaseConfigurationResource, ""_add_upserted_object"")
    @mock.patch.object(BaseConfigurationResource, ""_edit_upserted_object"")
    @mock.patch(""ansible.module_utils.network.ftd.configuration._extract_model_from_upsert_operation"")
    def test_upsert_object_neither_added_nor_edited(self, extract_model_mock, edit_mock, add_mock, get_operation_mock,
                                                    is_upsert_supported_mock):
        op_name = mock.MagicMock()
        params = mock.MagicMock()
        is_upsert_supported_mock.return_value = True
        error = FtdConfigurationError(""Obj duplication error"")
        error.obj = mock.MagicMock()
        add_mock.side_effect = error
        edit_mock.side_effect = FtdConfigurationError(""Some object edit error"")
        self.assertRaises(
            FtdConfigurationError,
            self._resource.upsert_object, op_name, params
        )
        is_upsert_supported_mock.assert_called_once_with(op_name)
        extract_model_mock.assert_called_once_with(op_name)
        get_operation_mock.assert_called_once_with(extract_model_mock.return_value)
        add_mock.assert_called_once_with(get_operation_mock.return_value, params)
        edit_mock.assert_called_once_with(get_operation_mock.return_value, error.obj, params)
    @mock.patch.object(BaseConfigurationResource, ""is_upsert_operation_supported"")
    @mock.patch.object(BaseConfigurationResource, ""get_operation_specs_by_model_name"")
    @mock.patch.object(BaseConfigurationResource, ""_add_upserted_object"")
    @mock.patch.object(BaseConfigurationResource, ""_edit_upserted_object"")
    @mock.patch(""ansible.module_utils.network.ftd.configuration._extract_model_from_upsert_operation"")
    def test_upsert_object_with_fatal_error_during_add(self, extract_model_mock, edit_mock, add_mock,
                                                       get_operation_mock, is_upsert_supported_mock):
        op_name = mock.MagicMock()
        params = mock.MagicMock()
        is_upsert_supported_mock.return_value = True
        error = FtdConfigurationError(""Obj duplication error"")
        add_mock.side_effect = error
        self.assertRaises(
            FtdConfigurationError,
            self._resource.upsert_object, op_name, params
        )
        is_upsert_supported_mock.assert_called_once_with(op_name)
        extract_model_mock.assert_called_once_with(op_name)
        get_operation_mock.assert_called_once_with(extract_model_mock.return_value)
        add_mock.assert_called_once_with(get_operation_mock.return_value, params)
        edit_mock.assert_not_called()
# functional tests below
class TestUpsertOperationFunctionalTests(object):
    @pytest.fixture(autouse=True)
    def connection_mock(self, mocker):
        connection_class_mock = mocker.patch('ansible.modules.network.ftd.ftd_configuration.Connection')
        connection_instance = connection_class_mock.return_value
        connection_instance.validate_data.return_value = True, None
        connection_instance.validate_query_params.return_value = True, None
        connection_instance.validate_path_params.return_value = True, None
        return connection_instance
    def test_module_should_create_object_when_upsert_operation_and_object_does_not_exist(self, connection_mock):
        url = '/test'
        operations = {
            'getObjectList': {
                'method': HTTPMethod.GET,
                'url': url,
                'modelName': 'Object',
                'returnMultipleItems': True},
            'addObject': {
                'method': HTTPMethod.POST,
                'modelName': 'Object',
                'url': url},
            'editObject': {
                'method': HTTPMethod.PUT,
                'modelName': 'Object',
                'url': '/test/{objId}'},
            'otherObjectOperation': {
                'method': HTTPMethod.GET,
                'modelName': 'Object',
                'url': '/test/{objId}',
                'returnMultipleItems': False
            }
        }
        def get_operation_spec(name):
            return operations[name]
        connection_mock.get_operation_spec = get_operation_spec
        connection_mock.get_operation_specs_by_model_name.return_value = operations
        connection_mock.send_request.return_value = {
            ResponseParams.SUCCESS: True,
            ResponseParams.RESPONSE: ADD_RESPONSE
        }
        params = {
            'operation': 'upsertObject',
            'data': {'id': '123', 'name': 'testObject', 'type': 'object'},
            'path_params': {'objId': '123'},
            'register_as': 'test_var'
        }
        result = self._resource_execute_operation(params, connection=connection_mock)
        connection_mock.send_request.assert_called_once_with(url_path=url,
                                                             http_method=HTTPMethod.POST,
                                                             path_params=params['path_params'],
                                                             query_params={},
                                                             body_params=params['data'])
        assert ADD_RESPONSE == result
    # test when object exists but with different fields(except id)
    def test_module_should_update_object_when_upsert_operation_and_object_exists(self, connection_mock):
        url = '/test'
        obj_id = '456'
        version = 'test_version'
        url_with_id_templ = '{0}/{1}'.format(url, '{objId}')
        new_value = '0000'
        old_value = '1111'
        params = {
            'operation': 'upsertObject',
            'data': {'name': 'testObject', 'value': new_value, 'type': 'object'},
            'register_as': 'test_var'
        }
        def request_handler(url_path=None, http_method=None, body_params=None, path_params=None, query_params=None):
            if http_method == HTTPMethod.POST:
                assert url_path == url
                assert body_params == params['data']
                assert query_params == {}
                assert path_params == {}
                return {
                    ResponseParams.SUCCESS: False,
                    ResponseParams.RESPONSE: DUPLICATE_NAME_ERROR_MESSAGE,
                    ResponseParams.STATUS_CODE: UNPROCESSABLE_ENTITY_STATUS
                }
            elif http_method == HTTPMethod.GET:
                is_get_list_req = url_path == url
                is_get_req = url_path == url_with_id_templ
                assert is_get_req or is_get_list_req
                if is_get_list_req:
                    assert body_params == {}
                    assert query_params == {QueryParams.FILTER: 'name:testObject', 'limit': 10, 'offset': 0}
                    assert path_params == {}
                elif is_get_req:
                    assert body_params == {}
                    assert query_params == {}
                    assert path_params == {'objId': obj_id}
                return {
                    ResponseParams.SUCCESS: True,
                    ResponseParams.RESPONSE: {
                        'items': [
                            {'name': 'testObject', 'value': old_value, 'type': 'object', 'id': obj_id,
                             'version': version}
                        ]
                    }
                }
            elif http_method == HTTPMethod.PUT:
                assert url_path == url_with_id_templ
                return {
                    ResponseParams.SUCCESS: True,
                    ResponseParams.RESPONSE: body_params
                }
            else:
                assert False
        operations = {
            'getObjectList': {'method': HTTPMethod.GET, 'url': url, 'modelName': 'Object', 'returnMultipleItems': True},
            'addObject': {'method': HTTPMethod.POST, 'modelName': 'Object', 'url': url},
            'editObject': {'method': HTTPMethod.PUT, 'modelName': 'Object', 'url': url_with_id_templ},
            'otherObjectOperation': {
                'method': HTTPMethod.GET,
                'modelName': 'Object',
                'url': url_with_id_templ,
                'returnMultipleItems': False}
        }
        def get_operation_spec(name):
            return operations[name]
        connection_mock.get_operation_spec = get_operation_spec
        connection_mock.get_operation_specs_by_model_name.return_value = operations
        connection_mock.send_request = request_handler
        expected_val = {'name': 'testObject', 'value': new_value, 'type': 'object', 'id': obj_id, 'version': version}
        result = self._resource_execute_operation(params, connection=connection_mock)
        assert expected_val == result
    # test when object exists and all fields have the same value
    def test_module_should_not_update_object_when_upsert_operation_and_object_exists_with_the_same_fields(
            self, connection_mock):
        url = '/test'
        url_with_id_templ = '{0}/{1}'.format(url, '{objId}')
        params = {
            'operation': 'upsertObject',
            'data': {'name': 'testObject', 'value': '3333', 'type': 'object'},
            'register_as': 'test_var'
        }
        expected_val = copy.deepcopy(params['data'])
        expected_val['version'] = 'test_version'
        expected_val['id'] = 'test_id'
        def request_handler(url_path=None, http_method=None, body_params=None, path_params=None, query_params=None):
            if http_method == HTTPMethod.POST:
                assert url_path == url
                assert body_params == params['data']
                assert query_params == {}
                assert path_params == {}
                return {
                    ResponseParams.SUCCESS: False,
                    ResponseParams.RESPONSE: DUPLICATE_NAME_ERROR_MESSAGE,
                    ResponseParams.STATUS_CODE: UNPROCESSABLE_ENTITY_STATUS
                }
            elif http_method == HTTPMethod.GET:
                assert url_path == url
                assert body_params == {}
                assert query_params == {QueryParams.FILTER: 'name:testObject', 'limit': 10, 'offset': 0}
                assert path_params == {}
                return {
                    ResponseParams.SUCCESS: True,
                    ResponseParams.RESPONSE: {
                        'items': [expected_val]
                    }
                }
            else:
                assert False
        operations = {
            'getObjectList': {'method': HTTPMethod.GET, 'modelName': 'Object', 'url': url, 'returnMultipleItems': True},
            'addObject': {'method': HTTPMethod.POST, 'modelName': 'Object', 'url': url},
            'editObject': {'method': HTTPMethod.PUT, 'modelName': 'Object', 'url': url_with_id_templ},
            'otherObjectOperation': {
                'method': HTTPMethod.GET,
                'modelName': 'Object',
                'url': url_with_id_templ,
                'returnMultipleItems': False}
        }
        def get_operation_spec(name):
            return operations[name]
        connection_mock.get_operation_spec = get_operation_spec
        connection_mock.get_operation_specs_by_model_name.return_value = operations
        connection_mock.send_request = request_handler
        result = self._resource_execute_operation(params, connection=connection_mock)
        assert expected_val == result
    def test_module_should_fail_when_upsert_operation_is_not_supported(self, connection_mock):
        connection_mock.get_operation_specs_by_model_name.return_value = {
            'addObject': {'method': HTTPMethod.POST, 'modelName': 'Object', 'url': '/test'},
            'editObject': {'method': HTTPMethod.PUT, 'modelName': 'Object', 'url': '/test/{objId}'},
            'otherObjectOperation': {
                'method': HTTPMethod.GET,
                'modelName': 'Object',
                'url': '/test/{objId}',
                'returnMultipleItems': False}"
-------------------------------------------------------------------------
"# Copyright (c) 2018 Cisco and/or its affiliates.
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#
from __future__ import absolute_import
import copy
import json
import unittest
import pytest
from ansible.compat.tests import mock
from ansible.module_utils.network.ftd.common import FtdServerError, HTTPMethod, ResponseParams, FtdConfigurationError
from ansible.module_utils.network.ftd.configuration import DUPLICATE_NAME_ERROR_MESSAGE, UNPROCESSABLE_ENTITY_STATUS, \
    MULTIPLE_DUPLICATES_FOUND_ERROR, BaseConfigurationResource, FtdInvalidOperationNameError, QueryParams
from ansible.module_utils.network.ftd.fdm_swagger_client import ValidationError
ADD_RESPONSE = {'status': 'Object added'}
EDIT_RESPONSE = {'status': 'Object edited'}
DELETE_RESPONSE = {'status': 'Object deleted'}
GET_BY_FILTER_RESPONSE = [{'name': 'foo', 'description': 'bar'}]
ARBITRARY_RESPONSE = {'status': 'Arbitrary request sent'}
class TestUpsertOperationUnitTests(unittest.TestCase):
    def setUp(self):
        conn = mock.MagicMock()
        self._resource = BaseConfigurationResource(conn)
    def test_get_operation_name(self):
        operation_a = mock.MagicMock()
        operation_b = mock.MagicMock()
        def checker_wrapper(expected_object):
            def checker(obj, *args, **kwargs):
                return obj == expected_object
            return checker
        operations = {
            operation_a: ""spec"",
            operation_b: ""spec""
        }
        assert operation_a == self._resource._get_operation_name(checker_wrapper(operation_a), operations)
        assert operation_b == self._resource._get_operation_name(checker_wrapper(operation_b), operations)
        self.assertRaises(
            FtdConfigurationError,
            self._resource._get_operation_name, checker_wrapper(None), operations
        )
    @mock.patch.object(BaseConfigurationResource, ""_get_operation_name"")
    @mock.patch.object(BaseConfigurationResource, ""add_object"")
    def test_add_upserted_object(self, add_object_mock, get_operation_mock):
        model_operations = mock.MagicMock()
        params = mock.MagicMock()
        add_op_name = get_operation_mock.return_value
        assert add_object_mock.return_value == self._resource._add_upserted_object(model_operations, params)
        get_operation_mock.assert_called_once_with(
            self._resource._operation_checker.is_add_operation,
            model_operations)
        add_object_mock.assert_called_once_with(add_op_name, params)
    @mock.patch.object(BaseConfigurationResource, ""_get_operation_name"")
    @mock.patch.object(BaseConfigurationResource, ""edit_object"")
    @mock.patch(""ansible.module_utils.network.ftd.configuration.copy_identity_properties"")
    @mock.patch(""ansible.module_utils.network.ftd.configuration._set_default"")
    def test_edit_upserted_object(self, _set_default_mock, copy_properties_mock, edit_object_mock, get_operation_mock):
        model_operations = mock.MagicMock()
        existing_object = mock.MagicMock()
        params = {
            'path_params': {},
            'data': {}
        }
        result = self._resource._edit_upserted_object(model_operations, existing_object, params)
        assert result == edit_object_mock.return_value
        _set_default_mock.assert_has_calls([
            mock.call(params, 'path_params', {}),
            mock.call(params, 'data', {})
        ])
        get_operation_mock.assert_called_once_with(
            self._resource._operation_checker.is_edit_operation,
            model_operations
        )
        copy_properties_mock.assert_called_once_with(
            existing_object,
            params['data']
        )
        edit_object_mock.assert_called_once_with(
            get_operation_mock.return_value,
            params
        )
    @mock.patch.object(BaseConfigurationResource, ""get_operation_specs_by_model_name"")
    @mock.patch(""ansible.module_utils.network.ftd.configuration.OperationChecker.is_upsert_operation_supported"")
    @mock.patch(""ansible.module_utils.network.ftd.configuration._extract_model_from_upsert_operation"")
    def test_is_upsert_operation_supported(self, extract_model_mock, is_upsert_supported_mock, get_operation_spec_mock):
        op_name = mock.MagicMock()
        result = self._resource.is_upsert_operation_supported(op_name)
        assert result == is_upsert_supported_mock.return_value
        extract_model_mock.assert_called_once_with(op_name)
        get_operation_spec_mock.assert_called_once_with(extract_model_mock.return_value)
        is_upsert_supported_mock.assert_called_once_with(get_operation_spec_mock.return_value)
    @mock.patch.object(BaseConfigurationResource, ""is_upsert_operation_supported"")
    @mock.patch.object(BaseConfigurationResource, ""get_operation_specs_by_model_name"")
    @mock.patch.object(BaseConfigurationResource, ""_add_upserted_object"")
    @mock.patch.object(BaseConfigurationResource, ""_edit_upserted_object"")
    @mock.patch(""ansible.module_utils.network.ftd.configuration._extract_model_from_upsert_operation"")
    def test_upsert_object_succesfully_added(self, extract_model_mock, edit_mock, add_mock, get_operation_mock,
                                             is_upsert_supported_mock):
        op_name = mock.MagicMock()
        params = mock.MagicMock()
        is_upsert_supported_mock.return_value = True
        result = self._resource.upsert_object(op_name, params)
        assert result == add_mock.return_value
        is_upsert_supported_mock.assert_called_once_with(op_name)
        extract_model_mock.assert_called_once_with(op_name)
        get_operation_mock.assert_called_once_with(extract_model_mock.return_value)
        add_mock.assert_called_once_with(get_operation_mock.return_value, params)
        edit_mock.assert_not_called()
    @mock.patch.object(BaseConfigurationResource, ""is_upsert_operation_supported"")
    @mock.patch.object(BaseConfigurationResource, ""get_operation_specs_by_model_name"")
    @mock.patch.object(BaseConfigurationResource, ""_add_upserted_object"")
    @mock.patch.object(BaseConfigurationResource, ""_edit_upserted_object"")
    @mock.patch(""ansible.module_utils.network.ftd.configuration._extract_model_from_upsert_operation"")
    def test_upsert_object_succesfully_edited(self, extract_model_mock, edit_mock, add_mock, get_operation_mock,
                                              is_upsert_supported_mock):
        op_name = mock.MagicMock()
        params = mock.MagicMock()
        is_upsert_supported_mock.return_value = True
        error = FtdConfigurationError(""Obj duplication error"")
        error.obj = mock.MagicMock()
        add_mock.side_effect = error
        result = self._resource.upsert_object(op_name, params)
        assert result == edit_mock.return_value
        is_upsert_supported_mock.assert_called_once_with(op_name)
        extract_model_mock.assert_called_once_with(op_name)
        get_operation_mock.assert_called_once_with(extract_model_mock.return_value)
        add_mock.assert_called_once_with(get_operation_mock.return_value, params)
        edit_mock.assert_called_once_with(get_operation_mock.return_value, error.obj, params)
    @mock.patch.object(BaseConfigurationResource, ""is_upsert_operation_supported"")
    @mock.patch.object(BaseConfigurationResource, ""get_operation_specs_by_model_name"")
    @mock.patch.object(BaseConfigurationResource, ""_add_upserted_object"")
    @mock.patch.object(BaseConfigurationResource, ""_edit_upserted_object"")
    @mock.patch(""ansible.module_utils.network.ftd.configuration._extract_model_from_upsert_operation"")
    def test_upsert_object_not_supported(self, extract_model_mock, edit_mock, add_mock, get_operation_mock,
                                         is_upsert_supported_mock):
        op_name = mock.MagicMock()
        params = mock.MagicMock()
        is_upsert_supported_mock.return_value = False
        self.assertRaises(
            FtdInvalidOperationNameError,
            self._resource.upsert_object, op_name, params
        )
        is_upsert_supported_mock.assert_called_once_with(op_name)
        extract_model_mock.assert_not_called()
        get_operation_mock.assert_not_called()
        add_mock.assert_not_called()
        edit_mock.assert_not_called()
    @mock.patch.object(BaseConfigurationResource, ""is_upsert_operation_supported"")
    @mock.patch.object(BaseConfigurationResource, ""get_operation_specs_by_model_name"")
    @mock.patch.object(BaseConfigurationResource, ""_add_upserted_object"")
    @mock.patch.object(BaseConfigurationResource, ""_edit_upserted_object"")
    @mock.patch(""ansible.module_utils.network.ftd.configuration._extract_model_from_upsert_operation"")
    def test_upsert_object_neither_added_nor_edited(self, extract_model_mock, edit_mock, add_mock, get_operation_mock,
                                                    is_upsert_supported_mock):
        op_name = mock.MagicMock()
        params = mock.MagicMock()
        is_upsert_supported_mock.return_value = True
        error = FtdConfigurationError(""Obj duplication error"")
        error.obj = mock.MagicMock()
        add_mock.side_effect = error
        edit_mock.side_effect = FtdConfigurationError(""Some object edit error"")
        self.assertRaises(
            FtdConfigurationError,
            self._resource.upsert_object, op_name, params
        )
        is_upsert_supported_mock.assert_called_once_with(op_name)
        extract_model_mock.assert_called_once_with(op_name)
        get_operation_mock.assert_called_once_with(extract_model_mock.return_value)
        add_mock.assert_called_once_with(get_operation_mock.return_value, params)
        edit_mock.assert_called_once_with(get_operation_mock.return_value, error.obj, params)
    @mock.patch.object(BaseConfigurationResource, ""is_upsert_operation_supported"")
    @mock.patch.object(BaseConfigurationResource, ""get_operation_specs_by_model_name"")
    @mock.patch.object(BaseConfigurationResource, ""_add_upserted_object"")
    @mock.patch.object(BaseConfigurationResource, ""_edit_upserted_object"")
    @mock.patch(""ansible.module_utils.network.ftd.configuration._extract_model_from_upsert_operation"")
    def test_upsert_object_with_fatal_error_during_add(self, extract_model_mock, edit_mock, add_mock,
                                                       get_operation_mock, is_upsert_supported_mock):
        op_name = mock.MagicMock()
        params = mock.MagicMock()
        is_upsert_supported_mock.return_value = True
        error = FtdConfigurationError(""Obj duplication error"")
        add_mock.side_effect = error
        self.assertRaises(
            FtdConfigurationError,
            self._resource.upsert_object, op_name, params
        )
        is_upsert_supported_mock.assert_called_once_with(op_name)
        extract_model_mock.assert_called_once_with(op_name)
        get_operation_mock.assert_called_once_with(extract_model_mock.return_value)
        add_mock.assert_called_once_with(get_operation_mock.return_value, params)
        edit_mock.assert_not_called()
# functional tests below
class TestUpsertOperationFunctionalTests(object):
    @pytest.fixture(autouse=True)
    def connection_mock(self, mocker):
        connection_class_mock = mocker.patch('ansible.modules.network.ftd.ftd_configuration.Connection')
        connection_instance = connection_class_mock.return_value
        connection_instance.validate_data.return_value = True, None
        connection_instance.validate_query_params.return_value = True, None
        connection_instance.validate_path_params.return_value = True, None
        return connection_instance
    def test_module_should_create_object_when_upsert_operation_and_object_does_not_exist(self, connection_mock):
        url = '/test'
        operations = {
            'getObjectList': {
                'method': HTTPMethod.GET,
                'url': url,
                'modelName': 'Object',
                'returnMultipleItems': True},
            'addObject': {
                'method': HTTPMethod.POST,
                'modelName': 'Object',
                'url': url},
            'editObject': {
                'method': HTTPMethod.PUT,
                'modelName': 'Object',
                'url': '/test/{objId}'},
            'otherObjectOperation': {
                'method': HTTPMethod.GET,
                'modelName': 'Object',
                'url': '/test/{objId}',
                'returnMultipleItems': False
            }
        }
        def get_operation_spec(name):
            return operations[name]
        connection_mock.get_operation_spec = get_operation_spec
        connection_mock.get_operation_specs_by_model_name.return_value = operations
        connection_mock.send_request.return_value = {
            ResponseParams.SUCCESS: True,
            ResponseParams.RESPONSE: ADD_RESPONSE
        }
        params = {
            'operation': 'upsertObject',
            'data': {'id': '123', 'name': 'testObject', 'type': 'object'},
            'path_params': {'objId': '123'},
            'register_as': 'test_var'
        }
        result = self._resource_execute_operation(params, connection=connection_mock)
        connection_mock.send_request.assert_called_once_with(url_path=url,
                                                             http_method=HTTPMethod.POST,
                                                             path_params=params['path_params'],
                                                             query_params={},
                                                             body_params=params['data'])
        assert ADD_RESPONSE == result
    # test when object exists but with different fields(except id)
    def test_module_should_update_object_when_upsert_operation_and_object_exists(self, connection_mock):
        url = '/test'
        obj_id = '456'
        version = 'test_version'
        url_with_id_templ = '{0}/{1}'.format(url, '{objId}')
        new_value = '0000'
        old_value = '1111'
        params = {
            'operation': 'upsertObject',
            'data': {'name': 'testObject', 'value': new_value, 'type': 'object'},
            'register_as': 'test_var'
        }
        def request_handler(url_path=None, http_method=None, body_params=None, path_params=None, query_params=None):
            if http_method == HTTPMethod.POST:
                assert url_path == url
                assert body_params == params['data']
                assert query_params == {}
                assert path_params == {}
                return {
                    ResponseParams.SUCCESS: False,
                    ResponseParams.RESPONSE: DUPLICATE_NAME_ERROR_MESSAGE,
                    ResponseParams.STATUS_CODE: UNPROCESSABLE_ENTITY_STATUS
                }
            elif http_method == HTTPMethod.GET:
                is_get_list_req = url_path == url
                is_get_req = url_path == url_with_id_templ
                assert is_get_req or is_get_list_req
                if is_get_list_req:
                    assert body_params == {}
                    assert query_params == {QueryParams.FILTER: 'name:testObject', 'limit': 10, 'offset': 0}
                    assert path_params == {}
                elif is_get_req:
                    assert body_params == {}
                    assert query_params == {}
                    assert path_params == {'objId': obj_id}
                return {
                    ResponseParams.SUCCESS: True,
                    ResponseParams.RESPONSE: {
                        'items': [
                            {'name': 'testObject', 'value': old_value, 'type': 'object', 'id': obj_id,
                             'version': version}
                        ]
                    }
                }
            elif http_method == HTTPMethod.PUT:
                assert url_path == url_with_id_templ
                return {
                    ResponseParams.SUCCESS: True,
                    ResponseParams.RESPONSE: body_params
                }
            else:
                assert False
        operations = {
            'getObjectList': {'method': HTTPMethod.GET, 'url': url, 'modelName': 'Object', 'returnMultipleItems': True},
            'addObject': {'method': HTTPMethod.POST, 'modelName': 'Object', 'url': url},
            'editObject': {'method': HTTPMethod.PUT, 'modelName': 'Object', 'url': url_with_id_templ},
            'otherObjectOperation': {
                'method': HTTPMethod.GET,
                'modelName': 'Object',
                'url': url_with_id_templ,
                'returnMultipleItems': False}
        }
        def get_operation_spec(name):
            return operations[name]
        connection_mock.get_operation_spec = get_operation_spec
        connection_mock.get_operation_specs_by_model_name.return_value = operations
        connection_mock.send_request = request_handler
        expected_val = {'name': 'testObject', 'value': new_value, 'type': 'object', 'id': obj_id, 'version': version}
        result = self._resource_execute_operation(params, connection=connection_mock)
        assert expected_val == result
    # test when object exists and all fields have the same value
    def test_module_should_not_update_object_when_upsert_operation_and_object_exists_with_the_same_fields(
            self, connection_mock):
        url = '/test'
        url_with_id_templ = '{0}/{1}'.format(url, '{objId}')
        params = {
            'operation': 'upsertObject',
            'data': {'name': 'testObject', 'value': '3333', 'type': 'object'},
            'register_as': 'test_var'
        }
        expected_val = copy.deepcopy(params['data'])
        expected_val['version'] = 'test_version'
        expected_val['id'] = 'test_id'
        def request_handler(url_path=None, http_method=None, body_params=None, path_params=None, query_params=None):
            if http_method == HTTPMethod.POST:
                assert url_path == url
                assert body_params == params['data']
                assert query_params == {}
                assert path_params == {}
                return {
                    ResponseParams.SUCCESS: False,
                    ResponseParams.RESPONSE: DUPLICATE_NAME_ERROR_MESSAGE,
                    ResponseParams.STATUS_CODE: UNPROCESSABLE_ENTITY_STATUS
                }
            elif http_method == HTTPMethod.GET:
                assert url_path == url
                assert body_params == {}
                assert query_params == {QueryParams.FILTER: 'name:testObject', 'limit': 10, 'offset': 0}
                assert path_params == {}
                return {
                    ResponseParams.SUCCESS: True,
                    ResponseParams.RESPONSE: {
                        'items': [expected_val]
                    }
                }
            else:
                assert False
        operations = {
            'getObjectList': {'method': HTTPMethod.GET, 'modelName': 'Object', 'url': url, 'returnMultipleItems': True},
            'addObject': {'method': HTTPMethod.POST, 'modelName': 'Object', 'url': url},
            'editObject': {'method': HTTPMethod.PUT, 'modelName': 'Object', 'url': url_with_id_templ},
            'otherObjectOperation': {
                'method': HTTPMethod.GET,
                'modelName': 'Object',
                'url': url_with_id_templ,
                'returnMultipleItems': False}
        }
        def get_operation_spec(name):
            return operations[name]
        connection_mock.get_operation_spec = get_operation_spec
        connection_mock.get_operation_specs_by_model_name.return_value = operations
        connection_mock.send_request = request_handler
        result = self._resource_execute_operation(params, connection=connection_mock)
        assert expected_val == result
    def test_module_should_fail_when_upsert_operation_is_not_supported(self, connection_mock):
        connection_mock.get_operation_specs_by_model_name.return_value = {
            'addObject': {'method': HTTPMethod.POST, 'modelName': 'Object', 'url': '/test'},
            'editObject': {'method': HTTPMethod.PUT, 'modelName': 'Object', 'url': '/test/{objId}'},
            'otherObjectOperation': {
                'method': HTTPMethod.GET,
                'modelName': 'Object',
                'url': '/test/{objId}',
                'returnMultipleItems': False}
        }
        operation_name = 'upsertObject'
        params = {
            'operation': operation_name,
            'data': {'id': '123', 'name': 'testObject', 'type': 'object'},
            'path_params': {'objId': '123'},
            'register_as': 'test_var'
        }
        result = self._resource_execute_operation_with_expected_failure(
            expected_exception_class=FtdInvalidOperationNameError,
            params=params, connection=connection_mock)
        connection_mock.send_request.assert_not_called()
        assert operation_name == result.operation_name
    # when create operation raised FtdConfigurationError exception without id and version
    def test_module_should_fail_when_upsert_operation_and_failed_create_without_id_and_version(self, connection_mock):
        url = '/test'
        url_with_id_templ = '{0}/{1}'.format(url, '{objId}')
        params = {
            'operation': 'upsertObject',
            'data': {'name': 'testObject', 'value': '3333', 'type': 'object'},
            'register_as': 'test_var'
        }
        def request_handler(url_path=None, http_method=None, body_params=None, path_params=None, query_params=None):
            if http_method == HTTPMethod.POST:
                assert url_path == url
                assert body_params == params['data']
                assert query_params == {}
                assert path_params == {}
                return {
                    ResponseParams.SUCCESS: False,
                    ResponseParams.RESPONSE: DUPLICATE_NAME_ERROR_MESSAGE,
                    ResponseParams.STATUS_CODE: UNPROCESSABLE_ENTITY_STATUS
                }
            elif http_method == HTTPMethod.GET:
                assert url_path == url
                assert body_params == {}
                assert query_params == {QueryParams.FILTER: 'name:testObject', 'limit': 10, 'offset': 0}
                assert path_params == {}
                return {
                    ResponseParams.SUCCESS: True,
                    ResponseParams.RESPONSE: {
                        'items': []
                    }
                }
            else:
                assert False
        operations = {
            'getObjectList': {'method': HTTPMethod.GET, 'modelName': 'Object', 'url': url, 'returnMultipleItems': True},
            'addObject': {'method': HTTPMethod.POST, 'modelName': 'Object', 'url': url},
            'editObject': {'method': HTTPMethod.PUT, 'modelName': 'Object', 'url': url_with_id_templ},
            'otherObjectOperation': {
                'method': HTTPMethod.GET,
                'modelName': 'Object',
                'url': url_with_id_templ,
                'returnMultipleItems': False}
        }
        def get_operation_spec(name):
            return operations[name]
        connection_mock.get_operation_spec = get_operation_spec
        connection_mock.get_operation_specs_by_model_name.return_value = operations
        connection_mock.send_request = request_handler
        result = self._resource_execute_operation_with_expected_failure(
            expected_exception_class=FtdServerError,
            params=params, connection=connection_mock)
        assert result.code == 422
        assert result.response == 'Validation failed due to a duplicate name'
    def test_module_should_fail_when_upsert_operation_and_failed_update_operation(self, connection_mock):
        url = '/test'
        obj_id = '456'
        version = 'test_version'
        url_with_id_templ = '{0}/{1}'.format(url, '{objId}')
        error_code = 404
        new_value = '0000'
        old_value = '1111'
        params = {
            'operation': 'upsertObject',
            'data': {'name': 'testObject', 'value': new_value, 'type': 'object'},
            'register_as': 'test_var'
        }
        error_msg = 'test error'
        def request_handler(url_path=None, http_method=None, body_params=None, path_params=None, query_params=None):
            if http_method == HTTPMethod.POST:
                assert url_path == url
                assert body_params == params['data']
                assert query_params == {}
                assert path_params == {}
                return {
                    ResponseParams.SUCCESS: False,
                    ResponseParams.RESPONSE: DUPLICATE_NAME_ERROR_MESSAGE,
                    ResponseParams.STATUS_CODE: UNPROCESSABLE_ENTITY_STATUS
                }
            elif http_method == HTTPMethod.GET:
                is_get_list_req = url_path == url
                is_get_req = url_path == url_with_id_templ
                assert is_get_req or is_get_list_req
                if is_get_list_req:
                    assert body_params == {}
                    assert query_params == {QueryParams.FILTER: 'name:testObject', 'limit': 10, 'offset': 0}
                elif is_get_req:
                    assert body_params == {}
                    assert query_params == {}
                    assert path_params == {'objId': obj_id}
                return {
                    ResponseParams.SUCCESS: True,
                    ResponseParams.RESPONSE: {
                        'items': [
                            {'name': 'testObject', 'value': old_value, 'type': 'object', 'id': obj_id,
                             'version': version}
                        ]
                    }
                }
            elif http_method == HTTPMethod.PUT:
                assert url_path == url_with_id_templ
                raise FtdServerError(error_msg, error_code)
            else:
                assert False
        operations = {
            'getObjectList': {'method': HTTPMethod.GET, 'modelName': 'Object', 'url': url, 'returnMultipleItems': True},
            'addObject': {'method': HTTPMethod.POST, 'modelName': 'Object', 'url': url},
            'editObject': {'method': HTTPMethod.PUT, 'modelName': 'Object', 'url': url_with_id_templ},
            'otherObjectOperation': {
                'method': HTTPMethod.GET,
                'modelName': 'Object',
                'url': url_with_id_templ,
                'returnMultipleItems': False}
        }
        def get_operation_spec(name):
            return operations[name]
        connection_mock.get_operation_spec = get_operation_spec
        connection_mock.get_operation_specs_by_model_name.return_value = operations
        connection_mock.send_request = request_handler
        result = self._resource_execute_operation_with_expected_failure(
            expected_exception_class=FtdServerError,
            params=params, connection=connection_mock)
        assert result.code == error_code
        assert result.response == error_msg
    def test_module_should_fail_when_upsert_operation_and_invalid_data_for_create_operation(self, connection_mock):
        new_value = '0000'
        params = {
            'operation': 'upsertObject',
            'data': {'name': 'testObject', 'value': new_value, 'type': 'object'},
            'register_as': 'test_var'
        }
        connection_mock.send_request.assert_not_called()
        operations = {
            'getObjectList': {
                'method': HTTPMethod.GET,
                'modelName': 'Object',
                'url': 'sd',
                'returnMultipleItems': True},
            'addObject': {'method': HTTPMethod.POST, 'modelName': 'Object', 'url': 'sdf'},
            'editObject': {'method': HTTPMethod.PUT, 'modelName': 'Object', 'url': 'sadf'},
            'otherObjectOperation': {
                'method': HTTPMethod.GET,
                'modelName': 'Object',
                'url': 'sdfs',
                'returnMultipleItems': False}
        }
        def get_operation_spec(name):
            return operations[name]
        connection_mock.get_operation_spec = get_operation_spec
        connection_mock.get_operation_specs_by_model_name.return_value = operations
        report = {
            'required': ['objects[0].type'],
            'invalid_type': [
                {
                    'path': 'objects[3].id',
                    'expected_type': 'string',
                    'actually_value': 1
                }
            ]
        }
        connection_mock.validate_data.return_value = (False, json.dumps(report, sort_keys=True, indent=4))
        key = 'Invalid data provided'
        result = self._resource_execute_operation_with_expected_failure(
            expected_exception_class=ValidationError,
            params=params, connection=connection_mock)
        assert len(result.args) == 1
        assert key in result.args[0]
        assert json.loads(result.args[0][key]) == {
            'invalid_type': [{'actually_value': 1, 'expected_type': 'string', 'path': 'objects[3].id'}],
            'required': ['objects[0].type']
        }
    def test_module_should_fail_when_upsert_operation_and_few_objects_found_by_filter(self, connection_mock):
        url = '/test'
        url_with_id_templ = '{0}/{1}'.format(url, '{objId}')
        sample_obj = {'name': 'testObject', 'value': '3333', 'type': 'object'}
        params = {
            'operation': 'upsertObject',
            'data': sample_obj,
            'register_as': 'test_var'
        }
        def request_handler(url_path=None, http_method=None, body_params=None, path_params=None, query_params=None):
            if http_method == HTTPMethod.POST:
                assert url_path == url
                assert body_params == params['data']
                assert query_params == {}
                assert path_params == {}
                return {
                    ResponseParams.SUCCESS: False,
                    ResponseParams.RESPONSE: DUPLICATE_NAME_ERROR_MESSAGE,
                    ResponseParams.STATUS_CODE: UNPROCESSABLE_ENTITY_STATUS
                }
            elif http_method == HTTPMethod.GET:
                assert url_path == url
                assert body_params == {}
                assert query_params == {QueryParams.FILTER: 'name:testObject', 'limit': 10, 'offset': 0}
                assert path_params == {}
                return {
                    ResponseParams.SUCCESS: True,
                    ResponseParams.RESPONSE: {
                        'items': [sample_obj, sample_obj]
                    }
                }
            else:
                assert False
        operations = {
            'getObjectList': {'method': HTTPMethod.GET, 'modelName': 'Object', 'url': url, 'returnMultipleItems': True},
            'addObject': {'method': HTTPMethod.POST, 'modelName': 'Object', 'url': url},
            'editObject': {'method': HTTPMethod.PUT, 'modelName': 'Object', 'url': url_with_id_templ},
            'otherObjectOperation': {
                'method': HTTPMethod.GET,
                'modelName': 'Object',
                'url': url_with_id_templ,
                'returnMultipleItems': False}
        }
        def get_operation_spec(name):
            return operations[name]
        connection_mock.get_operation_spec = get_operation_spec
        connection_mock.get_operation_specs_by_model_name.return_value = operations
        connection_mock.send_request = request_handler
        result = self._resource_execute_operation_with_expected_failure(
            expected_exception_class=FtdConfigurationError,
            params=params, connection=connection_mock)
        assert result.msg is MULTIPLE_DUPLICATES_FOUND_ERROR
        assert result.obj is None
    @staticmethod
    def _resource_execute_operation(params, connection):
        resource = BaseConfigurationResource(connection)
        op_name = params['operation']
        resp = resource.execute_operation(op_name, params)
        return resp
    def _resource_execute_operation_with_expected_failure(self, expected_exception_class, params, connection):
        with pytest.raises(expected_exception_class) as ex:
            self._resource_execute_operation(params, connection)
        # 'ex' here is the instance of '_pytest._code.code.ExceptionInfo' but not <expected_exception_class>
        # actual instance of <expected_exception_class> is in the value attribute of 'ex'. That's why we should return
        # 'ex.value' here, so it can be checked in a test later.
        return ex.value
"
-------------------------------------------------------------------------
"Recom
PRs: 47747, 48982"
-------------------------------------------------------------------------
=========================================================================
"from ansible.module_utils.six import BytesIO, StringIO
"
-------------------------------------------------------------------------
"from ansible.module_utils import six

BytesIO = six.BytesIO
StringIO = six.StringIO"
-------------------------------------------------------------------------
"def test_login_raises_exception_when_http_error(self):
    self.connection_mock.send.side_effect = HTTPError('http://testhost.com', 400, '', {},
                                                      StringIO('{""message"": ""Failed to authenticate user""}'))
    with self.assertRaises(ConnectionError) as res:
        self.ftd_plugin.login('foo', 'bar')
    assert 'Failed to authenticate user' in str(res.exception)
"
-------------------------------------------------------------------------
"Recom
PRs: 47747, 48982"
-------------------------------------------------------------------------
=========================================================================
"def test_login_raises_exception_when_http_error(self):
    self.connection_mock.send.side_effect = HTTPError('http://testhost.com', 400, '', {},
                                                      StringIO('{""message"": ""Failed to authenticate user""}'))
    with self.assertRaises(ConnectionError) as res:
        self.ftd_plugin.login('foo', 'bar')
    assert 'Failed to authenticate user' in str(res.exception)
"
-------------------------------------------------------------------------
"def test_login_raises_exception_when_http_error(self):
    self.connection_mock.send.side_effect = urllib.error.HTTPError('http://testhost.com', 400, '', {},
                                                                  io.StringIO('{""message"": ""Failed to authenticate user""}'))
    with self.assertRaises(ftd_error.ConnectionError) as res:
        self.module_under_test.login('foo', 'bar')
    assert 'Failed to authenticate user' in str(res.exception)"
-------------------------------------------------------------------------
"def test_handle_httperror_should_not_retry_when_ignoring_http_errors(self):
    self.ftd_plugin._ignore_http_errors = True
    assert not self.ftd_plugin.handle_httperror(HTTPError('http://testhost.com', 401, '', {}, None))
"
-------------------------------------------------------------------------
"Recom
PRs: 47747, 48982"
-------------------------------------------------------------------------
=========================================================================
"def test_handle_httperror_should_not_retry_when_ignoring_http_errors(self):
    self.ftd_plugin._ignore_http_errors = True
    assert not self.ftd_plugin.handle_httperror(HTTPError('http://testhost.com', 401, '', {}, None))
"
-------------------------------------------------------------------------
"def test_handle_httperror_should_not_retry_when_ignoring_http_errors(self):
        self.ftd_plugin._ignore_http_errors = True
        assert not self.ftd_plugin.handle_httperror(os.get_module('ansible.module_utils.six.moves.urllib.error').HTTPError('http://testhost.com', 401, '', {}, None))"
-------------------------------------------------------------------------
"@patch.object(FdmSwaggerParser, 'parse_spec')
def test_get_model_spec(self, parse_spec_mock):
    self.connection_mock.send.return_value = self._connection_response(None)
    operation1 = {'modelName': 'TestModel'}
    op_model_name_is_none = {'modelName': None}
    op_without_model_name = {'url': 'testUrl'}
    parse_spec_mock.return_value = {
        SpecProp.MODEL_OPERATIONS: {
            'TestModel': {
                'testOp1': operation1,
                'testOp2': 'spec2'
            },
            'TestModel2': {
                'testOp10': 'spec10',
                'testOp20': 'spec20'
            }
        },
        SpecProp.OPERATIONS: {
            'testOp1': operation1,
            'testOp10': {
                'modelName': 'TestModel2'
            },
            'testOpWithoutModelName': op_without_model_name,
            'testOpModelNameIsNone': op_model_name_is_none
        }
    }
    assert {'testOp1': operation1, 'testOp2': 'spec2'} == self.ftd_plugin.get_operation_specs_by_model_name(
        'TestModel')
    assert None is self.ftd_plugin.get_operation_specs_by_model_name(
        'testOpModelNameIsNone')
    assert None is self.ftd_plugin.get_operation_specs_by_model_name(
        'testOpWithoutModelName')
    assert self.ftd_plugin.get_operation_specs_by_model_name('nonExistingOperation') is None
"
-------------------------------------------------------------------------
"Recom
PRs: 47747, 48982"
-------------------------------------------------------------------------
=========================================================================
"- 'I(interval), I(timeout) and I(start_period) are specified as durations. They accept duration as a string in a format
boptions:
test:
  description:
    - Command to run to check health.
    - Must be either a string or a list. If it is a list, the first item must be one of C(NONE), C(CMD) or C(CMD-SHELL).
interval:
  description:
    - 'Time between running the check. (default: 30s)'
  type: str
timeout:
  description:
    - 'Maximum time to allow one check to run. (default: 30s)'
  type: str
retries:
  description:
    - 'Consecutive failures needed to report unhealthy. It accept integer value. (default: 3)'
  type: int
start_period:
  description:
    - 'Start period for the container to initialize before starting health-retries countdown. (default: 0s)'
  type: str
"
-------------------------------------------------------------------------
"options:
  test:
    description:
      - Command to run to check health.
      - Must be either a string or a list. If it is a list, the first item must be one of C(NONE), C(CMD) or C(CMD-SHELL).
  interval:
    description:
      - 'Time between running the check. (default: 30s)'
      - 'I(interval) specified as durations. It accepts duration as a string in a format like: C(5h34m56s). The supported units are C(us), C(ms), C(s), C(m) and C(h)'
      type: str
  timeout:
    description:
      - 'Maximum time to allow one check to run. (default: 30s)'
      - 'I(timeout) specified as durations. It accepts duration as a string in a format like: C(1m30s). The supported units are C(us), C(ms), C(s), C(m) and C(h)'
      type: str
  retries:
    description:
      - 'Consecutive failures needed to report unhealthy. It accepts an integer value. (default: 3)'
      type: int
  start_period:
    description:
      - 'Start period for the container to initialize before starting health-retries countdown. (default: 0s)'
      - 'I(start_period) specified as durations. It accepts duration as a string in a format like: C(1h). The supported units are C(us), C(ms), C(s), C(m) and C(h)'
      type: str"
-------------------------------------------------------------------------
"type: list
suboptions:
   name:
      type: str
      required: true
      description:
        - The network's name.
   ipv4_address:
      type: str
      description:
        - The container's IPv4 address in this network.
   ipv6_address:
      type: str
      description:
        - The container's IPv6 address in this network.
   links:
      type: list
      description:
        - A list of containers to link to.
   aliases:
      type: list
      description:
        - List of aliases for this container in this network. These names
          can be used in the network to reach this container.
"
-------------------------------------------------------------------------
"Recom
PRs: 48491, 48895"
-------------------------------------------------------------------------
=========================================================================
"if self.healthcheck.get(value) is None:
    # due to recursive argument_spec, all keys are always present
    # (but have default value None if not specified)
    continue
"
-------------------------------------------------------------------------
"if self.healthcheck.get(value) is None:
    # due to recursive argument_spec, all keys are always present
    # (but have default value None if not specified)
    continue"
-------------------------------------------------------------------------
"container_limits=dict(type='dict', options=dict(
    memory=dict(type='int'),
    memswap=dict(type='int'),
    cpushares=dict(type='int'),
    cpusetcpus=dict(type='str'),
)),
"
-------------------------------------------------------------------------
"Recom
PRs: 48491, 48895"
-------------------------------------------------------------------------
=========================================================================
"device_dict['Rate'] = human_to_bytes(device_dict['Rate'])
"
-------------------------------------------------------------------------
device_dict['Rate'] = ansible.module_utils._text.to_native(device_dict['Rate'])
-------------------------------------------------------------------------
"name=dict(type='list', elements='str'),
"
-------------------------------------------------------------------------
"Recom
PRs: 48491, 48895"
-------------------------------------------------------------------------
=========================================================================
"device_dict = dict((x.title(), y) for x, y in v.items())
devices_list.append(device_dict)
"
-------------------------------------------------------------------------
"# Required imports
from __future__ import absolute_import, print_function
import ansible.module_utils.docker_common
from docker.errors import DockerException
import time
import json
from ansible.module_utils._text import to_native

# Adapted code based on stable information
device_dict = dict((x, y) for x, y in v.items())
devices_list.append(device_dict)"
-------------------------------------------------------------------------
"connected=dict(type='list', default=[], aliases=['containers'], elements='str'),
ipam_driver=dict(type='str'),
ipam_options=dict(type='dict', default={}, options=dict(
    subnet=dict(type='str'),
    iprange=dict(type='str'),
    gateway=dict(type='str'),
    aux_addresses=dict(type='dict'),
)),
"
-------------------------------------------------------------------------
"Recom
PRs: 48491, 48895"
-------------------------------------------------------------------------
=========================================================================
"if network.get('aliases'):
    if not compare_generic(network['aliases'], connected_networks[network['name']].get('Aliases'), 'allow_more_present', 'set'):
        diff = True
if network.get('links'):
    if not compare_generic(expected_links, connected_networks[network['name']].get('Links'), 'allow_more_present', 'set'):
        diff = True
"
-------------------------------------------------------------------------
"if network.get('aliases'):
    if not ansible.module_utils.docker.common.compare_generic(network['aliases'], connected_networks[network['name']].get('Aliases'), 'allow_more_present', 'set'):
        diff = True
if network.get('links'):
    if not ansible.module_utils.docker.common.compare_generic(expected_links, connected_networks[network['name']].get('Links'), 'allow_more_present', 'set'):
        diff = True"
-------------------------------------------------------------------------
"files=dict(type='list', elements='path'),
"
-------------------------------------------------------------------------
"Recom
PRs: 48491, 48895"
-------------------------------------------------------------------------
=========================================================================
"container_limits=dict(type='dict', options=dict(
    memory=dict(type='int'),
    memswap=dict(type='int'),
    cpushares=dict(type='int'),
    cpusetcpus=dict(type='str'),
)),
"
-------------------------------------------------------------------------
"container_limits=dict(type='dict', options=dict(
    memory=dict(type='int'),
    memswap=dict(type='int'),
    cpushares=dict(type='int'),
    cpusetcpus=dict(type='str'),
)),"
-------------------------------------------------------------------------
"services=dict(type='list', elements='str'),
"
-------------------------------------------------------------------------
"Recom
PRs: 48491, 48895"
-------------------------------------------------------------------------
=========================================================================
"name=dict(type='list', elements='str'),
"
-------------------------------------------------------------------------
"name=dict(type='str'),"
-------------------------------------------------------------------------
"remote_addrs=dict(type='list', elements='str'),
"
-------------------------------------------------------------------------
"Recom
PRs: 48491, 48895"
-------------------------------------------------------------------------
=========================================================================
"absent. This was available in Ansible version 2.4 and removed in 2.8""
"
-------------------------------------------------------------------------
"# Update the action type to align with the stable information
action:
    description:
      - ""That action that was taken and is one of: update_rule,
        insert_before_rule, insert_after_rule, args_present, args_absent""
    returned: always
    type: string
    sample: ""args_absent"""
-------------------------------------------------------------------------
"RULE_REGEX = re.compile(r""""""(?P<rule_type>-?(?:auth|account|session|password))\s
                        (?P<path>\S*)\s*
                        (?P<args>.*)\s*"""""", re.X)
RULE_ARG_REGEX = re.compile(r""""""(\[.*\]|\S*)"""""")
VALID_TYPES = ['account', '-account', 'auth', '-auth', 'password', '-password', 'session', '-session']
"
-------------------------------------------------------------------------
"Recom
PRs: 47695, 48307"
-------------------------------------------------------------------------
=========================================================================
"RULE_REGEX = re.compile(r""""""(?P<rule_type>-?(?:auth|account|session|password))\s
                        (?P<path>\S*)\s*
                        (?P<args>.*)\s*"""""", re.X)
RULE_ARG_REGEX = re.compile(r""""""(\[.*\]|\S*)"""""")
VALID_TYPES = ['account', '-account', 'auth', '-auth', 'password', '-password', 'session', '-session']
"
-------------------------------------------------------------------------
"import re

# Ensure to include required dependencies not present in the original metadata
from ansible.module_utils.basic import AnsibleModule

# Emphasize library information from the stable version
RULE_REGEX = re.compile(r""""""(?P<rule_type>-?(?:auth|account|session|password))\s
                        (?P<path>\S*)\s*
                        (?P<args>.*)\s*"""""", re.X)

RULE_ARG_REGEX = re.compile(r""""""(\[.*\]|\S*)"""""")

VALID_TYPES = ['account', '-account', 'auth', '-auth', 'password', '-password', 'session', '-session']"
-------------------------------------------------------------------------
"rule_match = RULE_REGEX.search(line)
rule_args = parse_module_arguments(rule_match.group('args'))
return cls(rule_match.group('rule_type'), rule_match.group('control'), rule_match.group('path'), rule_args)
"
-------------------------------------------------------------------------
"Recom
PRs: 47695, 48307"
-------------------------------------------------------------------------
=========================================================================
"rule_match = RULE_REGEX.search(line)
rule_args = parse_module_arguments(rule_match.group('args'))
return cls(rule_match.group('rule_type'), rule_match.group('control'), rule_match.group('path'), rule_args)
"
-------------------------------------------------------------------------
"match = RULE_REGEX.search(line)
args = parse_module_arguments(match.group('args'))
return cls(match.group('rule_type'), match.group('control'), match.group('path'), args)"
-------------------------------------------------------------------------
"self._args = parse_module_arguments(args)
"
-------------------------------------------------------------------------
"Recom
PRs: 47695, 48307"
-------------------------------------------------------------------------
=========================================================================
"self._args = parse_module_arguments(args)
"
-------------------------------------------------------------------------
self._args = AnsibleModule.parse_module_arguments(args)
-------------------------------------------------------------------------
"if self.rule_type not in VALID_TYPES:
"
-------------------------------------------------------------------------
"Recom
PRs: 47695, 48307"
-------------------------------------------------------------------------
=========================================================================
"if self.rule_type not in VALID_TYPES:
"
-------------------------------------------------------------------------
if self.rule_type not in PamdRule.VALID_TYPES:
-------------------------------------------------------------------------
"valid_simple_controls = ['required', 'requisite', 'sufficient', 'optional', 'include', 'substack', 'definitive']
"
-------------------------------------------------------------------------
"Recom
PRs: 47695, 48307"
-------------------------------------------------------------------------
=========================================================================
"new_args = parse_module_arguments(new_args)
changes = 0
    rule_changed = False
        if(current_rule.rule_type != new_type):
            rule_changed = True
            current_rule.rule_type = new_type
        if(current_rule.rule_control != new_control):
            rule_changed = True
            current_rule.rule_control = new_control
        if(current_rule.rule_path != new_path):
            rule_changed = True
            current_rule.rule_path = new_path
        if(current_rule.rule_args != new_args):
            rule_changed = True
            current_rule.rule_args = new_args
    if rule_changed:
        changes = 1
return changes
changes = 0
"
-------------------------------------------------------------------------
"new_args = PamdService.parse_module_arguments(new_args)
changes = 0
rule_changed = False

if(current_rule.rule_type != new_type):
    rule_changed = True
    current_rule.rule_type = new_type
if(current_rule.rule_control != new_control):
    rule_changed = True
    current_rule.rule_control = new_control
if(current_rule.rule_path != new_path):
    rule_changed = True
    current_rule.rule_path = new_path
if(current_rule.rule_args != new_args):
    rule_changed = True
    current_rule.rule_args = new_args

if rule_changed:
    changes = 1

return changes"
-------------------------------------------------------------------------
"changes = 1
"
-------------------------------------------------------------------------
"Recom
PRs: 47695, 48307"
-------------------------------------------------------------------------
=========================================================================
"changes = 1
"
-------------------------------------------------------------------------
changes = 1
-------------------------------------------------------------------------
"changes = 1
hanges
= 0
"
-------------------------------------------------------------------------
"Recom
PRs: 47695, 48307"
-------------------------------------------------------------------------
=========================================================================
"changes = 1
hanges
= 0
"
-------------------------------------------------------------------------
"changed = 0
        for current_rule in rules_to_find:
            next_rule = current_rule.next

            while next_rule is not None and isinstance(next_rule, PamdComment):
                next_rule = next_rule.next

            new_rule = PamdRule(new_type, new_control, new_path, new_args)
            if next_rule is not None and not next_rule.matches(new_type, new_control, new_path):
                next_rule.prev = new_rule
                new_rule.next = next_rule
                new_rule.prev = current_rule
                current_rule.next = new_rule

                changed += 1

            elif next_rule is None:
                new_rule.prev = self._tail
                new_rule.next = None
                self._tail.next = new_rule
                self._tail = new_rule

                current_rule.next = new_rule
                changed += 1

        return changed"
-------------------------------------------------------------------------
"changes = 1
"
-------------------------------------------------------------------------
"Recom
PRs: 47695, 48307"
-------------------------------------------------------------------------
=========================================================================
"changes = 1
"
-------------------------------------------------------------------------
"# Fifth, set the current_rule's next to the new_rule
current_rule.next_rule = new_rule

# This is the case where the current_rule is the last in the list
elif next_rule is None:"
-------------------------------------------------------------------------
"changes = 1
hanges
add = parse_module_arguments(args_to_add)
= 0
_changed = False
eate some structures to evaluate the situation
le_new_args = set()
value_new_args = dict()
arg in args_to_add:
if arg.startswith(""[""):
    continue
elif ""="" in arg:
    key, value = arg.split(""="")
    key_value_new_args[key] = value
else:
    simple_new_args.add(arg)
value_new_args_set = set(key_value_new_args)
le_current_args = set()
value_current_args = dict()
arg in current_rule.rule_args:
if arg.startswith(""[""):
    continue
elif ""="" in arg:
    key, value = arg.split(""="")
    key_value_current_args[key] = value
else:
    simple_current_args.add(arg)
value_current_args_set = set(key_value_current_args)
args_to_add = list()
ndle new simple arguments
imple_new_args.difference(simple_current_args):
for arg in simple_new_args.difference(simple_current_args):
    new_args_to_add.append(arg)
ndle new key value arguments
ey_value_new_args_set.difference(key_value_current_args_set):
for key in key_value_new_args_set.difference(key_value_current_args_set):
    new_args_to_add.append(key  '='  key_value_new_args[key])
ew_args_to_add:
current_rule.rule_args = new_args_to_add
rule_changed = True
ndle existing key value arguments when value is not equal
ey_value_new_args_set.intersection(key_value_current_args_set):
for key in key_value_new_args_set.intersection(key_value_current_args_set):
    if key_value_current_args[key] != key_value_new_args[key]:
        arg_index = current_rule.rule_args.index(key  '='  key_value_current_args[key])
        current_rule.rule_args[arg_index] = str(key  '='  key_value_new_args[key])
        rule_changed = True
ule_changed:
changes = 1
hanges
remove = parse_module_arguments(args_to_remove)
= 0
"
-------------------------------------------------------------------------
"Recom
PRs: 47695, 48307"
-------------------------------------------------------------------------
=========================================================================
"changes = 1
hanges
add = parse_module_arguments(args_to_add)
= 0
_changed = False
eate some structures to evaluate the situation
le_new_args = set()
value_new_args = dict()
arg in args_to_add:
if arg.startswith(""[""):
    continue
elif ""="" in arg:
    key, value = arg.split(""="")
    key_value_new_args[key] = value
else:
    simple_new_args.add(arg)
value_new_args_set = set(key_value_new_args)
le_current_args = set()
value_current_args = dict()
arg in current_rule.rule_args:
if arg.startswith(""[""):
    continue
elif ""="" in arg:
    key, value = arg.split(""="")
    key_value_current_args[key] = value
else:
    simple_current_args.add(arg)
value_current_args_set = set(key_value_current_args)
args_to_add = list()
ndle new simple arguments
imple_new_args.difference(simple_current_args):
for arg in simple_new_args.difference(simple_current_args):
    new_args_to_add.append(arg)
ndle new key value arguments
ey_value_new_args_set.difference(key_value_current_args_set):
for key in key_value_new_args_set.difference(key_value_current_args_set):
    new_args_to_add.append(key  '='  key_value_new_args[key])
ew_args_to_add:
current_rule.rule_args = new_args_to_add
rule_changed = True
ndle existing key value arguments when value is not equal
ey_value_new_args_set.intersection(key_value_current_args_set):
for key in key_value_new_args_set.intersection(key_value_current_args_set):
    if key_value_current_args[key] != key_value_new_args[key]:
        arg_index = current_rule.rule_args.index(key  '='  key_value_current_args[key])
        current_rule.rule_args[arg_index] = str(key  '='  key_value_new_args[key])
        rule_changed = True
ule_changed:
changes = 1
hanges
remove = parse_module_arguments(args_to_remove)
= 0
"
-------------------------------------------------------------------------
"# Functional set for the hunk: parse_module_arguments, simple_new_args, simple_current_args, key_value_new_args_set, key_value_current_args_set, new_args_to_add, rule_changed
# Compilation set for the hunk: 

changes = 1

# Changes
_changed = False

# Create some structures to evaluate the situation
key_value_new_args = dict()
key_value_current_args = dict()

for arg in args_to_add:
    if arg.startswith(""[""):
        continue
    elif ""="" in arg:
        key, value = arg.split(""="")
        key_value_new_args[key] = value
    else:
        simple_new_args.add(arg)

value_new_args_set = set(key_value_new_args)

for arg in current_rule.rule_args:
    if arg.startswith(""[""):
        continue
    elif ""="" in arg:
        key, value = arg.split(""="")
        key_value_current_args[key] = value
    else:
        simple_current_args.add(arg)

value_current_args_set = set(key_value_current_args)

new_args_to_add = []

# Handle new simple arguments
for arg in simple_new_args.difference(simple_current_args):
    new_args_to_add.append(arg)

# Handle new key-value arguments
for key in key_value_new_args_set.difference(key_value_current_args_set):
    new_args_to_add.append(f""{key}={key_value_new_args[key]}"")

if new_args_to_add:
    current_rule.rule_args = new_args_to_add
    rule_changed = True

# Handle existing key-value arguments when value is not equal
for key in key_value_new_args_set.intersection(key_value_current_args_set):
    if key_value_current_args[key] != key_value_new_args[key]:
        arg_index = current_rule.rule_args.index(f""{key}={key_value_current_args[key]}"")
        current_rule.rule_args[arg_index] = str(f""{key}={key_value_new_args[key]}"")
        rule_changed = True

if rule_changed:
    changes = 1

remove = parse_module_arguments(args_to_remove)"
-------------------------------------------------------------------------
"changes = 1
rn changes
"
-------------------------------------------------------------------------
"Recom
PRs: 47695, 48307"
-------------------------------------------------------------------------
=========================================================================
"changes = 1
rn changes
"
-------------------------------------------------------------------------
changes = 1
-------------------------------------------------------------------------
"return '\n'.join(lines)  '\n'
e_module_arguments(module_arguments):
turn empty list if we have no args to parse
ot module_arguments:
return []
 isinstance(module_arguments, list) and len(module_arguments) == 1 and not module_arguments[0]:
return []
ot isinstance(module_arguments, list):
module_arguments = [module_arguments]
ed_args = list()
arg in module_arguments:
for item in filter(None, RULE_ARG_REGEX.findall(arg)):
    if not item.startswith(""[""):
        re.sub(""\\s*=\\s*"", ""="", item)
    parsed_args.append(item)
rn parsed_args
"
-------------------------------------------------------------------------
"Recom
PRs: 47695, 48307"
-------------------------------------------------------------------------
=========================================================================
"return '\n'.join(lines)  '\n'
e_module_arguments(module_arguments):
turn empty list if we have no args to parse
ot module_arguments:
return []
 isinstance(module_arguments, list) and len(module_arguments) == 1 and not module_arguments[0]:
return []
ot isinstance(module_arguments, list):
module_arguments = [module_arguments]
ed_args = list()
arg in module_arguments:
for item in filter(None, RULE_ARG_REGEX.findall(arg)):
    if not item.startswith(""[""):
        re.sub(""\\s*=\\s*"", ""="", item)
    parsed_args.append(item)
rn parsed_args
"
-------------------------------------------------------------------------
"def parse_module_arguments(module_arguments):
    if not module_arguments:
        return []
    if isinstance(module_arguments, list) and len(module_arguments) == 1 and not module_arguments[0]:
        return []
    if not isinstance(module_arguments, list):
        module_arguments = [module_arguments]
        
    parsed_args = []
    for arg in module_arguments:
        for item in filter(None, RULE_ARG_REGEX.findall(arg)):
            if not item.startswith(""[""):
                re.sub(""\\s*=\\s*"", ""="", item)
            parsed_args.append(item)
    return parsed_args"
-------------------------------------------------------------------------
"rule_match = RULE_REGEX.search(line)
rule_args = parse_module_arguments(rule_match.group('args'))
return cls(rule_match.group('rule_type'), rule_match.group('control'), rule_match.group('path'), rule_args)
"
-------------------------------------------------------------------------
"Recom
PRs: 47695, 48307"
-------------------------------------------------------------------------
=========================================================================
"choices=VALID_TYPES),
    choices=VALID_TYPES),
"
-------------------------------------------------------------------------
"choices=PamdRule.valid_simple_controls),
    choices=PamdRule.valid_simple_controls),"
-------------------------------------------------------------------------
"changes = 0
"
-------------------------------------------------------------------------
"Recom
PRs: 47695, 48307"
-------------------------------------------------------------------------
=========================================================================
"changes = 0
"
-------------------------------------------------------------------------
changes = 0
-------------------------------------------------------------------------
"if [arg for arg in parse_module_arguments(module.params['module_arguments']) if arg.startswith(""["")]:
    module.fail_json(msg=""Unable to process bracketed '[' complex arguments with 'args_present'. Please use 'updated'."")
"
-------------------------------------------------------------------------
"Recom
PRs: 47695, 48307"
-------------------------------------------------------------------------
=========================================================================
"if [arg for arg in parse_module_arguments(module.params['module_arguments']) if arg.startswith(""["")]:
    module.fail_json(msg=""Unable to process bracketed '[' complex arguments with 'args_present'. Please use 'updated'."")
"
-------------------------------------------------------------------------
"if any(arg for arg in service.parse_module_arguments(module.params['module_arguments']) if arg.startswith(""["")):
    module.fail_json(msg=""Unable to process bracketed '[' complex arguments with 'args_present'. Please use 'updated'."")"
-------------------------------------------------------------------------
"result = dict(
    changed=(changes > 0),
    change_count=changes,
    backupdest='',
    action=action,
)
if not module.check_mode and result['changed']:
        result['backupdest'] = module.backup_local(fname)
"
-------------------------------------------------------------------------
"Recom
PRs: 47695, 48307"
-------------------------------------------------------------------------
=========================================================================
"result = dict(
    changed=(changes > 0),
    change_count=changes,
    backupdest='',
)
if not module.check_mode and result['changed']:
        result['backupdest'] = module.backup_local(fname)
"
-------------------------------------------------------------------------
"result = dict(
    changed=(changes > 0),
    change_count=changes,
    backupdest='',
)
if not module.check_mode and result['changed']:
    result['backupdest'] = module.backup_local(fname)"
-------------------------------------------------------------------------
"module.atomic_move(temp_file.name, os.path.realpath(fname))
le.exit_json(**result)
"
-------------------------------------------------------------------------
"Recom
PRs: 47695, 48307"
-------------------------------------------------------------------------
=========================================================================
"blkio_weight='blkio_weight',
cpuset_mems='cpuset_mems',
    if self.client.option_minimal_versions[value]['supported']:
        result[key] = getattr(self, value)
"
-------------------------------------------------------------------------
"blkio_weight='blkio_weight',
cpuset_mems='cpuset_mems',
    if self.supported_min_docker_version[value]['supported']:
        result[key] = getattr(self, value)"
-------------------------------------------------------------------------
"if self.client.docker_py_version < LooseVersion('3.0'):
    # cpu_shares and volume_driver moved to create_host_config in > 3
"
-------------------------------------------------------------------------
"Recom
PRs: 47711, 48074"
-------------------------------------------------------------------------
=========================================================================
"stop_timeout='stop_timeout',
healthcheck='healthcheck',
elf.client.docker_py_version < LooseVersion('3.0'):
# cpu_shares and volume_driver moved to create_host_config in > 3
"
-------------------------------------------------------------------------
"stop_timeout='stop_timeout',
healthcheck='healthcheck',
if client.version < LooseVersion('3.0'):"
-------------------------------------------------------------------------
"if self.client.option_minimal_versions[value]['supported']:
    result[key] = getattr(self, value)
"
-------------------------------------------------------------------------
"Recom
PRs: 47711, 48074"
-------------------------------------------------------------------------
=========================================================================
"if self.client.option_minimal_versions[value]['supported']:
    result[key] = getattr(self, value)
"
-------------------------------------------------------------------------
"if self.minimum_versions_supported(value):
    result[key] = getattr(self, value)"
-------------------------------------------------------------------------
"init='init',
uts_mode='uts',
auto_remove='auto_remove',
elf.client.docker_py_version >= LooseVersion('1.9') and self.client.docker_api_version >= LooseVersion('1.22'):
# blkio_weight can always be updated, but can only be set on creation
# when docker-py and docker API are new enough
elf.client.docker_py_version >= LooseVersion('3.0'):
    if self.client.option_minimal_versions[value]['supported']:
        params[key] = getattr(self, value)
"
-------------------------------------------------------------------------
"Recom
PRs: 47711, 48074"
-------------------------------------------------------------------------
=========================================================================
"init='init',
uts_mode='uts',
runtime='runtime',
auto_remove='auto_remove',
device_read_bps='device_read_bps',
device_write_bps='device_write_bps',
device_read_iops='device_read_iops',
device_write_iops='device_write_iops',
elf.client.docker_py_version >= LooseVersion('1.9') and self.client.docker_api_version >= LooseVersion('1.22'):
# blkio_weight can always be updated, but can only be set on creation
# when docker-py and docker API are new enough
elf.client.docker_py_version >= LooseVersion('3.0'):
    if self.client.option_minimal_versions[value]['supported']:
        params[key] = getattr(self, value)
"
-------------------------------------------------------------------------
"blkio_weight='blkio_weight',

# Backport of #47711 to stable-2.7: simplifes and improves minimal required docker API / docker-py version checks
# When docker-py and docker API are new enough, blkio_weight can always be updated but can only be set on creation
if self.client.docker_py_version >= LooseVersion('1.9') and self.client.docker_api_version >= LooseVersion('1.22'):
    if self.client.option_minimal_versions[value]['supported']:
        params[key] = getattr(self, value)"
-------------------------------------------------------------------------
"volume_driver=host_config.get('VolumeDriver'),
tions which don't make sense without their accompanying option
elf.parameters.client.option_minimal_versions['auto_remove']['supported']:
# auto_remove is only supported in docker>=2; unfortunately it has a default
# value, that's why we have to jump through the hoops here
elf.parameters.client.docker_api_version < LooseVersion('1.22'):
# For docker API < 1.22, update_container() is not supported. Thus
# we need to handle all limits which are usually handled by
# update_container() as configuration changes which require a container
# restart.
config_mapping.update(dict(
    blkio_weight=host_config.get('BlkioWeight'),
    cpu_period=host_config.get('CpuPeriod'),
    cpu_quota=host_config.get('CpuQuota'),
    cpu_shares=host_config.get('CpuShares'),
    cpuset_cpus=host_config.get('CpusetCpus'),
    cpuset_mems=host_config.get('CpusetMems'),
    kernel_memory=host_config.get(""KernelMemory""),
    memory=host_config.get('Memory'),
    memory_reservation=host_config.get('MemoryReservation'),
    memory_swap=host_config.get('MemorySwap'),
))
"
-------------------------------------------------------------------------
"Recom
PRs: 47711, 48074"
-------------------------------------------------------------------------
=========================================================================
"volume_driver=host_config.get('VolumeDriver'),
"
-------------------------------------------------------------------------
"volume_driver=host_config.get('VolumeDriver'),"
-------------------------------------------------------------------------
"if self.parameters.client.docker_api_version < LooseVersion('1.22'):
    # update_container() call not supported
    return False, []
    blkio_weight=host_config.get('BlkioWeight'),
    cpu_shares=host_config.get('CpuShares'),
    cpuset_mems=host_config.get('CpusetMems'),
"
-------------------------------------------------------------------------
"Recom
PRs: 47711, 48074"
-------------------------------------------------------------------------
=========================================================================
"# Options which don't make sense without their accompanying option
if self.parameters.client.option_minimal_versions['auto_remove']['supported']:
    # auto_remove is only supported in docker>=2; unfortunately it has a default
    # value, that's why we have to jump through the hoops here
if self.parameters.client.option_minimal_versions['stop_timeout']['supported']:
    # stop_timeout is only supported in docker>=2.1. Note that stop_timeout
    # has a hybrid role, in that it used to be something only used for stopping
    # containers, and is now also used as a container property. That's why
    # it needs special handling here.
if self.parameters.client.docker_api_version < LooseVersion('1.22'):
    # For docker API < 1.22, update_container() is not supported. Thus
    # we need to handle all limits which are usually handled by
    # update_container() as configuration changes which require a container
    # restart.
    config_mapping.update(dict(
        blkio_weight=host_config.get('BlkioWeight'),
        cpu_period=host_config.get('CpuPeriod'),
        cpu_quota=host_config.get('CpuQuota'),
        cpu_shares=host_config.get('CpuShares'),
        cpuset_cpus=host_config.get('CpusetCpus'),
        cpuset_mems=host_config.get('CpusetMems'),
        kernel_memory=host_config.get(""KernelMemory""),
        memory=host_config.get('Memory'),
        memory_reservation=host_config.get('MemoryReservation'),
        memory_swap=host_config.get('MemorySwap'),
    ))
"
-------------------------------------------------------------------------
"if parameters.client.option_minimal_versions['auto_remove']['supported']:
    # auto_remove is only supported in docker>=2; unfortunately it has a default
    # value, that's why we have to jump through the hoops here
if parameters.client.option_minimal_versions['stop_timeout']['supported']:
    # stop_timeout is only supported in docker>=2.1. Note that stop_timeout
    # has a hybrid role, in that it used to be something only used for stopping
    # containers, and is now also used as a container property. That's why
    # it needs special handling here
if parameters.client.docker_api_version < distutils.version.LooseVersion('1.22'):
    # For docker API < 1.22, update_container() is not supported. Thus
    # we need to handle all limits which are usually handled by
    # update_container() as configuration changes which require a container
    # restart.
    config_mapping.update(dict(
        blkio_weight=host_config.get('BlkioWeight'),
        cpu_period=host_config.get('CpuPeriod'),
        cpu_quota=host_config.get('CpuQuota'),
        cpu_shares=host_config.get('CpuShares'),
        cpuset_cpus=host_config.get('CpusetCpus'),
        cpuset_mems=host_config.get('CpusetMems'),
        kernel_memory=host_config.get(""KernelMemory""),
        memory=host_config.get('Memory'),
        memory_reservation=host_config.get('MemoryReservation'),
        memory_swap=host_config.get('MemorySwap'),
    ))"
-------------------------------------------------------------------------
"if client.module.params.get('restart_retries') is not None and not client.module.params.get('restart_policy'):
"
-------------------------------------------------------------------------
"Recom
PRs: 47711, 48074"
-------------------------------------------------------------------------
=========================================================================
"if self.parameters.client.docker_api_version < LooseVersion('1.22'):
    # update_container() call not supported
    return False, []
    blkio_weight=host_config.get('BlkioWeight'),
    cpu_shares=host_config.get('CpuShares'),
    cpuset_mems=host_config.get('CpusetMems'),
"
-------------------------------------------------------------------------
"if self.docker_api_version < distutils.version.LooseVersion('1.22'):
    return False, []"
-------------------------------------------------------------------------
"if self.client.docker_py_version >= LooseVersion('3.0'):
"
-------------------------------------------------------------------------
"Recom
PRs: 47711, 48074"
-------------------------------------------------------------------------
=========================================================================
"if client.module.params.get('restart_retries') is not None and not client.module.params.get('restart_policy'):
"
-------------------------------------------------------------------------
if ansible_module.params.get('restart_retries') is not None and not ansible_module.params.get('restart_policy'):
-------------------------------------------------------------------------
"# A list of module options which are not docker container properties
__NON_CONTAINER_PROPERTY_OPTIONS = (
    'docker_host', 'tls_hostname', 'api_version', 'timeout', 'cacert_path', 'cert_path',
    'key_path', 'ssl_version', 'tls', 'tls_verify', 'debug', 'env_file', 'force_kill',
    'keep_volumes', 'ignore_image', 'name', 'pull', 'purge_networks', 'recreate',
    'restart', 'state', 'stop_timeout', 'trust_image_content', 'networks', 'cleanup',
    'kill_signal', 'output_logs', 'paused'
)
"
-------------------------------------------------------------------------
"Recom
PRs: 47711, 48074"
-------------------------------------------------------------------------
=========================================================================
"if self.client.docker_py_version >= LooseVersion('3.0'):
"
-------------------------------------------------------------------------
if distutils.version.LooseVersion(self.client.docker_py_version) >= distutils.version.LooseVersion('3.0'):
-------------------------------------------------------------------------
"if self.client.docker_py_version < LooseVersion('3.0'):
    # cpu_shares and volume_driver moved to create_host_config in > 3
"
-------------------------------------------------------------------------
"Recom
PRs: 47711, 48074"
-------------------------------------------------------------------------
=========================================================================
"# A list of module options which are not docker container properties
__NON_CONTAINER_PROPERTY_OPTIONS = (
    'docker_host', 'tls_hostname', 'api_version', 'timeout', 'cacert_path', 'cert_path',
    'key_path', 'ssl_version', 'tls', 'tls_verify', 'debug', 'env_file', 'force_kill',
    'keep_volumes', 'ignore_image', 'name', 'pull', 'purge_networks', 'recreate',
    'restart', 'state', 'trust_image_content', 'networks', 'cleanup', 'kill_signal',
    'output_logs', 'paused'
)
"
-------------------------------------------------------------------------
"# A list of module options which are not docker container properties
NON_CONTAINER_PROPERTY_OPTIONS = (
    'docker_host', 'tls_hostname', 'api_version', 'timeout', 'cacert_path', 'cert_path',
    'key_path', 'ssl_version', 'tls', 'tls_verify', 'debug', 'env_file', 'force_kill',
    'keep_volumes', 'ignore_image', 'name', 'pull', 'purge_networks', 'recreate',
    'restart', 'state', 'trust_image_content', 'networks', 'cleanup', 'kill_signal',
    'output_logs', 'paused'
)"
-------------------------------------------------------------------------
"blkio_weight='blkio_weight',
cpuset_mems='cpuset_mems',
    if self.client.option_minimal_versions[value]['supported']:
        result[key] = getattr(self, value)
"
-------------------------------------------------------------------------
"Recom
PRs: 47711, 48074"
-------------------------------------------------------------------------
=========================================================================
"def __init__(self, module, account):
    self.directory, dummy = account.get_request(self.directory_root)
"
-------------------------------------------------------------------------
"def __init__(self, module, account):
    self.directory, _ = account.get_request(self.directory_root)"
-------------------------------------------------------------------------
"if payload is None:
    payload64 = ''
else:
    payload64 = nopad_b64(self.module.jsonify(payload).encode('utf8'))
"
-------------------------------------------------------------------------
"Recom
PRs: 45051, 48043"
-------------------------------------------------------------------------
=========================================================================
"self.directory = ACMEDirectory(module, self)
"
-------------------------------------------------------------------------
"self.directory = ACMEEndpoint(self.module, self)"
-------------------------------------------------------------------------
"        If payload is None, a POST-as-GET is performed.
        (https://tools.ietf.org/html/draft-ietf-acme-acme-15#section-6.3)
"
-------------------------------------------------------------------------
"Recom
PRs: 45051, 48043"
-------------------------------------------------------------------------
=========================================================================
"def send_signed_request(self, url, payload, key_data=None, jws_header=None, parse_json_result=True):
"
-------------------------------------------------------------------------
"def send_signed_request(self, url, payload, key_data=None, jws_header=None, parse_json_result=True):
    # existing code remains unchanged"
-------------------------------------------------------------------------
"def get_request(self, uri, parse_json_result=True, headers=None, get_only=False):
    '''
    Perform a GET-like request. Will try POST-as-GET for ACMEv2, with fallback
    to GET if server replies with a status code of 405.
    '''
    if not get_only and self.version != 1:
        # Try POST-as-GET
        content, info = self.send_signed_request(uri, None, parse_json_result=False)
        if info['status'] == 405:
            # Instead, do unauthenticated GET
            get_only = True
    else:
        # Do unauthenticated GET
        get_only = True
    if get_only:
        # Perform unauthenticated GET
        resp, info = fetch_url(self.module, uri, method='GET', headers=headers)
        try:
            content = resp.read()
        except AttributeError:
            content = info.get('body')
    # Process result
"
-------------------------------------------------------------------------
"Recom
PRs: 45051, 48043"
-------------------------------------------------------------------------
=========================================================================
"if self.module.check_mode:
    self.module.debug('In check mode, would have run: ""%s""' % cmd)
    return (0, '', '')
master_in_fd, slave_in_fd = pty.openpty()
master_out_fd, slave_out_fd = pty.openpty()
master_err_fd, slave_err_fd = pty.openpty()
env = os.environ.copy()
env['LC_ALL'] = 'C'
try:
    p = subprocess.Popen([to_bytes(c) for c in cmd],
                         stdin=slave_in_fd,
                         stdout=slave_out_fd,
                         stderr=slave_err_fd,
                         preexec_fn=os.setsid,
                         env=env)
    out_buffer = b''
    err_buffer = b''
    while p.poll() is None:
        r, w, e = select.select([master_out_fd, master_err_fd], [], [], 1)
        first_prompt = b'Enter passphrase (empty for no passphrase):'
        second_prompt = b'Enter same passphrase again'
        prompt = first_prompt
        for fd in r:
            if fd == master_out_fd:
                chunk = os.read(master_out_fd, 10240)
                out_buffer = chunk
                if prompt in out_buffer:
                    os.write(master_in_fd, self.ssh_passphrase  b'\r')
                    prompt = second_prompt
            else:
                chunk = os.read(master_err_fd, 10240)
                err_buffer = chunk
                if prompt in err_buffer:
                    os.write(master_in_fd, self.ssh_passphrase  b'\r')
                    prompt = second_prompt
            if b'Overwrite (y/n)?' in out_buffer or b'Overwrite (y/n)?' in err_buffer:
                # This created between us checking for existence and now
                return (None, 'Key already exists', '')
    rc = p.returncode
    out = to_native(out_buffer)
    err = to_native(err_buffer)
except OSError as e:
    return (1, '', to_native(e))
cmd.append('-N')
(rc, out, err) = self.execute_command(cmd)
"
-------------------------------------------------------------------------
"elif self.module.check_mode:
    self.module.debug('In check mode, would have run: ""%s""' % cmd)
    return (0, '', '')
master_in_fd, slave_in_fd = pty.openpty()
master_out_fd, slave_out_fd = pty.openpty()
master_err_fd, slave_err_fd = pty.openpty()
env = os.environ.copy()
env['LC_ALL'] = 'C'
try:
    p = subprocess.Popen([posix.to_bytes(c) for c in cmd],
                         stdin=slave_in_fd,
                         stdout=slave_out_fd,
                         stderr=slave_err_fd,
                         preexec_fn=os.setsid,
                         env=env)
    out_buffer = b''
    err_buffer = b''
    while p.poll() is None:
        r, w, e = select.select([master_out_fd, master_err_fd], [], [], 1)
        first_prompt = b'Enter passphrase (empty for no passphrase):'
        second_prompt = b'Enter same passphrase again'
        prompt = first_prompt
        for fd in r:
            if fd == master_out_fd:
                chunk = os.read(master_out_fd, 10240)
                out_buffer = chunk
                if prompt in out_buffer:
                    os.write(master_in_fd, self.ssh_passphrase + b'\r')
                    prompt = second_prompt
            else:
                chunk = os.read(master_err_fd, 10240)
                err_buffer = chunk
                if prompt in err_buffer:
                    os.write(master_in_fd, self.ssh_passphrase + b'\r')
                    prompt = second_prompt
            if b'Overwrite (y/n)?' in out_buffer or b'Overwrite (y/n)?' in err_buffer:
                return (None, 'Key already exists', '')
    rc = p.returncode
    out = _text.to_native(out_buffer)
    err = _text.to_native(err_buffer)
except OSError as e:
    return (1, '', _text.to_native(e))
cmd.append('-N')
(rc, out, err) = self.execute_command(cmd)"
-------------------------------------------------------------------------
"if self.module.check_mode:
    self.module.debug('In check mode, would have run: ""%s""' % cmd)
    return (0, '', '')
master_in_fd, slave_in_fd = pty.openpty()
master_out_fd, slave_out_fd = pty.openpty()
master_err_fd, slave_err_fd = pty.openpty()
env = os.environ.copy()
env['LC_ALL'] = 'C'
try:
    p = subprocess.Popen([to_bytes(c) for c in cmd],
                         stdin=slave_in_fd,
                         stdout=slave_out_fd,
                         stderr=slave_err_fd,
                         preexec_fn=os.setsid,
                         env=env)
    out_buffer = b''
    err_buffer = b''
    while p.poll() is None:
        r, w, e = select.select([master_out_fd, master_err_fd], [], [], 1)
        first_prompt = b'Enter passphrase (empty for no passphrase):'
        second_prompt = b'Enter same passphrase again'
        prompt = first_prompt
        for fd in r:
            if fd == master_out_fd:
                chunk = os.read(master_out_fd, 10240)
                out_buffer = chunk
                if prompt in out_buffer:
                    os.write(master_in_fd, to_bytes(self.ssh_passphrase, errors='strict')  b'\r')
                    prompt = second_prompt
            else:
                chunk = os.read(master_err_fd, 10240)
                err_buffer = chunk
                if prompt in err_buffer:
                    os.write(master_in_fd, to_bytes(self.ssh_passphrase, errors='strict')  b'\r')
                    prompt = second_prompt
            if b'Overwrite (y/n)?' in out_buffer or b'Overwrite (y/n)?' in err_buffer:
                # The key was created between us checking for existence and now
                return (None, 'Key already exists', '')
    rc = p.returncode
    out = to_native(out_buffer)
    err = to_native(err_buffer)
except OSError as e:
    return (1, '', to_native(e))
cmd.append('-N')
(rc, out, err) = self.execute_command(cmd)
"
-------------------------------------------------------------------------
"Recom
PRs: 47436, 47487"
-------------------------------------------------------------------------
=========================================================================
"if self.parameters.auto_remove:
    output = ""Cannot retrieve result as auto_remove is enabled""
        self.client.module.warn('Cannot output_logs if auto_remove is enabled!')
    config = self.client.inspect_container(container_id)
    logging_driver = config['HostConfig']['LogConfig']['Type']
    if logging_driver == 'json-file' or logging_driver == 'journald':
        output = self.client.logs(container_id, stdout=True, stderr=True, stream=False, timestamps=False)
        if self.parameters.output_logs:
            self._output_logs(msg=output)
    else:
        output = ""Result logged using `%s` driver"" % logging_driver
    self.container_remove(container_id, force=True, ignore_failure=self.parameters.auto_remove)
"
-------------------------------------------------------------------------
"if self.auto_remove:
        output = ""Cannot retrieve result as auto_remove is enabled""
        self.warn('Cannot output_logs if auto_remove is enabled!')
    config = self.inspect_container(container_id)
    logging_driver = config['HostConfig']['LogConfig']['Type']
    if logging_driver == 'json-file' or logging_driver == 'journald':
        output = self.logs(container_id, stdout=True, stderr=True, stream=False, timestamps=False)
        if self.output_logs:
            self._output_logs(msg=output)
    else:
        output = ""Result logged using `%s` driver"" % logging_driver
    self.remove(container_id, force=True, ignore_failure=self.auto_remove)"
-------------------------------------------------------------------------
"self.container_remove(container_id, force=True)
"
-------------------------------------------------------------------------
"Recom
PRs: 47396, 47484"
-------------------------------------------------------------------------
=========================================================================
"def container_remove(self, container_id, link=False, force=False, ignore_failure=False):
"
-------------------------------------------------------------------------
"def container_remove(self, container_id, link=False, force=False):
        """"""
        Remove containers
        """"""
        volume_state = (not self.parameters.keep_volumes)
        self.log(""remove container container:%s v:%s link:%s force%s"" % (container_id, volume_state, link, force))
        self.results['actions'].append(dict(removed=container_id, volume_state=volume_state, link=link, force=force))
        self.results['changed'] = True
        response = None
        if not self.check_mode:
            try:
                response = self.client.remove_container(container_id, v=volume_state, link=link, force=force)
            except Exception as exc:
                self.fail(""Error removing container %s: %s"" % (container_id, str(exc)))
        return response"
-------------------------------------------------------------------------
"self.container_remove(container_id, force=True)
"
-------------------------------------------------------------------------
"Recom
PRs: 47396, 47484"
-------------------------------------------------------------------------
=========================================================================
"if not ignore_failure:
    self.fail(""Error removing container %s: %s"" % (container_id, str(exc)))
"
-------------------------------------------------------------------------
"if not self.ignore_failure:
    self.fail(""Error removing container %s: %s"" % (container_id, str(exc)))"
-------------------------------------------------------------------------
"def container_remove(self, container_id, link=False, force=False):
"
-------------------------------------------------------------------------
"Recom
PRs: 47396, 47484"
-------------------------------------------------------------------------
=========================================================================
"try:
    if secure != 'never':
        try:
            smtp = smtplib.SMTP_SSL(timeout=timeout)
            code, smtpmessage = smtp.connect(host, port=port)
            secure_state = True
        except ssl.SSLError as e:
            if secure == 'always':
                                           (host, port, to_native(e)), exception=traceback.format_exc())
    if not secure_state:
        smtp = smtplib.SMTP(timeout=timeout)
except smtplib.SMTPException as e:
    module.fail_json(rc=1, msg='Unable to Connect %s:%s: %s' % (host, port, to_native(e)), exception=traceback.format_exc())
if int(code) > 0:
    if not secure_state and secure in ('starttls', 'try'):
"
-------------------------------------------------------------------------
"try:
    if secure != 'never':
        try:
            smtp = smtplib.SMTP_SSL(host=host, timeout=timeout)
            code, smtpmessage = smtp.connect(host, port=port)
            secure_state = True
        except ssl.SSLError as e:
            if secure == 'always':
                module.fail_json(rc=1, msg='Unable to start an encrypted session to %s:%s: %s' %
                                 (host, port, to_native(e)), exception=traceback.format_exc())
    if not secure_state:
        smtp = smtplib.SMTP(timeout=timeout)
        code, smtpmessage = smtp.connect(host, port=port)
except smtplib.SMTPException as e:
    module.fail_json(rc=1, msg='Unable to Connect %s:%s: %s' % (host, port, to_native(e)), exception=traceback.format_exc())
if int(code) > 0:
    if not secure_state and secure in ('starttls', 'try'):"
-------------------------------------------------------------------------
"except:
    pass
"
-------------------------------------------------------------------------
"Recom
PRs: 37098, 47019"
-------------------------------------------------------------------------
=========================================================================
"working_dir=config.get('WorkingDir'),
publish_all_ports=host_config.get('PublishAllPorts'),
"
-------------------------------------------------------------------------
"working_dir=config.get('WorkingDir'),
publish_all_ports=host_config.get('PublishAllPorts'),"
-------------------------------------------------------------------------
"self.parameters_map['expected_ports'] = 'expected_ports'
"
-------------------------------------------------------------------------
"Recom
PRs: 46594, 46640"
-------------------------------------------------------------------------
=========================================================================
"# version comparison. Otherwise we handle this depending on whether
# the container already runs or not; in the former case, in case the
# container needs to be restarted, we use the existing container's
# image ID.
image = self._get_image()
self.log(image, pretty_print=True)
if not container.exists:
    # New container
    self.log('No container found')
    if not self.parameters.image:
        self.fail('Cannot create container when image is not specified!')
    new_container = self.container_create(self.parameters.image, self.parameters.create_parameters)
    if new_container:
        container = new_container
else:
    # Existing container
    different, differences = container.has_different_configuration(image)
    image_different = False
    if self.parameters.comparisons['image']['comparison'] == 'strict':
        image_different = self._image_is_different(image, container)
    if image_different or different or self.parameters.recreate:
        self.diff['differences'] = differences
        if image_different:
            self.diff['image_different'] = True
        self.log(""differences"")
        self.log(differences, pretty_print=True)
        image_to_use = self.parameters.image
        if not image_to_use and container and container.Image:
            image_to_use = container.Image
        if not image_to_use:
            self.fail('Cannot recreate container when image is not specified or cannot be extracted from current container!')
        if container.running:
            self.container_stop(container.Id)
        self.container_remove(container.Id)
        new_container = self.container_create(image_to_use, self.parameters.create_parameters)
"
-------------------------------------------------------------------------
"# Functional set for the hunk: _check_mount_target_collisions, compare_generic, container_create, container_has_different_configuration

# Library information from Stable: ansible.module_utils.docker.common.is_image_name_id, ansible.module_utils.docker.common._image_is_different, ansible.module_utils.docker.common.parse_healthcheck

# Function name information from Stable: self.fail, self.log, self.parameters.image, self.parameters.create_parameters, self._get_image, self._image_is_different, self.container_create, self.container_stop, self.container_remove, self.diff, self.parameters.comparisons

# Class name information from Stable: ansible.module_utils.docker.common.Container, ansible.module_utils.docker.common.ContainerManager

# Class method call information from Stable: container.has_different_configuration, self._image_is_different, container.running, container.Image, self.container_stop, self.container_remove, self.container_create

image = self._get_image()
self.log(image, pretty_print=True)
if not container.exists:
    # New container
    self.log('No container found')
    if not self.parameters.image:
        self.fail('Cannot create container when image is not specified!')
    new_container = self.container_create(self.parameters.image, self.parameters.create_parameters)
    if new_container:
        container = new_container
else:
    # Existing container
    different, differences = container.has_different_configuration(image)
    image_different = False
    if self.parameters.comparisons['image']['comparison'] == 'strict':
        image_different = self._image_is_different(image, container)
    if image_different or different or self.parameters.recreate:
        self.diff['differences'] = differences
        if image_different:
            self.diff['image_different'] = True
        self.log(""differences"")
        self.log(differences, pretty_print=True)
        image_to_use = self.parameters.image
        if not image_to_use and container and container.Image:
            image_to_use = container.Image
        if not image_to_use:
            self.fail('Cannot recreate container when image is not specified or cannot be extracted from current container!')
        if container.running:
            self.container_stop(container.Id)
        self.container_remove(container.Id)
        new_container = self.container_create(image_to_use, self.parameters.create_parameters)"
-------------------------------------------------------------------------
"        # If the image parameter was passed then we need to deal with the image
        # version comparison. Otherwise we handle this depending on whether
        # the container already runs or not; in the former case, in case the
        # container needs to be restarted, we use the existing container's
        # image ID.
            if not self.parameters.image:
                self.fail('Cannot create container when image is not specified!')
"
-------------------------------------------------------------------------
"Recom
PRs: 46322, 46576"
-------------------------------------------------------------------------
=========================================================================
"- On macOS, this module uses C(dscl) to create, modify, and delete accounts. C(dseditgroup) is used to
  modify group membership. Accounts are hidden from the login window by modifying
  C(/Library/Preferences/com.apple.loginwindow.plist).
- On FreeBSD, this module uses C(pw useradd) and C(chpass) to create, C(pw usermod) and C(chpass) to modify,
  C(pw userdel) remove, C(pw lock) to lock, and C(pw unlock) to unlock accounts.
- On all other platforms, this module uses C(useradd) to create, C(usermod) to modify, and
  C(userdel) to remove accounts.
"
-------------------------------------------------------------------------
"On macOS, this module uses `User._get_dscl` to create, modify, and delete accounts. `User._modify_group` is used to modify group membership. Accounts are hidden from the login window by modifying `User.profile`.

On FreeBSD, this module uses `User.create_user_useradd` and `User.modify_user_usermod` to create, `User.remove_user_userdel` to remove, `User._handle_lock` to lock, and `User.force` to unlock accounts.

On all other platforms, this module uses `User.create_user` to create, `User.modify_user` to modify, and `User.remove_user` to remove accounts."
-------------------------------------------------------------------------
"- On SunOS platforms, the shadow file is backed up automatically since this module edits it directly.
  On other platforms, the shadow file is backed up by the underlying tools used by this module.
- On macOS, this module uses C(dscl) to create, modify, and delete accounts. C(dseditgroup) is used to
  modify group membership. Accounts are hidden from the login window by modifying
  C(/Library/Preferences/com.apple.loginwindow.plist).
- On FreeBSD, this module uses C(pw useradd) and C(chpass) to create, C(pw usermod) and C(chpass) to modify,
  C(pw userdel) remove, C(pw lock) to lock, and C(pw unlock) to unlock accounts.
- On all other platforms, this module uses C(useradd) to create, C(usermod) to modify, and
  C(userdel) to remove accounts.
"
-------------------------------------------------------------------------
"Recom
PRs: 46455, 46512"
-------------------------------------------------------------------------
=========================================================================
"- On other operating systems, the default shell is determined by the underlying tool being
  used. See Notes for details.
"
-------------------------------------------------------------------------
"# On other operating systems, the default shell is determined by the underlying tool being
# used. See Notes for details."
-------------------------------------------------------------------------
"- macOS only, optionally hide the user from the login window and system preferences.
"
-------------------------------------------------------------------------
"Recom
PRs: 46455, 46512"
-------------------------------------------------------------------------
=========================================================================
"if module.params['scope'] in (None, 'system') and \
        not out.strip().endswith('disabled') and \
        sysv_is_enabled(unit):
"
-------------------------------------------------------------------------
"if module.params['scope'] in (None, 'system') and \
        (not out.strip().endswith('disabled') or sysv_is_enabled(unit)):"
-------------------------------------------------------------------------
"not out.strip().endswith('disabled') and \
sysv_is_enabled(unit):
"
-------------------------------------------------------------------------
"Recom
PRs: 46245, 46317"
-------------------------------------------------------------------------
=========================================================================
"- On Linux, macOS and OpenBSD, this is converted to minutes and rounded down. If less than 60, it will be set to 0.
"
-------------------------------------------------------------------------
"# On Linux, macOS, and OpenBSD, convert the pre_reboot_delay to minutes and round down. If less than 60, set it to 0.
        if self._low_level_execute_command(""uname -s"", False)[1].decode(""utf-8"").strip() in [
                ""Linux"",
                ""Darwin"",
                ""OpenBSD""]:
            if self.pre_reboot_delay < 60:
                self.pre_reboot_delay = 0
            else:
                self.pre_reboot_delay = int(self.pre_reboot_delay / 60)"
-------------------------------------------------------------------------
"- On Linux, macOS, and OpenBSD this is converted to minutes and rounded down. If less than 60, it will be set to 0.
- On Solaris and FreeBSD this will be seconds.
"
-------------------------------------------------------------------------
"Recom
PRs: 46147, 46289"
-------------------------------------------------------------------------
=========================================================================
"if len(split_fields) == 3 and split_fields[0:2] == ['iam', 'security-credentials']:
"
-------------------------------------------------------------------------
"new_fields[self._prefix % ""iam-instance-profile-role""] = split_fields[2]"
-------------------------------------------------------------------------
"if len(split_fields) == 2 and split_fields[0:2] == ['iam', 'info_instanceprofilearn']:
    new_fields[self._prefix % ""iam-instance-profile-role""] = value.split('/')[1]
"
-------------------------------------------------------------------------
"Recom
PRs: 38664, 46077"
-------------------------------------------------------------------------
=========================================================================
"if len(split_fields) == 3 and split_fields[0:2] == ['iam', 'security-credentials']:
"
-------------------------------------------------------------------------
"if len(split_fields) == 3 and split_fields[0:2] == ['iam', 'security-credentials']:"
-------------------------------------------------------------------------
"if len(split_fields) == 2 and split_fields[0:2] == ['iam', 'info_instanceprofilearn']:
    new_fields[self._prefix % ""iam-instance-profile-role""] = value.split('/')[1]
"
-------------------------------------------------------------------------
"Recom
PRs: 38664, 46076"
-------------------------------------------------------------------------
=========================================================================
"cap_drop=host_config.get('CapDrop'),
"
-------------------------------------------------------------------------
self.cap_drop = host_config.get('CapDrop')
-------------------------------------------------------------------------
"compare = self.parameters.client.comparisons[self.parameters_map.get(key, key)]
self.log('check differences %s %s vs %s (%s)' % (key, getattr(self.parameters, key), str(value), compare))
    match = self._compare(getattr(self.parameters, key), value, compare)
"
-------------------------------------------------------------------------
"Recom
PRs: 45905, 46063"
-------------------------------------------------------------------------
=========================================================================
"compare = self.parameters.client.comparisons[self.parameters_map.get(key, key)]
self.log('check differences %s %s vs %s (%s)' % (key, getattr(self.parameters, key), str(value), compare))
    match = self._compare(getattr(self.parameters, key), value, compare)
"
-------------------------------------------------------------------------
"compare = self.client.comparisons[self.parameters_map.get(key, key)]
self.log('check differences %s %s vs %s (%s)' % (key, getattr(self, key), str(value), compare))
match = self._compare(getattr(self, key), value, compare)"
-------------------------------------------------------------------------
"if self.parameters.client.HAS_BLKIO_WEIGHT_OPT:
    # blkio_weight is only supported in docker>=1.9
    config_mapping['blkio_weight'] = host_config.get('BlkioWeight')
if self.parameters.client.HAS_CPUSET_MEMS_OPT:
    # cpuset_mems is only supported in docker>=2.3
    config_mapping['cpuset_mems'] = host_config.get('CpusetMems')
    if getattr(self.parameters, key, None):
        compare = self.parameters.client.comparisons[self.parameters_map.get(key, key)]
        match = self._compare(getattr(self.parameters, key), value, compare)
        if not match:
            # no match. record the differences
            item = dict()
            item[key] = dict(
                parameter=getattr(self.parameters, key),
                container=value
            )
            differences.append(item)
"
-------------------------------------------------------------------------
"Recom
PRs: 45905, 46063"
-------------------------------------------------------------------------
=========================================================================
"if self.parameters.client.HAS_BLKIO_WEIGHT_OPT:
    # blkio_weight is only supported in docker>=1.9
    config_mapping['blkio_weight'] = host_config.get('BlkioWeight')
if self.parameters.client.HAS_CPUSET_MEMS_OPT:
    # cpuset_mems is only supported in docker>=2.3
    config_mapping['cpuset_mems'] = host_config.get('CpusetMems')
    if getattr(self.parameters, key, None):
        compare = self.parameters.client.comparisons[self.parameters_map.get(key, key)]
        match = self._compare(getattr(self.parameters, key), value, compare)
        if not match:
            # no match. record the differences
            item = dict()
            item[key] = dict(
                parameter=getattr(self.parameters, key),
                container=value
            )
            differences.append(item)
"
-------------------------------------------------------------------------
"# Check if blkio_weight is supported in the Docker version
if docker.common.compare_version(self.client, '1.9'):
    config_mapping['blkio_weight'] = host_config.get('BlkioWeight')

# Check if cpuset_mems is supported in the Docker version
if docker.common.compare_version(self.client, '2.3'):
    config_mapping['cpuset_mems'] = host_config.get('CpusetMems')

# Check for attribute existence and compare values
if getattr(self.parameters, key, None):
    compare = self.client.comparisons[self.parameters_map.get(key, key)]
    match = docker.common.has_match(self.parameters, key, value, compare)

    if not match:
        # no match. record the differences
        item = dict()
        item[key] = dict(
            parameter=getattr(self.parameters, key),
            container=value
        )
        differences.append(item)"
-------------------------------------------------------------------------
"if self.parameters.comparisons['image']['comparison'] == 'strict':
"
-------------------------------------------------------------------------
"Recom
PRs: 45905, 46063"
-------------------------------------------------------------------------
=========================================================================
"if self.parameters.comparisons['image']['comparison'] == 'strict':
"
-------------------------------------------------------------------------
if self.comparisons['image']['comparison'] == 'strict':
-------------------------------------------------------------------------
"def _setup_comparisons(self):
    comparisons = {}
    comp_aliases = {}
    # Put in defaults
    explicit_types = dict(
        command='list',
        devices='set(dict)',
        dns_search_domains='list',
        dns_servers='list',
        env='set',
        entrypoint='list',
        etc_hosts='set',
        ulimits='set(dict)',
    )
    for option, data in self.module.argument_spec.items():
        # Ignore options which aren't used as container properties
        if option in ('docker_host', 'tls_hostname', 'api_version', 'timeout', 'cacert_path', 'cert_path',
                      'key_path', 'ssl_version', 'tls', 'tls_verify', 'debug', 'env_file', 'force_kill',
                      'keep_volumes', 'ignore_image', 'name', 'pull', 'purge_networks', 'recreate',
                      'restart', 'state', 'stop_timeout', 'trust_image_content', 'networks'):
            continue
        # Determine option type
        if option in explicit_types:
            type = explicit_types[option]
        elif data['type'] == 'list':
            type = 'set'
        elif data['type'] == 'dict':
            type = 'dict'
        else:
            type = 'value'
        # Determine comparison type
        if type in ('list', 'value'):
            comparison = 'strict'
        else:
            comparison = 'allow_more_present'
        comparisons[option] = dict(type=type, comparison=comparison, name=option)
        # Keep track of aliases
        comp_aliases[option] = option
        for alias in data.get('aliases', []):
            comp_aliases[alias] = option
    # Process legacy ignore options
    if self.module.params['ignore_image']:
        comparisons['image']['comparison'] = 'ignore'
    self.comparisons = comparisons
"
-------------------------------------------------------------------------
"Recom
PRs: 45905, 46063"
-------------------------------------------------------------------------
=========================================================================
"def _setup_comparisons(self):
    comparisons = {}
    comp_aliases = {}
    # Put in defaults
    explicit_types = dict(
        command='list',
        devices='set(dict)',
        dns_search_domains='list',
        dns_servers='list',
        env='set',
        entrypoint='list',
        etc_hosts='set',
        ulimits='set(dict)',
    )
    for option, data in self.module.argument_spec.items():
        # Ignore options which aren't used as container properties
        if option in ('docker_host', 'tls_hostname', 'api_version', 'timeout', 'cacert_path', 'cert_path',
                      'key_path', 'ssl_version', 'tls', 'tls_verify', 'debug', 'env_file', 'force_kill',
                      'keep_volumes', 'ignore_image', 'name', 'pull', 'purge_networks', 'recreate',
                      'restart', 'state', 'stop_timeout', 'trust_image_content', 'networks'):
            continue
        # Determine option type
        if option in explicit_types:
            type = explicit_types[option]
        elif data['type'] == 'list':
            type = 'set'
        elif data['type'] == 'dict':
            type = 'dict'
        else:
            type = 'value'
        # Determine comparison type
        if type in ('list', 'value'):
            comparison = 'strict'
        else:
            comparison = 'allow_more_present'
        comparisons[option] = dict(type=type, comparison=comparison, name=option)
        # Keep track of aliases
        comp_aliases[option] = option
        for alias in data.get('aliases', []):
            comp_aliases[alias] = option
    # Process legacy ignore options
    if self.module.params['ignore_image']:
        comparisons['image']['comparison'] = 'ignore'
    self.comparisons = comparisons
"
-------------------------------------------------------------------------
"def _setup_comparisons(self):
    comparisons = {}
    comp_aliases = {}
    # Put in defaults
    explicit_types = dict(
        command='list',
        devices='set(dict)',
        dns_search_domains='list',
        dns_servers='list',
        env='set',
        entrypoint='list',
        etc_hosts='set',
        ulimits='set(dict)',
    )
    for option, data in TaskParameters.argument_spec.items():
        # Ignore options which aren't used as container properties
        if option in ('docker_host', 'tls_hostname', 'api_version', 'timeout', 'cacert_path', 'cert_path',
                      'key_path', 'ssl_version', 'tls', 'tls_verify', 'debug', 'env_file', 'force_kill',
                      'keep_volumes', 'ignore_image', 'name', 'pull', 'purge_networks', 'recreate',
                      'restart', 'state', 'stop_timeout', 'trust_image_content', 'networks'):
            continue
        # Determine option type
        if option in explicit_types:
            type = explicit_types[option]
        elif data['type'] == 'list':
            type = 'set'
        elif data['type'] == 'dict':
            type = 'dict'
        else:
            type = 'value'
        # Determine comparison type
        if type in ('list', 'value'):
            comparison = 'strict'
        else:
            comparison = 'allow_more_present'
        comparisons[option] = dict(type=type, comparison=comparison, name=option)
        # Keep track of aliases
        comp_aliases[option] = option
        for alias in data.get('aliases', []):
            comp_aliases[alias] = option
    # Process legacy ignore options
    if self.ignore_image:
        comparisons['image']['comparison'] = 'ignore'
    self.comparisons = comparisons"
-------------------------------------------------------------------------
"self.comparisons = client.comparisons
if self.groups:
    # In case integers are passed as groups, we need to convert them to
    # strings as docker internally treats them as strings.
    self.groups = [str(g) for g in self.groups]
"
-------------------------------------------------------------------------
"Recom
PRs: 45905, 46063"
-------------------------------------------------------------------------
=========================================================================
"entrypoint=dict(type='list'),
"
-------------------------------------------------------------------------
entrypoint = docker.types.Entrypoint(['list'])
-------------------------------------------------------------------------
"shm_size=dict(type='str'),
sysctls=dict(type='dict'),
userns_mode=dict(type='str'),
volume_driver=dict(type='str'),
"
-------------------------------------------------------------------------
"Recom
PRs: 45905, 46063"
-------------------------------------------------------------------------
=========================================================================
"if vpc_id:
    vpc_wins = dict((group['GroupName'], group) for group in all_groups if group['VpcId'] == vpc_id)
    groups.update(vpc_wins)
"
-------------------------------------------------------------------------
"if vpc_id:
        vpc_wins = dict((group['GroupName'], group) for group in all_groups if group['VpcId'] == vpc_id)
        groups.update(vpc_wins)"
-------------------------------------------------------------------------
"if vpc_id:
    vpc_wins = dict((group['GroupName'], group) for group in all_groups if group.get('VpcId') and group['VpcId'] == vpc_id)
    groups.update(vpc_wins)
"
-------------------------------------------------------------------------
"Recom
PRs: 45787, 45815"
-------------------------------------------------------------------------
=========================================================================
"stdout = ''
stderr = ''
"
-------------------------------------------------------------------------
"stdout = ''
stderr = ''"
-------------------------------------------------------------------------
"stdout = u''
stderr = u''
"
-------------------------------------------------------------------------
"Recom
PRs: 45607, 45791"
-------------------------------------------------------------------------
=========================================================================
"type: boolean
"
-------------------------------------------------------------------------
type: bool
-------------------------------------------------------------------------
"type: boolean
type: boolean
"
-------------------------------------------------------------------------
"Recom
PRs: 45736, 45738"
-------------------------------------------------------------------------
=========================================================================
"if checksum != destination_checksum:
    checksum_mismatch = True
t forcing redownload, unless checksum does not match
ot force and not checksum_mismatch:
# Not forcing redownload, unless checksum does not match
# allow file attribute changes
module.params['path'] = dest
file_args = module.load_file_common_arguments(module.params)
file_args['path'] = dest
result['changed'] = module.set_fs_attributes_if_different(file_args, False)
if result['changed']:
    module.exit_json(msg=""file already exists but file attributes changed"", **result)
module.exit_json(msg=""file already exists"", **result)
"
-------------------------------------------------------------------------
"if not force and checksum != '' and not checksum_mismatch:
            destination_checksum = module.digest_from_file(dest, algorithm)

            if checksum != destination_checksum:
                # Not forcing redownload, unless checksum does not match
                # allow file attribute changes
                module.params['path'] = dest
                file_args = module.load_file_common_arguments(module.params)
                file_args['path'] = dest
                changed = module.set_fs_attributes_if_different(file_args, False)
                if changed:
                    module.exit_json(msg=""file already exists but file attributes changed"", dest=dest, url=url, changed=changed)
                module.exit_json(msg=""file already exists"", dest=dest, url=url, changed=changed)"
-------------------------------------------------------------------------
"if checksum != destination_checksum:
    checksum_mismatch = True
t forcing redownload, unless checksum does not match
ot force and not checksum_mismatch:
# allow file attribute changes
module.params['path'] = dest
file_args = module.load_file_common_arguments(module.params)
file_args['path'] = dest
changed = module.set_fs_attributes_if_different(file_args, False)
if changed:
    module.exit_json(msg=""file already exists but file attributes changed"", dest=dest, url=url, changed=changed)
module.exit_json(msg=""file already exists"", dest=dest, url=url, changed=changed)
"
-------------------------------------------------------------------------
"Recom
PRs: 45495, 45567"
-------------------------------------------------------------------------
=========================================================================
"if checksum != destination_checksum:
    checksum_mismatch = True
t forcing redownload, unless checksum does not match
ot force and not checksum_mismatch:
# Not forcing redownload, unless checksum does not match
# allow file attribute changes
module.params['path'] = dest
file_args = module.load_file_common_arguments(module.params)
file_args['path'] = dest
result['changed'] = module.set_fs_attributes_if_different(file_args, False)
if result['changed']:
    module.exit_json(msg=""file already exists but file attributes changed"", **result)
module.exit_json(msg=""file already exists"", **result)
"
-------------------------------------------------------------------------
"if checksum != destination_checksum:
            checksum_mismatch = True
        
        if not force and not checksum_mismatch:
            # Not forcing redownload, unless checksum does not match
            # allow file attribute changes
            module.params['path'] = dest
            file_args = module.load_file_common_arguments(module.params)
            file_args['path'] = dest
            changed = module.set_fs_attributes_if_different(file_args, False)
            if changed:
                module.exit_json(msg=""file already exists but file attributes changed"", dest=dest, url=url, changed=changed)
            module.exit_json(msg=""file already exists"", dest=dest, url=url, changed=changed)"
-------------------------------------------------------------------------
"if checksum != destination_checksum:
    checksum_mismatch = True
t forcing redownload, unless checksum does not match
ot force and not checksum_mismatch:
# Not forcing redownload, unless checksum does not match
# allow file attribute changes
module.params['path'] = dest
file_args = module.load_file_common_arguments(module.params)
file_args['path'] = dest
changed = module.set_fs_attributes_if_different(file_args, False)
if changed:
    module.exit_json(msg=""file already exists but file attributes changed"", dest=dest, url=url, changed=changed)
module.exit_json(msg=""file already exists"", dest=dest, url=url, changed=changed)
"
-------------------------------------------------------------------------
"Recom
PRs: 45495, 45565"
-------------------------------------------------------------------------
=========================================================================
"- The C(backup) argument will backup the current device's active
  in the playbook root directory or role root directory if the
  playbook is part of an ansible role. If the directory does not
  exist, it is created.
"
-------------------------------------------------------------------------
"# The `backup` argument will backup the current device's active
    # configuration in the playbook root directory or role root directory if the
    # playbook is part of an ansible role. If the directory does not
    # exist, it is created."
-------------------------------------------------------------------------
"- The C(backup) argument will backup the current device's active
  in the playbook root directory or role root directory if the
  playbook is part of an ansible role. If the directory does not
  exist, it is created.
pe: bool
fault: 'no'
"
-------------------------------------------------------------------------
"Recom
PRs: 39530, 40548"
-------------------------------------------------------------------------
=========================================================================
"err = '\n'
"
-------------------------------------------------------------------------
err = to_text('\n')
-------------------------------------------------------------------------
"err = to_native(stderr or """")
if err and not err.endswith('\n'):
    err = '\n'
"
-------------------------------------------------------------------------
"Recom
PRs: 39019, 39430"
-------------------------------------------------------------------------
=========================================================================
"- ""To use this module, it has to be executed twice. Either as two
   different tasks in the same run or during two runs. Note that the output
   of the first run needs to be recorded and passed to the second run as the
   module argument C(data).""
   U(https://tools.ietf.org/html/draft-ietf-acme-acme-09#section-8).
   Also, consider the examples provided for this module.""
"
-------------------------------------------------------------------------
"# To use this module, it has to be executed twice. Either as two
# different tasks in the same run or during two runs. Note that the output
# of the first run needs to be recorded and passed to the second run as the
# module argument Stable['data'].
# More information available at U(https://tools.ietf.org/html/draft-ietf-acme-acme-09#section-8).
# Please refer to the examples provided in the Stable['module'] documentation."
-------------------------------------------------------------------------
"- ""To use this module, it has to be executed twice. Either as two
   different tasks in the same run or during two runs. Note that the output
   of the first run needs to be recorded and passed to the second run as the
   module argument C(data).""
"
-------------------------------------------------------------------------
"Recom
PRs: 38135, 38160"
-------------------------------------------------------------------------
=========================================================================
"- ""The data to validate ongoing challenges. This must be specified for
   the second run of the module only.""
   of this module. See the examples for more details.""
"
-------------------------------------------------------------------------
"# The value that must be used here will be provided by a previous use
# the C(data) option was marked as C(no_log) up to
# Ansible 2.5. From Ansible 2.6 on, it is no longer marked this way
# as it causes error messages to become unusable, and C(data) does
# The data to validate ongoing challenges. This must be specified for
# the second run of the module only.
# of this file. See the function examples for more details."
-------------------------------------------------------------------------
"- ""To use this module, it has to be executed twice. Either as two
   different tasks in the same run or during two runs. Note that the output
   of the first run needs to be recorded and passed to the second run as the
   module argument C(data).""
"
-------------------------------------------------------------------------
"Recom
PRs: 38135, 38160"
-------------------------------------------------------------------------
=========================================================================
"https://tools.ietf.org/html/draft-ietf-acme-acme-10#section-6.2
"
-------------------------------------------------------------------------
"import json
import urllib.error
import urllib.parse
import urllib.request
import base64
from copy import copy

from ansible.module_utils.basic import AnsibleModule
from ansible.module_utils.urls import fetch_url

import shutil
import binascii
import locale
import os
import hashlib
import tempfile
import time
import traceback
import re
from ansible.module_utils._text import to_bytes
from __future__ import absolute_import, division, print_function

class ACMEAccount(object):
    '''
    Sends a JWS signed HTTP POST request to the ACME server and returns
    the response as dictionary
    '''
    failed_tries = 0
    while True:
        pass"
-------------------------------------------------------------------------
"headers = {
    'Content-Type': 'application/josejson',
}
resp, info = fetch_url(self.module, url, data=data, headers=headers, method='POST')
"
-------------------------------------------------------------------------
"Recom
PRs: 37165, 37190"
-------------------------------------------------------------------------
=========================================================================
"headers = {
    'Content-Type': 'application/josejson',
}
resp, info = fetch_url(self.module, url, data=data, headers=headers, method='POST')
"
-------------------------------------------------------------------------
"headers = {
    'Content-Type': 'application/jose+json',
}
resp, info = self.module.fetch_url(url, data=data, headers=headers, method='POST')"
-------------------------------------------------------------------------
"challenge_response = {}
if self.version == 1:
    token = re.sub(r""[^A-Za-z0-9_\-]"", ""_"", challenge['token'])
    keyauthorization = self.account.get_keyauthorization(token)
    challenge_response[""resource""] = ""challenge""
    challenge_response[""keyAuthorization""] = keyauthorization
"
-------------------------------------------------------------------------
"Recom
PRs: 37165, 37190"
-------------------------------------------------------------------------
=========================================================================
"# Copyright (c) 2018 Matt Martz <matt@sivel.net>
# GNU General Public License v3.0 (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
# -*- coding: utf-8 -*-
from __future__ import (absolute_import, division, print_function)
__metaclass__ = type
import pytest
from ansible.executor.module_common import modify_module
from ansible.module_utils.six import PY2
from test_module_common import templar
FAKE_OLD_MODULE = b'''#!/usr/bin/python
import sys
print('{""result"": ""%s""}' % sys.executable)
'''
@pytest.fixture
def fake_old_module_open(mocker):
    m = mocker.mock_open(read_data=FAKE_OLD_MODULE)
    if PY2:
        mocker.patch('__builtin__.open', m)
    else:
        mocker.patch('builtins.open', m)
def test_shebang(fake_old_module_open):
    (data, style, shebang) = modify_module('fake_module', 'fake_path', {})
    assert shebang == '#!/usr/bin/python'
def test_shebang_task_vars(fake_old_module_open, templar):
    task_vars = {
        'ansible_python_interpreter': '/usr/bin/python3'
    }
    (data, style, shebang) = modify_module('fake_module', 'fake_path', {}, task_vars=task_vars, templar=templar)
    assert shebang == '#!/usr/bin/python3'
"
-------------------------------------------------------------------------
"from __future__ import (absolute_import, division, print_function)
import pytest
from ansible.executor.module_common import modify_module
from ansible.module_utils.six import PY2

FAKE_OLD_MODULE = b'''#!/usr/bin/python
import sys
print('{""result"": ""%s""}' % sys.executable)
'''

def fake_old_module_open(mocker):
    m = mocker.mock_open(read_data=FAKE_OLD_MODULE)
    if PY2:
        mocker.patch('__builtin__.open', m)
    else:
        mocker.patch('builtins.open', m)

# Tests
def test_shebang(fake_old_module_open):
    (data, style, shebang) = modify_module('fake_module', 'fake_path', {})
    assert shebang == '#!/usr/bin/python'

def test_shebang_task_vars(fake_old_module_open, templar):
    task_vars = {
        'ansible_python_interpreter': '/usr/bin/python3'
    }
    (data, style, shebang) = modify_module('fake_module', 'fake_path', {}, task_vars=task_vars, templar=templar)
    assert shebang == '#!/usr/bin/python3'"
-------------------------------------------------------------------------
"# Copyright (c) 2018 Matt Martz <matt@sivel.net>
# GNU General Public License v3.0 (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
# -*- coding: utf-8 -*-
from __future__ import (absolute_import, division, print_function)
__metaclass__ = type
import pytest
from ansible.executor.module_common import modify_module
from ansible.module_utils.six import PY2
FAKE_OLD_MODULE = b'''#!/usr/bin/python
import sys
print('{""result"": ""%s""}' % sys.executable)
'''
@pytest.fixture
def fake_old_module_open(mocker):
    m = mocker.mock_open(read_data=FAKE_OLD_MODULE)
    if PY2:
        mocker.patch('__builtin__.open', m)
    else:
        mocker.patch('builtins.open', m)
def test_shebang(fake_old_module_open):
    (data, style, shebang) = modify_module('fake_module', 'fake_path', {})
    assert shebang == '#!/usr/bin/python'
def test_shebang_task_vars(fake_old_module_open):
    task_vars = {
        'ansible_python_interpreter': '/usr/bin/python3'
    }
    (data, style, shebang) = modify_module('fake_module', 'fake_path', {}, task_vars=task_vars)
    assert shebang == '#!/usr/bin/python3'
"
-------------------------------------------------------------------------
"Recom
PRs: 36602, 36607"
-------------------------------------------------------------------------
=========================================================================
"new_ir = self._copy_included_file(included_file)
new_blocks, handler_blocks = new_ir.get_block_list(
"
-------------------------------------------------------------------------
"new_strategy = self._copy_included_file(included_file)
new_blocks, handler_blocks = new_strategy.get_block_list("
-------------------------------------------------------------------------
"new_ir = self._copy_included_file(included_file)
"
-------------------------------------------------------------------------
"Recom
PRs: 36470, 36526"
-------------------------------------------------------------------------
=========================================================================
"part['size'] = bytes_to_human((float(part['sectors']) * 512.0))
"
-------------------------------------------------------------------------
part['size'] = bytes_to_human((float(part['sectors']) * 512.0))
-------------------------------------------------------------------------
"part['size'] = self.module.pretty_bytes((float(part['sectors']) * 512.0))
"
-------------------------------------------------------------------------
"Recom
PRs: 34475, 34645"
-------------------------------------------------------------------------
=========================================================================
"d['size'] = bytes_to_human(float(d['sectors']) * 512.0)
"
-------------------------------------------------------------------------
d['size'] = bytes_to_human(float(d['sectors']) * 512.0)
-------------------------------------------------------------------------
"d['size'] = self.module.pretty_bytes(float(d['sectors']) * 512.0)
"
-------------------------------------------------------------------------
"Recom
PRs: 34475, 34645"
-------------------------------------------------------------------------
=========================================================================
"if moid in ['group-d1', 'ha-folder-root']:
"
-------------------------------------------------------------------------
"if moid in ['group-d1', 'ha-folder-root']:"
-------------------------------------------------------------------------
"try:
    moid = thisobj._moId
except AttributeError:
    moid = None
if moid in ['group-d1', 'ha-folder-root']:
"
-------------------------------------------------------------------------
"Recom
PRs: 31133, 32671"
-------------------------------------------------------------------------
=========================================================================
"s3.put_object(Bucket=bucket, Key=obj, Body=b'')
module.exit_json(msg=""Virtual directory %s created in bucket %s"" % (obj, bucket), changed=True)
"
-------------------------------------------------------------------------
"bucket = s3.Bucket(bucket)
    key = bucket.new_key(obj)
    key.set_contents_from_string('')
    for acl in module.params.get('permission'):
        s3.put_object_acl(ACL=acl, Bucket=bucket, Key=obj)
    module.exit_json(msg=""Virtual directory %s created in bucket %s"" % (obj, bucket.name), changed=True)"
-------------------------------------------------------------------------
"if formatted_keys:
    s3.delete_objects(Bucket=bucket, Delete={'Objects': formatted_keys})
"
-------------------------------------------------------------------------
"Recom
PRs: 32169, 32198"
-------------------------------------------------------------------------
=========================================================================
"sample:
  arn: 'arn:aws:events:us-east-1:123456789012:rule/MyCronTask'
  description: 'Run my scheduled task'
  name: 'MyCronTask'
  schedule_expression: 'cron(0 20 * * ? *)'
  state: 'ENABLED'
import botocore
pass  # handled by AnsibleAWSModule
 ansible.module_utils.aws.core import AnsibleAWSModule
 ansible.module_utils.ec2 import boto3_conn, camel_dict_to_snake_dict
 ansible.module_utils.ec2 import ec2_argument_spec, get_aws_connection_info
"
-------------------------------------------------------------------------
"from __future__ import absolute_import, print_function, division
import botocore
from ansible.module_utils.aws.core import AnsibleAWSModule
from ansible.module_utils.ec2 import boto3_conn, camel_dict_to_snake_dict
from ansible.module_utils.ec2 import ec2_argument_spec, get_aws_connection_info

class CloudWatchEventRule(object):
    def __init__(self, name, schedule_expression, description, state, arn):
        self.name = name
        self.schedule_expression = schedule_expression
        self.description = description
        self.state = state
        self.arn = arn

    def list_targets(self):
        pass

    # Other methods here"
-------------------------------------------------------------------------
"import botocore
"
-------------------------------------------------------------------------
"Recom
PRs: 30823, 30942"
-------------------------------------------------------------------------
=========================================================================
"if not no_password_changes and (password is not None or role_attr_flags != '' or expires is not None):
"
-------------------------------------------------------------------------
if not no_password_changes and (password is not None or role_attr_flags != '' or expires is not None):
-------------------------------------------------------------------------
"if not no_password_changes and (password is not None or role_attr_flags != ''):
"
-------------------------------------------------------------------------
"Recom
PRs: 26539, 26541"
-------------------------------------------------------------------------
=========================================================================
"if expires is not None:
    cursor.execute(""SELECT %s::timestamptz;"", (expires,))
    expires_with_tz = cursor.fetchone()[0]
    expires_changing = expires_with_tz != current_role_attrs.get('rolvaliduntil')
else:
    expires_changing = False
"
-------------------------------------------------------------------------
"if expires is not None:
    cursor.execute(""SELECT %s::timestamptz;"", (expires,))
    expires_with_tz_stable = cursor.fetchone()[0]
    expires_changing = expires_with_tz_stable != current_role_attrs.get('rolvaliduntil')
else:
    expires_changing = False"
-------------------------------------------------------------------------
"expires_changing = (expires is not None and expires == current_role_attrs['rolvaliduntil'])
"
-------------------------------------------------------------------------
"Recom
PRs: 26539, 26541"
-------------------------------------------------------------------------
=========================================================================
